arXiv:2305.17877v4  [cs.SC]  27 Jun 2023Eﬃcient Quotients of
Non-Commutative Polynomials
Stephen M. Watt
Cheriton School of Computer Science, University of Waterlo o
https://cs.uwaterloo.ca/ ~smwatt
smwatt@uwaterloo.ca
Abstract. It is shown how to compute quotients eﬃciently in non-
commutativeunivariatepolynomialrings.Thisextendsear lier workwhere
eﬃcient generic quotients were studied with a primary focus on commu-
tative domains. Fast algorithms are given for left and right quotients of
polynomials where the variable commutes with coeﬃcients. T hese algo-
rithms are based on the concept of the “whole shifted inverse ”, which is
a specialized quotient where the dividend is a power of the po lynomial
variable. It is also shown that when the variable does not com mute with
coeﬃcients, that is for skew polynomials, left and right who le shifted in-
verses are deﬁned and may be used to compute right and left quo tients.
In this case their computation is not asymptotically fast, b ut once ob-
tained, they may be used to compute multiple quotients, each with one
multiplication. Examples are shown of polynomials with mat rix coef-
ﬁcients, diﬀerential operators and diﬀerence operators. I n addition, a
proof-of-concept generic Maple implementations is given.
1 Introduction
In symbolic mathematical computation it is important to have eﬃcient algo-
rithms for the fundamental arithmetic operations of addition, mult iplication
and division. While linear time algorithms for additive operations are usu ally
straightforward, considerable attention has been devoted to ﬁn d eﬃcient meth-
ods to compute products and quotients of integers, polynomials wit h integer
or ﬁnite ﬁeld coeﬃcients and matrices with elements from a ring. For t hese,
both practically eﬃcient algorithms and theoretically important boun ds are well
known.
For integer and polynomial division, eﬃcient algorithms based on Newt on it-
erationallowthecomputationofquotientsintimeproportionaltomu ltiplication.
Until recently, these algorithms left the original domain to perform arithmetic
in related domains. For integers, this involved computing an approxim ation to
the inverse of the divisor in extended precision approximate arithme tic or in a
1residue ring, and for polynomials it involvedcomputing the inverse of t he reverse
of the divisor polynomial in ideal-adic arithmetic.
We have recently shown how these quotients may be computed witho ut
leaving the original domain, and we have extended this to a generic do main-
preservingalgorithmforringswith a suitablewhole shift operation[ 10]. Forinte-
gersthe wholeshift multiplies byapowerofthe representationbase and forpoly-
nomials it multiplies by a power of the variable, in both cases discarding t erms
with negative powers. The previous paper developed the concept o f the whole
shifted inverse and used it to compute quotients eﬃciently. Non-co mmutative
domains were mentioned only brieﬂy.
The present article expands on how these methods may be used to c ompute
quotients of non-commutative polynomials. In particular, it is shown that
•the whole shifted inverse is well-deﬁned on non-commutative polynom ial
ringsR[x],
•its computation is eﬃcient,
•they may be used to compute left or right quotients in R[x], each with one
multiplication,
•left and right whole shifted inverses may be deﬁned on skew polynomia ls
R[x;σ,δ], and
•they may be used to compute the right and left quotients in R[x;σ,δ], each
with one multiplication.
The remainder of this article is organized as follows. Section 2presents
some basic background, including notation, the deﬁnition of division in a non-
commutative context, and the Newton-Schulz iteration. Section 3considers di-
vision of non-commutative polynomials in R[x], showing O(n2) algorithms for
classicaldivision and for pseudodivision.It recallsthe notion ofthe w hole shifted
inverse, proves it is well-deﬁned on non-commutative R[x] and shows that it can
be used to compute left and right quotients in this setting. Section 4recapitu-
lates the generic algorithms from [ 10] that use a modiﬁed Newton iteration to
compute the whole shifted inverse. It also explains why it applies when poly-
nomial coeﬃcients are non-commutative. Section 5gives an example of these
algorithms applied to polynomial matrices. Section 6extends the discussion to
skew polynomials R[x;σ,δ], deﬁning left and right whole shifted inverse, and
showing how they may be used. Section 7gives linear ordinary diﬀerential and
diﬀerence operators as examples, before concluding remarks in Se ction8.
22 Background
2.1 Notation
We adopt the following notation:
precBunumber of base- Bdigits of an integer u,⌊logB|u|⌋+1
precxpnumber of coeﬃcients of a polynomial p, degreexp+1
uquov, uremvquotient and remainder (see below)
uxquov, uxremvleft and right (pseudo)quotient and remainder, x∈ {l,lp,r,pr}
shiftnv, shinv nvwhole shift and whole shifted inverse (see below)
R[x;σ,δ],R[x,δ] skew polynomials (see Section 6)
iu,uicoeﬃcient of skew polynomial uwith variable powers on the left, right.
xshiftnv,xshinvnvleft and right whole shift and shifted inverse, x∈ {l,r}(see Section 6)
X(i) value ofXatithiteration
The “prec” notation, standing for “precision”, means the number of base-Bdig-
its or polynomial coeﬃcients. It is similar to that of [ 4], where it is used to
present certain algorithms generically for integers and polynomials. In particu-
lar, if we take integers to be represented in base- B,i.e.for any integer u/n⌉}ationslash= 0
there ish= precB(u)−1, such that
u=h/summationdisplay
i=0uiBi, ui∈Z,0≤ui< B, u h/n⌉}ationslash= 0, (1)
then integers base- Bbehave similarly to univariate polynomials with coeﬃcients
ui, but with carries complicating matters.
2.2 Division
The notion of integer quotients and remainders can be extended to more general
rings. For a Euclidean domain Dwith valuation N:D→Z≥0, such that for
anyu,v∈D,v/n⌉}ationslash= 0, there exist q,r∈Dsuch that
u=qv+r, r = 0 orN(r)< N(v).
The value qis aquotient ofuandvandris aremainder of dividing ubyvand
we write
q=uquov r =uremv
when these are unique. When both the quotient and remainder are r equired, we
writeudivv= (uquov,uremv). When Dis a non-commutative ring with
a valuation N, theremayexist left and right quotients such that
u=vql+rl, r l= 0 orN(rl)< N(v)
u=qrv+rr, r r= 0 orN(rr)< N(v).(2)
3When these exist and are unique, we write
ql=ulquov r l=ulremv q r=urquov r r=urremv.
For certain non-commutative rings with a distance measure /⌊ar⌈⌊l·/⌊ar⌈⌊l, a sequence
of approximations to the inverse of Amay be computed via the Newton-Schulz
iteration [ 7]
X(i+1)=X(i)+X(i)(1−AX(i)) (3)
where 1 denotes the multiplicative identity of the ring. There are sev eral ways to
arrange this expression, but the form above emphasizes that as X(i)approaches
A−1, the product X(i)(1−AX(i)) approaches 0. For Cn×nmatrices, a suitable
initial value is X(0)=A†/(nTr(AA†)), where A†is the Hermitian transpose.
2.3 Whole Shift and Whole Shifted Inverse
In previous work[ 10] we studied the problem ofeﬃcient domain-preservingcom-
putation of quotients and remainders for integers and polynomials, then general-
ized these results to a generic setting. To this end, we deﬁned the n otions of the
whole shift andwhole shifted inverse with attention to commutative domains.
We recapitulate these deﬁnitions and two results relevant to the pr esent article.
Deﬁnition 1 (Whole n-shift in R[x])Given a polynomial u=/summationtexth
i=0uixi∈
R[x], withRa ring and n∈Z, thewholen-shift ofuwith respect to xis
shiftn,xu=/summationdisplay
i+n≥0uixi+n. (4)
Whenxis clear by context, we write shiftnu.
Deﬁnition 2 (Whole n-shifted inverse in F[x])Givenn∈Z≥0andv∈
F[x],Fa ﬁeld, the wholen-shifted inverse of vwith respect to xis
shinvn,xv=xnquov. (5)
Whenxis clear by context, we write shinvnv,
Theorem 1 Given two polynomials u,v∈F[x],Fa ﬁeld, and 0≤degreeu≤h,
uquov= shift −h(u·shinvhv). (6)
For classical and Karatsuba multiplication it is more eﬃcient to comput e just
the top part of the product in ( 6), omitting the lower hterms, instead of shifting:
shift−h(u·shinvhv) =MultQuo (u,shinvhv,h),
withMultQuo (a,b,n) =abquoxncomputing only degree a+degree b−n+1
terms. For multiplication methods where computing only the top part of the
product gives no saving, some improvement is obtained using
shift−h(u·shinvhv) = shift −(h−k)(shift−ku·shinvhv).
4Algorithm 1 Classical division for non-commutative R[x] with invertible vk
1:⊲Compute q=/summationtexth−k
i=0qixiandr=/summationtextk−1
i=0rixisuch that u=q×πv+r.
2:function div(u=/summationtexth
i=0uixi∈R[x],v=/summationtextk
i=0vixi∈R[x],π∈S2)
3:v∗←invvk
4:q←0
5:r←u
6:fori←h−kto 0 by−1do
7: t←(ri+k×πv∗)xi
8: q←q+t
9: r←r−t×πv
10:return(q, r)
11:⊲Left division: (ql,rl)←ldiv(u,v)⇒u=v×ql+rl
12:ldiv(u,v)/mapsto→div/parenleftbig
u,v,(21)/parenrightbig
13:⊲Right division: (qr,rr)←rdiv(u,v)⇒u=qr×v+rr
14:rdiv(u,v)/mapsto→div/parenleftbig
u,v,(12)/parenrightbig
Theorem 2 Givenv∈F[x], withFa ﬁeld and h >degreev=kand suitable
starting value w(0), the sequence of iterates
w(i+1)=w(i)+shift −h/parenleftbig
w(i)(shifth1−vw(i))/parenrightbig
converges to shinvhvin⌈log2(h−k)⌉steps.
A suitable starting value for w(0)is given by Shinv0in Section 4.
3 Division in Non-Commutative R[x]
We now lay out how to use shift and shinv to compute quotients for po lynomials
with non-commutative coeﬃcients. First we show classical algorithm s to com-
pute left and right quotients in R[x]. We then prove two theorems, one showing
thatxnlquov=xnrquovin this setting, making the whole shifted inverse well
deﬁned, and another showing that it may be used to compute left an d right
quotients.
3.1 Deﬁnitions and Classical Algorithms
Letuandvbe two polynomials in R[x] with Euclidean norm being the polyno-
mial degree. The left and right quotients and remainders are deﬁne d as in ( 2).
Left and right quotients will exist provided that vkis invertible in Rand they
may be computed by Algorithm 1. In the presentation of the algorithm, πde-
notes a permutation on two elements so is either the identity or a tra nsposition.
The notation ×πis a shorthand for ×◦πsoa×πb=a×bwhenπis the identity
anda×πb=b×awhenπis a transposition.
5Algorithm 2 Non-commutative polynomial pseudodivision
1:⊲Compute q=/summationtexth−k
i=0qixiandr=/summationtextk−1
i=0rixisuch that vh−k+1
ku=q×πv+r.
Requires v×vk=vk×v.
2:function pdiv(u=/summationtexth
i=0uixi∈R[x],v=/summationtextk
i=0vixi∈R[x],π∈S2)
3:q←0
4:r←u
5:fori←h−kto 0 by−1do
6: t←ui+kxi
7: q←q+t×πvi
k
8: r←r×πvk−t×πv
9:return(q, r)
10:⊲Left pseudodivision: (ql,rl)←lpdiv(u,v)⇒vh−k+1
ku=v×ql+rl
11:lpdiv(u,v)/mapsto→pdiv/parenleftbig
u,v,(21)/parenrightbig
12:⊲Right pseudodivision: (qr,rr)←rpdiv(u,v)⇒vh−k+1
ku=qr×v+rr
13:rpdiv(u,v)/mapsto→pdiv/parenleftbig
u,v,(12)/parenrightbig
There are some circumstances where quotients or related quantit ies may be
computed even if vkis not invertible. When Ris an integral domain, quotients
may be computed as usual in K[x] withKbeing the quotient ﬁeld of R. Alter-
natively, when Ris non-commutative but vkcommutes with v, it is possible to
compute pseudoquotients andpseudoremainders satisfying
mu=vql+rl, degreerl<degreev
um=qrv+rr, degreerr<degreev
m=vh−k+1
k,
as shown in Algorithm 2. In this case, we write
ql=ulpquov r l= lpremv
qr=urpquov r l= rprem v.
Requiring vkto commute with vis quite restrictive, however, so we focus our
attention to situations where the inverse of vkexists.
3.2 Whole Shift and Whole Shifted Inverse in R[x]
We now examine the notions of the whole shift and whole shifted invers e for
R[x] with non-commutative R. First consider the whole shift. Since xcommutes
with all values in R[x], we may without ambiguity take, for u=/summationtexth
i=0uixiand
n∈Z,
shiftnu=/summationdisplay
i+n≥0xn(uixi) =/summationdisplay
i+n≥0(uixi)xn. (7)
That is, the fact that R[x] is non-commutative does not lead to left and right
variants of the whole shift.
6We state two simple theorems with obvious proofs:
Theorem 3 Letw∈R[x]. Then, for all n∈Z≥0,shift−nshiftnw=w.
Theorem 4 Letu,v∈R[x]withdegreeu=handdegreev=k. Then, for
m∈Z,
shift−k−m(u×v) = shift −k(shift−m(u)×v)
shift−h−m(u×v) = shift −h(u×shift−m(v)).
We now come to the main point of this section and show shinv is well-deﬁn ed
whenRis non-commutative.
Theorem 5 (Whole shifted inverse for non-commutative R[x])
Letv=/summationtextk
i=0vixi∈R[x], withRa non-commutative ring and vkinvertible in
R. Then, for h∈Z≥0,
xhlquov=xhrquov.
Proof. Letql=xhlquovandqr=xhrquov. Ifh < k, thenql=qr= 0.
Otherwise, both qlandqrhave degree h−k≥0 so
vkqlh−k= 1 qrh−kvk= 1 (8)
k/summationdisplay
j=Mvjqli+k−j= 0k/summationdisplay
j=Mqri+k−jvj= 0,0≤i < h−k,(9)
whereM= max(0 ,i−h+ 2k). We show by induction on ithatqli=qrifor
0≤i≤h−k. Sincevkis invertible, ( 8) and (9) give
qlh−k=qrh−k=v−1
k(10)
and
qli=−k−1/summationdisplay
j=Mv−1
kvjqli+k−jqri=−k−1/summationdisplay
j=Mqri+k−jvjv−1
k,0≤i < h−k.(11)
Equation ( 10) gives the base of the induction. Now suppose qli=qriforN <
i≤h−k. Then for i=N≥0 equation ( 11) gives
qlN=−k−1/summationdisplay
j=Mv−1
kvjqlN+k−j=−k−1/summationdisplay
j=Mv−1
kvjqrN+k−j
=−k−1/summationdisplay
j=Mv−1
kvj/parenleftBigg
−k−1/summationdisplay
ℓ=MqrN+k−j+k−ℓvℓv−1
k/parenrightBigg
=−k−1/summationdisplay
ℓ=M
−k−1/summationdisplay
j=Mv−1
kvjqrN+k−j+k−ℓ
vℓv−1
k=−k−1/summationdisplay
ℓ=MqrN+k−jvℓv−1
k=qrN.
/square
7Thus we may write shinv hvwithout ambiguity in the non-commutative case, i.e
shinvhv=xhlquov=xhrquov. (12)
3.3 Quotients from the Whole Shifted Inverse in R[x]
Weconsidercomputingtheleftandrightquotientsin R[x]fromthewholeshifted
inverse. We have the following theorem.
Theorem 6 (Left and right quotients from the whole shifted in verse in R[x])
Letu,v∈R[x],Ra ring, with degreev=kandvkinvertible in R. Then for
h≥degreeu,
ulquov= shift −h(shinv h(v)×u)and
urquov= shift −h(u×shinvh(v)).
Proof. Consider ﬁrst the right quotient. It is suﬃcient to show
u= shift −h(u×shinvhv)×v+rr
for some rrwith degree rr< k. It is therefore suﬃcient to show
shift−ku= shift −k/parenleftbig
shift−h(u×shinvhv)×v/parenrightbig
. (13)
We have
(u×shinvhv)×v=u×((xhrquov)×v) (14)
=u×(xh−ρ), ρ= 0 or degree ρ < k
= shift hu−u×ρ.
shifthu= (u×shinvhv)×v+u×ρ. (15)
Sinceh≥0, Theorem 3applies and equation ( 15) gives
u= shift −h/parenleftbig
(u×shinvhv)×v/parenrightbig
+shift −h(u×ρ)
with the degree of shift −h(u×ρ) less than k. Therefore
shift−ku= shift −k−h/parenleftbig
(u×shinvhv)×v/parenrightbig
= shift −k/parenleftbig
shift−h(u×shinvhv)×v)/parenrightbig
,
by Theorem 4, and we have shown equation ( 13) as required. The proof for lquo
replaces equation ( 14) with
v×(shinv hv×u) = (v×(xhlquov))×u
and follows the same lines, mutatis mutandis . /square
As in the commutative case, it may be more eﬃcient to compute only th e top
part of the product instead of computing the whole thing then shift ing away
part. Now that we have shown that shift and shinv are well-deﬁned f or non-
commutative R[x], we next see that shinv may be computed by our generic
algorithm.
84 Generic Algorithm for the Whole Shifted Inverse
Earlier work has shown how to compute shinv eﬃciently for Z, both for Eu-
clidean domains F[x], and generically [ 10]. The generic version shown here in
Algorithm 3. We justify below that it applies equally well to polynomials with
non-commutative coeﬃcients. The algorithm operates on a ring Dthat is re-
quired to have a suitable shift and certain other operations and pro perties must
be deﬁned. For example, on F[x],Fa ﬁeld, these are
shiftnu=/braceleftBigg
u·xnifn≥0
uquox−nifn <0
coeﬀ(u,i) =ui
Shinv0(v) = (1/vkx−1/vk·vk−1·1/vk,2)
hasCarries = false
Mult(a,b) =ab
MultMod (a,b,n) =abremxn.
TheiterativestepofAlgorithm 3isgivenonline 32.SinceD.PowDiff computes
shifth1−v·w, this line computes
shiftmw+shift 2m−h/parenleftbig
w·(shifth1−v·w)/parenrightbig
. (16)
The shift operations are multiplications by powers of x, with shift hp=pxh. The
theexpressionsinvolving k,h,ℓandmforshift amountsarisefrommultiplication
byvariouspowersof xatdiﬀerentpointsinordertocomputeshorterpolynomials
when possible. Since xcommutes with all values, it is possible to accumulate
these into single pre- and post- shifts. With this in mind, the R[x] operations +
and·ultimately compute the polynomial coeﬃcients using the operations o fR
and the order of the multiplicands in ( 16) is exactly that of the Newton-Schulz
iteration ( 3). The form of Shinv0above is chosen so that it gives a suitable
initial value for non-commutative polynomials.
Thecomputationalcomplexityofthe RefinemethodsofAlgorithm 3maybe
summarized as follows: The function D.Refine1 computes full-length values at
eachiterationsohastimecomplexity O(log(h−k)M(h))where M(N)isthetime
complexityofmultiplication.Thefunction D.Refine2 reducesthesizeoftheval-
ues, computingonlythe necessarypreﬁxes.The function D.Refine3 reducesthe
size of some values further and achieves time complexity O/parenleftbig/summationtextlog(h−k)
i=1M(2i)/parenrightbig
,
which gives time complexity O(M(N)),N=h−kfor the purely theoretical
M(N)∈O(NlogN), for Sch¨ onhage-Strassen M(N)∈O(NlogNloglogN) and
forM(N)∈O(Np),p >0.
9Algorithm 3 GenericShinv(v,h)
Input:v∈D,h∈Z>0where 0 < k= precv−1< h
Output: shinvhv∈D
1:function D.Shinv (v,h)
2:⊲Domain-speciﬁc initialization
3: (w,ℓ)←D.Shinv0 (v) ⊲Initialize wtoℓcorrect places.
4:returnD.Refine (v,h,k,w,ℓ )⊲One ofD.Refine1 ,D.Refine2 ,D.Refine3 .
5:⊲Below,gis the number of guard places and dis the precision doubling shortfall.
6:function D.Refine1 (v,h,k,w,ℓ )
7:ifD.HasCarries theng←1;d←1elseg←0;d←0
8:h←h+g
9:w←D.shifth−k−ℓ(w) ⊲Scale initial value to full length
10:whileh−k+1−d > ℓdo
11: w←D.Step(h,v,w,0,ℓ)
12: ℓ←min(2ℓ−d,h−k+1−d) ⊲Number of accurate digits
13:returnw
14:function D.Refine2 (v,h,k,w,ℓ )
15:ifD.HasCarries theng←2;d←1elseg←0;d←0
16:w←D.shiftgw
17:whileh−k+1−d > ℓdo
18: m←min(h−k+1−ℓ,ℓ) ⊲How much to grow
19: w←D.shift−dD.Step/parenleftbig
k+ℓ+m+d−1+g, v, w ,m, ℓ−g/parenrightbig
20: ℓ←ℓ+m−d
21:returnw
22:function D.Refine3 (v,h,k,w,ℓ )
23:ifD.HasCarries theng←2;d←1elseg←0;d←0
24:w←D.shiftgw
25:whileh−k+1−d > ℓdo
26: m←min(h−k+1−ℓ, ℓ)
27: s←max(0, k−2ℓ+1−g)
28: w←D.shift−d/parenleftbig
D.Step/parenleftbig
k+ℓ+m−s−1+d+g,D.shift−sv, w, m, ℓ−g/parenrightbig/parenrightbig
29: ℓ←ℓ+m−d
30:returnD.shift−g(w)
31:function D.Step(h,v,w,m,ℓ )
32:D.shiftmw+D.shift2m−hMult/parenleftbig
w,D.PowDiff (v,w,h−m,ℓ)/parenrightbig
33:⊲Compute D.shifth1−vweﬃciently.
34:function D.PowDiff (v,w,h,ℓ)
35:c←ifD.HasCarries then1else0
36:L←D.precv+D.precw−ℓ+c ⊲ cfor coeﬀ to peek
37:ifv= 0∨w= 0∨L≥hthen
38: returnD.shifth1−D.Mult (v,w)
39:else
40: P←D.MultMod (v,w,L)
41: ifD.HasCarries∧D.coeﬀ(P,L−1)/negationslash= 0then return D.shiftL1−P
42: else return−P
105 Non-Commutative Polynomial Example
We give an example of computing left and right quotients via the whole s hifted
inverse with R[x] =F72×2[x] using the algorithms of Sections 3and4. Note
thatR[x] is not a domain—there may be zero divisors, but it is easy enough to
check for them. This example, and the one in Section 7, were produced using the
Domains package in Maple [ 5]. The setup to use the Domains package for this
example is
with(Domains);
F := GaloisField(7);
F2x2 := SquareMatrix(2, F);
PF2x2 := DenseUnivariatePolynomial(F2x2, x);
We start with
u=/bracketleftbigg
4 6
6 1/bracketrightbigg
x5+/bracketleftbigg
2 2
0 1/bracketrightbigg
x4+/bracketleftbigg
2 1
1 3/bracketrightbigg
x3+/bracketleftbigg
2 0
4 1/bracketrightbigg
x2+/bracketleftbigg
3 3
5 4/bracketrightbigg
x+/bracketleftbigg
4 5
1 2/bracketrightbigg
,
v=/bracketleftbigg4 3
4 5/bracketrightbigg
x2+/bracketleftbigg5 3
0 4/bracketrightbigg
x+/bracketleftbigg1 2
6 1/bracketrightbigg
.
The whole 5-shifted inverse of vis then
shinv5v=/bracketleftbigg
5 4
3 4/bracketrightbigg
x3+/bracketleftbigg
6 0
4 1/bracketrightbigg
x2+/bracketleftbigg
1 0
2 2/bracketrightbigg
x+/bracketleftbigg
5 1
6 3/bracketrightbigg
.
From this, the left and right quotients and remainders are compute d to be
ql=/bracketleftbigg2 6
1 1/bracketrightbigg
x3+/bracketleftbigg6 1
0 0/bracketrightbigg
x2+/bracketleftbigg2 0
3 3/bracketrightbigg
x+/bracketleftbigg3 1
0 0/bracketrightbigg
, rl=/bracketleftbigg1 6
4 1/bracketrightbigg
x+/bracketleftbigg1 4
4 3/bracketrightbigg
,
qr=/bracketleftbigg
3 5
5 0/bracketrightbigg
x3+/bracketleftbigg
1 1
1 5/bracketrightbigg
x2+/bracketleftbigg
0 5
5 5/bracketrightbigg
x+/bracketleftbigg
4 0
2 6/bracketrightbigg
, rr=/bracketleftbigg
2 0
2 1/bracketrightbigg
x+/bracketleftbigg
0 4
5 6/bracketrightbigg
.
Taking a largerexample where uhas degree 100 and vdegree 10, D.Refine1
computes shinv 100vwith one guard digit in 6 steps with intermediate values of
wall of prec 92. Methods D.Refine2 andD.Refine3 compute the same result
also in 6 steps but with values of whave prec 4, 8, 16, 32, 64, 92 successively.
MethodD.Refine3 uses a shorter preﬁx of von the ﬁrst iteration ( s= 3). The
Maple code used for this example is given in Figure 1.
116 Division in R[x;σ,δ]
We now examine the more general case where the polynomial variable does not
commute with coeﬃcients. For quotients and remainders to be deﬁn ed, a notion
of degree is required and we note that this leads immediately to Ore ex tensions,
or skew polynomials. After touching upon classical algorithms, we int roduce
the notions of left and right whole shifted inverse. We note that the modiﬁed
Newton-Schulz iteration may be used to compute whole shifted inver ses, though
in this case there is no beneﬁt over classical division. Finally, we show h ow left
and right whole shifted inversesmay be used to compute right and lef t quotients,
each with only one multiplication.
6.1 Deﬁnitions and Classical Algorithms
Consider a ring of objects with elements from a ring Rextended by x, with
xnot necessarily commuting with elements of R. By distributivity, any ﬁnite
expression in this extended ring is equal to a sum of monomials, the mo nomials
composed of products of elements of Randx. To have a well-deﬁned degree
compatible with that of usual polynomials, it is required that
∀r∈R∃a,b,c,d∈Rs.t.xr−rx=ax+b=xc+d. (17)
We call the elements of such a ring skew polynomials. Condition ( 17) implies
that for all r∈Rthere exist σ(r),δ(r)∈Rsuch that
xr=σ(r)x+δ(r). (18)
Therefore, to have well-deﬁned notion of degree, the ring must be an Ore exten-
sion,R[x;δ,σ].Orestudiedthesenon-commutativepolynomialsalmostacentury
ago [6] and overviews of Ore extensions in computer algebra are given in [ 1,2].
The subject is viewed from a linear algebra perspective in [ 3] and the complexity
of skew arithmetic is studied in [ 9]. The ring axioms of R[x;σ,δ] imply that σ
be an endomorphism on Randδbe aσ-derivation, i.e.for allr,s∈R
δ(r+s) =δ(r)+δ(s) δ(r·s) =σ(r)·δ(s)+δ(r)·s.
Diﬀerent choices of σandδallow skew polynomials to represent linear diﬀer-
ential operators, linear diﬀerence operators, q-generalizations of these and other
algebraic systems.
Condition ( 18) implies that it is possible to write any skew polynomial as a
sum of monomials with all the powers of xon the right or all on the left. We
will use the notation uifor coeﬃcients of skew polynomials with all powers of
the variable on the right and iufor coeﬃcients with all powers of the variable
on the left, e.g.
u=h/summationdisplay
i=0uixi=h/summationdisplay
i=0xi
iu.
12Algorithm 4 Classical division for R[x;σ,δ] with invertible vk
1:⊲Compute qandrfromuof degree handvof degree ksuch that u=q×πv+r.
The left division algorithm applies when σis bijective.
2:function skewdiv (u,v∈R[x;σ,δ],π∈S2,qcoeff)
3:v∗←invvk
4:q←0;r←u
5:fori←h−kto 0 by−1do
6: t←qcoeff(ri+k,v∗,i,k)×xi
7: q←q+t;r←r−t×πv
8:return(q, r)
9:⊲Left division: (ql,rl)←lskewdiv (u,v)⇒u=v×ql+rl
10:lskewdiv (u,v)/mapsto→skewdiv/parenleftbig
u, v,(21),(a,b,n,k)/mapsto→σ−k(b×a)/parenrightbig
11:⊲Right division: (qr,rr)←rskewdiv (u,v)⇒u=qr×v+rr
12:rskewdiv (u,v)/mapsto→skewdiv/parenleftbig
u, v,(12),(a,b,n,k)/mapsto→a×σn(b)/parenrightbig
Algorithm 4givesleft andright classicaldivisionin R[x;σ,δ]. As in Section 3,
×πis multiplication with arguments permuted by π. Whenσ(r) =r,R[x;σ,δ]
is a diﬀerential ring, usually denoted R[x,δ], and Algorithm 4specializes to
Algorithm 1. The left division algorithm applies only when σis bijective. If left
division is of primary interest, start from rx=xσ∗(r) +δ∗(r) instead of ( 18)
and work in the adjoint ring R[x;σ∗,δ∗].
Some care is needed in Algorithm 4to avoid duplicating computation. Notice
that forrskewdiv the application of qcoeff on line6requires n-fold applica-
tion ofσto invvkand that the computation of t×πvon line7is coeﬀ(t)xi+k×v.
The latter requires commuting h−kpowers of xacrossvover the course of the
division. Depending on the cost to compute σ, it may be useful to create an
array of the values σi(invvk) forifrom 0 to h−k. It is also possible to pre-
compute and store the products xi×v, withxi+1×vobtained from xi×vby
one application of ( 18). Then the xi×vmay be used in descending order in the
forloop without re-computation. Both of these pre-computations ar e performed
in the Maple program for P[RDiv] shown in Figure 2.
6.2 Whole Shift and Inverse in R[x;σ,δ]
It is possible to deﬁne left and right analogs of the whole shift and who le shifted
inverse for skew polynomials. In general, the left and right operatio ns give dif-
ferent values.
Deﬁnition 3 (Left and right whole n-shift in R[x;σ,δ])
Givenu=∈R[x;σ,δ]andn∈Z, theleft whole n-shift ofuis
lshiftn,xu=/summationdisplay
i+n≥0xi+niu,
13theright whole n-shift ofuis
rshiftn,xu=/summationdisplay
i+n≥0uixi+n
Whenxis clear by context, we write lshiftnuandrshiftnu.
Deﬁnition 4 (Left and right whole n-shifted inverse in R[x;σ,δ])
Givenn∈Z≥0andv∈R[x;σ,δ], theleft whole n-shifted inverse of vwith
respect to xis
lshinvn,xv=xnlquov
theright whole n-shifted inverse of vwith respect to xis
rshinv n,xv=xnrquov
Whenxis clear by context, we write lshinvnvandrshinv nv.
Modiﬁed Newton-Schulz Iteration For monic v∈R[x;σ,δ], the whole
shifted inverses may be computed using modiﬁed Newton-Schulz iter ations with
g= 1 guard places as follows:
wl(0)=wr(0)=xh−k+g−vk−1xh−k−1+g
wl(i+1)=wl(i)+rshift −h/parenleftbig
wl(i)×(rshift h1−v×wl(i))/parenrightbig
,
wr(i+1)=wr(i)+ lshift −h/parenleftbig
(lshifth1−wr(i)×v)×wr(i)/parenrightbig
,
rshift−gwl(i)→lshinvhv
lshift−gwr(i)→rshinv hv.(19)
These generalize D.Refine1 in Algorithm 3. ForD.Refine2 andD.Refine3 ,
the shifts that reduce the size of intermediate expressions are co mbined into
one pre- and one post-shift in R[x]. But on R[x;σ,δ] we do not expect these
simpliﬁcations of shift expressions to be legitimate.
Even though ( 19)canbe used to compute whole shifted inverses, it does
not give any beneﬁt over classical division. In the special case of R[x,δ], the
multiplication by vand then by wmake it so each iteration creates only one
correct term, so h−kiterations are required rather than log2(h−k). In other
skew polynomial rings, e.g.linear diﬀerence operators,the iteration ( 19) can still
converge, but with multiple iterations required for each degree of t he quotient.
It is therefore simpler to compute lshinv and rshinv by classical divisio n.
6.3 Quotients from Whole Shifted Inverses in R[x;σ,δ]
It is possible to compute left and right quotients from the right and le ft whole
shifted inverses in R[x;σ,δ]. Although computing whole shifted inverses is not
asymptotically fast as it is in R[x], once a whole shifted inverse is obtained it can
be usedtocompute multiple quotientsandhence remainders,eachr equiringonly
one multiplication. This is useful, e.g., when working with diﬀerential ideals. In
some cases this multiplication of skew polynomials is asymptotically fast [8].
14Theorem 7 (Quotients from whole shifted inverses in R[x;σ,δ])
Letu,v∈R[x;σ,δ], withRa ring,k= degree v,h= degree u, andvkinvertible
inR. Then
urquov= rshift −h(u×lshinvhv) (20)
ulquov= lshift −h(rshinv hv×u). (21)
Proof. We ﬁrst prove ( 20). Forh≥k, we proceed by induction on h−k.
Suppose h−k= 0. Since u−(uh×1/vk)×vhas no term of degree h, we have
urquov=uh×1/vk.
On the other hand, when h=k, lshinv hv= 1/vkso
rshift−h(u×lshinvhv) =uh×1/vk
and (20) holds. For the inductive step, we assume that ( 20) holds for h−k < N.
Forh−k=N, letu=q×v+o(xk) and let Q, ˆqand ˆube given by
u= (Qxh−k+ ˆq)×v+r, Q ∈R,ˆq∈o(xh−k), r∈o(xk),
ˆu=u−Qxh−k×v.
With this, ˆ uhas degree at most h−1. The inductive hypothesis gives ˆ urquov=
rshift−h(ˆu×lshinvhv).Therefore,
ˆu=u−Qxh−k×v= (ˆurquov)×v+ ˆr,ˆr∈o(xk)
= rshift −h(ˆu×lshinvhv)×v+ ˆr
⇒u=/parenleftbig
rshift−h(ˆu×lshinvhv)+Qxh−k/parenrightbig
×v+ ˆr
= rshift −h(ˆu×lshinvhv+Qx2h−k)×v+ ˆr.
From this, we have
urquov= rshift −h(ˆu×lshinvhv+Qx2h−k)
= rshift −h/parenleftbig
(u−Qxh−k×v)×lshinvhv+Qx2h−k/parenrightbig
= rshift −h/parenleftbig
u×lshinvhv−Qxh−k×v×lshinvhv+Qx2h−k/parenrightbig
= rshift −h/parenleftbig
u×lshinvhv−Qxh−k×v×(xhlquov)+Qx2h−k/parenrightbig
= rshift −h/parenleftbig
u×lshinvhv−Qxh−k×(xh+o(xk))+Qx2h−k/parenrightbig
= rshift −h/parenleftbig
u×lshinvhv+Q×o(xh)/parenrightbig
= rshift −h(u×lshinvhv).
This completes the inductive step and the proof of ( 20). Equation ( 21) is proven
as above, mutatis mutandis . /square
Asinthecommutativecase,itmaybemoreeﬃcienttocomputeonlyth erequired
top part of the product in ( 20) and (21) rather than to compute the whole
product and then shift by −h.
157 Skew Polynomial Examples
7.1 Diﬀerential Operators
We take F7[y,∂y] as a ﬁrst example of using whole shifted inverses to compute
quotients of skew polynomials. We use Algorithm 4to compute the left and right
whole shifted inverses, and then Theorem 7to obtain the quotients. We start
withuandv
u= (3y+6)∂5
y+(3y+1)∂4
y+6y∂3
y+4y∂2
y+(2y+1)∂y+(2y+5)
v= 4∂2
y+(2y+5)∂y+(4y+6).
The whole shifted inverses lshinv 5v=∂5
ylquovand rshinv 5=∂5
yrquovare
computed by Algorithm 4.
lshinv5= 2∂3
y+(6y+1)∂2
y+(4y2+4y+3)∂y+(5y3+y2+3y+2)
rshinv 5= 2∂3
y+(6y+1)∂2
y+(4y2+4y+5)∂y+(5y3+y2+y+1).
Thenql= lshift −5(rshinv 5v×u) andqr= rshift −5(u×lshinv5v) so
ql= (6y+5)∂3
y+(4y2+3y+3)∂2
y+(5y3+5y2+5)∂y
+(y4+3y3+5y2+5y+2)
rl= (5y5+4y4+3y3+6y2+4y)∂y+(3y5+2y4+y3+5y2+5)
qr= (6y+5)∂3
y+(4y2+3y+1)∂2
y+(5y3+5y2+4y+3)∂y
+(y4+3y3+5y2+3y+5)
rr= (5y5+4y4+6y3)∂y+(3y5+3y4+5y3+y2+4y+5).
A proof-of-concept Maple implementation for generic skew polynom ials is given
in Figure 2. The program is to clarify any ambiguities without any serious at-
tention to eﬃciency. The setup for the above example is
with(Domains):
LinearOrdinaryDifferentialOperator :=
(R, x) -> SkewPolynomial(R, x, r->r, R[Diff], r->r):
F := GaloisField(7):
R := DenseUnivariatePolynomial(F, ’y’):
Lodo := LinearOrdinaryDifferentialOperator(R, ’D[y]’):
167.2 Diﬀerence Operators
We use linear ordinary diﬀerence operators as a second example, th is time with
σnot being the identity. We construct F7[y,∆y] asF7[y][∆y;E,E−1].As before,
we use Algorithm 4to compute the left and right whole shifted inverses, and
then Theorem 7to obtain the quotients. We take uandvto be
u=y∆5
y+(3y+6)∆4
y+(6y+5)∆3
y+3y∆2
y+(2y+1)∆y+5y
v= 4∆2
y+(6y+1)∆y+(6y+6).
The whole shifted inverses lshinv 5v=∆5
ylquovand rshinv 5=∆5
yrquovare
computed by Algorithm 4.
lshinv5= 2∆3
y+(4y+2)∆2
y+(y2+4y)∆y+(2y3+6y2+y)
rshinv 5= 2∆3
y+(4y+1)∆2
y+(y2+2)∆y+(2y3+y2+4y+1).
Thenql= lshift −5(rshinv 5v×u) andqr= rshift −5(u×lshinv5v) so
ql= (2y+3)∆3
y+(4y2+3y+4)∆2
y+(y3+5y2+6y+4)∆y
+(2y4+6y3+4y2+4y+4)
rl= (2y5+6y4+6y2+5y+3)∆y+(2y5+2y4+4y3+2y+1)
qr= 2y∆3
y+(4y2+5)∆2
y+(y3+5y2+y+6)∆y+(2y4+4y3+5y+1)
rr= (2y5+3y4+4y3+y2)∆y+(2y5+6y4+5y3+3y2+5y).
The Maple setup for this example is
# Delta(f) acts as subs(y=y+1, f) - f for f in R
LinearOrdinaryDifferenceOperator := proc(R, x, C)
local E := R[ShiftOperator];
SkewPolynomial(R, x, r->E(r,C[1]), r->R[‘-‘](E(r,C[1]) ,r),
r->E(r,C[‘-‘](C[1])));
end:
F := GaloisField(7);
R := DenseUnivariatePolynomial(F, ’y’);
Lodo := LinearOrdinaryDifferenceOperator(R, ’Delta[y]’ , F)
7.3 Diﬀerence Operators with Matrix Coeﬃcients
As a ﬁnal example, we take quotients in F2×2
7[y,∆y] to underscorethe genericity
of this method.
u=/parenleftbigg/bracketleftbigg
6 0
1 1/bracketrightbigg
y+/bracketleftbigg
3 0
2 0/bracketrightbigg/parenrightbigg
∆5
y+/parenleftbigg/bracketleftbigg
4 4
6 5/bracketrightbigg
y+/bracketleftbigg
3 2
4 4/bracketrightbigg/parenrightbigg
∆4
y+/parenleftbigg/bracketleftbigg
4 3
0 3/bracketrightbigg
y+/bracketleftbigg
1 1
4 1/bracketrightbigg/parenrightbigg
∆3
y
+/parenleftbigg/bracketleftbigg0 1
4 5/bracketrightbigg
y+/bracketleftbigg3 2
5 4/bracketrightbigg/parenrightbigg
∆2
y+/parenleftbigg/bracketleftbigg0 6
4 3/bracketrightbigg
y+/bracketleftbigg0 0
0 6/bracketrightbigg/parenrightbigg
∆y+/parenleftbigg/bracketleftbigg5 3
6 2/bracketrightbigg
y+/bracketleftbigg5 2
1 2/bracketrightbigg/parenrightbigg
v=/bracketleftbigg
1 5
2 6/bracketrightbigg
∆2
y+/parenleftbigg/bracketleftbigg
1 5
0 0/bracketrightbigg
y+/bracketleftbigg
4 6
3 4/bracketrightbigg/parenrightbigg
∆y+/parenleftbigg/bracketleftbigg
2 6
0 4/bracketrightbigg
y+/bracketleftbigg
0 3
1 2/bracketrightbigg/parenrightbigg
17lshinv5=/bracketleftbigg2 3
4 5/bracketrightbigg
∆3
y+/parenleftbigg/bracketleftbigg5 0
3 0/bracketrightbigg
y+/bracketleftbigg0 4
1 2/bracketrightbigg/parenrightbigg
∆2
y+/parenleftbigg/bracketleftbigg2 0
4 0/bracketrightbigg
y2+/bracketleftbigg3 1
0 1/bracketrightbigg
y+/bracketleftbigg0 2
4 4/bracketrightbigg/parenrightbigg
∆y
+/parenleftbigg/bracketleftbigg5 0
3 0/bracketrightbigg
y3+/bracketleftbigg4 2
0 4/bracketrightbigg
y2+/bracketleftbigg2 6
6 6/bracketrightbigg
y+/bracketleftbigg1 2
6 6/bracketrightbigg/parenrightbigg
rshinv 5=/bracketleftbigg2 3
4 5/bracketrightbigg
∆3
y+/parenleftbigg/bracketleftbigg5 0
3 0/bracketrightbigg
y+/bracketleftbigg4 4
2 2/bracketrightbigg/parenrightbigg
∆2
y+/parenleftbigg/bracketleftbigg2 0
4 0/bracketrightbigg
y2+/bracketleftbigg2 1
5 1/bracketrightbigg
y+/bracketleftbigg6 0
0 2/bracketrightbigg/parenrightbigg
∆y
+/parenleftbigg/bracketleftbigg
5 0
3 0/bracketrightbigg
y3+/bracketleftbigg
2 2
3 4/bracketrightbigg
y2+/bracketleftbigg
3 5
5 4/bracketrightbigg
y+/bracketleftbigg
1 3
3 1/bracketrightbigg/parenrightbigg
ql=/parenleftbigg/bracketleftbigg
1 3
1 5/bracketrightbigg
y+/bracketleftbigg
3 1
6 4/bracketrightbigg/parenrightbigg
∆3
y+/parenleftbigg/bracketleftbigg
2 0
4 0/bracketrightbigg
y2++/bracketleftbigg
4 6
2 1/bracketrightbigg
y+/bracketleftbigg
2 1
5 0/bracketrightbigg/parenrightbigg
∆2
y
+/parenleftbigg/bracketleftbigg
5 0
3 0/bracketrightbigg
y3+/bracketleftbigg
4 0
6 6/bracketrightbigg
y2+/bracketleftbigg
2 4
5 4/bracketrightbigg
y+/bracketleftbigg
0 5
6 1/bracketrightbigg/parenrightbigg
∆y
+/parenleftbigg/bracketleftbigg2 0
4 0/bracketrightbigg
y4+/bracketleftbigg4 3
2 6/bracketrightbigg
y3+/bracketleftbigg1 0
5 0/bracketrightbigg
y2+/bracketleftbigg4 3
1 5/bracketrightbigg
y+/bracketleftbigg5 6
1 6/bracketrightbigg/parenrightbigg
rl=/parenleftbigg/bracketleftbigg6 0
0 0/bracketrightbigg
y5+/bracketleftbigg6 2
1 0/bracketrightbigg
y4+/bracketleftbigg6 6
4 6/bracketrightbigg
y3+/bracketleftbigg2 2
3 6/bracketrightbigg
y2+/bracketleftbigg2 4
6 0/bracketrightbigg
y+/bracketleftbigg6 5
2 0/bracketrightbigg/parenrightbigg
∆y
+/parenleftbigg/bracketleftbigg
0 0
5 0/bracketrightbigg
y5+/bracketleftbigg
6 0
3 4/bracketrightbigg
y4+/bracketleftbigg
3 2
3 6/bracketrightbigg
y3+/bracketleftbigg
5 1
3 0/bracketrightbigg
y2+/bracketleftbigg
3 6
4 6/bracketrightbigg
y+/bracketleftbigg
2 4
2 6/bracketrightbigg/parenrightbigg
qr=/parenleftbigg/bracketleftbigg5 4
6 1/bracketrightbigg
y+/bracketleftbigg6 2
4 6/bracketrightbigg/parenrightbigg
∆3
y+/parenleftbigg/bracketleftbigg2 0
1 0/bracketrightbigg
y2+/bracketleftbigg0 0
6 0/bracketrightbigg
y+/bracketleftbigg5 3
4 5/bracketrightbigg/parenrightbigg
∆2
y
+/parenleftbigg/bracketleftbigg
5 0
6 0/bracketrightbigg
y3+/bracketleftbigg
1 6
0 2/bracketrightbigg
y2+/bracketleftbigg
5 5
1 4/bracketrightbigg
y+/bracketleftbigg
5 3
2 6/bracketrightbigg/parenrightbigg
∆y
+/parenleftbigg/bracketleftbigg2 0
1 0/bracketrightbigg
y4+/bracketleftbigg2 5
5 6/bracketrightbigg
y3+/bracketleftbigg5 2
4 3/bracketrightbigg
y2+/bracketleftbigg2 2
1 1/bracketrightbigg
y+/bracketleftbigg2 5
2 3/bracketrightbigg/parenrightbigg
rr=/parenleftbigg/bracketleftbigg5 4
6 2/bracketrightbigg
y5+/bracketleftbigg1 4
0 3/bracketrightbigg
y4+/bracketleftbigg4 4
3 2/bracketrightbigg
y3+/bracketleftbigg1 3
1 4/bracketrightbigg
y2+/bracketleftbigg3 2
2 5/bracketrightbigg
y+/bracketleftbigg2 6
4 5/bracketrightbigg/parenrightbigg
∆y
+/parenleftbigg/bracketleftbigg
3 2
5 1/bracketrightbigg
y5+/bracketleftbigg
3 4
4 6/bracketrightbigg
y4+/bracketleftbigg
3 0
2 6/bracketrightbigg
y3+/bracketleftbigg
6 1
2 6/bracketrightbigg
y2+/bracketleftbigg
3 2
6 0/bracketrightbigg
y+/bracketleftbigg
4 0
1 3/bracketrightbigg/parenrightbigg
The Maple setup for this example is the same as for the previous exam ple but
withF := SquareMatrix(2, GaloisField(7)) .
188 Conclusions
We have extended earlier work on eﬃcient computation of quotients in a generic
setting to the case of non-commutative univariate polynomial rings . We have
shown that when the polynomial variable commutes with the coeﬃcien ts, the
whole shift and whole shifted inverse are well-deﬁned and they may be used to
compute left and right quotients. The whole shifted inverse may be c omputed
by a modiﬁed Newton method in exactly the same way as when the coeﬃ cients
are commutative and the number of iterations is logarithmic in the deg ree of the
result. When the polynomial variable does not commute with the coeﬃ cients,
left and right whole shifted inverses exist and may be computed by cla ssical
division.Oncealeft orrightwholeshifted inverseis obtained,severa lrightorleft
quotients with that divisor may be computed, each with a single multiplic ation.
References
1. Abramov, S.A., Le, H.Q., Li, Z.: Univariate Ore polynomia l rings in computer
algebra. Journal of Mathematical Sciences 131(5), 5885–5903 (2005)
2. Bronstein, M., Petkovˇ sek, M.: An introduction to pseudo -linear algebra. Theoret-
ical Computer Science 157(1), 3–33 (1996)
3. Jacobson, N.: Pseudo-linear transformations. Annals of Mathematics, Second Se-
ries38(2), 484–507 (1937)
4. Moenck, R.T., Borodin, A.B.: Fast modular transforms via division. In: Proc. 13th
Annual Symposium on Switching and Automata Theory (SWAT 197 2). pp. 90–96.
IEEE, New York (1972)
5. Monagan, M.B.: Gauss: a parameterized domain of computat ion system with sup-
port for signature functions. In: Miola, A. (ed.) Design and Implementation of
Symbolic Computation Systems. pp. 81–94. Springer Berlin H eidelberg, Berlin,
Heidelberg (1993)
6. Ore, Ø.: Theory of non-commutative polynomials. Annals o f Mathematics, Second
Series34(3), 480–508 (1933)
7. Schulz,G.: Iterative Berechnungder reziproken Matrix. Zeitschrift f¨ ur Angewandte
Mathematik und Mechanik 13(1), 57–59 (1933)
8. van der Hoeven, J.: FFT-like multiplication of linear diﬀ erential operators. Journal
of Symbolic Computation 33(1), 123–127 (2002)
9. van der Hoeven, J.: On the complexity of skew arithmetic. A pplicable Algebra in
Engineering, Communication and Computing 27, 105–122 (2016)
10. Watt, S.M.: Eﬃcient generic quotients using exact arith metic. In: Proc. Interna-
tional Symposium on Symbolic and Algebraic Computation (IS SAC 2023). ACM,
New York (2023)
19fshinv := proc (PR, method, h, v, perm)
local R, x, k, vk, ivk, vkm1, w, ell, m, s, g, rmul, pmul, pshift , monom,
step, refine, refine1, refine2, refine3;
R := PR[CoefficientRing];
pmul := (a, b) -> PR[‘*‘](perm(a, b));
rmul := (a, b) -> R [‘*‘](perm(a, b));
monom := (c, x, n) -> PR[‘*‘](PR[Polynom]([c]), PR[‘^‘](x, n));
pshift := (n,v) -> shift(PR, n, v);
step := proc(h, v, w, m, ell)
PR[‘+‘]( pshift(m,w), pshift(2*m-h,pmul(w,PR[‘-‘]( PR[ ‘^‘](x,h-m), pmul(v,w) ))) )
end;
refine1 := proc (v, h, k, w0, ell0) local m, s, w, ell;
w := pshift(h-k-ell0+1, w0); ell := ell0;
while ell < h-k+1 do
w := step(h, v, w, 0, ell); ell := min(2*ell, h-k+1)
od;
w
end;
refine2 := proc (v, h, k, w0, ell0) local m, w, ell;
w := w0; ell := ell0;
while ell < h-k+1 do
m := min(h-k+1-ell, ell);
w := step(k+ell+m-1, v, w, m, ell); ell := ell+m
od;
w
end;
refine3 := proc (v, h, k, w0, ell0) local m, s, w, ell;
w := w0; ell := ell0;
while ell < h-k+1 do
m := min(h-k+1-ell, ell); s := max(0, k-2*ell+1);
w := step(k+ell+m-1-s, pshift(-s, v), w, m, ell); ell := ell+ m
od;
w
end;
if method = 1 then refine := refine1
elif method = 2 then refine := refine2
elif method = 3 then refine := refine3
else error "Unknown method", method
fi;
x := PR[Polynom]([R[0],R[1]]); k := PR[Degree](v);
vk := PR[Lcoeff](v); ivk := R[‘^‘](vk, -1);
if h < k then return 0
elif k = 0 or h = k or v = monom(vk,x,k) then return monom(ivk,x, h-k)
fi;
vkm1 := PR[Coeff](v, k-1);
w := PR[Polynom]([rmul(ivk, rmul(R[‘-‘](vkm1), ivk)), iv k]); ell := 2;
g := 1; # Assume all coeff rings need a guard digit
pshift(-g, refine(v, h + g, k, w, ell))
end:
fdiv := proc (PR, method, u, v, perm) local mul, h, iv, q, r;
mul := (a, b) -> PR[‘*‘](perm(a, b));
h := PR[Degree](u);
iv := fshinv(PR, method, h, v, perm);
q := shift(PR,-(h-k),mul(shift(PR,-k,u),iv)); # Need onl y top h-k terms
r := PR[‘-‘](u, mul(q, v));
(q, r)
end:
lfdiv := (PR, method, u, v) -> fdiv(PR, method, u, v, (a,b)->( b,a)):
rfdiv := (PR, method, u, v) -> fdiv(PR, method, u, v, (a,b)->( a,b)):
Fig.1: Maple code for fast generic polynomial shinv and left and right division
20SkewPolynomial := proc (R, x, sigma, delta, sigmaInv)
local P, deltaStar, mult2, MultVarOnLeft, MultVarOnRight ;
# Table to contain the operations.
P := DenseUnivariatePolynomial(R, x);
# If x*r = sigma(r)*x + delta(r), then
# r*x = x*sigmaInv(r) - delta(sigmaInv(r)) = x*sigmaInv(r) + deltaStar(r)
deltaStar := r -> R[‘-‘](delta(sigmaInv(r)));
P[DomainName]:= ’SkewPolynomial’;
P[Categories]:= P[Categories] minus {CommutativeRing,I ntegralDomain};
P[Properties]:= P[Properties] minus {Commutative(‘*‘)} ;
P[ThetaOp] := P[Polynom]([R[0], R[1]]); # The variable as s kew polynomial.
P[Apply] := proc(ell, p) local i, pi, result; # Apply a skew po lynomial as an operator.
pi := p; # delta^i (p)
result := R[‘*‘](P[Coeff](ell, 0), pi);
for i to P[Degree](ell) do # For Maple, for loop default from i s 1.
pi := delta(pi);
result := R[‘+‘](result, R[‘*‘](P[Coeff](ell, i), pi))
od;
result
end:
P[‘^‘] := proc(a0, n0) local a, n, p; # Binary powering
a := a0; n := n0; p := P[1];
while n > 0 do
if irem(n,2) = 1 then p := P[‘*‘](p, a) fi; a := P[‘*‘](a, a); n : = iquo(n,2);
od;
p
end:
P[‘*‘] := proc() local i, p; # N-ary product
p := P[1]; for i to nargs do p := mult2(p, args[i]) od; p
end:
mult2 := proc(a, b) local s, i, ai, xib; # Binary product
xib := b; ai := P[Coeff](a,0);
s := P[Map](c->R[‘*‘](ai, c), xib);
for i to P[Degree](a) do
xib := MultVarOnLeft(xib); ai := P[Coeff](a, i);
s := P[‘+‘](s, P[Map](c->R[‘*‘](ai,c), xib));
od;
s
end:
# Compute x*b as polynomial with powers on right.
# x*sum(b[i]*x^i, i=0..degb) = sum(sigma(b[i])*x^(i+1) + delta(b[i])*x^i, i=0..degb)
MultVarOnLeft := proc(b) local cl, slist, dlist;
cl := P[ListCoeffs](b);
slist := [ R[0], op(map(sigma, cl)) ]; dlist := [ op(map(delt a, cl)), R[0] ];
P[Polynom](zip(R[‘+‘], slist, dlist));
end:
# Compute b*x as polynomial with powers on left.
# sum(x^i*b[i], i=0..degb)*x = sum(x^(i+1)*sigmaInv(b[i ]) + deltaStar(b[i])*x^i, i=0..degb)
MultVarOnRight := proc(b) local cl, slist, dlist;
cl := P[ListCoeffs](b);
slist := [ R[0], op(map(sigmaInv, cl)) ]; dlist := [ op(map(d eltaStar, cl)), R[0] ];
P[Polynom](zip(R[‘+‘], slist, dlist));
end:
# Continued in Part 2...
Fig.2: Maple code for generic skew polynomials (Part 1)
21# ... continued from Part 1.
# For v = sum(vr_i x^i, i = 0..k) = sum(x^i vl_i, i = 0..k)
# return polynomial with vl_i, interpreting powers as on lef t,
# abusing the representation of output.
P[ConvertToAdjointForm] := proc(v) local v_adj, i, rci, rc ip;
v_adj := P[0];
for i from P[Degree](v) to 0 by -1 do
rci := P[Polynom]([P[Coeff](v,i)]);
v_adj := P[‘+‘](v_adj, (MultVarOnRight@@i)(rci));
od;
v_adj
end:
# For v = sum(x^i vl_i, i = 0..k) = sum(x^i vr_i, i = 0..k)
# return polynomial with vr_i, interpreting powers as on rig ht,
# abusing the representation of input.
P[ConvertFromAdjointForm] := proc(v_adj) local v, i, rci;
v := P[0];
for i from 0 to P[Degree](v_adj) do
rci := P[Polynom]([P[Coeff](v_adj,i)]);
v := P[‘+‘](v, (MultVarOnLeft@@i)(rci))
od;
v
end:
# Shift by power on left.
P[LShift] := proc(n, v0) local v, shv, i, k;
v := P[ConvertToAdjointForm](v0); k := P[Degree](v);
if k + n < 0 then shv := P[0]
elif n < 0 then shv := P[Polynom]([seq(P[Coeff](v,i), i = -n. .k)])
else shv := P[Polynom]([seq(R[0], i=1..n), seq(P[Coeff]( v,i), i=0..k)])
fi;
P[ConvertFromAdjointForm](shv)
end:
# Shift by power on right.
P[RShift] := proc(n, v) local i, k;
k := P[Degree](v);
if k + n < 0 then P[0]
elif n < 0 then P[Polynom]([seq(P[Coeff](v,i), i = -n..k)])
else P[Polynom]([seq(R[0], i=1..n), seq(P[Coeff](v,i), i=0..k)])
fi
end:
# Quotient and remainder
P[GDiv] := proc(perm, qfun) proc (u, v) local h, k, x, ivk, t, q , r, i, qi;
x := P[Polynom]([R[0], R[1]]); ivk := R[Inv](P[Lcoeff](v) );
h := P[Degree](u); k := P[Degree](v);
q := P[0]; r := u;
for i from h - k by -1 to 0 do
qi := qfun(P[Coeff](r,i+k), ivk, i, k);
t := P[‘*‘](P[Constant](qi), P[‘^‘](x,i));
q := P[‘+‘](q, t);
r := P[‘-‘](r, P[‘*‘](perm(t, v)));
od;
(q, r)
end end:
P[RDiv0] := P[GDiv](rperm, (u,iv,n,k)->R[‘*‘](u,(sigma @@n)(iv)));
P[LDiv] := P[GDiv](lperm, (u,iv,n,k)->(sigmaInv@@k)(R[ ‘*‘](iv,u)));
# Continued in Part 3...
Fig.2: Maple code for generic skew polynomials (Part 2)
22# ... continued from Part 2.
# A slightly less repetitive RDiv.
P[RDiv] := proc (u, v) local h, k, x, ivk, sigma_ivk_i, x_i_v, q, r, i, qi;
x := P[Polynom]([R[0], R[1]]); ivk := R[Inv](P[Lcoeff](v) );
h := P[Degree](u); k := P[Degree](v);
# Precompute sigma^i(ivk) and x^i*v for required i.
sigma_ivk_i[0] := ivk;
for i from 1 to h-k do sigma_ivk_i[i] := sigma(sigma_ivk_i[i -1]); od;
x_i_v[0] := v;
for i from 1 to h-k do x_i_v[i] := P[‘*‘](x, x_i_v[i-1]) od;
q := P[0]; r := u;
for i from h - k by -1 to 0 do
qi := P[Constant](R[‘*‘](P[Coeff](r, i+k), sigma_ivk_i[ i]));
q := P[‘+‘](q, P[‘*‘](qi, P[‘^‘](x,i)));
r := P[‘-‘](r, P[‘*‘](qi, x_i_v[i]));
od;
(q, r)
end:
# Needed for some versions of Maple.
P[0] := P[Polynom]([R[0]]);
P[1] := P[Polynom]([R[1]]);
P[‘-‘] := proc()
local nb := P[Polynom](map(c-> R[‘-‘](c), P[ListCoeffs]( args[nargs])));
if nargs = 1 then nb else P[‘+‘](args[1], nb) fi
end:
# Return the table
P
end:
Fig.2: Maple code for generic skew polynomials (Part 3)
23
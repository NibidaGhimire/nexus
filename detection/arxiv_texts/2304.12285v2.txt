arXiv:2304.12285v2  [cs.DS]  31 May 2023Low-Memory Algorithms for Online and W-Streaming Edge
Coloring
Prantar Ghosh * Manuel Stoeckl†
Abstract
For edge coloring, the online and the W-streaming models seem so mewhat orthogonal: the former needs edges
to be assigned colors immediately after insertion, typically witho ut any space restrictions, while the latter limits
memory to sublinear in the input size but allows an edge’ s color to b e announced any time after its insertion.
We aim for the best of both worlds by designing small-space online algorithms for edge coloring. We study the
problem under both (adversarial) edge arrivals and vertex arr ivals. Our results signiﬁcantly improve upon the
memory used by prior online algorithms while achieving an O(1)-competitive ratio. In particular, for n-node
graphs with maximum vertex-degree ∆under edge arrivals, we obtain an online O(∆)-coloring in ˜O(n/ra⌈i⌋allow
∆) space.
This is also the ﬁrst W-streaming edge-coloring algorithm using O(∆) colors (in sublinear memory). All prior
works either used linear memory or ω(∆) colors. We also achieve a smooth color-space tradeoff: for a nyt=
O(∆), we get an O(∆t(log2∆))-coloring in ˜O(n/ra⌈i⌋allow
∆/t) space, improving upon the state of the art that used ˜O(n∆/t)
space for the same number of colors (the /tildewideO(.) notation hides polylog( n) factors). The improvements stem from
extensive use of random permutations that enable us to avoid pre viously used colors. Most of our algorithms can
be derandomized and extended to multigraphs, where edge colorin g is known to be considerably harder than for
simple graphs.
1 Introduction
A proper edge-coloring of a graph or a multigraph colors its e dges such that no two adjacent edges share the same
color. The goal is to use as few colors as possible. Any graph w ith maximum vertex-degree ∆trivially requires
∆colors to be properly edge-colored. A celebrated theorem of Vizing [ Viz64 ] says that ∆+1 colors sufﬁce for
any simple graph.1There are constructive polynomial time algorithms that ach ieve a ( ∆+1)-edge-coloring in
the classical ofﬂine setting [ MG92 ]. These algorithms are likely to be optimal with respect to t he number of colors:
distinguishing between whether the edge-chromatic number (i.e., the minimum number of colors needed to edge-
color a graph) of a simple graph is ∆or∆+1 is NP-hard [ Hol81 ].
The edge-coloring problem has several practical applicati ons, including in switch routing [ AMSZ03 ], round-
robin tournament scheduling [ JURdW16 ], call scheduling [ EJ01 ], optical networks [ RU94 ], and link scheduling in
sensor networks [ GDP05 ]. In many of these applications, such as in switch routing, t he underlying graph is built
gradually by a sequence of edge insertions and the color assi gnments need to be done instantly and irrevocably.
This is modeled by the online edge coloring problem. Due to its restrictions, an online al gorithm cannot obtain
a (∆+1)-coloring [ BMN92 ]. Consider, however, the simple greedy algorithm that colo rs every edge with the ﬁrst
available color that is not already assigned to any of its nei ghbors. Since each edge can have at most 2 ∆−2 adjacent
edges, this algorithm achieves a (2 ∆−1)-coloring, i.e., a competitive ratio of 2 −o(1) (since the optimum is ∆or
∆+1). Bar-Noy, Motwani, and Naor [ BMN92 ] showed that no online algorithm can perform better than thi s greedy
algorithm. However, they proved this only for graphs with ma x-degree ∆=O(log n). They conjectured that for
∆=ω(log n), it is possible to get better bounds, and that, in particula r, a (1+o(1))∆-coloring is possible. Several
works [ AMSZ03 ,BMM12 ,CPW19 ,BGW21 ,SW21 ,KLS+22,NSW23 ] have studied online edge coloring with the aim
of beating the greedy algorithm and/or resolving the said co njecture. Other variants of the problem have also been
*DIMACS, Rutgers University. Research supported in part by a grant (820931) to DIMACS from the Simons Foundation.
†Department of Computer Science, Dartmouth College. This wo rk was supported in part by the National Science Foundation u nder award
2006589.
1For multigraphs, 3 ∆/2 colors are necessary and sufﬁcient. [ Sha49 ]
1studied [ FN03 ,Mik16 ,FM18 ]. However, all prior works assume that all graph edges are al ways stored in the memory
along with their colors.
With the ubiquity of big data in the modern world, this assump tion often seems fallacious. The graphs that mo-
tivate the study of edge coloring, such as communication and internet routing networks, turn out to be large-scale
or massive graphs in today’s world, making it expensive for s ervers to store them entirely in their memory. This
has led to big graph processing models such as graph streaming that, similar to the online model, have sequential
access to the graph edges, but can only store a small summary o f the input graph so as to solve a problem related
to it. There is an immediate barrier for the edge coloring pro blem in this setting: the output size is as large as the
input, and hence an algorithm must use space linear in the inp ut size to present the output as a whole. To remedy
this, one can consider the natural extension of the model whe re the output is also reported in streaming fashion: in
the context of edge coloring, think of the algorithm having a limited working memory to store information about
both the input graph and the output coloring; it periodicall y streams or announces the edge colors before deleting
them from its memory. This is the so called W-streaming model . Unlike the online model, here we don’t need to
assign a color to the incoming edge right away, and can defer i t to some later time. However, due to the space
restriction, we are not able to remember all the previously a nnounced colors. Note that this makes even the greedy
(2∆−1)-coloring algorithm hard (or maybe impossible) to implem ent in this model.
In this work, we aim to get the best of both worlds of the online and the streaming models: we focus on de-
signing low-memory online algorithms for edge coloring. This is motivated by mo dern practical scenarios that
demand immediate color assignment as well as space optimiza tion. We succeed in designing such algorithms and
at the same time, the quality of our algorithms is close to opt imal: we achieve an O(1)-competitive ratio, i.e., a
color bound of O(∆). Note that no prior work studying edge-coloring in the subl inear-space setting could attain
anO(∆)-coloring W-streaming algorithm, let alone online. For ad versarial edge-arrival streams, we get an on-
line O(∆)-coloring in O(n/ra⌈i⌋allow
∆) space, signiﬁcantly reducing the space used by prior onlin e algorithms at the cost
of only a constant factor in the number of colors. We can smoot hly tradeoff space with colors to get an O(∆t)-
coloring in /tildewideO(n/ra⌈i⌋allow
∆/t) space. This improves upon the state of the art [ CL21 ,ASZZ22 ] which obtained the same
color bound using /tildewideO(n∆/t) space. Furthermore, for the natural and well-studied sett ings of vertex-arrival in gen-
eral graphs and one-sided vertex arrival in bipartite graph s, we can improve the space usage to O(npolylog n), i.e.,
semi-streaming, which is the most popular memory regime for graph streaming problems. Most of our algorithms
generalize to multigraphs and can be made deterministic.
1.1 Our Results and Contributions
We study edge-coloring in the online model with sublinear (i .e.,o(n∆)) memory as well as in the W-streaming
model and improve upon the state of the art. These results are summarized in Table 1and Table 2. They also
mention the state of the art, for comparison.
We consider the problem under (adversarial) edge-arrivals as well as vertex-arrivals. We give an account of our
results in each of these models below.
Edge-arrival model. Here we design both online and W-streaming algorithms.
Theorem 1.1 (Formalized in Theorem 4.4).Given any adversarial edge-arrival stream of a simple graph , there is a
randomized algorithm for online O (∆)-edge-coloring using /tildewideO(n/ra⌈i⌋allow
∆)bits of space.
Previously, there was no sublinear space online algorithm k nown for O(∆)-coloring. As observed in Table 1, all
prior algorithms need Θ(n∆) space in the worst case to achieve a color bound of O(∆).
Note that Theorem 1.1immediately implies a randomized W-streaming algorithm wi th the same space and
color bounds. Although immediate, we believe that it is impo rtant to note it as a corollary.
Corollary 1.2. Given an adversarially ordered edge stream of any simple gra ph, there is a randomized W-streaming
algorithm for O (∆)-edge-coloring using /tildewideO(n/ra⌈i⌋allow
∆)bits of space.
The above result improves upon the state of the art algorithm s of [ CL21 ,ASZZ22 ] which, as implied by Table 2,
only obtain ω(∆)-colorings for o(n∆) space (the non-trivial memory regime in W-streaming). In f act, we improve
upon them by a factor of Ω(/ra⌈i⌋allow
∆) in space for O(∆)-coloring.
We show that the above W-streaming algorithm can be made to wo rk for multigraphs and against adaptive
adversaries at the cost of /tildewideO(n∆) bits of oracle randomness.
2Arrival Algorithm Colors Space Graph Reference
Edge Randomized/parenleftbige
e−1+o(1)/parenrightbig
∆ /tildewideO(n∆) Simple [ KLS+22]
Edge Randomized O(∆) /tildewideO(n/ra⌈i⌋allow
∆) Simple Theorem 1.1
Edge Deterministic (2 ∆−1)t O (n∆/t) Multigraph [ ASZZ22 ]
Edge Deterministic /tildewideO(∆t) /tildewideO(n/ra⌈i⌋allow
∆/t)⋆ Multigraph Theorem 1.4
Vertex Randomized (1.9 +o(1))∆ /tildewideO(n∆) Simple [ SW21 ]
Vertex Randomized O(∆) /tildewideO(n)⋆ Multigraph Theorem 1.7
Vertex Deterministic 2 ∆−1 O(n∆) Multigraph Greedy folklore
Vertex Deterministic O(∆) /tildewideO(n)⋆ Multigraph Theorem 1.8
One-sided vertex Randomized (1 +o(1))∆ /tildewideO(n∆) Simple [ CPW19 ]
One-sided vertex Randomized 1.533 ∆ /tildewideO(n∆) Multigraph [ NSW23 ]
One-sided vertex Randomized 5 ∆ /tildewideO(n)⋆ Multigraph Lemma 3.4
One-sided vertex Deterministic 2 ∆−1 O(n∆) Multigraph Greedy folklore
One-sided vertex Deterministic O(∆) /tildewideO(n)⋆ Multigraph Lemma 3.8
Table 1: Our results in the online model. Here, t=O(∆) is any positive integer. Algorithms marked with a ⋆require
oracle randomness for randomized algorithms and advice com putable in exponential time for deterministic.
Algorithm Colors Space Graph Reference
Randomized O(∆2/s) /tildewideO(ns) Simple [ CL21 ]
Randomized O(∆2/s) /tildewideO(n/ra⌈i⌋allows) Simple Corollary 1.2
Randomized O(∆2/s) /tildewideO(n/ra⌈i⌋allows)⋆ Multigraph Theorem 1.3
Deterministic (1 −o(1))∆2/s O (ns) Simple [ ASZZ22 ]
Deterministic /tildewideO(∆2/s) /tildewideO(n/ra⌈i⌋allows)⋆ Multigraph Corollary 1.5
Table 2: Our results in the W-streaming model. Here, s≤∆/2 is any positive integer. Results marked with ⋆require
oracle randomness for randomized algorithms and advice com putable in exponential time for deterministic.
Theorem 1.3 (Formalized in Theorem 4.3).Given an adversarially ordered edge stream of any multigrap h, there
is a randomized W-streaming algorithm for O (∆)edge-coloring using /tildewideO(n/ra⌈i⌋allow
∆)bits of space and /tildewideO(n∆)bits of oracle
randomness. The algorithm works even against adaptive adve rsaries.
Further, we prove that we can make the above algorithms deter ministic at the cost of only a polylogarithmic
factor in space. Once again, the online algorithm immediate ly implies a W-streaming algorithm.
Theorem 1.4 (Formalized in Theorem 4.8).Given an adversarial edge-arrival stream of edges of any mul tigraph,
there is a deterministic algorithm for online O (∆(log2∆))-edge-coloring using /tildewideO(n/ra⌈i⌋allow
∆)bits of space.
Corollary 1.5. Given an adversarially ordered edge stream of any multigrap h, there is a deterministic W-streaming
algorithm for O (∆(log2∆))-edge-coloring using /tildewideO(n/ra⌈i⌋allow
∆)bits of space.
Furthermore, in each case, we can achieve a smooth tradeoff b etween the number of colors and the memory
used. This is implied by a framework captured in the followin g lemma.
Lemma 1.6 (Formalized and generalized in Lemma 4.1).Suppose that we are given an f (n,∆)-space streaming
algorithm Afor O (∆)-coloring any n-node multigraph with max-degree ∆under adversarial edge arrivals. Then,
for any s ≥1, there is a streaming algorithm Bfor O (s∆)-coloring the same kind of graphs under adversarial edge
arrivals using f (n/s,s∆)+/tildewideO(n)bits of space.
For the online model, the above lemma combined with Theorem 1.4immediately gives the tradeoff of /tildewideO(∆t)
colors and /tildewideO(n/ra⌈i⌋allow
∆/t) space for any t=O(∆), as claimed in Table 1. In other words, combined with Corollary 1.2, it
implies the W-streaming bounds of O(∆2/s) colors and O(n/ra⌈i⌋allows) space for any s=O(∆), as claimed in Table 2. Note
3that our results match the tradeoff obtained by the state of t he art for t=Θ(∆) and s=O(1), and strictly improve
upon them for t=o(∆) and s=ω(1).
Vertex-Arrival Model. We now turn to the weaker vertex-arrival model. The online ed ge-coloring problem has
been widely studied in this setting as well (see Section 1.2for a detailed discussion). Our online algorithms obtain
signiﬁcantly better space bounds than the edge-arrival set ting.
Theorem 1.7 (Formalized in Theorem 3.5).Given any adversarial vertex-arrival stream of a multigrap h, there
is a randomized online O (∆)-edge coloring algorithm using /tildewideO(n)bits of space. It works even against an adaptive
adversary and uses /tildewideO(n∆)oracle random bits.
Thus, at the cost of only a constant factor in the number of col ors, we can improve the memory usage from
/tildewideO(n∆) to/tildewideO(n) for vertex-arrival streams. Since this algorithm immedia tely implies a W-streaming algorithm with
the same bounds, we see that for vertex-arrival streams, O(∆)-coloring can be achieved in semi-streaming space,
the most popular space regime for graph streaming. Behnezha d et al. [ BDH+19] mentioned that “a major open
question is whether [the number of colors for W-streaming ed ge-coloring] can be improved to O(∆) while also
keeping the memory near-linear in n.” Our results answer the question in the afﬁrmative for vert ex-arrival streams,
which is a widely studied model in the streaming literature a s well.
Further, we show that the algorithm can be made deterministi c using /tildewideO(n) bits of advice instead of /tildewideO(n∆) bits
of oracle randomness. By picking a uniformly random advice s tring, the same algorithm can alternatively be used
as a robust algorithm with 1/poly( n) error; the advice can also be computed in exponential time.
Theorem 1.8 (Formalized in Theorem 3.9).Given any adversarial vertex-arrival stream of a multigrap h, there is a
deterministic online O (∆)-edge-coloring algorithm using /tildewideO(n)bits of space, using /tildewideO(n)bits of advice.
An interesting special case of the vertex-arrival model is t he one-sided vertex-arrival setting for bipartite graphs.
Here, the vertices on one side of the bipartite graph are ﬁxed , while the vertices on the other side arrive in a se-
quence along with their incident edges. A couple of works [ CPW19 ,NSW23 ] have studied online edge-coloring
speciﬁcally in this model. We design low-memory online algo rithms in this model (see Algorithms 3and 4) and use
them as building blocks for our algorithms in the more genera l settings of vertex-arrival and edge-arrival. These
algorithms maybe of independent interest due to practical a pplications of the one-sided vertex-arrival model;
moreover, the randomized algorithm in this model uses only 5 ∆colors (as opposed to our algorithms where the
hidden constant in O(∆) is rather large).
Finally, we present a lower bound on the space requirement of a deterministic online edge-coloring algorithm.
Theorem 1.9 (Formalized in Theorem 5.2).For∆≤εn for a sufﬁciently small constant ε, any deterministic online
algorithm that edge-colors a graph using (2−o(1))∆colors requires Ω(n)space.
To the best of our knowledge, this is the ﬁrst non-trivial spa ce lower bound proven for an online edge-coloring
algorithm.
An outline of how the several building blocks are put togethe r to obtain the above results is given in Figure 1.
1.2 Related Work
Online model. The edge-coloring problem has a rich literature in the onlin e model [ AMSZ03 ,ASZZ22 ,BMN92 ,
BMM12 ,BGW21 ,CPW19 ,FM18 ,FN03 ,Mik15 ,Mik16 ,NSW23 ,KLS+22,SW21 ]. The seminal work of Bar-Noy, Mot-
wani, and Naor [ BMN92 ] showed that no online algorithm can do better than the greed y algorithm that obtains
a (2∆−1)-coloring by assigning each edge the ﬁrst available color that’s not already used by any of its adjacent
edges. However, this lower bound applies only to graphs with ∆=O(log n). They conjectured that for ∆=ω(log n),
there exist online (1 +o(1))∆-coloring algorithms. Although this conjecture remains un resolved, there has been
signiﬁcant progress on it over the years. A number of works [ AMSZ03 ,BMM12 ,BGW21 ] considered the problem
under random-order edge arrivals: Aggarwal et al. [ AMSZ03 ] showed that if ∆=ω(n2), then a (1 +o(1))∆-coloring is
possible. For ∆=ω(log n) (the bound in the said conjecture), Bahmani et al. [ BMM12 ] obtained a 1.26 ∆-coloring.
Bhattacharya et al. [ BGW21 ] then attained the “best of both worlds” by designing a (1 +o(1))∆-coloring algorithm
for∆=ω(log n), resolving the conjecture for random-order arrivals.
More relevant to our work is the setting of adversarial-order edge arrivals. Cohen et al. [ CPW19 ] were the ﬁrst
to make progress on [ BMN92 ]’s conjecture in this setting: they obtained a (1 +o(1))∆-coloring for bipartite graphs
4Theorem 1.7
Theorem 1.8
Theorem 1.3
Theorem 1.1
Theorem 1.4
Lemma 1.6
Theorem 1.9Lemma 3.4
Lemma 3.8
Lemma 3.7Lemma 3.6Lemma 6.2
Lemma 4.2Corollary 3.3
Corollary 3.2[SS96 ], as
Corollary 6.1
Lemma 4.7Lemma 6.3
Lemma 4.5[Mor13 ]
Lemma 5.1
Figure 1: Overview of how the results in this paper ﬁt togethe r. Primary results are in red; main supporting lemmas
in orange; and speciﬁc external results in yellow.
under one-sided vertex arrivals (i.e., the nodes on one side are ﬁxed, and the nodes on the other side arrive one by
one with all incident edges). Their algorithm assumes a prio ri knowledge of the value of ∆. For unknown ∆, they
prove that no online algorithm can achieve better than a ( e/(e−1))∆-coloring, and also complement this result with
a (e/(e−1)+o(1))∆-coloring algorithm for unknown ∆. For bipartite multigraphs with one-sided vertex arrivals,
Naor et al. [ NSW23 ] very recently prove that 1.533 ∆colors sufﬁce, while at least 1.207 ∆colors are necessary even
for∆=2. Saberi and Wajc [ SW21 ] showed that it is possible to beat the greedy algorithm for ∆=ω(log n) under
vertex arrivals in general graphs: they design a (1.9 +o(1))∆-coloring algorithm. Recently, Kulkarni et al. [ KLS+22]
made the ﬁrst progress on the said conjecture in the general s etting of adversarial edge arrivals: they obtained
a (e/(e−1)+o(1))∆-coloring in this model. Note that the focus of all these work s was on resolving [ BMN92 ]’s
conjecture without any space limitations. Our focus is on de signing low-memory online algorithms while staying
within a constant factor of the optimal number of colors. The only prior sublinear-space online edge-coloring
algorithm we know was given by Ansari et al. [ ASZZ22 ]: a (deterministic) online 2 ∆t-coloring in O(n∆/t) space for
any t≤∆.
A number of works [ FN03 ,EFKM10 ,FM18 ] have studied the variant of the problem where given a ﬁxed nu mber
of colors, the goal is to color as many edges as possible. Mikk elsen [ Mik15 ,Mik16 ] considered online edge-coloring
with limited advice for the future.
W-Streaming model. The W-streaming model [ DFR06 ] is a natural extension of the classical streaming model for
the study of problems where the output size is very large, pos sibly larger than our memory. While prior works have
considered several graph problems in this model [ DFR06 ,DEMR10 ,LS11 ,GSS22 ], we are only aware of three papers
[BDH+19,CL21 ,ASZZ22 ] that have studied edge-coloring here. Behnezhad et al. [ BDH+19] initiated the study of
W-streaming edge-coloring algorithms. They considered th e problem for both adversarial-order and random-
order streams: using /tildewideO(n) bits of working memory, they gave an O(∆2)-coloring in the former setting, and a (2 e∆)-
5coloring in the latter setting. Charikar and Liu [ CL21 ] improved these results: for adversarial-order streams, f or any
s=Ω(log n), they gave an O(∆2/s)-coloring algorithm that uses /tildewideO(ns) space; and for random-order streams, they
gave a (1 +o(1))∆-coloring algorithm using /tildewideO(n) space. Both of the aforementioned algorithms for adversar ial-
order streams are, however, randomized. Ansari et al. [ ASZZ22 ] gave simple deterministic algorithms achieving
the same bounds of O(∆2/s) colors and /tildewideO(ns) space. Their algorithm can also be made online at the cost of a
factor of 2 in the number of colors. Note that parameterizing our results in Table 2appropriately, our algorithms
achieve O(∆2/s)-colorings in /tildewideO(n/ra⌈i⌋allows) space, matching the state of the art for s=O(1), and strictly improving upon
it for s=ω(1).
Concurrent work. In an independent and parallel work, Behnezhad and Saneian [ BS23 ] have designed a ran-
domized /tildewideO(n/ra⌈i⌋allow
∆)-space W-streaming algorithm for O(∆)-edge-coloring for edge-arrival streams in simple genera l
graphs. This matches our Corollary 1.2. Their result generalizes to give, for any s∈[/ra⌈i⌋allow
∆], an O(∆1.5/s) coloring
algorithm in /tildewideO(ns) space, while we achieve an O(∆2/s)-coloring in the same space. They also get an O(∆)-edge-
coloring algorithm for vertex-arrival streams using /tildewideO(n) space, similar to our Theorem 1.7. Note that some of our
edge-arrival algorithms have the additional strong featur e of being online, while it is not clear if their edge-arrival
algorithm can also be implemented in the online setting. In t erms of techniques, while both works have some
high level ideas in common, e.g., using random offsets/perm utations to keep track of colors, or designing a one-
sided vertex-arrival algorithm ﬁrst and building on it to ob tain the edge-arrival algorithm, the ﬁnal algorithms and
analyses in the two papers are fairly different.
Another independent work by Chechik, Mukhtar, and Zhang [ CMZ23 ] obtains a randomized W-streaming al-
gorithm that edge-colors an edge-arrival stream on general multi-graphs using O(∆1.5log∆) colors in expectation2,
and/tildewideO(n) bits of space in expectation. Unlike us, they make no claims in the online model.
2 Preliminaries
2.1 Notation
Throughout the paper, logarithms are in base 2. The notation [t] indicates the set of integers {1,... , t}. The notation
/tildewideO(x) ignores poly(log( n),log(∆)) factors in x.A⊔Bgives the disjoint union of Aand B.Stis the set of permutations
over [ t], and for any permutation σ∈Stand X⊆[t], we denote σ[X] :={σi:i∈X}. For any set X,/parenleftbigX
k/parenrightbig
denotes the
set of all k-sized subsets of X.
If not otherwise stated, nis the number of vertices in a graph G,Vthe set of vertices (or A⊔Bif the graph is
bipartite), Ethe (multi-)set of edges, and ∆is the maximum degree of the graph.
2.2 Basic Deﬁnitions
Deﬁnition 2.1. A random permutation σinSnisk-wise independent if, for all distinct a1,... , akin [n], and distinct
b1,... , bkin [n], we have:
Pr/bracketleftBigg
/logicalanddisplay
i∈[k]{σ(ai)=bi}/bracketrightBigg
=1/producttext
i∈[k](n−i+1)
A family of permutations is k-wise independent if the random variable for a uniformly ran domly chosen ele-
ment of that family is k-wise independent.
Per [ AL12 ], while it is not known if there are nontrivial k-wise independent families of permutations for large
kand n, one can always construct weighted distributions which hav e support of size nO(k)and provide k-wise
independence.
A random permutation σis (ǫ,k)-wise independent if for all distinct a1,... , akin [n], the distribution of σon
a1,... , akhas total variation distance ≤ǫfrom uniform. In other words,
1
2/summationdisplay
distinct b1,... , bkin [n]/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBigg
/logicalanddisplay
i∈[k]{σ(ai)=bi}/bracketrightBigg
−1/producttext
i∈[k](n−i+1)/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤ǫ
We say almost k-wise independent, when the random permutation is ( ǫ,k)-wise independent for sufﬁciently
small ǫ.
2While [ CMZ23 ] does not claim this, one can prove their algorithm uses O(∆1.5log∆) colors with ≥1−1/poly( n) probability.
62.3 Models
This paper will use the following models of presenting edges to an algorithm to be colored. In all cases, the set of
vertices for the graph is known in advance. For general graph s, we call the set of vertices V; for bipartite graphs, V
is partitioned into two disjoint sets, which we typically ca llAand B. Let Gbe the (multi-) graph formed by taking
the union of all edges in the stream.
We assume that the maximum degree ∆ofGis known in advance. An edge-coloring algorithm for which ∆
is not known in advance can be converted to one which is, altho ugh one way to do this conversion (by running
a new 2 ∆-coloring algorithm with a fresh set of colors whenever the m aximum degree of graph formed by the
input stream doubles) increases the total number of colors u sed by a constant factor, and requires O(nlog∆) bits
of space to keep track of the maximum degree. Since the algori thms in this paper already have large constant
factors on number of colors used, it is not worth it to optimiz e the algorithms for the case where ∆is not known in
advance.
Deﬁnition 2.2. With an edge arrival stream , the algorithm is given a sequence of edges in the graph. Each edge is
provided as an ordered pair { x,y} of vertices in V. In this paper, online algorithms processing edge arrival s treams
will implement a method P ROCESS ({x,y}) which returns the color assigned to the edge. For example, see Algo-
rithm 1, an implementation of the greedy edge coloring algorithm us ing O(n∆) bits of space. W-streaming algo-
rithms may assign the color for an edge at any time, although a ll edges must be given a color at the end of the
stream.
Deﬁnition 2.3. In a vertex arrival stream , the algorithm is given a sequence of (vertex,edge-set) pai rs (v,Mv), where
the edge set Mvcontains all edges from vto vertices that have been seen earlier in the stream. Online algorithms
should report colors for all edges in Mvwhen ( v,Mv) is processed.
Aone-sided vertex arrival stream on a bipartite graph with parts A,Bis like a vertex arrival stream, if which the
vertices for one part ( B) were all presented ﬁrst, and then all the (vertex,edge-set ) pairs for the other part ( A) are
given. For one-sided vertex arrival, we assume that the algo rithm knows parts Aand Bin advance, and receives
the (vertex,edge-set) pairs for B. The stream consists of pairs ( v,Mv), where each v∈A, and Mvcontains all edges
from vtoB.
An algorithm is said to be robust if it works with ≥1−δprobability even when its input streams are adaptively
generated. By "adaptively generated", we mean that the inpu t is produced by an adaptive adversary that sees all
outputs of the online (or W-streaming) algorithm, and repea tedly chooses the next element of the stream based on
what the algorithm has output so far. See [ BJWY20 ] for a more detailed explanation.
Algorithm 1 An implementation of a greedy 2 ∆−1 online edge-coloring algorithm using O(n∆) bits of space
Input : Stream of edges in an n-vertex graph G=(V,E)
Initialize :
1:forv∈Vdo
2: Uv←/⌉mp⊔ys⌉⊔s⊔r⌉ss is a subset of [2 ∆−1]
Process (edge { x,y})→color
3:Letcbe arbitrary color in [2 ∆−1] \Ux\Uy
4:Add ctoUxand to Uy
5:return color c
3 Edge coloring on vertex arrival streams
Lemma 3.1 (Deterministic general-to-bipartite partition ing). For sufﬁciently large n, there is a set of t =4/ceilingleftbig
logn/ceilingrightbig
bipartite graphs F 1,... , Ft, and an online algorithm A, which processes a stream of edges and assigns each edge to
one of the t graphs. The algorithm ensures that at each time, f or each vertex v, degFi(v)≤300
logndegG(x)+1. It uses
O(n(log n)(log∆))bits of space.
7Using Lemma 3.1to route edges to O(log n) instances of an algorithm that f(ˆ∆) colors bipartite graphs of max
degree≤ˆ∆implies the following corollary.
Corollary 3.2 (Of Lemma 3.1).Say f :N/maps⊔o⌋har→Nis a function for which f (x)/x is monotonically increasing. Then
given an algorithm Afor edge coloring with f (∆)colors on edge arrival streams over bipartite graphs of max d egree
∆, which uses g (n,∆)bits of space, one can implement an algorithm Bfor edge coloring with O (f(∆))colors on
general graphs, using O ((g(n,∆)+nlog∆)log n)space.
Combining the previous corollary with that fact that one can convert an algorithm for one-sided vertex arrival
streams on bipartite graphs to general ("two-sided") verte x arrival streams on bipartite graphs, only doubling the
number of colors used, gives the following:
Corollary 3.3 (Of Lemma 3.1).Say f :N/maps⊔o⌋har→Nis a function for which f (x)/x is monotonically increasing. Then given
an algorithm Afor edge coloring with f (∆)colors on one-sided vertex arrival streams over bipartite g raphs of max
degree ∆, which uses g (n,∆)bits of space, one can implement an algorithm Bfor edge coloring under vertex arrivals
of general graphs using O (f(∆))colors and O ((g(n,∆)+nlog∆)log n)space.
Proof of Lemma 3.1.We claim Algorithm 2works for sufﬁciently large n.
Algorithm 2 Algorithm to partition general graph edges into bipartite g raphs
Input : Stream of edges in an n-vertex graph G=(V,E)
Initialize :
1:forv∈Vdo
2: degFi(v)←0
3:Setup binary code Cof length t:=4/ceilingleftbig
logn/ceilingrightbig
from Corollary 6.1
4:fori∈[t]do
5: LetFibe the bipartition with parts Ai={v∈V:C(v)i=0} and Bi={v∈V:C(v)i=1}
Process (edge { x,y})
6:Let deg( x)=/summationtext
i∈[t]degFi(x) and deg( y)=/summationtext
i∈[t]degFi(y).
7:fori∈[t]do
8: ifC(x)i/n⌉ga⊔ionslash=C(y)iand degFi(x)≤1200deg( x)/tand degFi(y)≤1200deg( y)/tthen
9: Increase degFi(x) and degFi(y) by 1
10: Assign edge { x,y} to Fi
11: return
12:unreachable
It is clear that at each point in time, for all v∈Vand i∈[t], the algorithm will have degFi(v) be the number of
edges assigned to Fiincident on v.
Line 8of the algorithm ensures that before edge { x,y} is assigned, degFi(x)≤1200deg( x)/t. Consequently,
after the edge is assigned, degFi(x)≤1200deg( x)/t+1≤300deg( x)/log( n)+1. Similarly, we will have degFi(y)≤
300deg( y)/log( n)+1.
It remains to prove that the algorithm will always assign an e dge, and that Line 12is never reached. When pro-
cessing edge an { x,y}, deﬁne Bv:={i∈[t] : degFi(v)>1200deg( v)/t. By Markov’s inequality, since/summationtext
i∈[t]degFi(v)=
deg( v),|Bv|≤t/1200. Because the code Chas minimum distance t/400, the set K={i:C(x)i/n⌉ga⊔ionslash=C(y)i} has size
≥t/400; and the set of i∈[t] for which Line 8passes has size |K\Bx\By|≥t/400−t/1200−t/1200=t/1200, and
hence is nonempty.
Lemma 3.4. Theorem 1.7holds for one-sided vertex arrival streams on bipartite gra phs.
Proof of Lemma 3.4.Consider Algorithm 3. This algorithm will have the required properties if ∆≥6lnn
δ; if∆is
smaller, convert the vertex arrival stream to an edge arriva l stream and pass it to Algorithm 1, which guarantees a
2∆−1 coloring of the graph using O(n∆)=O(nlnn
δ) bits of space.
This algorithm will never assign the same color to any pair of edges adjacent to the same vertex; at worst, it will
abort. The condition on Line 7ensures that when a vertex xis processed, no two edges will be assigned the same
8Algorithm 3 Randomized algorithm for 5 ∆edge coloring for (adversarial) one sided vertex arrival bi partite streams
Input : Stream of vertex arrivals n-vertex graph G=(A⊔B,E)
Initialize :
1:LetC=5∆.
2:forv∈Bdo
3: Letσvbe a uniformly random permutation over [ C]⊲constructed on demand from random oracle bits .
4: hv←1.
Process (vertex xwith multiset Mvof edges to B)
5:LetS←/⌉mp⊔ys⌉⊔s⊔r⌉ss ⊲Set of colors Mxwill have used so far
6:fore={x,y} in Mx, in arbitrary order do
7: while hy≤C∧σy[hy]∈Sdo
8: hy←hy+1
9: ifhy>Cthen
10: abort
11: Assign color σy[hy] to e
12: S←S∪{σy[hy]}
13: hy←hy+1
color. On the other hand, after Line 11assigns a color to an edge, Line 13increases hy; because σvis a permutation,
this prevents the algorithm from ever assigning the same col or twice to edges incident on some vertex yinB.
For the rest of the proof, we will argue that the algorithm nev er aborts; equivalently, that hy≤Calways holds
for all y∈B. In fact, we shall prove the stronger claim, that hy≤C−2∆holds with probability ≥1−δ/nfor each
individual y∈B. Consider a speciﬁc vertex y∈B. For each i∈[∆], let Vy,ibe the random variable counting the
number of times that the loop starting at Line 7ran, when the ith edge adjacent to ywas processed. If there
was no ith edge (or the algorithm already aborted), we set Vy,i=0; then at the end of the stream, we will have
hy≤∆+/summationtext
i∈∆Vy,i.
We now consider the distribution of Vy,i, conditioned on both the value of the variable Sat the time the ith
edge was processed, and on the parts of the permutation σywhich the algorithm has read so far, σy[1..hy−1].
Pr[Vy,i≥k|S,σy[1..hy−1]]=Pr[σy[hy,... , hy+k−1]⊆S|S,σy[1..hy−1]]
=/parenleftBigg
|S∩σy[hy,...,C]|
k/parenrightBigg
//parenleftBigg
C−hy−1
k/parenrightBigg
≤/parenleftBigg
∆
k/parenrightBigg
//parenleftBigg
2∆
k/parenrightBigg
since|S|≤∆,hy≤C−2∆
≤∆·(∆−1)···(∆−k+1)
2∆·(2∆−1)···(2∆−k+1)≤1
2k
Since this bound holds for all values of Sand all σy[1..hy−1], in particular we have
Pr[Vy,i≥k|(Vy,j)j<i]=ES,σy[1..hy−1] compat with ( Vy,j)j<iPr[Vy,i≥k|S,σy[1..hy−1]]≤1
2k
By Lemma 6.2, for et∈[1,2), we have E[etVy,i|(Vy,j)j<i]≤1/(2−et), and E[Vy,i|(Vy,j)j<i]≤1.
By a slight variation on the Chernoff bound:
Pr[∆/summationdisplay
i=1Vy,i≥2∆]≤inf
t≥0Pr/bracketleftBigg
∆/productdisplay
i=1etVy,i≥e2t∆/bracketrightBigg
≤inf
t≥01
e2t∆E[etVy,1···E/bracketleftbig
etVy,∆|(Vy,j)j<∆/bracketrightbig
···]
≤min
t:et∈[1,2)1
e2t∆/parenleftbigg1
2−et/parenrightbigg∆
=/parenleftbigg
min
t:et∈[1,2)1
e2t(2−et)/parenrightbigg∆
9=/parenleftbigg1
max x∈[1,2) x2(2−x)/parenrightbigg∆
=/parenleftbigg27
32/parenrightbigg∆
≤exp(−∆/6)
Since hv≤∆+/summationtext
i∈∆Vy,i, this implies that
Pr[hv≥C]≤Pr[hv≥C−2∆]=Pr[hv≥3∆]≤Pr[∆/summationdisplay
i=1Vy,i≥2∆]≤exp(−∆/6)
Thus, by a union bound, the probability that any vertices v∈Bwill have hv>Cat the end of the algorithm will be
≤nexp(−∆/6). In particular, if ∆≥6ln( n/δ), the algorithm will the guaranteed to abort with probabili ty≤δ.
Observe that Corollary 3.3and Lemma 3.4collectively imply Theorem 1.7.
Theorem 3.5 (Formal version of Theorem 1.7).There is a randomized online O (∆)-edge coloring algorithm for
vertex arrival streams over multigraphs using O (nlog( n∆/δ))bits of space, with error ≤δagainst any adaptive
adversary. It uses O (n∆log∆)oracle random bits.
Let us now turn to the deterministic version of the problem. W e will introduce an a deterministic algorithm
which uses advice, and show that if the advice is chosen rando mly, the algorithm will work with high probability.
This algorithm can also be used as a randomized algorithm, if we choose the advice uniformly at random, and we
use a somewhat complicated analysis to show that this can be a chieved using only /tildewideO(n) (random) bits of advice.
Lemma 3.6. Let C ,t,w be integers, with C ≥t≥512, and 8|C. Let ǫ≤C−t−1. Say that F 1,... , Fware subsets of [C],
and deﬁne s i= |Fi|for all i ∈[w]. We furthermore require min i∈[w]si≥1
2t, and min i∈[w]si≥1
2max i∈[w]si. Let
X⊆[C]satisfy|X|≤1
8C, and let/summationtext
i∈[w]si≤1
2C. Then if σ1,... ,σware(ǫ,t)-wise independent random permutations
over [C],
Pr/bracketleftBigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/uniondisplay
i∈[w]σi[Fi] \X/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle<1
8/summationdisplay
i∈[w]si/bracketrightBigg
≤exp(−1
29t w).
Proof of Lemma 3.6.Since the ( σi)i∈[w]are (ǫ,t)-wise independent, in particular we have for any i∈[w],j∈[C],
that Pr/bracketleftbig
j∈σi[Fi]/bracketrightbig
≤si/C+ǫ, and for any Q⊆[C] with|Q|≤t, that
Pr[Q⊆σi[Fi]]=si·(si−1)···(si−|Q|+1)
C·(C−1)···(C−|Q|+1)+ǫ≤/parenleftBigsi
C/parenrightBig|Q|
(1)
LetUibe a random subset of [ C] in which each element in Cis included independently with probability si/C. Eq. 1
thus implies Pr[ Q⊆σi[Fi]]≤Pr[Q⊆Ui]. Now, for any ﬁxed set H⊆[C], let YH,i:=|σi[Fi]∩H|, and WH,i=|Ui∩H|.
Then E[YH,i]≤si|H|/C+ǫC=E[WH,i]+ǫC, and as a consequence of Eq. 1, we have for all k≤t, that E[Yk
H,i]≤
E[Wk
H,i]+ǫC. This lets us bound the moment generating function of YH,i, for nonnegative z:
EezYH,i≤∞/summationdisplay
k=01
k!(E(zYH,i)k)
≤t/summationdisplay
k=01
k!(E(zYH,i)k)+∞/summationdisplay
k=t+11
k!(E(zYH,i)k)
≤t/summationdisplay
k=01
k!(E(zW H,i)k)+∞/summationdisplay
k=t+11
(k−t−1)!(t+1)!((zsi)k)+ǫtC
≤EezW H,i+(zsi)t+1
(t+1)!ezsi+ǫtC
≤exp/parenleftbiggsi|H|
C(ez−1)/parenrightbigg
+(zsi)t+1
(t+1)!ezsi+ǫtC (2)
We will use this to upper bound the probability that a superma rtingale, which sums how many elements in each
σi[Fi] were present in/uniontext
j<iσj[Fj], grows too large. Let B1be an arbitrary set of size1
8Cwhich contains X. (This
deﬁnition will make the following analysis simpler than if w e had set B1=X). For each i∈{2,... , w}, deﬁne Bi=
Bi−1∪σi−1[Fi−1]. Note that |Bw|≤5
8C. We have E[/summationtext
i∈[w]YBi,i]≤/summationtext
i∈[w]/parenleftBig
|Bi|
Csi+ǫC/parenrightBig
≤|Bw|
C/summationtext
i∈[w]si≤5
8/summationtext
i∈[w]si.
10Note that
Pr/bracketleftBigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/uniondisplay
i∈[w]σi[Fi] \X/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle<1
8/summationdisplay
i∈[w]si/bracketrightBigg
≤Pr/bracketleftBigg
/summationdisplay
i∈[w]YBi,i≥7
8/summationdisplay
i∈[w]si/bracketrightBigg
(3)
Letγ=(7
8/summationtext
i∈[w]si)/E[/summationtext
i∈[w]YBi,i]; this is ≥7/5. Applying a modiﬁed proof of the Chernoff bound/Azuma’s in-
equality to the right hand side of Eq. 3gives:
=inf
z>0Pr/bracketleftBigg
exp/parenleftBigg
z/summationdisplay
i∈[w]YBi,i/parenrightBigg
≥exp/parenleftBigg
γzE[/summationdisplay
i∈[w]YBi,i]/parenrightBigg/bracketrightBigg
≤inf
z>0exp/parenleftbig
z/summationtext
i∈[w]YBi,i/parenrightbig
exp/parenleftbig
γzE[/summationtext
i∈[w]YBi,i]/parenrightbig by Markov’s inequality
=inf
z>0exp/parenleftBigg
z/summationdisplay
i∈[w](YBi,i−γE[YBi,i])/parenrightBigg
=inf
z>0E/bracketleftbig
exp/parenleftbig
z(YB1,1−γE[YB1,1])/parenrightbig
···E/bracketleftbig
exp/parenleftbig
z(YBw,w−γE[YBw,w])/parenrightbig/vextendsingle/vextendsingleYB1,1,... , YBw−1,w−1/bracketrightbig
···/bracketrightbig
≤inf
z>0/productdisplay
i∈[w]max
B:1
8C≤|B|≤5
8CEexp/parenleftbig
z(YB,i−γE[YB,i])/parenrightbig
bounding terms from the inside out
=inf
z>0/productdisplay
i∈[w]max
B:1
8C≤|B|≤5
8CEexp/parenleftbig
zYB,i/parenrightbig
exp/parenleftbig
γzE[YB,i])/parenrightbig
≤inf
z>0/productdisplay
i∈[w]max
B:1
8C≤|B|≤5
8Cexp/parenleftBig
si|B|
C(ez−1)/parenrightBig
+(zsi)t+1
(t+1)!ezsi+ǫtC
exp/parenleftbig
γzE[YB,i])/parenrightbig by Eq. 2
Now set z=t
81
w/summationtext
i∈[w]si. Since t≤2min i∈[w]si, it follows z≤2min i∈[w]si
8min i∈[w]si≤1
4. Since max i∈[w]si≤2min i∈[w]si, we
have z≤t/(4si) for all i∈[w]. This implies ( zsi)t+1/(t+1)!ezsi≤(t/4)t+1et/4/(t+1)!≤1
2. Since ǫ≤C−t−1, we also
have ǫtC≤1
2. Continuing the upper bound of Eq. 3:
≤/productdisplay
i∈[w]max
B:1
8C≤|B|≤5
8Cexp/parenleftBig
si|B|
C(ez−1)/parenrightBig
+1
exp/parenleftbig
γ((zsi|B|/C)−ǫ)/parenrightbig
≤eγwǫ/productdisplay
i∈[w]exp/parenleftbigsi
8(ez−1)/parenrightbig
+1
exp/parenleftbig
γzsi/8/parenrightbig maximum occurs at |B|=1
8C
≤ew(ln(2)+γǫ)/productdisplay
i∈[w]exp(( ez−1−γz)si/8) since ( x+1)/xγ≤2/xγ−1
≤ew(ln(2)+γǫ)/productdisplay
i∈[w]exp/parenleftbigg
−1
4zsi
8/parenrightbigg
since z≤1
4implies1
4z≤7
5z−(ez−1)
=exp/parenleftBigg
−1
4t w
8/summationtext
i∈[w]si/summationdisplay
i∈[w]si
8+w(ln 2+γǫ)/parenrightBigg
≤exp(−t w
28+w(ln 2+γǫ))
≤exp(−t w
29) sincet
29≥1≥ln2+γǫ
This completes the proof of the lemma.
Lemma 3.7. Let C ,s,w be integers, with s ≥4. Letǫ≤C−s−1. Say that F 1,... , Fware subsets of [C], with each |Fi|≤s,
|Fi|≥2and/summationtext
i∈[w]|Fi|≥1
2C. Furthermore, let X ⊆[C]satisfy|X|≤1
8C. Then if σ1,... ,σware(ǫ,s)-wise independent
random permutations over [C],
Pr/bracketleftBigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/uniondisplay
i∈[w]σi[Fi] \X/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle<1
16C/bracketrightBigg
≤exp(−1
2/summationdisplay
i∈[w]|Fi|).
This lemma differs from Lemma 3.6in that the sets (σi[Fi])i∈[w]are now smaller, and/summationtext
i∈[w]|Fi|isΩ(C).
11Proof of Lemma 3.7.Because the ( σi)i∈[w]are (ǫ,s)-wise independent, for each i∈[w], the random variable σi[Fi]
has total variation distance ǫfrom being a uniform random subset of [ C] of size|Fi|. Letτ=/floorleftbig1
16C/floorrightbig
. We will bound
the probability that there exists any set T⊆[C] of size τfor which/uniontext
i∈[w]σi[Fi]⊆T∪X. Observe:
Pr/bracketleftBigg
∃T∈/parenleftBigg
[C]
τ/parenrightBigg
:/uniondisplay
i∈[w]σi[Fi]⊆T∪X/bracketrightBigg
≤/summationdisplay
T∈/parenleftbig[C]
τ/parenrightbigPr/bracketleftBigg
/uniondisplay
i∈[w]σi[Fi]⊆T∪X/bracketrightBigg
=/summationdisplay
T∈/parenleftbig[C]
τ/parenrightbig/productdisplay
i∈[w]Pr[σi[Fi]⊆T∪X] since σiare independent
≤/summationdisplay
T∈/parenleftbig[C]
τ/parenrightbig/productdisplay
i∈[w]/parenleftBigg/parenleftbig|T∪X|
|Fi|/parenrightbig
/parenleftbigC
|Fi|/parenrightbig+ǫ/parenrightBigg
since Fiapproximately uniform
=/summationdisplay
T∈/parenleftbig[C]
τ/parenrightbig/productdisplay
i∈[w]/parenleftbigg|T∪X|···(|T∪X|−|Fi|+1)
C···(C−|Fi|+1)+ǫ/parenrightbigg
≤/summationdisplay
T∈/parenleftbig[C]
τ/parenrightbig/productdisplay
i∈[w]/parenleftbigg|T∪X|
C/parenrightbigg|Fi|
since 2≤|Fi|≤sandǫ≤C−s−1
≤/parenleftBigg
C
τ/parenrightBigg/parenleftbigg|T∪X|
C/parenrightbigg/summationtext
i∈[w]|Fi|
≤20.338 C/parenleftbigg3
16/parenrightbigg/summationtext
i∈[w]|Fi|
using|T|+|X|≤/parenleftbigg1
16+1
8/parenrightbigg
Candτ≤C
16
≤exp(0.235 C−ln(16/3)/summationdisplay
i∈[w]|Fi|)
≤exp(−1
2/summationdisplay
i∈[w]|Fi|) since/summationdisplay
i∈[w]|Fi|≥C/2
This completes the proof.
Lemma 3.8. Theorem 1.8holds for one-sided vertex arrival streams on bipartite gra phs.
Proof of Lemma 3.8.δ∈(0,1) is a parameter governing the probability that the Algo rithm 4will fail to be a correct
deterministic algorithm, if its advice is chosen randomly; if one just wants a deterministic algorithm, setting δ=
1/2 sufﬁces. If ∆≤logn∆
δ, use the simple greedy algorithm (Algorithm 1). Otherwise, use Algorithm 4.
This algorithm maintains, for each vertex v∈B, two variables bvand Qvthat indicate which colors in [ C] are
certainly available for that vertex. It ensures that that no ne of the colors in the set Ξv={σv[(bv−1)s)] :i∈Qv}⊔
{σv[j] :j>bvs} have been used. When a new vertex xinAarrives, along with the multiset Mxof edges adjacent
to it, the algorithm selects a set Fyindicating candidate colors σy[Fy] for each yadjacent to x, and computes a
matching between the edges in Mxand the set of all colors, allowing each edge in Mxonly the colors corresponding
to the edges endpoint in B. This matching ensures that all edges incident to xreceive different colors; and for all
y∈B, the use of the set Fyto constrain the set of candidate colors to a subset of Ξvensures that all incident to y
receive different colors.
For a given vertex y, as the algorithm runs, bywill be increased, by either Line 18or22. Line 18only triggers
when|Qy| ≤s−1
217s, which requires that vertex yhas received ≥1
217sincident edges since the last time bywas
increased. Since there will be at most ∆edges incident to y, the total increase to byfrom this line over the course
of the algorithm will be ≤∆/(1
217s)=217∆/s. On the other hand, Line 18only triggers when dx,y≥1
16s, and then
increases byby/ceilingleftbig
64dx,y/s/ceilingrightbig
+1. Since/summationtext
x∈Adx,y≤∆,
/summationdisplay
x∈A:dx,y>1
16s/parenleftbigg/ceilingleftbigg64dx,y
s/ceilingrightbigg
+1/parenrightbigg
≤/summationdisplay
x∈A:dx,y>1
16s/parenleftbigg64dx,y
s+2/parenrightbigg
≤/summationdisplay
x∈A:dx,y>1
16s96dx,y
s≤96∆
s
12Algorithm 4 Deterministic algorithm for O(∆) edge coloring for (adversarial) one sided vertex arrival b ipartite
streams, using /tildewideO(n) bits of advice
Input : Stream of vertex arrivals for n-vertex graph G=(A⊔B,E) of max degree ∆
δ∈(0,1) is a parameter so that, if the advice is chosen randomly , it will work for all inputs with probability
≥1−δ
Initialize :
LetC=218∆.
Lets=/ceilingleftbig
218logn∆
δ/ceilingrightbig
.
Advice: ( σv)v∈B, where each σvis a permutation over [ C]. If chosen randomly, each is ( ǫ,s)-wise independent
forǫ≤C−s−1
1:forv∈Bdo
2: bv←1.
3: Qv←[s].
Process (vertex xwith multiset Mxof edges to B)
Letdx,ybe the number of times edge { x,y} is in Mx
4:foreach y∈Bwith dx,y>0do
5: ifdx,y<1
16sthen
6: LetFy=(by−1)s+Qy
7: else
8: LetFy=((by−1)s+Qy)⊔[bys,by+/ceilingleftBig64da,b
s/ceilingrightBig
s]
9:Construct bipartite graph Hfrom Mxto [C], edge e∈Mxis linked to all c∈σy[Fy].
10:Compute an Mx-saturating matching PofH.
11:foreach e∈Mxdo
12: Assign color P(e) to e
13: ifdx,y<1
16sthen
14: Remove σ−1
y−(by−1)sfrom Qy
15:foreach y∈Bwith dx,y>0do
16: ifdx,y<1
16sthen
17: if|Qy|≤s−1
217sthen
18: by←by+1
19: Qy←[s]
20: else
21: Qy←[s]
22: by←by+/ceilingleftBig2dx,y
s/ceilingrightBig
+1
Thus, the total increase in bywill be≤(217+96)∆/s, and bywill always be ≤(217+97)∆/s. Looking at the construc-
tion of the set Fyon Lines 6and 8, we see that it will only ever contain elements which are ≤(217+98)∆. Since
C=218∆≥(217+98)∆, it follows that computing σy[Fy] will never index out of range.
The only remaining way this algorithm could fail is if Line 10were to report that no Mx-saturating matching
exists. We will show that, if the ( σv)v∈Bare drawn from ( ǫ,s)-wise independent distributions, then probability
≥1−δ, for all possible sets Mxand combinations of "free slots", ( Fy)y:dx,y>0, Hall’s condition will hold on the graph
Hconstructed on Line 9.
Since whether the constructed graph Hhas a matching does not depend on the value of x, only on the number
of edges arriving at a given y∈B, we do not need to take a union bound over all possible sets Mx. Instead, deﬁne
a conﬁguration by a tuple ( S,(dy)y∈S,(by)y∈S,(Qy)y∈S). The set Sgives the neighborhood of x, and for each y∈
Swe set dy=dx,y. The values by,Qymatch the values from the algorithm at the time Mxarrives. Note that
the set Fyis a function of by,Qy, and dy, and for ﬁxed by,Qyis monotone increasing as a function of dy. We
donot need any extra cases to handle Hall’s condition for subsets o fMx; consider any subset M′
x⊆Mx, and let
S′,d′
y,F′
ycorrespond to M′
x. Then because F′
y⊆Fyfor each y∈S′, if Hall’s condition holds for the conﬁguration
13(S′,(d′
y)y∈S′,(by)y∈S′,(Qy)y∈S′), then
/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/uniondisplay
y∈S′Fy/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/uniondisplay
y∈S′F′
y/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥/summationdisplay
y∈S′d′
y
which implies that Hall’s condition also holds for the subse tM′
xwithin the bipartite graph Hconstructed for Mx.
Let d=/summationtext
y∈Sdy. If the permutations ( σy)y∈Bwere each chosen uniformly at random, it would be straight-
forward to prove that Hall’s condition fails for each conﬁgu ration ( S,(dy)y∈S,(by)y∈S,(Qy)y∈Swith probability ≤
ed(d/C)Θ(|S|s+d), after which a union bound over conﬁgurations gives a ≤δtotal failure probability. However, be-
cause we assume the ( σy)y∈Bare only ( ǫ,s)-wise independent, we will need a more precise argument.
Each conﬁguration ( S,(dy)y∈S,(by)y∈S,(Qy)y∈Scan be split into O(log∆) different "level conﬁgurations". Let
τ=s/16; then for each vertex y, ifdy<τ, the algorithm will choose Fyusing Line 6to be a subset of size ≤s
and≥s(1−2−17)≥s/2; and if dy≥τ, the algorithm will choose Fyusing Line 8, to be a subset of size ≥64dy.
Deﬁne L0={y∈S:dy<τ}. For each ℓ∈{1,... , λ}, for λ=/ceilingleftbig
log∆/ceilingrightbig
letLℓ={y∈S: 2ℓ−1τ≤dy<2ℓτ}. Also write
L>ℓ=/uniontext
j>ℓLj. Within each "level", the values of dyare either all small ( <τ), or all within a factor 2 of each other.
We will show that with high probability, the following two co nditions hold:
∀ℓ≥1,∀(Lλ,... , Lℓ+1) where max
i>ℓ(3/2)i−ℓ|Li|≤|Lℓ|,∀dy,by,Qyfory∈/unionsqdisplay
j≥ℓLℓ:
/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/parenleftBigg
/uniondisplay
y∈Lℓσy[Fy]/parenrightBigg
\/parenleftBigg
/uniondisplay
y∈L>ℓσy[Fy]/parenrightBigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥8/summationdisplay
y∈L0dy (4)
∀(Lλ,... , L1) where max
i>0(3/2)i|Li|≤|L0|,∀dy,by,Qyfory∈/unionsqdisplay
j≥0Lℓ:
/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/parenleftBigg
/uniondisplay
y∈L0σy[Fy]/parenrightBigg
\/parenleftBigg
/uniondisplay
y∈L>0σy[Fy]/parenrightBigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥/summationdisplay
y∈L0dy (5)
Then for the speciﬁc conﬁguration ( S,(dy)y∈S,(by)y∈S,(Qy)y∈S), let A⊆{0,... , λ} contain all ℓfor which |Lℓ| ≥
max i>ℓ(3/2)i−ℓ|Li|. Because the condition of Eq. 4holds for all i∈Awith i>0, these "levels" of the conﬁgu-
ration are associated with enough entries of Cthat they "pay for" all levels with smaller degrees that also do not
have many more vertices. Level L0pays for itself if 0 ∈A, by Eq. 5. Formally, we have:
|/uniondisplay
y∈Sσy[Fy]|=/summationdisplay
i∈{0,...,λ}|(/uniondisplay
y∈Liσy[Fy]) \ (/uniondisplay
y∈L>iσy[Fy])|
≥/summationdisplay
i∈A|(/uniondisplay
y∈Liσy[Fy]) \ (/uniondisplay
y∈L>iσy[Fy])|
≥10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}8/summationdisplay
y∈Lidy
≥10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}8·2i−1τ|Li|
=10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}4·2iτ|Li|
≥10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}/summationdisplay
j≤i/parenleftbigg3
4/parenrightbiggi−j/parenleftBig
2iτ|Li|/parenrightBig
≥10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}/summationdisplay
j≤i:|Lj|≤(3/2)i−j|Li|2jτ/parenleftbigg3
2/parenrightbiggi−j
|Li|
≥10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}/summationdisplay
j≤i:|Lj|≤(3/2)i−j|Li|2jτ|Lj|
≥10∈A/parenleftBigg
/summationdisplay
y∈L0dy/parenrightBigg
+/summationdisplay
i∈A\{0}/summationdisplay
j≤i:|Lj|≤(3/2)i−j|Li|/summationdisplay
y∈Ljdy
14=/summationdisplay
i∈{0,...,λ}/summationdisplay
y∈Ljdy=/summationdisplay
y∈Sdy
We ﬁrst observe that Eq. 4matches the conditions for Lemma 3.6. Speciﬁcally, if y∈Lℓforℓ>1, then dy≥
s/16, and we have both |Fy| ≥sand|Fy| ≥64dy. Also, since the dy∈[2ℓ−1τ,2ℓτ), we will have max y∈Lℓ|Fy| ≤
2min y∈LℓFy. Letting X=/uniontext
y∈L>iσy[Fy], we have |X| ≤/summationtext
y∈L>i|Fy| ≤/summationtext
y∈L>ℓ(2s+64dy)≤96∆≤1
8C. Similarly,/summationtext
y∈Lℓσy[Fy]≤96∆≤1
2C. Thus, Lemma 3.6applies, and gives an exp( −O(s|Lℓ|)) upper bound on the probability
that|/uniontext
y∈Lℓσy[Fy] \X|≥4/summationtext
y∈L0dy.
For Eq. 5, if/summationtext
y∈L0|Fy|≥1
2C, we apply Lemma 3.7. As argued above, the set X=/uniontext
y∈L>0σy[Fy] will have size
≤1
8C. If the bad event in Lemma 3.7does not hold, then the condition in Eq. 5will, since/summationtext
y∈L0dy≤∆≤1
16C. On
the other hand, if/summationtext
y∈L0|Fy|<1
2C, we apply Lemma 3.6; this works because we have |Fy|≥(1−2−17)s≥1
2s.
Since Lemma 3.6and Lemma 3.7both ensure a exp( −Ω(s|Li|)) type upper bound for the probability of condi-
tions from Eqs. 4and 5, we can bound the probability that none of the individual eve nt fails in a single sum. Since
for each y,Qyis refreshed after at least s/217elements are removed from it, there are only/summationtext⌈s/217⌉
i=0/parenleftbigs
i/parenrightbig
≤2sH(1/216)≤
exp( s/211) possible values for Qy; here His the binary entropy function.
Pr[Eqs. 4and 5hold]
≤/summationdisplay
ℓ∈{0,...,λ}/summationdisplay
w∈{1,...,∆}
where|Lℓ|=w/summationdisplay
Lλ,...,Lℓ
all|Lj|≤(2/3)j−ℓw/summationdisplay
(dy,by,Qy)y∈/unionsqtext
j≥ℓLjexp(−sw/29)
≤/summationdisplay
ℓ∈{0,...,λ}/summationdisplay
w∈{1,...,∆}
where|Lℓ|=w/productdisplay
j≥ℓ/parenleftbig
(n+1)C2exp( s/211)/parenrightbig(2/3)j−ℓwexp(−sw/29)
≤/summationdisplay
ℓ∈{0,...,λ}/summationdisplay
w∈{1,...,∆}
where|Lℓ|=w/parenleftbig
(n+1)C2exp( s/211)/parenrightbig3wexp(−sw/29)
≤/summationdisplay
ℓ∈{0,...,λ}/summationdisplay
w∈{1,...,∆}
where|Lℓ|=w(nC)6wexp(−sw/211) since ( n+1)≤n2and 2−9−3·2−11=2−11
≤/summationdisplay
ℓ∈{0,...,λ}/summationdisplay
w∈{1,...,∆}
where|Lℓ|=wexp(−sw/212) since s≥6·212(18+log( n∆))≥6·212ln(nC)
≤(λ+1)∆exp(−s/212)≤δ since s≥213log(∆/δ)≥213ln(∆/δ)
Thus,
Pr[any conﬁguration fails Hall’s condition] ≤δ.
If the ( ǫ,s)-wise random permutations over [ C] are constructed using Lemma 6.3(assuming ∆is a power of
two), then the total number of bits of randomness needed to sa mple advice for the algorithm will be O(ns(log C)4log1
ǫ)=
O(ns2(log C)5)=O/parenleftBig
n/parenleftbig
logn∆
δ/parenrightbig2(log∆)5/parenrightBig
.
Combining Corollary 3.3with Lemma 3.8, we immediately get the following theorem.
Theorem 3.9 (Formal version of Theorem 1.8).There is a deterministic online O (∆)-edge coloring algorithm for
vertex arrival streams over multigraphs using O (nlog( n∆))bits of space, using /tildewideO(n)bits of advice. (By picking a
uniformly random advice string, the same algorithm can alte rnatively be used as a robust algorithm with 1/poly( n)
error; the advice can also be computed in exponential time.)
4 Edge coloring on edge arrival streams
First we prove the general version of Lemma 1.6.
15Lemma 4.1 (Generalized Lemma 1.6).Let f ,g be functions from N/maps⊔o⌋har→N. Given a streaming algorithm Afor g (∆)-
coloring over edge arrival streams on multigraphs of max deg ree∆, using f (N,∆)bits of space, for any positive integer
s, there is a streaming algorithm Bfor(g(s∆)+s∆)-coloring edge arrival streams for multigraphs of max degre e∆,
using f (N/s,s∆)+O(nlog∆)bits of space.
Proof. Pseudocode for algorithm Bis given by Algorithm 5.
Algorithm 5 Adapting edge coloring algorithm Bto use more colors and less space, with parameter s
Input : Stream of edge arrivals for n-vertex graph G=(V,E)
Assume V=[n]
Initialize :
Letχ:Ks/maps⊔o⌋har→[s] give an s-edge coloring of Ks.3
1:A←instance of A(⌈n/s⌉,∆s).
2:forv∈[n]do
3: dv←0
Process (edge { x,y})→color
4:dx←dx+1
5:dy←dy+1
6:if⌈x/s⌉=/ceilingleftbig
y/s/ceilingrightbig
then
7: Letc←∆·(χ({xmod s,ymod s})−1)+dmin( x,y)
8: return color (0, c)
9:Letc←A.PROCESS (⌈x/s⌉,/ceilingleftbig
y/s/ceilingrightbig
)
10:return color (1, c)
This algorithm partitions the set of all vertices into sets S1,... , S⌈n/δ⌉, where set Sicontains the svertices { s(i−
1)+1,... , si−1,si}.It provides the nested algorithm instance Awith the (non-loop) edges in the graph Hformed
by contracting these sets. Edges entirely inside one of the Siare colored using a separate set of ∆scolors.
As the total number of edges incident on a set of svertices in Gis≤∆s, the maximum degree of Hwill also be
≤∆s. Since instance Ais guaranteed to correctly edge color all multigraphs on [ ⌈n/s⌉] of maximum degree ≤∆s, no
two edges adjacent to a vertex in Hwill be assigned the same color. Consequently, the edges fro m each individual
vertex v∈Sito vertices outside S−Iwill all be given different colors.
Consider one of the vertex sets Si; a given edge { x,y} with x,y∈Siwill be assigned a color which, due to the
use of χto partition edges, will differ from the colors assigned to a ll other edge types between vertices in Si; and
if the edge { x,y} was processed in the past, this time will assign a different color since dmin( x,y)has been increased
since then.
The algorithm will require f(⌈N/s⌉,∆s) bits of space to store A, and nlog∆bits of state to keep track of all vertex
degrees. The total number of colors used will be g(s∆)+s∆; ifg(x)=O(x), this will be O(s∆).
Lemma 4.2. Given a streaming algorithm Afor O (∆)edge coloring for one-sided vertex arrival streams over bip ar-
tite multigraphs using ≤f(n,∆)space, we can construct a streaming algorithm Bfor O (∆)edge coloring of edge
arrival streams over bipartite multigraphs using O (/ra⌈i⌋allow
∆f(n,O(/ra⌈i⌋allow
∆))+n/ra⌈i⌋allow
∆(log n∆)log( n/δ))bits of space. The new
streaming algorithm Bis randomized, runs in polynomial time, and has additional ≤δprobability of error, even if
the input stream is adaptively generated.
Proof of Lemma 4.2.The W-streaming edge-arrival algorithm is given by Algorit hm 6. The algorithm uses s=
O(/ra⌈i⌋allow
∆) instances of A. This algorithm maintains a pool Pof edges, and whenever it receives a new edge it adds it
to the pool. Edges with high multiplicity ( /tildewideΩ(/ra⌈i⌋allow
∆/log( n2/δ)) in Pare moved to a different pool L; since there are not
many of this type, they can be stored using only /tildewideO(n/ra⌈i⌋allow
∆) space. When a vertex vreaches a high degree ( ≥/ra⌈i⌋allow
∆) in
the pool, it and its incident edges are removed from Pand assigned to a random instance of Awhich has not yet
received v. At the end of the stream, all edges still stored in either PorLare colored.
3While it is possible to implement this more efﬁciently, this function can also be evaluated by running the Misra-Gries al gorithm in O(s3)
time.. [ MG92 ]
16Algorithm 6 W-streaming algorithm for O(∆) edge coloring on edge-arrival stream given black-box acce ss to algo-
rithm AforC∆edge coloring on vertex-arrival stream
Input : Stream of edge arrivals for n-vertex graph G=(A⊔B,E)
Initialize :
1:Lets=2/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
2:Letτ=/floorleftBig/ra⌈i⌋allow
∆
9ln( n/δ)/floorrightBig
3:P←/⌉mp⊔ys⌉⊔s⊔r⌉ss is a multiset of edges – used to cache all arriving edges
4:L←/⌉mp⊔ys⌉⊔s⊔r⌉ss is a multiset of edges – used to efﬁciently store certain edge types which have high multiplicity
5:fori∈[s]do
6: I(i)←instance of algorithm Afor graphs of max degree ⌈4∆/s⌉; this will use C⌈4∆/s⌉colors
7: x(i)←[0,... ,0] ∈{0,1}A, tracks for which vertices winAthe instance I(i)has received ( w,Mw)
Process (edge { x,y})
8:P←P∪{{x,y}}.
9:ifedge { x,y} has multiplicity > τinPthen
10: Remove all copies of { x,y} from P, and add them to L
11: return
12:if∃v∈Awith degree ≥/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
inPthen
13: Pick random ifrom { j∈[s] :x(j)
v=0}
14: x(i)
v←1
15: LetMvbe edges incident on vinP
16: Send ( v,Mv) toI(i)to be colored
17: Remove Mvfrom P
End of Stream
18:Color edges in P∪Lgreedily using an independent set of 2 ∆−1 colors
Algorithm 6requires s f(n) bits of space to store the instances I(1),... ,I(s), and snbits to keep track of the
vectors x(1),... , x(s). Since the edges adjacent to a vertex in Aare removed from Pas soon as it reaches degree/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
,
the total number of edges in P, counting multiplicity, will be ≤|A|(/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
−1)=O(n/ra⌈i⌋allow
∆). Thus, Pcan be stored using
O(n/ra⌈i⌋allow
∆log( n2/δ)) bits of space. Finally, since Lreceives only edges whose multiplicity was at least/ra⌈i⌋allow
∆/log n, it will
contain at most ( n∆/2)/(/ra⌈i⌋allow
∆/log n)=n/ra⌈i⌋allow
∆/(2log n) distinct edges; keeping track of them and their multiplici ty can
be done in O(n/ra⌈i⌋allow
∆log( n∆)/log n) space. In total, Algorithm 6will require O(/ra⌈i⌋allow
∆(f(n)+n(log( n∆))log( n/δ))) bits
of space in total.
The total number of colors used is 2/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
·C⌈4∆/s⌉+(2∆−1)=O(∆).
Because Algorithm 6only sends a star around a vertex vto an instance I(i)(Line 16) when the vertex vhas
degree=/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
inP, the maximum degree of arriving vertices that any instance o fAwill process will be/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
.
However, it is still possible that for some sketch I(i), a vertex v∈Bwill receive a too many edges from vertices in
Athat the sketch I(i)receives later.
For some pair i∈[s],z∈B, we will show that sketch I(i)receives ≤4∆/sedges (counting multiplicity) for z,
with≥δ
n2probability. Let X1,... , X∆be random variables, where Xiis the number of edges that are sent to I(i)
when the jth star adjacent to zis removed. If the stream ends before an jth star is removed, then Xj=0. Because
Line 10removes all edges with multiplicity >τinP,zwill have at most τedges between it and the center of the
jth star, so Xj≤τ. Furthermore, at the time the jth star is selected, the algorithm makes a random decision on
Line 13to choose which sketch will receive it. Because s=2/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
, and each star has root degree only/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig
, there
will always be ≥s/2 instances that have not received a given vertex as the root of a star, so the probability that
I(i)will receive the jth star is ≤2
s. Thus E[Xj|X1,... , Xj−1]≤2τ/s. This bound holds even if the input stream is
produced by an adaptive adversary. Since the degree of zwill be less than ≤∆at the end of the stream, we also
have E[/summationtext
j∈∆Xj]≤2∆/s.
We now apply the multiplicative (Chernoff-like) form of Azu ma’s inequality, on the [0,1] random variables
17Y1,... , Y∆, deﬁned by Yj:=Xj/τ. Letα=E[/summationtext
j∈∆Yj].
Pr/bracketleftBigg
/summationdisplay
i∈[∆]Xj≥4∆/s/bracketrightBigg
=Pr/bracketleftBigg
/summationdisplay
i∈[∆]Yj≥4∆
sτ/bracketrightBigg
=Pr/bracketleftBigg
/summationdisplay
i∈[∆]Yj≥/parenleftbigg
1+/parenleftbigg4∆
sτα−1/parenrightbigg/parenrightbigg
α/bracketrightBigg
≤exp/parenleftbigg
−1
3/parenleftbigg4∆
sτα−1/parenrightbigg
·α/parenrightbigg
since4∆
sτα−1>1
≤exp/parenleftbigg
−1
32∆
sτα·α/parenrightbigg
=exp/parenleftbigg
−2
3∆
sτ/parenrightbigg
=exp/parenleftBigg
−2∆
3·2/ceilingleftbig/ra⌈i⌋allow
∆/ceilingrightbig/floorleftbig/ra⌈i⌋allow
∆/(9ln( n/δ))/floorrightbig/parenrightBigg
≤exp (−2ln( n/δ))≤δ
n2since 2/ceilingleftBig/ra⌈i⌋allow
∆/ceilingrightBig
≤3/ra⌈i⌋allow
∆and 1/⌊x⌋≥1/x
By a union bound over all ≤nvertices v∈B, and all ≤ninstances in { I(j)}j∈[s], we have that the total proba-
bility of any vertex vin an instance I(i)receiving more than 4 ∆/sedges is ≤δ.
Combining Lemma 4.2with Lemma 3.4, and then applying Corollary 3.2proves the following.
Theorem 4.3 (Formal version of Theorem 1.3).There is a randomized W-streaming algorithm for O (∆)edge col-
oring on edge arrival streams for multigraphs which uses O (n/ra⌈i⌋allow
∆(log( n∆))2)bits of space, with error ≤1/poly( n)
against any adaptive adversary. The algorithm also require s/tildewideO(n∆)bits of oracle randomness.
The following online edge coloring algorithms will both use the same core primitive; a pool of random colors,
which is periodically refreshed, along with data to keep tra ck of which colors in the pool have been used so far. The
times at which the pool are refreshed only depend on the numbe r of colors that were used, and not which colors
where used; this property makes the primitive easier to hand le in proofs.
Algorithm 7 Storing free regions from a permutation
F←InitFreeTracker (C,s,∆,σ): ⊲Assume C,s,∆are powers of two, and σpermutation of [ C], and C≥∆
1:H←[s] be a subset of [ s]
2:b←1 be a counter between 1 and C/s
3:Optional: Q←/⌉mp⊔ys⌉⊔s⊔r⌉ss is a set of references to objects
Interpreting Fas subset of [C]
4:return σ[H+(b−1)s]
F.RemoveAndUpdate( c,optional: o) ⊲Requires c∈Fv
5:H←H\ {σ−1(c)}
6:Optional: Add a reference to o, and store it in Q
7:if|H|≤s−s∆/Cthen ⊲Switch to next block
8: H←[s]
9: b←b+1
10: Optional: Drop all references in Qand set Q←/⌉mp⊔ys⌉⊔s⊔r⌉ss
We are now ready to state and prove the formal version of Theor em1.1.
Theorem 4.4 (Formal version of Theorem 1.1).Given any adversarial edge-arrival stream of a simple graph , there
is a randomized algorithm for online O (∆)-edge-coloring using O (n/radicalbig
∆logn)bits of space and /tildewideO(n/ra⌈i⌋allow
∆)oracle ran-
dom bits.
Proof. We will show that Algorithm 8satisﬁes the claims of the lemma, if ∆=Ω(log( n/δ)). (For smaller values of
∆, fall back to Algorithm 1.) In the following argument, we shall assume that the permut ations ( σv)v∈Sares-wise
independent. The pseudocode states ( ǫ,s)-wise independence, since that is attainable per Lemma 6.3using only
O(spoly(log1/ ǫ,log s)) bits of randomness per permutation. This will not affect t he validity of the proof, since it at
18most increases the probabilities of events H{u,v}and Ju,vdeﬁned later by ǫ, which is polynomially smaller than the
losses in the argument due to bounding the number of events by n2instead of/parenleftbign
2/parenrightbig
orn2−n. We also assume that
∆is a power of two; if not, we can increase ∆to the nearest power of two, and the algorithm will still give anO(∆)
coloring.
Each color tracker Fvcan be stored using O(log∆) bits for b, and O(s) bits for H; thus Algorithm 8will use
O(n(s+log∆))=O(n/radicalbig
∆log( n/δ)) bits in total. For ∆=O(log( n/δ)), the Algorithm 1uses O(n∆) bits, which is also
O(n/radicalbig
∆log( n/δ)).
Algorithm 8 Randomized algorithm for O(∆) edge coloring for simple graph edge arrival streams
Input : Stream of vertex arrivals n-vertex graph G=(A⊔B,E)
Assume ∆is a power of two, and ∆=Ω(log( n/δ))
Initialize :
1:LetC=128∆
2:Letsbe the least power of two which is ≥128/radicalbig
∆log( n/δ)
3:LetHbe an ( ǫ,s)-wise independent distribution of permutations on [ C], with ǫ≤exp(−s2/C)≤(δ/n)128
4:forv∈Bdo
5: Letσvbe a random permutation from H
6: Fv←INITFREETRACKER (C,s,∆,σv), without reference count tracking
Process (edge { x,y})→color
7:ifFx∩Fy=/⌉mp⊔ys⌉⊔s⊔r⌉ss then
8: abort
9:Letcbe chosen uniformly at random from Fx∩Fy.
10:Fx.REMOVE ANDUPDATE (C)
11:Fy.REMOVE ANDUPDATE (C)
12:return color c
For each v∈V,i∈[C/s], write Pv,ifor the set σ[[s]+(i−1)s] of the free region tracker Fvfor vertex v. (See
Algorithm 7.) Since we are assuming the σvares-wise independent, the set Pv,iwill be uniformly distributed over
over/parenleftbig[C]
s/parenrightbig
.
Consider a ﬁxed input stream e1,e2,..., where the edges of the stream together form the simple g raph G. Write
bx,{u,v}for the value of the counter binside Fxjust before the algorithm processed edge { u,v}. Let D{u,v}:=
Pu,bu,{u,v}∩Pv,bv,{u,v}. Also deﬁne Mu,v:={x: {x,u}∈G∧bu,{x,u}=bu,{u,v}∧{x,u}≺{u,v}}; this is the set of ver-
tices which were adjacent to u, for which the edge { x,u} was added before { u,v}, and while the value of the counter
binside Fufor vertex uwas the same as it was at the time { u,v} was added. This is the set of vertices whose color
choices might reduce the size of Fu∩Fvat the time { u,v} is added.
We will ﬁrst show that of the following two classes of mevents, the probability that any of the events is true is
≤δ/2.
∀{u,v}∈G:H{u,v}:=/braceleftbigg
D{u,v}≤1
2s2/C/bracerightbigg
∀(u,v) where { u,v}∈G:Ju,v:=/braceleftBigg
/summationdisplay
x∈Mu,v|D{u,v}∩Px,bx,{x,u}|≥2·3
2s3
C2∆s
C/bracerightBigg
To bound the probability of H{u,v}, we let X1,... , XCbe indicator random variables where Xi=1 iff i∈Pu,bu,{u,v}.
Since the Xiare negatively associated [ JP83 ], the proof of the Chernoff bound holds, and
Pr[|D{u,v}|≤1
2s2/C]=Pr[D{u,v}≤1
2E[D{u,v}]]
=Pr[/summationdisplay
i∈[Pv,bv,{u,v}]Xi≤1
2E[D{u,v}]]
19≤exp(−1
8E[D{u,v}])=exp(−s2
8C)
≤exp(−16logn
δ)≤δ
2n2
To bound the probability of the events { Ju,v}, we will show that |Du,v|is not too large w.h.p, and conditioned on
that, the sum/summationtext
x∈Mu,v|D{u,v}∩Px,bx,{x,u}|is not too large w.h.p. With { Xi}i∈[C]as deﬁned above:
Pr[|D{u,v}|≥3
2s2/C]=Pr[D{u,v}≥3
2E[D{u,v}]]
≤Pr[/summationdisplay
i∈[Pv,bv,{u,v}]Xi≥3
2E[D{u,v}]]
≤exp(−1
10E[D{u,v}])=exp(−s2
10C)
≤exp(−128
10logn
δ)≤δ
4n2
The permutations { σx}x∈Mu,vare independent of σuandσv. For each x∈Mu,v, let Y1,x,... , YC,xbe indicator ran-
dom variables where Yi,xis 1 iff i∈Px,bx,{x,u}, and zero otherwise. Due to the frequency of free color buffe r refresh-
ing,|Mu,v|≤s∆/C; and since |Px,bx,{x,u}|=s,EYi,x=s/C. Since the { Yi,x}i∈D{u,v},x∈Mu,vare negatively associated, we
can apply a Chernoff bound. If we assume that |D{u,v}|≤3s2
2C, then we have:
Pr/bracketleftBigg
/summationdisplay
x∈Mu,v|D{u,v}∩Px,bx,{x,u}|≥2∆s2
C23s2
2C/bracketrightBigg
=Pr/bracketleftBigg
/summationdisplay
i∈D{u,v},x∈Mu,vYi,x≥2∆s2
C23s2
2C/bracketrightBigg
≤exp/parenleftbigg
−1
8∆s2
C23s2
2C/parenrightbigg
≤exp(−12(log( n/δ))2)≤δ
4n2
Thus, the probability that either |D{u,v}|≥3s2
2Cor event Ju,vdoes not hold isδ
2n2.
For the rest of the proof, we will consider the case where none of the events Ju,vorH{u,v}holds; this happens
with probability ≥1−δ/2. Fix values of the ( σv)v∈Vsatisfying none of the events. The only other random decisio ns
made by the algorithm are the choices made on Line 9, randomly choosing the edge color χ{u,v}for { u,v} from
Fu∩Fv. We will prove by induction on the number of edges processed t hat the probability of |Fu∩Fv| ≤1
4s2/C
holding at the time Line 9is executed, in total over all tedges so far is, ≤δ·t/(2n2).
To do this, we will use the following lower bound:
|Fu∩Fv|≥|D{u,v}|−/summationdisplay
x∈Mu,vWx,u−/summationdisplay
x∈Mu,vWx,v (6)
Here Wx,uis the indicator random variable for the event that the color chosen for { x,u} was in D{u,v}. The lower
bound overcounts the number of colors in D{u,v}that have been removed from Fu∩Fv.
The base case of the induction (0 edges) is immediate. Assume that we are processing edge { u,v}, and that all
edges { x,y} earlier in the stream, when they were processed, had |Fx∩Fy|≥s2
4C. For each x∈Mu,v, the color χ{x,u}
was drawn uniformly at random from some setFx∩Fu, which we assume satisﬁes |Fx∩Fu|≥s2
4C. For any subset H
ofD{x,u}of sizes2
4C, ifˆχis chosen u.a.r. from H, then
Pr[ˆχ∈D{u,v}]≤|H∩D{u,v}|
|H|≤4C
s2|Px,bx,{x,u}∩D{u,v}|
Conditioned on the color choices of all earlier edges, we thu s have EWx,u≤4C
s2|Px,bx,{x,u}∩D{u,v}|. Thus
E/bracketleftBigg
/summationdisplay
x∈Mu,vWx,u+/summationdisplay
x∈Mv,uWx,v/bracketrightBigg
≤4C
s2/parenleftBigg
/summationdisplay
x∈Mu,v|Px,bx,{x,u}∩D{u,v}|+/summationdisplay
x∈Mv,u|Px,bx,{x,v}∩D{u,v}|/parenrightBigg
20≤4C
s2·2∆s2
C23s2
2C=12∆
Cs2
C<s2
8Csince∆≤C/128
By the multiplicative/Chernoff-like formulation of Azuma ’s inequality,
Pr/bracketleftBigg
/summationdisplay
x∈Mu,vWx,u+/summationdisplay
x∈Mv,uWx,v≥s2
4C/bracketrightBigg
≤exp(−1
3s2
4C)≤exp/parenleftbigg
−32
3logn
δ/parenrightbigg
≤δ
2n2
By a union bound over all edges, the probability that any edge {u,v} has|Fu∩Fv|≤s2
4Cis≤δ/2.
We have shown that, in total, the probability of the algorith m aborting because Fu∩Fv=/⌉mp⊔ys⌉⊔s⊔r⌉ss is≤δ.
Algorithm 8can be generalized to produce O(∆2/t) edge colorings using /tildewideO(n/ra⌈i⌋allow
t) bits of space, by increasing
the parameters Cand swhile ensuring that s2/C=Ω(log( n/δ)). Then as at most s∆/Ccolors are removed from
each free color tracker, it will be possible to store each fre e color tracker using /tildewideO(s∆/C) bits of space. However,
further adjustment would be necessary to make the algorithm use/tildewideO(n/ra⌈i⌋allow
t) random bits. We suspect that picking
(ǫ,O(s2/C))-wise independent distributions will be sufﬁcient. As pr oving this would be tedious, and the following
Theorem 1.4already provides a color-space tradeoff for the edge arriva l setting, we do not do so.
We now introduce a technical lemma which will be useful in the proof of Theorem 1.4
Lemma 4.5. Let V be a set of size n, δ∈(0,1) , and let ∆be a power of two, satisfying ∆≥256logn
δ. Deﬁne C =32∆,
and let s be the least power of two which is ≥512/radicalBig
∆logn
δ. Let (σv)v∈Vbe randomly chosen permutations from an
(ǫ,s)-wise independent family, where ǫ≤exp(−s2/C)≤(δ/n)1024. For i∈[C/s], v∈V , let P v,i:=σ[s(i−1)+[s]].
We say that the permutations (σv)v∈Varegood if, for all simple graphs H on V ×[C/s]for which, for any u ,w∈V
and i∈[C/s], there is at most one j for which edge {(u,i),(v,j)}is in H, and the max degree of H is ≤s∆/C; that the
graph H can be list-edge colored where edge {(u,i),(v,j)}may only use colors in P u,i∩Pv,j.
The probability that the (σv)v∈Varegood is≥1−δ.
Proof of Lemma 4.5.We will prove this in two steps. First, deﬁne a speciﬁc proper ty U that the ( σv)v∈Vshould
satisfy with probability ≥1−δ; second, prove that if this property holds, then any graph Hcan be colored.
The permutations ( σv)v∈Vsatisfy property U if:
• For all pairs ( u,i),(v,j)∈V×[C/s], with u/n⌉ga⊔ionslash=v, we have |Pu,i∩Pv,i|≥s2
2C.
• For each ( u,i)∈V×[C/s],S⊆(V\{s})×[C/s] where|S|≤s∆/Cand Sincludes no two vertices ( v,i),(u,j) with
v=u, and all T∈/parenleftbigPu,i
|S|−1/parenrightbig
, there exists some ( x,j)∈Sfor which |Px,j∩T|<1
10|Px,j∩Pu,i|. (This is, in effect, a
stronger version of Hall’s condition).
For the ﬁrst part of property U, it is straightforward to bound the probability that it does not hold. For a given
pair ( u,i),(v,j)∈V×[C/s],u/n⌉ga⊔ionslash=v, because the permutations are ( ǫ,s)-wise independent, the sets Pu,iand Pv,jare
within ǫ-total-variation distance of being uniformly random subse ts of [ C] of size s, we can apply a Chernoff bound
for the number of elements in Pu,ithat lie in Pv,j:
Pr[Pu,i∩Pv,j≤1
2s2
C]≤exp(−1
8s2
C)+ǫ≤exp(−210log( n/δ))+ǫ≤δ
2n2(7)
(The additive factor ǫaccounts for the maximum difference in probabilities for th is event between the case where
Pu,iis exactly uniform and the case where it is ǫ-far from such.)
For the second part, consider a speciﬁc combination ( u,i,S,T), and ﬁx Pu,i. Then the probability that this
combination violates property U is:
Pr/bracketleftBigg
/logicalanddisplay
(x,j)∈S/braceleftbigg
|Px,j∩T|≥1
10|Px,j∩Pu,i/bracerightbigg/bracketrightBigg
≤/productdisplay
(x,j)∈SPr
Px,j/bracketleftbigg
|Px,j∩T|≥1
10|Px,j∩Pu,i|/bracketrightbigg
(8)
since the Px,j∈Sare all independent, since Scontains at most one entry for each v∈V. Since Px,jis a uniformly
random subset [ C],Px,j∩Pu,iis symmetrically distributed over Pu,i. Now let ˆTbe a uniformly random element of
21/parenleftbigPu,i
s/parenrightbig
, and deﬁne indicator random variables { Yk}k∈Pu,iso that Yk=1 iff k∈ˆT; these are negatively associated and
E[Yk]=|S|−1
s. Thus, if we assume |Px,j∩Pu,i|=h:
Pr
Px,j/bracketleftbigg
|Px,j∩T|≥1
10|Px,j∩Pu,i|/vextendsingle/vextendsingle/vextendsingle|Px,j∩Pu,i|=h/bracketrightbigg
≤Pr
ˆT/bracketleftbigg
|Px,j∩ˆT|≥1
10h/vextendsingle/vextendsingle/vextendsingle|Px,j∩Pu,i|=h/bracketrightbigg
+ǫ
= Pr
{Yk}k∈Pu,i/bracketleftBigg
/summationdisplay
k∈Pu,iYk≥1
10h/vextendsingle/vextendsingle/vextendsingle|Px,j∩Pu,i|=h|/bracketrightBigg
+ǫ
≤exp/parenleftbigg
−2/parenleftbigg1
10−|S|−1
s/parenrightbigg2
h/parenrightbigg
+ǫ
≤exp/parenleftbigg
−2/parenleftbigg1
10−∆
C/parenrightbigg2
h/parenrightbigg
+ǫ≤exp (−h/200 )+ǫ since C=32∆
This bound is useful only if his large enough. By the law of total probability, and using th e bound from Eq. 7to
handle the case where his small:
Pr
Px,j/bracketleftbigg
|Px,j∩T|≥1
10|Px,j∩Pu,i|/bracketrightbigg
≤Pr
Px,j/bracketleftbigg
|Px,j∩T|≥1
10|Px,j∩Pu,i|/vextendsingle/vextendsingle/vextendsingle|Px,j∩Pu,i|≥s2
2C/bracketrightbigg
Pr/bracketleftbigg
|Px,j∩Pu,i|≥s2
2C/bracketrightbigg
+Pr/bracketleftbigg
|Px,j∩Pu,i|≤s2
2C/bracketrightbigg
≤(exp/parenleftbigg
−s2
400C/parenrightbigg
+ǫ)·1+(exp(−s2
8C)+ǫ)≤2exp/parenleftbigg
−s2
400C/parenrightbigg
.
Substituting this result into Eq. 8gives:
Pr/bracketleftBigg
/logicalanddisplay
(x,j)∈S/braceleftbigg
|Px,j∩T|≥1
10|Px,j∩Pu,i/bracerightbigg/bracketrightBigg
≤2|S|exp/parenleftbigg
−|S|s2
400C/parenrightbigg
.
Taking a union bound over all ( u,i,S,T) tuples gives:
Pr[second part of Property U fails]
≤/summationdisplay
(u,i)∈V×[C/s]s∆/C/summationdisplay
k=1/summationdisplay
valid Swith|S|=k/summationdisplay
T⊆/parenleftbigPu,i
k−1/parenrightbig2kexp/parenleftbigg
−ks2
400C/parenrightbigg
≤n·s∆/C/summationdisplay
k=1·/parenleftBigg
n−1
k/parenrightBigg/parenleftbiggC
s/parenrightbiggk
·/parenleftBigg
s
k−1/parenrightBigg
·2kexp/parenleftbigg
−ks2
400C/parenrightbigg
≤ns∆/C/summationdisplay
k=1/parenleftbigg
2nC s exp/parenleftbigg
−s2
400C/parenrightbigg/parenrightbiggk
≤2n·2nC s exp/parenleftbigg
−s2
400C/parenrightbigg
for large enough s2/C
≤4n2·(32n)2exp(−2048
100log( n/δ))≤δ
2since s≤C=32∆
Combining this with a union bound over Eq. 7implies that property U fails to hold with probability ≤δ.
For the second stage of the proof, we consider the following i terative process to color any graph Hsatisfying
the given conditions. Consider an arbitrary ordering v1,... , vnof the vertices in V×[C/s]. For a given vertex vt,
letA(vt) be the set of vertices in { v1,... , vt−1} which are adjacent to ( vt,i), and let B(vt,i) be the set of vertices in
{vt+1,... , vn} which are adjacent to ( vt,i). For each z∈A(vt)∪B(vt), deﬁne Ut,vt,zto be the set of colors in Pvt∩Pz
that were already used by edges to vertices in A(vt) just after step t. The color assignment chosen will maintain the
invariant W that |Ut,z,(vt′)|≤1
3|Pz∩Pvt′|for all t′>tand z∈A(vt′). In other words, that when it is time to color the
22edges from a future vertex ( vt′) to A(vt′, only a≤1/3 fraction of the initially possible color options will ha ve been
used.
Invariant W automatically holds when t=0, since no edges have been colored. Say the invariant holds a t time
t−1. Then we are guaranteed that |Ut−1,z,vt|≤1
3|Pz∩Pvt|for all z∈A(vt), and want to ﬁnd color assignments for
the edges from A(vt) to zso that|Ut,z,vt|≤1
3|Pz∩Pvt|for all z∈B(vt). To do this, we will ﬁrst pick a set F⊆Pvtthat
satisﬁes:
∀x∈A(vt) :|Px∩Pvt\Ut−1,x,vt\F|≥1
10|Px∩Pvt| (9)
∀x∈B(vt) :|(Py∩Pvt) \F|≤1
3|Py∩Pvt| (10)
That such a set Fexists follows by the probabilistic method; say Fwere chosen so that each element of Pvtis
included u.a.r with probability7
10. For i∈Pv,t, let Xibe the indicator random variable for the event that i∈F.
Then the probability of Eq. 9is bounded by:
Pr/bracketleftbigg
|(Px∩Pvt) \Ut−1,x,vt\F|≥1
10|Px∩Pvt|/bracketrightbigg
≤Pr/bracketleftbigg
|(Px∩Pvt) \Ut−1,x,vt\F|≥3
20|(Px∩Pvt) \Ut−1,x,vt|/bracketrightbigg
since|(Px∩Pvt) \Ux,v|≥2
3|Px∩Pvt|
≤Pr/bracketleftBigg
/summationdisplay
i∈(Px∩Pvt)\Ut−1,x,vtXi≥17
20|(Px∩Pvt) \Ut−1,x,vt|/bracketrightBigg
≤exp/parenleftbigg
−9
200|Px∩Pvt\Ut−1,x,vt|/parenrightbigg
by Chernoff bound, since Eof LHS is14
20|(Px∩Pvt) \Ut−1,x,vt|
≤exp/parenleftbigg
−3
100|Px∩Pvt|/parenrightbigg
since|(Px∩Pvt) \Ut−1,x,vt|≥2
3|Px∩Pvt|
≤exp/parenleftbigg
−3s2
200C/parenrightbigg
=exp/parenleftbigg
−3072
25log( n/δ)/parenrightbigg
<1
2n
And for Eq. 10:
Pr/bracketleftbigg
|(Px∩Pvt) \F|≥1
3|Px∩Pvt|/bracketrightbigg
=Pr/bracketleftBigg
/summationdisplay
i∈(Px∩Pvt)Xi≤2
3|Px∩Pv,t|/bracketrightBigg
≤exp/parenleftbigg
−2/parenleftbigg7
10−2
3/parenrightbigg2
|Px∩Pv,t|/parenrightbigg
≤exp/parenleftbigg
−1
450|Py∩Pv|/parenrightbigg
=exp/parenleftbigg
−s2
900C/parenrightbigg
=exp/parenleftbigg
−2048
225log( n/δ)/parenrightbigg
<1
2n
Applying a union bound for the complements of Eq. 10and Eq. 9over all applicable z, we ﬁnd that both conditions
hold with positive probability, so a suitable Fexists.
Now that Fhas been chosen, we will select the colors for the edges from vtto each x∈A(vt) from the set
(Px∩Pvt)\Ut−1,x,vt\F. Since no colors in Fare chosen, for any z∈B(vt),Ut,z,vtwill not contain any element of F;
thus|Ut,z,vt|≤|(Px∩Pvt) \F|≤1
3|Px∩Pvt|.
Construct the bipartite graph Jbetween A(vt) and Pvt, where x∈A(vt) has an edge to each of the colors in
(Px∩Pvt) \Ut−1,x,vt\F. We claim there is an an A(vt)-saturating matching MofJ; given this matching, we assign
to edge { x,vt} its matched color M(x). For all x∈A(vt), we will have M(x)∈(Px∩Pvt) \Ut−1,x,vt\F; since M(x)∉
Ut−1,x,vt, the edge color for { x,vt} will not have been used before by any edge adjacent to x. As the matching assigns
a unique color to each edge, the edge coloring constraint wil l also be satisﬁed for vt.
To prove there exists a matching MinJ, we verify that Hall’s condition holds. For any subset Sof the vertices in
A(vt), we want to show that
/vextendsingle/vextendsingle/vextendsingle/vextendsingle/uniondisplay
x∈S((Px∩Pvt) \Ut−1,x,vt\F)/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥|S|
23The construction of Hensures that A(vt) and all subsets thereof satisfy the conditions for the seco nd part of Prop-
erty U (Speciﬁcally, |A(vt)| ≤s∆/C, and that for any b∈Vthere is at most one jfor which ( b,j)∈A(v,t).) By
this property, we are guaranteed that for all T⊆Pvtof size k−1, that there exists some x∈Sfor which |Px∩T|≤
1
10|Px∩Pvt. If Hall’s condition does not hold for S, then there must exist some T⊆Pv,tfor which:
/uniondisplay
x∈S((Px∩Pvt) \Ut−1,x,vt\F)⊆T
=⇒ ∀ x∈S: (Px∩Pvt) \Ut−1,x,vt\F⊆T
=⇒ ∀ x∈S: (Px∩Pvt) \Ut−1,x,vt\F⊆T∩Px
=⇒ ∀ x∈S:|(Px∩Pvt) \Ut−1,x,vt\F|≤|T∩Px|
=⇒ ∀ x∈S:1
10|Px∩Pvt|≤|T∩Px| by Eq. 9
But by the second part of Property U, there must exist an x∈Sfor which1
10|Px∩Pvt|>|T∩Px|; this is a contradic-
tion, so it follows that Hall’s condition does hold for S. Since Hall’s condition holds for all S⊆A(vt),Jwill contain
a matching, and step twill ensure invariant W holds for step t+1.
By induction, it follows that invariant W holds for all t∈[n], and thus that the process to color the edges of the
graph will always work.
At the core of the algorithm used by Theorem 1.4will be an algorithm for partial coloring of input streams.
We will prove that this inner algorithm Algorithm 9works for a speciﬁc class of edge arrival streams. These are
categorized by a Property Z, which is closely linked to the wa y the free color tracker (Algorithm 7) refreshes its pool
of colors.
Deﬁnition 4.6. For each edge { u,v} that arrives at time t, let du,tand dv,tbe the degrees of uand vrespectively
in the multigraph formed by all stream edges up to t. The edges adjacent to each x∈Vare assigned to blocks
depending on the degree of xafter they were added; thus edge { x,y} arriving at time tis assigned to block number
bx,t:=/ceilingleftbig
dx,t·C
s∆/ceilingrightbig
. Note that bx,t∈[C/s]. The stream satisﬁes Property Z when, for all v∈V,i∈[C/s], and w∈V\{v},
the stream contains at most one edge { v,w}, added at time t, for which bv,t=i.
Lemma 4.7. Algorithm 9properly edge-colors a ≥1/3 fraction of the edges in its input stream, if the permutation s it
is given are good according to Lemma 4.5, and the input stream satisﬁes Property Z.
Proof of Lemma 4.7.Say that the input stream for Algorithm 9satisﬁes Property Z. To each edge { x,y}, arriving at
time t, we can associate a set of possible colors Px,bx,t∩Py,by,t, where Px,i:=σx[(i−1)s+[s] indicates the ith set of
colors used by the free color tracker Fx. Of course, as the algorithm progresses some of the colors in Px,bx,t∩Py,by,t
may be used by other edges adjacent to xand y; the color trackers Fxand Fyprecisely record these.
Let Hbe the simple graph on V×[C/s] formed by mapping each edge { x,y} arriving in the input stream at
time tto the edge {( x,bx,t),(y,by,t)}. Because the stream satisﬁes Property Z, for any u,i,v, there is at most one
jfor which {( u,i),(v,j)} is in H. Thus, by Lemma 4.5, with probability ≥1−δover randomly chosen advice, the
permutations ( σv)v∈Vare good, and there exists an edge coloring χofHwhere each edge {( x,i),(y,j)} is given a
color from Px,i∩Py,j. This implies that, ifthe color chosen at Line 4were to exactly match the color from χat each
step, it would be possible to for the ﬁrst layer to assign a col or to every edge.
However, Line 4, when processing edge { x,y} at time t, chooses a color arbitrarily from the set of available color s
inPx,bx,t∩Py,by,t. As a result, the algorithm may select colors so that at some p oint, a given edge has Fx∩Fy=/⌉mp⊔ys⌉⊔s⊔r⌉ss on
Line 3, and cannot be colored. We claim that nevertheless, it will c olor a≥1
3fraction of all input edges. Consider
any ﬁxed input graph stream of length Tfor Algorithm 9, whose edges form multiset E. Consider a run of this
algorithm on the stream. At each time t, letρt:E/maps⊔o⌋har→[C]∪{⊥} indicate the partial coloring produced by the stream
after tedges were processed. Let χ:E/maps⊔o⌋har→[C] be the coloring produced by Lemma 4.5. Call an edge e"good" at
time tifρt(e)=⊥ and it is possible to assign color χ(e) to e. (In other words, there is no edge fincident on one of
e’s endpoints for which ρt−1(f)=χ(e).) Initially, all edges in Eare good. Each time tthat the algorithm processes
an edge { u,v}, it will either fail to color the edge, or set ρt({u,v})=cfor some color c. If c=χ({u,v}, then the
number of "good" edges will be reduced by 1, because χis a valid edge coloring. If c/n⌉ga⊔ionslash=χ({u,v}, then the number
of "good" edges will be reduced by 3; { u,v} will no longer be good, and there are at most two edges fthat are
incident to either uorvand have χ(f)=c. If the algorithm fails to color edge { u,v}, then this means χ({u,v}) was
24Algorithm 9 Partial coloring algorithm: (1/3)-partial O(∆) edge coloring for graph edge arrival streams satisfying
Property Z, plus reference counting
Input : Stream of edge arrivals n-vertex graph G=(V,E).
Assume ∆is a power of two
Initialize( ℓ,ξ,∆,C,(σv)v∈V,s,R):
Input∆is the maximum degree of the input graph stream
Input Cthe number of colors this sketch will use
Input sis block size parameter, and ( σv)v∈Vares-wise almost independent permutations
Input Ris a reference counted pool of edges
Each edge e∈Rwill have associated counter M(ℓ)
e∈[2ℓ] and color class χ(ℓ)
e∈{0,... ,/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig
}×[C(ℓ)]
1:forv∈Vdo
2: Fv←INITFREETRACKER (C,s,∆,σv). ⊲Also referred to as: F(ℓ,ξ)
v
Process (edge { x,y})→Option<color> ∈{⊥}∪[C]
3:ifFx∩Fy/n⌉ga⊔ionslash=/⌉mp⊔ys⌉⊔s⊔r⌉ss then
4: Choose c∈Fx∩Fyarbitrarily
5: Fx.REMOVE ANDUPDATE (C, {x,y}) ⊲This will increase { x,y}’s refcount in R
6: Fy.REMOVE ANDUPDATE (C, {x,y})
7: χ(ℓ)
{x,y}←(ξ,c)
8: M(ℓ)
{x,y}←1
9: return color c
10:else
11: return⊥
not available (because some edge incident on uorvused that color); so in all cases, after the algorithm proces ses
an edge, it will no longer be "good". Thus, at the end of the str eam, there will be no "good" edges remaining; and
since the number of "good" edges is reduced by at most 3 per edg e that was colored, the number of colored edges
must be at least |E|/3.
Finally, we state and prove the formal version of Theorem 1.4.
Theorem 4.8 (Formal version of Theorem 1.4).There is a deterministic algorithm for online O (∆(log∆)2)edge
coloring in edge arrival streams for multigraphs, using O (n/ra⌈i⌋allow
∆(log n)2.5(log∆)3)bits of space, and /tildewideO(n/ra⌈i⌋allow
∆)bits of
advice. (By picking a uniformly random advice string, the sa me algorithm can alternatively be used as a robust
algorithm with 1/poly( n)error; the advice can also be veriﬁed and computed in exponen tial time.)
Proof. We claim that Algorithm 11satisﬁes the conditions of the theorem. This algorithm uses O(n/ra⌈i⌋allow
∆) bits of
advice, for which we do not know of an efﬁcient polynomial tim e construction. δ∈(0,1) is a parameter which
gives, if the advice string is chosen uniformly at random, an upper bound on the probability that the advice string
does not work for all possible inputs. If we ran this algorith m with a random advice string, it would be robust to
adversarially generated inputs, with failure probability ≤δ.
Algorithm 11runs O(log∆) instances of an inner algorithm, Algorithm 10, which is designed to give correct edge
colorings for graph streams with a speciﬁc low-repetition g uarantee: that for any vertex v∈V, if one considers the
sequence of edges adjacent to vin stream order, and splits them into O(/radicalbig
∆/log n) contiguous lists, that no lists will
include a given edge more than once. To handle edges that are m ore commonly repeated, Algorithm 11will keep
track of all edges which, if added, might violate the guarant ee, and send them to another instance of Algorithm 10
which handles graph streams where no contiguous lists of edg es adjacent to a vertex includes a given edge twice;
and if an edge in the stream might violate that condition, the algorithm sends it to another copy of Algorithm 10,
and so on.
We will ﬁrst prove that the inner algorithm, Algorithm 10, works. This algorithm runs a number of instances
of Algorithm 9, which perform a greedy partial coloring of the input stream , with constraints on the set of colors
that it can use for any edge, as per Lemma 4.5. This greedy-coloring can be performed in O(n/ra⌈i⌋allow
∆) space, and by
25Algorithm 10 Inner algorithm: O(∆log∆) edge coloring for graph edge arrival streams which have cer tain sub-
streams satisfying Property Z, plus reference counting
Input : Stream of edge arrivals n-vertex graph G=(V,E).
Assume ∆is a power of two
Superscript ·(ℓ)indicates level of algorithm
Initialize( ℓ,∆(ℓ),R):
Input∆(ℓ)is the maximum degree of the input graph
LetC(ℓ)=32∆(ℓ)
1:D(ℓ)←/⌉mp⊔ys⌉⊔s⊔r⌉ss be a set of O(nlogn) "overﬂow" edges
2:if∆(ℓ)≥256log( n/δ))then ⊲Condition for Lemma 4.5to apply
3: Lets(ℓ)satisfy constraints of Lemma 4.5
4: Advice: { σ(ℓ)
v}v∈Vare permutations over [ C(ℓ)], "good" for Lemma 4.5
5: foreach layer ξ∈[/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig
]do
6:I(ℓ,ξ)←INITIALIZE (ℓ,ξ,∆,C,s,{σ(ℓ)
v}v∈V,R) from Algorithm 9
Process (edge { x,y})→color∈/bracketleftbig/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig/bracketrightbig
×/bracketleftbig
C(ℓ)/bracketrightbig
7:if∆(ℓ)≥256log( n/δ))then
8: forξ∈/bracketleftbig/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig/bracketrightbig
do
9: Letc←I(ℓ,ξ).PROCESS ({x,y}) from Algorithm 9
10: ifc/n⌉ga⊔ionslash=⊥ then
11: return color ( ξ,c)
12:D(ℓ)←D(ℓ)∪{{x,y}}
13:Increase reference count for { x,y} in R
14:Greedily pick a color class c∈[C(ℓ)] not used by any edge in D(ℓ)adjacent to xory
15:χ(ℓ)
{x,y}←(0,c)
16:M(ℓ)
{x,y}←1
17:return color (0, c)
Lemma 4.7is guaranteed to color at least 1/3 of the edges in the input st ream. By sending all edges which the
greedy procedure did not color to an independent greedy colo ring instance, the number of uncolored edges can
be reduced further; after O(log∆) iterations of this, an O(1/∆) fraction of the input stream has not been colored;
this part of the stream can be stored entirely and colored wit h 2∆−1 colors.
In Algorithm 10, the for loop at Line 8sends the edge { x,y} being processed to each of the/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig
instances
of Algorithm 9, until either one of them assigns a color to the edge, or all th e instances fail to color the edge. Since
each instance is guaranteed to color a ≥1/3 fraction of the edges it processes, only a (2/3)/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig
≤1
∆(ℓ)fraction
of the edges received by Algorithm 10will reach Line 12of the algorithm and be stored in D(ℓ); since there are only
O(n) such edges, storing them does not signiﬁcantly affect the s pace usage of the algorithm. These edges will be
greedily colored using a fresh set of colors.
To handle general multigraphs, Algorithm 11divides the stream into a series of levels, for ℓfrom 0 to log ∆. The
higher levels process very common edges, which are assigned blocks of 2ℓcolors for layer ℓ. Each level uses an
instance of Algorithm 10to assign color blocks for the edges it receives. If a copy eof a given edge { u,v} arrives,
and the color block for { u,v} is not full, then the ewill be assigned the next available color in the block. The sp eciﬁc
scheme, as we shall show, ensures that every edge is either co lored from an existing color block, or passed to an
instance of Algorithm 10; and in the latter case, ensures that property Z holds for the stream sent to Algorithm 10.
Algorithm 11maintains a global reference counted pool R, which keeps track of every edge { x,y} that arrives
for some amount of time. Each level ℓcan provide references for the edge; { x,y} will only be dropped from Rif no
levels have a reference. At level ℓ, we have two cases, depending on how { x,y} was processed by Algorithm 10. If
{x,y} was not colored by any layer ξ, it will be stored in D(ℓ)for the rest of the stream, and any further copies of
that edge will not be sent by Algorithm 11to the level ℓinstance of Algorithm 10. If { x,y} was successfully colored
by layer ξ, the edge will be recorded until both of the free color tracke rsF(ℓ,ξ)
x and F(ℓ,ξ)
y have been refreshed.
26Algorithm 11 Deterministic algorithm for O(∆(log∆)2) edge coloring for multigraph edge arrival streams
Input : Stream of edge arrivals n-vertex graph G=(V,E)
Assume ∆is a power of two
Initialize :
1:LetR←/⌉mp⊔ys⌉⊔s⊔r⌉ss be a reference counted pool of edges. (This will be a set of "re cent" edges for each layer in each level,
including edges that are either in D(ℓ)or have a reference from one of the F(ℓ,ξ)
x
2:Each edge e∈Rwill have, per level ℓ, one associated counter M(ℓ)
e∈[0,2ℓ] and color class χ(ℓ)
e∈
{0,... ,/ceilingleftbig
log3/2∆(ℓ)/ceilingrightbig
}×[C(ℓ)]. When an edge is added to the pool, M(ℓ)
e=0 for all layers.
3:foreach level ℓin 0,... ,log ∆do
4: Deﬁne ∆(ℓ)=∆/2ℓ
5:K(ℓ)←INITIALIZE (ℓ,∆(ℓ)) from Algorithm 10
Process (edge { x,y})→color
6:forℓin 0,... ,log ∆do
7: if{x,y} is in Rand M(ℓ)
{x,y}>0then
8: ifM(ℓ)
{x,y}=2ℓthen
9: continue
10: else
11: M(ℓ)
{x,y}←M(ℓ)
{x,y}+1
12: Let ( i,j)←χ(ℓ)
{x,y}
13: return color/parenleftBig
ℓ,i,(j−1)2ℓ+M(ℓ)
{x,y}/parenrightBig
14: else
15: Let (ξ,c)←K(ℓ).PROCESS ({x,y}) for level ℓalgorithm
16: return color/parenleftbig
ℓ,ξ,(c−1)2ℓ+1/parenrightbig
This only happens if the block numbers bx,tand by,tof {x,y} with respect to the substream received by the layer
ξinstance of Algorithm 9have increased. Consequently, that substream will satisfy Property Z – if Algorithm 11
receives a second copy of edge { x,y} at time t′while either bx,t′=bx,torby,t=by,t, because { x,y} will be still be in
R, Algorithm 11will not send the second copy to the level ℓinstance of Algorithm 10.
We now check that the level ℓinstance of Algorithm 10does not receive a graph stream of degree more than
∆(ℓ). When a copy of an edge { u,v} arrives, the loop at Line 6only continues from level ℓto to level ℓ+1 ifM(ℓ)
{u,v}=2ℓ
was true. Thus, for an edge eto be processed by the level ℓinstance of Algorithm 10, the edge emust have arrived
at least 20+21...+2ℓ−1=2ℓ−1 times before in the stream, and 2ℓtimes in total, since the last time ewas dropped
from R. Since the maximum degree of the graph is ∆, and an edge must be added ≥2ℓtimes for each time that it
is sent to the level ℓinstance of Algorithm 10, the level ℓinstance will receive at most ∆/2ℓedges adjacent to any
given vertex.
When ℓ=log∆in the for loop, Line 9will not be executed; because for M(ℓ)
{x,y}to equal 2ℓ=∆, this must be the
∆+1st copy of edge { x,y} to arrive. Thus Algorithm 11will assign a color to every edge in the stream.
The total space usage of Algorithm 11is dominated by the sets D(ℓ), free color trackers F(ℓ,ξ)
v , and the pool R
(along with its linked properties χ(ℓ)
e,M(ℓ)
e, for each ℓ∈{0,... ,log ∆}.) Over all levels ℓ, layers ξ, and vertices in V,
there are O((log∆)2n) color trackers, each of which uses O(s(ℓ)logn+log∆)=O(/radicalbig
∆log( n/δ)log n) bits of space
to store colors and O(log n)-bit references to edges. Each D(ℓ)is guaranteed to contain O(nlogn) edges, at most,
and needs O(n(log n)2) bits of space. Finally, the ℓth level references at most |D(ℓ)|+O(ns(ℓ)log∆) edges in R, so
in total Rwill have O(nlogn+n/radicalbig
∆log( n/δ)log∆) edges. Each each needs O(log n) bits to identify, and there are
O((log∆)2) bits of associated information in the ( χ(ℓ)
e,M(ℓ)
e)ℓ. Thus, in total, Algorithm 11uses:
O(n/radicalBig
∆log( n/δ)(log∆)2lognlog( n∆))
bits of space.
If the advice ( σ(ℓ)
v)v∈V,ℓ∈{0,...,log ∆}was chosen randomly using Lemma 6.3, then O(spoly(log ∆,log n)) truly ran-
27dom bits per permutation would be needed for a level of accura cy (≤1/poly( n) total variation variation distance
from uniformity) under which the proof of Lemma 4.5works. At δ=1/2, this is O(n/ra⌈i⌋allow
∆poly(log ∆,log n) bits. Given
exponential time, the advice can also be computed on demand, since checking that Property U from the proof of
Lemma 4.5can be done in exponential time.
5 Lower bounds for deterministic edge coloring
Lemma 5.1. Let B be a set of n vertices; let ∆be an integer, and let C ∈[∆,2∆−1]be another integer . Deﬁne β:=C/∆.
Consider the case where (2−β)n≥32C.
For each v ∈B, say we have a nonempty set S v⊆[C]of possible colors, where/summationtext
i∈B|Si|≤βn. If G is a uniformly
random bipartite graph between a set A of size ⌊n/∆⌋, then the probability p (n,∆,β)that G has a valid edge coloring
where each edge (a,b)is given a color from S bis:
p(n,∆,β)≤exp(−1
213(2−β)3n) (11)
Proof of Lemma 5.1.The graph Gcan be interpreted as a random partition of Binto sets P1,... , P⌊n/∆⌋, plus a possi-
blePremainder set, where all sets Piexcept for the remainder have size ∆. Note that P1is a uniformly random subset
of size ∆inB,P2is a uniformly random subset of size ∆inB\P1, and so on. For each i∈⌊n/∆⌋, let Cibe the event
that there is a Pi-saturating matching in the bipartite graph between Piand [ C], where each v∈Pis adjacent to all
c∈Sv. Letγ=2−β. Then we have:
p(n,∆,β)≤/ceilingleftbig1
2γn/∆/ceilingrightbig
/productdisplay
i=1Pr[Ci|C1,... , Ci−1] (12)
We will prove Eq. 11by proving a upper bounds on Pr[ Ci|C1,... , Ci−1], for all i∈[/ceilingleftbig1
2γn/∆/ceilingrightbig
], and then applying Eq.
12.
By Markov’s inequality, the fraction of vertices in Bfor which |Sv|−1≥1 is≤β−1=1−γ, so Pr v∼B[|Sv|=1]≥γ.
For each i∈[⌊n/∆⌋], let Ti=B\/uniontext
j<iPj. Then for all i≤/ceilingleftbig1
2γn/∆/ceilingrightbig
:
|{v∈Ti:|Sv|=1}|
|Ti|≥|{v∈B:|Sv|=1}|−∆(i−1)
|B|−∆i≥γn−(i−1)∆
n−∆(i−1)≥γn−1
2γn
n−1
2γn≥1
2γ
Consequently, conditioned on P1,... , Pi−1, the set Piwill be drawn uniformly at random from a set Tiof vertices
for which at least a γ/2 fraction have singleton color sets (have |Sv|=1).
For a given i, we remark that if Picontains two vertices v,wfor which |Sv|=| Sw|=1 and Sv=Sw, then it is
not possible to match the vertices in Pito colors, as vand wwould conﬂict. Let us bound the probability that
this occurs. Let ˆn= |Ti|; note that this is ≥n/2. To make the distribution of singleton sets drawn from { Sv}v∈Ti
appear more uniform, we construct Cdisjoint sets L1,... , LCinTi, so that for each Li, the associated color sets are
all a singleton |/uniontext
j∈LiSj|=1; and for which |Li|≥γˆn/4C. (If each singleton color set were equally likely, we could
get|Li|≥γˆn/2C– but it is possible that {1} is rare, while {2} more common tha n average. One way to construct
the L1,... , LCis by iteratively removing sets of γˆn/4Cvertices from Tiwhose associated color sets are all the same
singleton set.)
For each j∈Ti, let Xjbe the indicator random variable for the event that j∈Pi. For each k∈[C], let Yk=/summationtext
j∈LkXj. Since the random variables { Xj}j∈Tiare negatively associated, sums of disjoint sets of them, th e {Yk}k∈[C],
are also negatively associated. (See [ JP83 ].) We have:
Pr[Pihas no two elements from same Lk]
≤Pr[/logicalanddisplay
k∈[C]{Yk≤1}]
≤/productdisplay
k∈[C]Pr[Yk≤1] since negative association =⇒ negative orthant dependence
28We calculate Pr[ Yk≤1] exactly, and then prove an upper bound on it.
Pr[Yk≤1]=/parenleftbigˆn−|Lk|
∆/parenrightbig
+|Lk|/parenleftbigˆn−|Lk|
∆−1/parenrightbig
/parenleftbigˆn
∆/parenrightbig
=ˆn−|Lk|−∆+1
∆/parenleftbigˆn−|Lk|
∆−1/parenrightbig
+|Lk|/parenleftbigˆn−|Lk|
∆−1/parenrightbig
ˆn
∆/parenleftbigˆn−1
∆−1/parenrightbig
=ˆn−|Lk|−∆+1
∆+|Lk|
ˆn/∆·/parenleftbigˆn−|Lk|
∆−1/parenrightbig
/parenleftbigˆn−1
∆−1/parenrightbig
≤ˆn−|Lk|−∆+1
∆+|Lk|
ˆn/∆·/parenleftbiggˆn−|Lk|
ˆn−1/parenrightbigg∆−1
since/parenleftBigg
a
c/parenrightBigg
//parenleftBigg
b
c/parenrightBigg
≤(a/b)cifc≤a≤b
=/parenleftbigg
1+|Lk|−1
ˆn(∆−1)/parenrightbigg/parenleftbigg
1−|Lk|−1
ˆn−1/parenrightbigg∆−1
≤exp/parenleftbigg
ln/parenleftbigg
1+|Lk|−1
ˆn(∆−1)/parenrightbigg
−|Lk|−1
ˆn−1(∆−1)/parenrightbigg
since 1−x≤exp( x)
≤exp/parenleftbigg|Lk|−1
ˆn(∆−1)−1
4/parenleftbigg|Lk|−1
ˆn(∆−1)/parenrightbigg2
−|Lk|−1
ˆn−1(∆−1)/parenrightbigg
since ln(1 +x)≤x−x2/4 for x≤1
≤exp/parenleftbigg
−(|Lk|−1)(∆−1)
ˆn(ˆn−1)−1
4/parenleftbigg|Lk|−1
ˆn(∆−1)/parenrightbigg2/parenrightbigg
≤exp/parenleftbigg
−1
4γ2
210/parenrightbigg
=exp(−γ2/212)
In the last inequality, we used the fact that ( |Lk|−1)(∆−1)/ˆn≥(γˆn/4C−1)(∆−1)/ˆn≥γ/32C.
Having bounded Pr[ Yk≤1], it follows that:
p(n,∆,β)≤/ceilingleftbig1
2γn/∆/ceilingrightbig
/productdisplay
i=1Pr[Ci|C1,... , Ci−1]≤/parenleftBig
exp/parenleftbig
−γ2/212/parenrightbigC/parenrightBig/ceilingleftbig1
2γn/∆/ceilingrightbig
≤exp/parenleftbigg
−γ2/212·C·/ceilingleftbigg1
2γn/∆/ceilingrightbigg/parenrightbigg
≤exp(−γ3n/213)
We now formally restate Theorem 1.9and prove it.
Theorem 5.2 (Formal version of Theorem 1.9).For all β∈(1,2) , and integers n ,∆satisfying ∆≤n(2−β)/(32β),
every deterministic online streaming algorithm for edge-c oloring that uses β∆colors requires Ω((2−β)3n)bits of
space.
Proof. Say we have an algorithm Ato provide an online ( β∆) edge-coloring of an input stream, presented in one-
sided vertex arrival order, using Sbits of space. We assume that ∆|n; if this is not the case, we can reduce nto
the nearest multiple of ∆, weakening our ﬁnal lower bound by at most a factor of 2. With t he algorithm, we can
implement a protocol for a ∆-player one-way communication game in which each message us es≤Sbits. We will
then prove a communication lower bound for this game.
Speciﬁcally, let P1,... , P∆be the players of the game. Let A1,... , A∆and Bbe sets of vertices, where for each
i∈[∆],|Ai|=n/∆, and|B| =n. For each i∈[∆], the player Piis given a regular bipartite graph Gifrom AitoB,
in which each vertex in Aihas degree ∆, and each vertex in Bihas degree 1. Player P1starts the communication
game by outputing an edge coloring χ1ofG1, using colors in [ β∆]; and then it sends a message m1to Player P2.
For each i∈{2,... ,∆}, the player Piwill receive a message mi−1from its predecessor, output an edge coloring χiof
G1which is compatible with the edge colorings χ1,... ,χi−1made by the earlier players, and then (if i<∆) send a
message mito the next player.
The conversion from an algorithm Ato a protocol for this game is straightforward; P1initializes an instance A
ofA, uses it to process G1in arbitrary order, and reports the colors the algorithm out put; then it encodes the state
29of the instance Aas an S-bit message m1.P2receives this message, and uses it to continue running the in stance
A, this time having it process G2;P2outputs the results, and sends the new state of AtoP3asm2. The players
continue in this way until P∆produces output.
For each i∈{1,... ,∆−1}, and message mi, we deﬁne Smi=(Smi,v)v∈B. Here Smi,vis the set of all colors which
players P1,... , Picould have assigned to edges incident on vfor executions of the protocol in which Pisent mes-
sage mi. If player Pi+1receives message mi, the coloring χi+1that it outputs must be disjoint from Smi; specif-
ically, if we view χi+1as a vector in [ β∆]Bwhose vth entry gives the color assigned to the edge incident to vert ex
v, then∀v∈B:χi+1,v∉Smi,v. If this were not the case, and there was a vertex xfor which χi+1,x∈Smi,x, then
there would be an execution of the protocol on which some play erPjoutput color χi+1,xfor an edge incident on x,
later Pisent message mi, and now Pi+1’s assignment of χi+1,xto the edge incident on xviolates the edge coloring
constraint.
Let p(n,∆,β) be the probability from Lemma 5.1. We claim that there exists an input for which some player
must send a message with more than log 1/ p(n,∆,β) bits. If this is not the case, then we shall construct an inpu t
on which the protocol must give an incorrect output, a contra diction.
LetM1be the set of all messages that player P1can send. Let Hbe chosen uniformly at random from the set of
(∆,1)-regular bipartite graphs from A1toB, and let m1(H) be the message P1would send if G1=H. Then, if for all
m∈M1, we were to have/summationtext
v∈B|Smi,v|≤βn,
1=/summationdisplay
m∈M1Pr[m=m1(H)]≤|M1|p(n,∆,β)
But since we have assumed messages in M1need<log 1/ p(n,∆,β) bits, and hence |M1|<1/p(n,∆,β), the above
equation would imply 1 <1; thus there must be some m⋆
1∈M1for which/summationtext
v∈BSmi,v≥βn. LetG1be the set of
graphs for which H∈G1⇐⇒ m1(H)=m⋆
1; then on being given any graph in G1, player P1will output m⋆
1.
We will now iterate over i∈{2,... ,∆−1} and build a sequence of messages m⋆
1,m⋆
2,... , m⋆
∆, along with sets
of input graphs G1,... ,G∆−1on which the protocol will send these messages. For each i∈[∆], deﬁne Tm,i,i=
(Tv,m,i)v∈B, where Tv,m,i:=Sm\Sm⋆
i−1,i. Any coloring χithat Pioutputs which is compatible with all inputs leading
tom⋆
iwill satisfy χi,v∈Tv,m,i. (Ifχi,v∈Sm⋆
i−1,i, then as noted above there is a set of inputs where this will vi olate the
edge coloring constraint for v.) As argued for M1, there must be some message m⋆
i∈Mifor which/summationtext
v∈B|Tv,m,i|≥
βn.
Finally, for each v∈B, deﬁne Rv=[β∆]\Sm⋆
∆−1,v. Since Sm⋆
∆−1,v=⊔∆−1
i=1Tv,m⋆
i,iwe will have |Rv|≤β∆−β(∆−1)=
β. On receiving m⋆
∆−1, player P∆can only assign edge colors so that edges incident on vuse colors in Rv; for
any other color, there is a input which uses it and which makes P∆−1send m⋆
∆−1. IfG∆were chosen uniformly at
random from its set of possible values, then the probability that G∆has an edge coloring compatible with { Rv}v∈m
is≤p(n,∆,β). Since this is <1, there must exist a speciﬁc graph G†
∆on which the protocol uses a color not in Rvfor
some v∈B. We have thus shown that if the protocol always uses fewer tha n log1/ p(n,∆,β) bits for its messages, it
will give incorrect outputs for some input.
We conclude:
S≥log1
p(n,∆,β)=Ω((2−β)3n)
6 Supporting lemmas
Corollary 6.1 (Practical high-rate-distance-product bin ary codes, via [ SS96 ]).For sufﬁciently large t, there is a
binary code of length t with rate ≥1
4t, and distance ≥1
400t. The code can be implemented with pol y (t)initial setup
time and space, and O (t2)encoding time.
Proof of Corollary 6.1.Letǫ=/ra⌈i⌋allow
2/20. By [ SS96 ] Theorem 19, there is a polynomial time constructible famil y of
codes of rate 1 −2H(ǫ)=0.2628... ≥1/4, and relative distance approaching ǫ2=1/200. In particular, for sufﬁciently
large code length t, the rate will be ≥1/4 and the relative distance will be ≥1/400.
The expander codes described by [ SS96 ], at code length t, require poly( t) time to construct the expander graph
used, and can be encoded in O(t2) time.
30Lemma 6.2. Let W be a nonnegative integral random variable where, for al l k∈N,Pr[W≥k]≤1/2k. Then E[W]≤1;
and furthermore, for all t for which et∈[1,2) :
E[etW]≤1
2−et
Proof of Lemma 6.2.First,
E[W]=∞/summationdisplay
k=0Pr[W≥k]≤/summationdisplay
k=01/2k+1=1
Next,
E[etW]=∞/summationdisplay
k=0etkPr[W=k]≤∞/summationdisplay
k=0etk 1
2k+1=1
2∞/summationdisplay
k=0/parenleftbigget
2/parenrightbiggk
=1
2·1
1−1
2et=1
2−et
The inequality step follows because:
∞/summationdisplay
k=0etk/parenleftbigg1
2k+1−Pr[W=k]/parenrightbigg
=∞/summationdisplay
k=0etk/parenleftbigg
(1
2k−1
2k+1)−(Pr[W≥k]−Pr[W≥k−1])/parenrightbigg
=∞/summationdisplay
k=0etk/parenleftbigg1
2k−Pr[W≥k]/parenrightbigg
−∞/summationdisplay
k=0etk/parenleftbigg1
2k+1−Pr[W≥k−1]/parenrightbigg
=∞/summationdisplay
k=0etk/parenleftbigg1
2k−Pr[W≥k]/parenrightbigg
−∞/summationdisplay
k=1et(k−1)/parenleftbigg1
2k−Pr[W≥k]/parenrightbigg
=/parenleftbigg1
20−Pr[W≥0]/parenrightbigg
+∞/summationdisplay
k=1(et−et(k−1))/parenleftbigg1
2k−Pr[W≥k]/parenrightbigg
=0+∞/summationdisplay
k=1et(k−1)(et−1)/parenleftbigg1
2k−Pr[W≥k]/parenrightbigg
≥0
By [ Mor13 ] plus some algebra, for any ǫ>0, a sequence of O/parenleftbig
d3+dln(1
ǫ)/parenrightbig
Thorp shufﬂe steps will produce a
permutation on [2d] whose distribution has total variation distance at most ǫaway from the uniform distribution.
4
Lemma 6.3 (Random permutations through switching networks ).For any C which is a power of 2, there is an ex-
plicit construction of an (ǫ,s)-wise independent random permutation, using r =O(s(log C)4log1
ǫ)bits. Furthermore,
we can evaluate σ(i)andσ−1(i)in O (s(log C)4log1
ǫlogC)time.
Proof of Lemma 6.3.Letk=O(d3+dln(1/ǫ)) be the constant for which kThorp shufﬂe steps would permute [ C]=
[2d] within total variation distance of ǫof the uniform distribution over permutations on [2d].
The switching network Ncorresponding to the kThorp shufﬂe steps has depth kand uses exactly kC/2 gates.
Assign each gate a unique number in [ kC/2]. Then given a uniformly random bit vector x∈{0,1}kC/2, we evaluate
the switching network by having the gate numbered iswitch its inputs iff xi=1. A key property of switching
networks is that one can evaluate their action on a single inp ut by only evaluating one gate per layer – for this
network, only kgates. Reversing the order in which the layers are applied wi ll produce the inverse of the original
permutation. Thus, one can evaluate N(i) by reading only kentries of x, and similarly for and N−1i.
Now, say the bits of xare the output of a hash function drawn from a ks-wise independent hash family. (For
example, using a family of [ WC81 ], let h=/ceilingleftbig
log2kC/2/ceilingrightbig
, take the family of random polynomials of degree ks−
1 inside F2h, and output the least bit of the output. The polynomial coefﬁ cients can be encoded using ksh=
O(kslog( C)) bits, and the polynomials evaluated at any point in O(ksh2)=O(ks(log C)2) time.)
4While there exist more efﬁcient switching networks that als o permute sets whose sizes are not powers of two, we use the res ult of [ Mor13 ]
here because it is simple to work with. In particular, see the results claimed by [ Czu15 ], although we could not ﬁnd the full version of that paper.
31Ifπis a uniformly random permutation on [ C], then for all lists of distinct h1,... , hs, and all lists of distinct
j1,... , js, we have
Pr[/logicalanddisplay
i∈[s]π(hi)=ji]=1/producttext
i∈[s](C−i+1)
Now, let f: {0,1}kC/2×[C]/maps⊔o⌋har→[C]kbe the function which maps the gate-controlling vector x∈{0,1}kC/2and an
input a∈[C] to the path b1,... , bkthat atakes through the switching network Nif its gates are conﬁgured accord-
ing to x. The last node of this path, f(x,a)kis the output of Ngiven xand a. Each path P=(a,b1,... , bk) through
the switching network corresponds to a restriction RP∈{0,1,⋆}kC/2which has value ⋆on gates not touched by the
path, and for each gate traversed by the path assigns either 0 or 1 depending on whether a straight or switched
conﬁguration of the gate is compatible with P. Since all paths through the network have length k,RPonly sets k
coordinates. Now, for each pair ( a,b)∈[C]2, let
Fa,b={RP:P=(a,b1,... , bk−1,b) is a possible path}
Then, for lists ( h1,... , hs), (j1,... , js), deﬁne
Kh1,...,hs,j1,...,js={R∈{0,1,⋆}kC/2:∀i∈[k],∃T∈Fhi,jiwhere Ris a minimal reﬁnement of T},
i.e., the set of minimal restrictions for vectors in {0,1}kC/2which completely determine the paths through the
switching network of inputs ( h1,... , hs).
Now, let Y∈{0,1}kC/2beks-wise independent, and X∈{0,1}kC/2be fully independent. We have:
Pr[/logicalanddisplay
i∈[s]f(Y,hi)k=ji]=/summationdisplay
R∈Kh1,...,hs,j1,...,jsPr[Ycompatible with R]
=/summationdisplay
R∈Kh1,...,hs,j1,...,jsPr[Xcompatible with R]
=Pr[/logicalanddisplay
i∈[s]f(X,hi)k=ji]
where the second inequality follows because each restricti onR∈Kh1,...,hs,j1,...,jsonly constrains sk/2 coordinates
corresponding to the gates on the paths in the switching netw ork from h1,... , hstoj1,... , jsthat it ﬁxes.
Thus,
1
2/summationdisplay
distinct b1,... , bkin [C],/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBigg
/logicalanddisplay
i∈[s]{f(X,hi)k=ji}/bracketrightBigg
−1/producttext
i∈[s](C−i+1)/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle=
1
2/summationdisplay
distinct b1,... , bkin [C],/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBigg
/logicalanddisplay
i∈[s]{f(Y,hi)k=ji}/bracketrightBigg
−1/producttext
i∈[s](C−i+1)/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤ǫ
which proves that the switching network evaluated on Xproduces outputs that are ( ǫ,s)-wise independent.
7 Regarding implementation
Several of the algorithms in this paper rely on the availabil ity of oracle randomness (i.e, having a long read only ran-
dom string) in order to avoid the space penalty of explicitly storing many independent random permutations. In
practice (where we assume cryptographic pseudo-random num ber generators exist), it is straightforward to gen-
erate the bits of the oracle random string on demand, ensurin g that computationally bounded systems essentially
cannot produce hard inputs for the algorithm.
The randomized algorithms Algorithm 3and Algorithm 8both use the same idea of trying and discarding (mak-
ing unavailable for future use), either immediately or peri odically, a set of fresh colors chosen by iterating over a
random permutation. This construction has the downside tha t, since many colors are discarded, the total num-
ber Cof colors in the algorithm might use must be large. Instead of discarding colors, a possibly more efﬁcient
approach is to retain, for each vertex, a pool of all the color s that were tried but not used; this ensures that colors
are only removed from consideration when they have been used . The downside of retaining unused colors is an
32increased space usage that is harder to prove upper bounds fo r. For the following two algorithms, Algorithm 12
and Algorithm 13, for one-sided vertex arrival, and edge arrival streams, we conjecture that they require /tildewideO(n) and
/tildewideO(n/ra⌈i⌋allow
∆) bits of space with high probability, but have not been able t o prove this. The second algorithm in particu-
lar is rather similar to an online edge coloring algorithm co njectured to use ∆+O(/ra⌈i⌋allow
∆logn) colors by [ BMN92 ], in
which each edge is assigned a uniformly random color from the set of colors that no edges incident to its endpoints
have used.
Algorithm 12 A simple randomized algorithm for (2 ∆−1)-edge coloring in the one-sided vertex arrival model
which is conjectured to use O(nlog∆) space w.h.p.; and uses /tildewideO(n∆) oracle random bits
Input : Stream of one-sided vertex arrivals on n-vertex graph G=(A⊔B).
LetC:=2∆−1.
Initialize():
1:forz∈Bdo
2: σz←uniformly randomly chosen permutation over [ C]
3: hz←1
4: Fz←/⌉mp⊔ys⌉⊔s⊔r⌉ss
Process (vertex a∈A, adjacent edges Ma)
5:S←/⌉mp⊔ys⌉⊔s⊔r⌉ss
6:for{a,b}∈Ma, in random order do
7: while Fb⊆Sdo
8: Fb←Fb∪σb[hb]
9: hb←hb+1
10: Letcbe random color from Fb\S
11: Assign color cto edge { a,b}
12: Fb←Fb\ {c}
13: S←S∪{c}
Algorithm 13 A simple randomized algorithm for (2 ∆−1)-edge coloring in the edge arrival model which is conjec-
tured to use O(n/ra⌈i⌋allow
∆log∆) space w.h.p.; and uses /tildewideO(n∆) oracle random bits
Input : Stream of edge arrivals on n-vertex graph G=(V,E).
LetC:=2∆−1.
Initialize:
1:forv∈Bdo
2: σv←uniformly randomly chosen permutation over [ C]
3: hv←1
4: Fv←/⌉mp⊔ys⌉⊔s⊔r⌉ss
Process (edge { x,y}):
5:while Fx∩Fy=/⌉mp⊔ys⌉⊔s⊔r⌉ss do
6: Fx←Fx∪σx[hy]
7: hx←hx+1
8: Fy←Fy∪σy[hy]
9: hy←hy+1
10:Letcbe random color from Fx∩Fy
11:Assign color cto edge { x,y}
12:Fx←Fx\ {c}
13:Fy←Fy\ {c}
14:S←/⌉mp⊔ys⌉⊔s⊔r⌉ss
33References
[AL12] Noga Alon and Shachar Lovett. Almost k-wise vs. k-wis e independent permutations, and uniformity
for general group actions. In Proc. 16th International Workshop on Randomization and App roximation
Techniques in Computer Science , pages 350–361. Springer, 2012.
[AMSZ03] Gagan Aggarwal, Rajeev Motwani, Devavrat Shah, an d An Zhu. Switch scheduling via randomized
edge coloring. In 44th Annual IEEE Symposium on Foundations of Computer Scien ce (FOCS), 2003, ,
pages 502–512. IEEE, 2003.
[ASZZ22] Mohammad Ansari, Mohammad Saneian, and Hamid Zarr abi-Zadeh. Simple Streaming Algorithms
for Edge Coloring. In Shiri Chechik, Gonzalo Navarro, Eva Ro tenberg, and Grzegorz Herman, editors,
30th Annual European Symposium on Algorithms (ESA 2022) , volume 244 of Leibniz International Pro-
ceedings in Informatics (LIPIcs) , pages 8:1–8:4, Dagstuhl, Germany, 2022. Schloss Dagstuhl – Leibniz-
Zentrum für Informatik.
[BDH+19] Soheil Behnezhad, Mahsa Derakhshan, MohammadTaghi Haj iaghayi, Marina Knittel, and Hamed
Saleh. Streaming and massively parallel algorithms for edg e coloring. In 27th Annual European Sym-
posium on Algorithms, ESA 2019, September 9-11, 2019, Munic h/Garching, Germany , volume 144 of
LIPIcs , pages 15:1–15:14. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2019.
[BGW21] Sayan Bhattacharya, Fabrizio Grandoni, and David W ajc. Online edge coloring algorithms via the
nibble method. In Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algo rithms, SODA 2021,
Virtual Conference, January 10 - 13, 2021 , pages 2830–2842. SIAM, 2021.
[BJWY20] Omri Ben-Eliezer, Rajesh Jayaram, David P . Woodru ff, and Eylon Yogev. A framework for adversarially
robust streaming algorithms. In Proc. 39th ACM Symposium on Principles of Database Systems , page
63–80, 2020.
[BMM12] Bahman Bahmani, Aranyak Mehta, and Rajeev Motwani. Online graph edge-coloring in the random-
order arrival model. Theory of Computing , 8(1):567–595, 2012.
[BMN92] Amotz Bar-Noy, Rajeev Motwani, and Joseph Naor. The greedy algorithm is optimal for on-line edge
coloring. Information Processing Letters , 44(5):251–253, 1992.
[BS23] Soheil Behnezhad and Mohammad Saneian. Streaming ed ge coloring with asymptotically optimal
colors. arXiv preprint arXiv:2305.01714 , 2023.
[CL21] Moses Charikar and Paul Liu. Improved algorithms for edge colouring in the W-streaming model.
In4th Symposium on Simplicity in Algorithms, SOSA 2021, Virtu al Conference, January 11-12, 2021 ,
pages 181–183. SIAM, 2021.
[CMZ23] Shiri Chechik, Doron Mukhtar, and Tianyi Zhang. Str eaming edge coloring with subquadratic palette
size. arXiv preprint arXiv:2305.07090 , 2023.
[CPW19] Ilan Reuven Cohen, Binghui Peng, and David Wajc. Tig ht bounds for online edge coloring. In 60th
IEEE Annual Symposium on Foundations of Computer Science, F OCS 2019, Baltimore, Maryland, USA,
November 9-12, 2019 , pages 1–25. IEEE Computer Society, 2019.
[Czu15] Artur Czumaj. Random permutations using switching networks. In Proc. 47th Annual ACM Sympo-
sium on the Theory of Computing , pages 703–712, 2015.
[DEMR10] Camil Demetrescu, Bruno Escofﬁer, Gabriel Moruz, and Andrea Ribichini. Adapting parallel algo-
rithms to the w-stream model, with applications to graph pro blems. Theoretical Computer Science ,
411(44):3994–4004, 2010.
[DFR06] Camil Demetrescu, Irene Finocchi, and Andrea Ribic hini. Trading off space for passes in graph stream-
ing problems. In Proceedings of the Seventeenth Annual ACM-SIAM Symposium o n Discrete Algorithms,
SODA 2006 , pages 714–723. ACM Press, 2006.
34[EFKM10] Martin R. Ehmsen, Lene M. Favrholdt, Jens S. Kohrt, and Rodica Mihai. Comparing ﬁrst-ﬁt and next-ﬁt
for online edge coloring. Theor . Comput. Sci. , 411(16-18):1734–1741, 2010.
[EJ01] Thomas Erlebach and Klaus Jansen. The complexity of p ath coloring and call scheduling. Theoretical
Computer Science , 255(1):33–50, 2001.
[FM18] Lene M. Favrholdt and Jesper W. Mikkelsen. Online edg e coloring of paths and trees with a ﬁxed
number of colors. Acta Informatica , 55(1):57–80, 2018.
[FN03] Lene M. Favrholdt and Morten N. Nielsen. On-line edge -coloring with a ﬁxed number of colors. Algo-
rithmica , 35(2):176–191, 2003.
[GDP05] S. Gandham, M. Dawande, and R. Prakash. Link schedul ing in sensor networks: distributed edge
coloring revisited. In Proceedings IEEE 24th Annual Joint Conference of the IEEE Co mputer and Com-
munications Societies. , volume 4, pages 2492–2501 vol. 4, 2005.
[GSS22] Christian Glazik, Jan Schiemann, and Anand Srivast av. A one pass streaming algorithm for ﬁnding
euler tours. Theory of Computing Systems , pages 1–23, 12 2022.
[Hol81] Ian Holyer. The np-completeness of edge-coloring. SIAM Journal on Computing , 10(4):718–720, 1981.
[JP83] Kumar Joag-Dev and Frank Proschan. Negative associa tion of random variables, with applications.
Ann. Stat. , 11(1):286–295, 1983.
[JURdW16] Tiago Januario, Sebastián Urrutia, Celso C. Ribe iro, and Dominique de. Werra. Edge coloring: A natural
model for sports scheduling. European Journal of Operational Research , 254(1):1–8, 2016.
[KLS+22] Janardhan Kulkarni, Yang P . Liu, Ashwin Sah, Mehtaab Saw hney, and Jakub Tarnawski. Online edge
coloring via tree recurrences and correlation decay. In STOC ’22: 54th Annual ACM SIGACT Symposium
on Theory of Computing, Rome, Italy, June 20 - 24, 2022 , pages 104–116. ACM, 2022.
[LS11] Luigi Laura and Federico Santaroni. Computing stron gly connected components in the streaming
model. In Alberto Marchetti-Spaccamela and Michael Segal, editors, Theory and Practice of Algorithms
in (Computer) Systems , pages 193–205. Springer Berlin Heidelberg, 2011.
[MG92] Jayadev Misra and David Gries. A constructive proof o f vizing’s theorem. Information Processing Let-
ters, 41(3):131–133, 1992.
[Mik15] Jesper W. Mikkelsen. Optimal online edge coloring o f planar graphs with advice. In Algorithms and
Complexity - 9th International Conference, CIAC 2015, Pari s, France, May 20-22, 2015. Proceedings ,
volume 9079 of Lecture Notes in Computer Science , pages 352–364. Springer, 2015.
[Mik16] Jesper W. Mikkelsen. Randomization can be as helpfu l as a glimpse of the future in online computa-
tion. In 43rd International Colloquium on Automata, Languages, and Programming, ICALP 2016, July
11-15, 2016, Rome, Italy , volume 55 of LIPIcs , pages 39:1–39:14. Schloss Dagstuhl - Leibniz-Zentrum
für Informatik, 2016.
[Mor13] Ben Morris. Improved mixing time bounds for the thor p shufﬂe. Combinatorics, Probability and
Computing , 22(1):118–132, 2013.
[NSW23] Joseph Naor, Aravind Srinivasan, and David Wajc. On line dependent rounding schemes. CoRR ,
abs/2301.08680, 2023.
[RU94] Prabhakar Raghavan and Eli Upfal. Efﬁcient routing i n all-optical networks. In Proceedings of the
twenty-sixth annual ACM symposium on Theory of computing (S TOC) , pages 134–143, 1994.
[Sha49] Claude E. Shannon. A theorem on coloring the lines of a network. Journal of Mathematics and Physics ,
28(1-4):148–152, 1949.
[SS96] Michael Sipser and Daniel A. Spielman. Expander code s.IEEE Transactions on Information Theory ,
42(6):1710–1722, 1996.
35[SW21] Amin Saberi and David Wajc. The greedy algorithm is no t optimal for on-line edge coloring. In 48th
International Colloquium on Automata, Languages, and Prog ramming, ICALP 2021, July 12-16, 2021,
Glasgow, Scotland (Virtual Conference) , volume 198 of LIPIcs , pages 109:1–109:18. Schloss Dagstuhl -
Leibniz-Zentrum für Informatik, 2021.
[Viz64] V . G. Vizing. On an estimate of the chromatic class of a p-graph. Discret Analiz , 3:25–30, 1964.
[WC81] Mark N. Wegman and Larry Carter. New hash functions an d their use in authentication and set equal-
ity.J. Comput. Syst. Sci. , 22(3):265–279, 1981.
36
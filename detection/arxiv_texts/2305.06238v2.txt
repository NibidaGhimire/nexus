Designing Asynchronous Multiparty Protocols
with Crash-Stop Failures
Adam D. Barwell /envelope
University of St. Andrews and University of Oxford, UK
Ping Hou /envelope
University of Oxford, UK
Nobuko Yoshida /envelope
University of Oxford, UK
Fangyi Zhou /envelope
Imperial College London and University of Oxford, UK
Abstract
Session types provide a typing discipline for message-passing systems. However, most session type
approaches assume an ideal world: one in which everything is reliable and without failures. Yet
this is in stark contrast with distributed systems in the real world. To address this limitation, we
introduce Teatrino , a code generation toolchain that utilises asynchronous multiparty session types
(MPST) with crash-stop semantics to support failure handling protocols.
We augment asynchronous MPST and processes with crash handling branches. Our approach
requires no user-level syntax extensions for global types and features a formalisation of global
semantics, which captures complex behaviours induced by crashed/crash handling processes. The
sound and complete correspondence between global and local type semantics guarantees deadlock-
freedom, protocol conformance, and liveness of typed processes in the presence of crashes.
Our theory is implemented in the toolchain Teatrino , which provides correctness by construction .
Teatrino extends the Scribble multiparty protocol language to generate protocol-conforming
Scalacode, using the Effpiconcurrent programming library. We extend both Scribble andEffpi
to support crash-stop behaviour. We demonstrate the feasibility of our methodology and evaluate
Teatrino with examples extended from both session type and distributed systems literature.
2012 ACM Subject Classiﬁcation Software and its engineering →Source code generation; Software
and its engineering →Concurrent programming languages; Theory of computation →Process calculi;
Theory of computation →Distributed computing models
Keywords and phrases Session Types, Concurrency, Failure Handling, Code Generation, Scala
Supplementary Material ECOOP 2023 Artifact Evaluation approved artifact, also available at
https://github.com/adbarwell/ECOOP23-Artefact
Funding Worksupportedby: EPSRCEP/T006544/2, EP/K011715/1, EP/K034413/1,EP/L00058X/1,
EP/N027833/2, EP/N028201/1, EP/T014709/2, EP/V000462/1, EP/X015955/1, NCSS/EPSRC
VeTSS, and Horizon EU TaRDIS 101093006.
Acknowledgements We thank the anonymous reviewers for their useful comments and suggestions.
We thank Jia Qing Lim for his contribution to the Effpiextension. We thank Alceste Scalas for
useful discussions and advice in the development of this paper and for his assistance with Effpi.
1 Introduction
Background As distributed programming grows increasingly prevalent, signiﬁcant research
eﬀort has been devoted to improve the reliability of distributed systems. A key aspect of
this research focuses on studying unreliability (or, more speciﬁcally, failures). ModellingarXiv:2305.06238v2  [cs.PL]  15 May 20232 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
unreliability and failures enables a distributed system to be designed to be more tolerant of
failures, and thus more resilient.
In pursuit of methods to achieve safety in distributed communication systems, session
types[18] provide a lightweight, type system–based approach to message-passing concurrency.
Inparticular, Multiparty Session Types (MPST)[19]facilitatethespeciﬁcationandveriﬁcation
of communication between message-passing processes in concurrent and distributed systems.
The typing discipline prevents common communication-based errors, e.g. deadlocks and
communication mismatches [20,38]. On the practical side, MPST have been implemented in
various mainstream programming languages [6,9,10,21,24,25,28,30], which facilitates their
applications in real-world programs.
Nevertheless, the challenge to account for unreliability and failures persists for session
types: most session type systems assume that both participants and message transmissions
arereliablewithout failures. In a real-world setting, however, participants may crash,
communications channels may fail, and messages may be lost. The lack of failure modelling in
session type theories creates a barrier to their applications to large-scale distributed systems.
Recent works [2,26,27,33,43] close the gap of failure modelling in session types with
various techniques. [43] introduces failure suspicion , where a participant may suspect their
communication partner has failed, and act accordingly. [33] introduces reliability annotations
at type level, and fall back to a given defaultvalue in case of failures. [26] proposes a
framework of aﬃnemultiparty session types, where a session can terminate prematurely, e.g.
in case of failures. [2] integrates crash-stop failures , where a generalised type system validates
safety and liveness properties with model checking; [27] takes a similar approach, modelling
more kinds of failures in a session type system, e.g. message losses, reordering, and delays.
While steady advancements are made on the theoretical side, the implementations of those
enhanced session type theories seem to lag behind. Barring the approaches in [26,43], the
aforementionedapproaches[2,27,33]donotprovidesessiontypeAPIsupportforprogramming
languages.1To bring the beneﬁts of the theoretical developments into real-world distributed
programming, a gap remains to be ﬁlled on the implementation side.
This Paper We introduce a top-down methodology for designing asynchronous multiparty
protocols with crash-stop failures: (1)We use an extended asynchronous MPST theory,
which models crash-stop failures, and show that the usual session type guarantees remain
valid, i.e. communication safety, deadlock-freedom, and liveness; (2)We present a toolchain
for implementing asynchronous multiparty protocols, under our new asynchronous MPST
theory, in Scala, using the Effpiconcurrency library [40].
The top-down design methodology comes from the original MPST theory [19], where the
design of multiparty protocols begins with a given globaltype (top), and implementations rely
onlocaltypes (bottom) obtained from the global type. The global and local types reﬂect the
global and local communication behaviours respectively. Well-typed implementations that
conform to a global type are guaranteed to be correct by construction , enjoying full guarantees
(safety, deadlock-freedom, liveness) from the theory. This remains the predominant approach
for implementing MPST theories, and is also followed by some aforementioned systems [26,43].
We model crash-stop failures [5, §2.2], i.e. a process may fail arbitrarily and cease to
interact with others. This model is simple and expressive, and has been adopted by other
approaches [2,27]. Using global types in our design for handling failures in multiparty
1[2] provides a prototype implementation, utilising the mCRL2 model checker [4], for verifying type-level
properties, instead of a library for general use.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 3
protocols presents two distinct advantages: (1)global types provide a simple, high-level
means to both specify a protocol abstractly and automatically derive local types; and,
(2)desirable behavioural properties such as communication safety, deadlock-freedom, and
liveness are guaranteed by construction. In contrast to the synchronous semantics in [2], we
model an asynchronous semantics, where messages are buﬀered whilst in transit. We focus on
asynchronous systems since most communication in the real distributed world is asynchronous.
In [27], although the authors develop a generic typing system incorporating asynchronous
semantics, their approach results in the type-level properties becoming undecidable [27, §4.4].
With global types, we restore the decidability at a minor cost to expressivity.
To address the gap on the practical side, we present a code generator toolchain, Teatrino ,
to implement our MPST theory. Our toolchain takes an asynchronous multiparty protocol
as input, using the protocol description language Scribble [44], and generates Scalacode
using the Effpi[40] concurrency library as output.
TheScribble Language [44] is designed for describing multiparty communication proto-
cols, andiscloselyconnectedtoMPSTtheory(cf.[31]). Thislanguageenablesaprogrammatic
approach for expressing global types and designing multiparty protocols. The Effpicon-
currency library [40] oﬀers an embedded Domain Speciﬁc Language (DSL) that provides
a simple actor-based API. The library oﬀers both type-level and value-level constructs for
processes and channels. Notably, the type-level constructs reﬂect the behaviour of programs
(i.e. processes) and can be used as speciﬁcations. Our code generation technique, as well as
theEffpilibrary itself, utilises the type system features introduced in Scala3, including
match types and dependent function types, to encode local types in Effpi. This approach
enables us to specify and verify program behaviour at the type level, resulting in a more
powerful and ﬂexible method for handling concurrency.
By extending Scribble andEffpito support crash detection and handling , our toolchain
Teatrino provides a lightweight way for developers to take advantage of our theory, bridging
the gap on the practical side. We evaluate the expressivity and feasibility of Teatrino with
examples incorporating crash handling behaviour, extended from session type literature.
Outline Webeginwithanoverviewofourmethodologyin§2. Weintroduceanasynchronous
multiparty session calculus in §3 with semantics of crashing and crash handling. We introduce
an extended theory of asynchronous multiparty session types with semantic modelling of
crash-stop failures in §4. We present a typing system for the multiparty session calculus
in §5. We introduce Teatrino , a code generation toolchain that implements our theory
in §6, demonstrating how our approach is applied in the Scalaprogramming language.
We evaluate our toolchain with examples from both session type and distributed systems
literature in §7. We discuss related work in §8 and conclude in §9. Full proofs, further
deﬁnitions, examples, and more technical details of Teatrino can be found in Appendix.
Additionally, our toolchain and examples used in our evaluation are available in an artifact,
which can be accessed on Zenodo. For those interested in the source ﬁles, they are available
on GitHub.
2 Overview
In this section, we give an overview of our methodology for designing asynchronous multiparty
protocols with crash-stop failures, and demonstrate our code generation toolchain, Teatrino .4 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
A Global Type Gwith crash
projection ()
Local Type for LTLLocal Type for Iwith crashTILocal Type for CTC
typing(/turnstileleft)
Process for LPLProcess for Iwith crashPIProcess for CPC
Figure 1 Top-down View of MPST with Crash
Asynchronous Multiparty Protocols with Crash-Stop Failures We follow a standard top-
down design approach enabling correctness by construction , but enrich asynchronous MPST
with crash-stop semantics. As depicted in Fig. 1, we formalise (asynchronous) multiparty
protocols with crash-stop failures as global types with crash handling branches (crash). These
are projected into local types, which may similarly contain crash handling branches ( crash).
The projected local types are then used to type-check processes (also with crash handling
branches ( crash)) that are written in a session calculus. As an example, we consider a
simpledistributed logging scenario, which is inspired by the logging-management protocol [26],
but extended with a third participant. The full distributed logging protocol can be found
in Appendix §H.
The Simpler Logging protocol consists of a logger(L) that controls the logging services,
aninterface (I) that provides communications between logger and client, and a client(C)
that requires logging services via interface. Initially, Lsends a heartbeat message trigger
toI. Then Csends a command to Lto read the logs ( read). When a readrequest is sent, it
is forwarded to L, and Lresponds with a report, which is then forwarded onto C. Assuming
all participants (logger, interface, and client) are reliable, i.e. without any failures or crashes,
this logging behaviour can be represented by the global typeG0:
G0=L→I:trigger.C→I:read.I→L:read.L→I:report (log).I→C:report (log).end (1)
Here,G0is a speciﬁcation of the Simpler Logging protocol between multiple roles from a
global perspective.
In the real distributed world, all participants in the Simpler Logging system may fail.
Ergo, we need to model protocols with failures or crashes and handling behaviour, e.g. should
the client fail after the logging has started, the interface will inform the logger to stop and
exit. We follow [5, §2.2] to model a crash-stop semantics, where we assume that roles can
crashat any time unless assumed reliable(never crash). For simplicity, we assume Iand
Lto be reliable. The above logging behaviour, incorporating crash-stop failures, can be
represented by extending G0with a branch handling a crash of C:
G=L→I:trigger.C→I:/braceleftbigg
read.I→L:read.L→I:report (log).I→C:report (log).end
crash.I→L:fatal.end/bracerightbigg
(2)
We model crash detection on receiving roles: when Iis waiting to receive a message from C,
the receiving role Iis able to detect whether Chascrashed. Since crashes are detected only
by the receiving role, we do not require a crash handling branch on the communication step
between IandC– nor do we require them on any interaction between LandI(since we are
assuming that LandIare reliable).
Following the MPST top-down methodology, a global type is then projected ontolocal
types, which describe communications from the perspective of a single role. In our unreliable
Simpler Logging example, Gis projected onto three local types (one for each role C,L,I):A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 5
Figure 2 Workﬂow of Teatrino
TC=I⊕read.I&report (log).endTL=I⊕trigger.I&/braceleftbigg
read.I⊕report (log).end
fatal.end/bracerightbigg
TI=L&trigger.C&/braceleftbigg
read.L⊕read.L&report (log).C⊕report (log).end
crash.L⊕fatal.end/bracerightbigg
Here,TIstates that Iﬁrst receives a trigger message from L; then Ieither expects a read
request from C, or detects the crash of Cand handles it (in crash) by sending the fatal
message to notify L. We add additional crash modelling and introduce a stoptype for crashed
endpoints. We show the operational correspondence between global and local type semantics,
and demonstrate that a projectable global type always produces a safe, deadlock-free, and
live typing context.
The next step in this top-down methodology is to use local types to type-check processes
Piexecuted by role piin our session calculus. For example, TIcan be used to type check I
that executes the process:
L?trigger./summationtext/braceleftbigg
C?read.L!read.L?report (x).C!report/angbracketleftx/angbracketright.0
C?crash.L!fatal.0/bracerightbigg
In our operational semantics (§3), we allow active processes executed by unreliable roles
to crash arbitrarily . Therefore, the role executing the crashed process also crashes, and is
assigned the local type stop. To ensure that a communicating process is type-safe even in
presence of crashes, we require that its typing context satisﬁes a safety property accounting for
possible crashes (Def. 14), which is preserved by projection. Additional semantics surrounding
crashes adds subtleties even in standard results. We prove subject reduction and session
ﬁdelity results accounting for crashes and sets of reliable roles.
Code Generation Toolchain: Teatrino To complement the theory, we present a code
generation toolchain, Teatrino , that generates protocol-conforming Scalacode from a mul-
tiparty protocol. We show the workﬂow diagram of our toolchain in Fig. 2. Teatrino takes
aScribble protocol ( Protocol.scr ) and generates executable code ( Protocol.scala ) conforming
to that protocol, which the programmer can integrate with existing code ( Final.scala ).
Teatrino implements our session type theory to handle global types expressed using
theScribble protocol description language [44], a programmer-friendly way for describing
multiparty protocols. We extend the syntax of Scribble slightly to include constructs for
crashrecovery branches and reliable roles.
The generated Scalacode utilises the Effpiconcurrency library [40]. Effpiis an
embedded domain speciﬁc language in Scala3 that oﬀers a simple Actor-based API for
concurrency. Our code generation technique, as well the Effpilibrary itself, leverages the
type system features introduced in Scala3, e.g. match types and dependent function types,
to encode local types in Effpi. We extend Effpito support crash detection and handling.
As a brief introduction to Effpi, the concurrency library provides types for processes
and channels. For processes, an output process type Out[A, B] describes a process that
uses a channel of type Ato send a value of type B, and an input process type In[A, B, C]
describes a process that uses a channel of type Ato receive a value of type B, and pass it
to a continuation type C. Process types can be sequentially composed by the >>:operator.6 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
For channels, Chan[X] describes a channel that can be used communicate values of type X.
More speciﬁcally, the usage of a channel can be reﬂected at the type level, using the types
InChan[X] /OutChan[X] for input/output channels.
1type I[C0 <: InChan[Trigger], C1 <: OutChan[Fatal],
2 C2 <: InChan[Read], C3 <: InChan[Report], C4 <: OutChan[Report]]
3= InErr[C0, Trigger,
4 (X <: Read) =>
5 Out[C3,Read] >>: In[C4, Report, (Y <: Log) => Out[C5, Report]],
6 (Err <: Throwable) => Out[C2,Fatal]
7 ]
Figure 3 EffpiType forTI
As a sneak peek of the code we generate, in Fig. 3, we show the generated Effpi
representation for the projected local type TIfrom the Simpler Logging example. Readers
may be surprised by the diﬀerence between TIand the generated Effpitype I. This is
because the process types need their respective channel types, namely the type variables
C0,C1,etc.bounded by InChan[...] and OutChan[...] . We explain the details of code
generation in §6.2, and describe an interesting challenge posed by the channel generation
procedure in §6.3.
For crash handling behaviour, we introduce a new type InErr, whose last argument
speciﬁes a continuation type to follow in case of a crash. Line 3 in Fig. 3 shows the crash
handling behaviour: sending a message of type Fatal, which reﬂects the crashbranch in the
local typeTI. We give more details of the generated code in §6.2.
Code generated by Teatrino is executable, protocol-conforming, and can be specialised
by the programmer to integrate with existing code. We evaluate our toolchain on examples
taken from both MPST and distributed programming literature in §7. Moreover, we extend
each example with crash handling behaviour to deﬁne unreliable variants. We demonstrate
that, with Teatrino , code generation takes negligible time, and all potential crashes are
accompanied with crash handlers.
3 Crash-Stop Asynchronous Multiparty Session Calculus
In this section, we formalise the syntax and operational semantics of our asynchronous
multiparty session calculus with process failures and crash detection.
Syntax Our asynchronous multiparty session calculus models processes that may crash
arbitrarily. Our formalisation is based on [15] – but in addition, follows the fail-stop model
in [5, §2.7], where processes may crash and never recover, and process failures can be detected
by failure detectors [5, §2.6.2] [7] when attempting to receive messages.
We give the syntax of processes in Fig. 4. In our calculus, we assume that there are basic
expressions e(e.g. true,false,7 + 11) that are assigned basic types B(e.g. int,bool). We
writee↓vto denote an expression eevaluates to a value v(e.g. (7<11)↓true,(1 + 1)↓2).
A process, ranged over by P,Q, is a communication agent within a session. An output
process p!m/angbracketlefte/angbracketright.Psends a message to another role pin the session, where the message is
labelled m, and carries a payload expresion e, then the process continues as P. Anexternal
choice(input) process/summationtext
i∈Ip?mi(xi).Pireceives a message from another role pin the session,
among a ﬁnite set of indexes I, if the message is labelled mi, then the payload would be
received as xi, and process continues as Pi. Note that our calculus uses crashas a specialA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 7
P,Q ::= Processes/summationtext
i∈Ip?mi(xi).Pi external choice/vextendsingle/vextendsinglep!m/angbracketlefte/angbracketright.P(where m/negationslash=crash)output/vextendsingle/vextendsingleifethenPelseQ conditional/vextendsingle/vextendsingleX variable/vextendsingle/vextendsingleµX.P recursion/vextendsingle/vextendsingle0 inaction/vextendsingle/vextendsingle crashedM::= Sessions
p/triangleleftP|p/trianglelefthparticipant/vextendsingle/vextendsingleM|M parallel
h::= Queues
/epsilon1 empty/vextendsingle/vextendsingle/circledivide unavailable/vextendsingle/vextendsingle(p,m(v))message/vextendsingle/vextendsingleh·h concatenation
Figure 4 Syntax of sessions, processes, and queues. Noticeable changes w.r.t. standard session
calculus [15] are highlighted.
message label denoting that a participant (role) has crashed. Such a label cannot be sent
by any process, but a process can implement crash detection and handling by receiving it.
Consequently, an output process cannotsend a crashmessage (side condition m/negationslash=crash),
whereas an input process may include a crash handling branch of the form crash.P/primemeaning
thatP/primeis executed when the sending role has crashed. A conditional process ifethenPelseQ
continues as either PorQdepending on the evaluation of e. We allow recursion at the
process level using µX.PandX, and we require process recursion variables to be guarded
by an input or an output action; we consider a recursion process structurally congruent to
its unfolding µX.P≡P{µX.P/X}. Finally, we write 0for aninactiveprocess, representing a
successful termination; and  for acrashedprocess, representing a termination due to failure.
Anincoming queue2, ranged over by h,h/prime, is a sequence of messages tagged with their
origin. We write /epsilon1for anemptyqueue;/circledividefor anunavailable queue; and (p,m(v))for a
message sent from p, labelled m, and containing a payload value v. We write h1·h2to
denote the concatenation of two queues h1andh2. When describing incoming queues, we
consider two messages from diﬀerent origins as swappable: h1·(q1,m1(v1))·(q2,m2(v2))·h2≡
h1·(q2,m2(v2))·(q1,m1(v1))·h2whenever q1/negationslash=q2. Moreover, we consider concatenation (·)
as associative, and the empty queue /epsilon1as the identity element for concatenation.
A session, ranged over by M,M/prime, consists of processes and their respective incoming
queue, indexed by their roles. A single entry for a role pis denoted p/triangleleftP|p/trianglelefth, wherePis
the process for pandhis the incoming queue. Entries are composed together in parallel
asM|M/prime, where the roles in MandM/primeare disjoint. We consider parallel composition as
commutative and associative, with p/triangleleft0|p/triangleleft/epsilon1as a neutral element of the operator. We write/producttext
i∈I(pi/triangleleftPi|pi/trianglelefthi)for the parallel composition of multiple entries in a set.
Operational Semantics of our session calculus is given in Def. 1, using a standard structural
congruence≡deﬁned in [15]. Standard congruence rules can be found in Appendix §A. Our
semantics parameterises on a (possibly empty) set of reliablerolesR, which are assumed to
never crash .
IDeﬁnition 1 (Session Reductions) .Session reduction →Ris inductively deﬁned by the rules
in Fig. 5, parameterised by a ﬁxed set Rof reliable roles. We write →whenRis insigniﬁcant.
We write→R∗(resp.→∗) for the reﬂexive and transitive closure of →R(resp.→).
2In [15], the queues are outgoing instead of incoming. We use incoming queues to model our crashing
semantics more easily.8 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
[r- ] p/triangleleftP|p/trianglelefth p|M → Rp/triangleleft |p/triangleleft/circledivide|M (P/negationslash=0,p/∈R)
[r-send] p/triangleleftq!m/angbracketlefte/angbracketright.P|p/trianglelefth p|q/triangleleftQ|q/trianglelefth q|M
→p/triangleleftP|p/trianglelefth p|q/triangleleftQ|q/trianglelefth q·(p,m(v))|M (e↓v,h q/negationslash=/circledivide)
[r-send- ]p/triangleleftq!m/angbracketlefte/angbracketright.P|p/trianglelefth p|q/triangleleft |q/triangleleft/circledivide|M → p/triangleleftP|p/trianglelefth p|q/triangleleft |q/triangleleft/circledivide|M
[r-rcv] p/triangleleft/summationtext
i∈Iq?mi(xi).Pi|p/triangleleft(q,mk(v))·hp|M→ p/triangleleftPk{v/xk}|p/trianglelefth p|M (k∈I)
[r-rcv-⊙]p/triangleleft/summationtext
i∈Iq?mi(xi).Pi|p/trianglelefth p|q/triangleleft |q/triangleleft/circledivide|M
→p/triangleleftPk|p/trianglelefth p|q/triangleleft |q/triangleleft/circledivide|M (k∈I,mk=crash,@m,v: (q,m(v))∈hp)
[r-cond-T] p/triangleleftifethenPelseQ|p/trianglelefth|M → p/triangleleftP|p/trianglelefth|M (e↓true )
[r-cond-F] p/triangleleftifethenPelseQ|p/trianglelefth|M → p/triangleleftQ|p/trianglelefth|M (e↓false )
[r-struct]M1≡M/prime
1andM/prime
1→M/prime
2andM/prime
2≡M 2=⇒ M 1→M 2
Figure 5 Reduction relation on sessions with crash-stop failures.
Our operational semantics retains the basic rules in [15], but also includes ( highlighted )
rules for crash-stop failures and crash handling, adapted from [2]. Rules [r-send]and [r-rcv]
model ordinary message delivery and reception: an output process located at psending to q
appends a message to the incoming queue of q; and an input process located at preceiving
from qconsumes the ﬁrst message from the incoming queue. Rules [r-cond-T] and [r-cond-F]
model conditionals; and rule [r-struct] permits reductions up to structural congruence.
With regard to crashes and related behaviour, rule [r- ]models process crashes: an active
(P/negationslash=0) process located at an unreliable role ( p/∈R) may reduce to a crashed process p/triangleleft ,
with its incoming queue becoming unavailable p/triangleleft/circledivide. Rule [r-send- ]models a message delivery
to a crashed role (and thus an unavailable queue), and the message becomes lost and would
not be added to the queue. Rule [r-rcv-⊙]models crash detection, which activates as a “last
resort”: an input process at preceiving from qwould ﬁrst attempt ﬁnd a message from qin
the incoming queue, which engages the usual rule [r-recv]; if none exists and qhas crashed
(q/triangleleft ), then the crash handling branch in the input process at pcan activate. We draw
attention to the interesting fact that [r-recv]may engage even if qhas crashed, in cases where
a message from qin the incoming queue may be consumed. We now illustrate our operational
semantics of sessions with an example. More examples can be found in Appendix §C.
IExample2. Considerthesession M=p/triangleleftP|p/triangleleft/epsilon1|q/triangleleftQ|q/triangleleft/epsilon1,whereP=q!m/angbracketleft“abc”/angbracketright./summationtext/braceleftbigg
q?m/prime(x).0
q?crash.0/bracerightbigg
andQ=/summationtext/braceleftbigg
p?m(x).p!m/prime/angbracketleft42/angbracketright.0
p?crash.0/bracerightbigg
.In this session, the process Qforqreceives a message sent
from ptoq; the process Pforpsends a message from ptoq, and then receives a message
sent from qtop. Let each role be unreliable, i.e. R=∅, andPcrash before sending. We
haveM→∅p/triangleleft |p/triangleleft/circledivide|q/triangleleftQ|q/triangleleft/epsilon1→p/triangleleft |p/triangleleft/circledivide|q/triangleleft0|q/triangleleft/epsilon1. We observe that when the
output process Plocated at an unreliable role pcrashes (by [r- ]), the resulting entry for pis
a crashed process ( p/triangleleft ) with an unavailable queue ( p/triangleleft/circledivide). Subsequently, the input process
Qlocated at qcan detect and handle the crash by [r-rcv-⊙]via its crashhandling branch.
4 Asynchronous Multiparty Session Types with Crash-Stop Semantics
In this section, we present our asynchronous multiparty session types with crash-stop
semantics. We give an overview of global and local types with crashes in §4.1, including
syntax, projection, subtyping, etc.; our key additions to the classic theory are crash handling
branches in both global and local types, and a special local type stopto denote crashedA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 9
B::= int/vextendsingle/vextendsinglebool/vextendsingle/vextendsinglereal/vextendsingle/vextendsingleunit/vextendsingle/vextendsingle... Basic types
G::=p→q†:{mi(Bi).Gi}i∈I Transmission/vextendsingle/vextendsinglep† q:j{mi(Bi).Gi}i∈I(j∈I) Transmission en route/vextendsingle/vextendsingleµt.G/vextendsingle/vextendsinglet/vextendsingle/vextendsingleend Recursion, Type variable, Termination
†::=·/vextendsingle/vextendsingle Crash annotation
S,T ::=p&{mi(Bi).Ti}i∈I/vextendsingle/vextendsinglep⊕{mi(Bi).Ti}i∈IExternal choice, Internal choice/vextendsingle/vextendsingleµt.T/vextendsingle/vextendsinglet/vextendsingle/vextendsingleend/vextendsingle/vextendsinglestop Recursion, Type variable, Termination, Crash
Figure 6 Syntax of global types and local types. Runtime types are shaded.
processes. We give a Labelled Transition System (LTS) semantics to both global types (§4.2)
and conﬁgurations (i.e. a collection of local types and point-to-point communication queues,
§4.3). We discuss alternative design options of modelling crash-stop failures in §4.4. We
relate the two semantics in §4.5, and show that a conﬁguration obtained via projection is
safe, deadlock-free, and live in §4.6.
4.1 Global and Local Types with Crash-Stop Failures
The top-down methodology begins with global types to provide an overview of the communic-
ation between a number of roles(p,q,s,t,...), belonging to a (ﬁxed) set R. At the other
end, we use local types to describe how a singlerole communicates with other roles from
a local perspective, and they are obtained via projection from a global type. We give the
syntax of both global and local types in Fig. 6, which are similar to syntax used in [2,38].
Global Types are ranged over G,G/prime,Gi,..., and describe the behaviour for all roles from
a bird’s eye view. The syntax shown in shadeareruntime syntax, which are not used for
describing a system at design-time, but for describing the state of a system during execution.
The labels mare taken from a ﬁxed set of all labels M, and basic types B(types for payloads)
from a ﬁxed set of all basic types B.
We explain each construct in the syntax of global types: a transmission, denoted
p→q†:{mi(Bi).Gi}i∈I, represents a message from role pto role q(with possible crash
annotations), with labels mi, payload types Bi, and continuations Gi, whereiis taken from
an index set I. We require that the index set be non-empty ( I/negationslash=∅), labels mibe pair-wise
distinct, and self receptions be excluded (i.e. p/negationslash=q), as standard in session type works.
Additionally, we require that the special crashlabel (explained later) not be the only label in
a transmission, i.e. {mi|i∈I}/negationslash={crash}. A transmission en route p† q:j{mi(Bi).Gi}i∈Iis
a runtime construct representing a message mj(indexj) sent by p, and yet to be received
byq. Recursive types are represented via µt.Gandt, where contractive requirements
apply [34, §21.8]. The type enddescribes a terminated type (omitted where unambiguous).
To model crashes and crash handling, we use crash annotations  and crash handling
branches: a crash annotation  , a new addition in this work, marks a crashedrole (only
used in the runtime syntax ), and we omit annotations for live roles, i.e. pis a live role, p is
a crashed role, and p†represents a possibly crashed role, namely either porp . We use a
special label crashfor handling crashes: this continuation denotes the protocol to follow when
the sender of a message is detected to have crashed by the receiver. The special label acts as
a ‘pseudo-message’: when a sender role crashes, the receiver can select the pseudo-message to
enter crash handling. We write roles(G)(resp. roles (G)) for the set of active(resp.crashed)10 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
roles in a global type G,excluding (resp. consisting onlyof) those with a crash annotation  .
Local Types are ranged over S,T,U,... , and describe the behaviour of a single role. An
internal choice (selection) (resp. an external choice (branching)), denoted p⊕{mi(Bi).Ti}i∈I
(resp. p&{mi(Bi).Ti}i∈I) indicates that the currentrole is to sendto (resp. receivefrom) the
rolep. Similarly to global types, we require pairwise-distinct, non-empty labels. Moreover,
we require that the crashlabel not appear in internal choices, reﬂecting that a crashpseudo-
message can never be sent; and that singleton crashlabels not permitted in external choices.
The type endindicates a successful termination (omitted where unambiguous), and recursive
types follow a similar fashion to global types. We use a new runtime type stopto denote
crashes.
Subtyping relation6on local types will be used in §4.5 to relate global and local type
semantics. Our subtyping relation is mostly standard [38, Def. 2.5], except for an extra rule
forstopand additional requirements to support crash handling branch in external choices.
The deﬁnition of 6can be found in Appendix §B.
Projection gives the local type of a participating role in a global type, deﬁned as a partial
function that takes a global type Gand a role p, and returns a local type, given by Def. 3.
IDeﬁnition 3 (Global Type Projection) .Theprojection of a global type Gonto a role p,
with respect to a set of reliablerolesR, writtenGRp, is:
/parenleftbig
q→r†:{mi(Bi).Gi}i∈I/parenrightbig
Rp=

r⊕{mi(Bi).(GiRp)}i∈{j∈I|mj/negationslash=crash}ifp=q
q&{mi(Bi).(GiRp)}i∈Iifp=r,and q/∈Rimplies
∃k∈I:mk=crashd
i∈IGiRp ifp/negationslash=q,and p/negationslash=r
/parenleftbig
q† r:j{mi(Bi).Gi}i∈I/parenrightbig
Rp=

GjRp ifp=q
q&{mi(Bi).(GiRp)}i∈Iifp=r,and q/∈Rimplies
∃k∈I:mk=crashd
i∈IGiRp ifp/negationslash=q,and p/negationslash=r
(µt.G)Rp=/braceleftbigg
µt.(GRp)ifp∈Gorfv(µt.G)/negationslash=∅
end otherwisetRp=t
endRp=end
wheredis themerge operator for local types (full merging ):
p&{mi(Bi).S/prime
i}i∈I/intersectionsqp&/braceleftbig
mj(Bj).T/prime
j/bracerightbig
j∈J
=p&{mk(Bk).(S/prime
k/intersectionsqT/prime
k)}k∈I∩J&p&{mi(Bi).S/prime
i}i∈I\J&p&/braceleftbig
mj(Bj).T/prime
j/bracerightbig
j∈J\I
p⊕{mi(Bi).S/prime
i}i∈I/intersectionsqp⊕{mi(Bi).T/prime
i}i∈I=p⊕{mi(Bi).(S/prime
i/intersectionsqT/prime
i)}i∈I
µt.S/intersectionsqµt.T=µt.(S/intersectionsqT) t/intersectionsqt=t end/intersectionsqend=end
We parameterise our theory on a (ﬁxed) set of reliablerolesR, i.e. roles assumed to never
crash: ifR=∅, every role is unreliable and susceptible to crash; if roles(G)⊆R, every role
inGis reliable, and we simulate the results from the original MPST theory without crashes.
We base our deﬁnition of projection on [38], but include more ( highlighted ) cases to account
for reliable roles, crashbranches, and runtime global types.
When projecting a transmission from qtor, we remove the crashlabel from the internal
choice at q, reﬂecting our model that a crashpseudo-message cannot be sent. Dually,
we require a crashlabel to be present in the external choice at r– unless the sender
role qis assumed to be reliable. Our deﬁnition of projection enforces that transmissions,
whenever an unreliable role is the sender ( q/∈R),must include a crash handling branchA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 11
(∃k∈I:mk=crash). This requirement ensures that the receiving role rcanalwayshandle
crashes whenever it happens, so that processes are not stuck when crashes occur. We explain
how these requirements help us achieve various properties by projection in §4.6. The rest of
the rules are taken from the literature [38,41], without much modiﬁcation.
4.2 Crash-Stop Semantics of Global Types
We now give a Labelled Transition System (LTS) semantics to global types, with crash-stop
semantics. To this end, we ﬁrst introduce some auxiliary deﬁnitions. We deﬁne the transition
labels in Def. 4, which are also used in the LTS semantics of conﬁgurations (later in §4.3).
IDeﬁnition 4 (Transition Labels) .Letαbe a transition label of the form:
α::=p&q:m(B) (preceives m(B)from q)/vextendsingle/vextendsinglep⊕q:m(B) (psends m(B)toq)/vextendsingle/vextendsinglep (pcrashes )/vextendsingle/vextendsinglep⊙q (pdetects the crash of q)
The subject of a transition label, written subj(α), is deﬁned as:
subj( p&q:m(B)) = subj( p⊕q:m(B)) = subj( p ) = subj( p⊙q) =p.
The labels p⊕q:m(B)andp&q:m(B)describe sending and receiving actions respectively.
The crash of pis denoted by the label p , and the detection of a crash by label p⊙q: we
model crash detection at reception , the label contains a detecting rolepand acrashedroleq.
We deﬁne an operator to removea role from a global type in Def. 5: the intuition is
to remove any interaction of a crashed role from the given global type. When a role has
crashed, we attach a crashed annotation , and remove infeasible actions, e.g. when the sender
and receiver of a transmission have both crashed. The removal operator is a partial function
that takes a global type Gand a live role r(r∈roles(G)) and gives a global type G r.
IDeﬁnition 5 (Role Removal) .The removal of a live role pin a global type G, writtenG p,
is deﬁned as follows:
(p→q:{mi(Bi).Gi}i∈I) r=

p  q:j{mi(Bi).(Gi r)}i∈Iifp=rand∃j∈I:mj=crash
p→q :{mi(Bi).(Gi r)}i∈Iifq=r
p→q:{mi(Bi).(Gi r)}i∈Iifp/negationslash=rand q/negationslash=r
(p q:j{mi(Bi).Gi}i∈I) r=

p  q:j{mi(Bi).(Gi r)}i∈Iifp=r
Gj r ifq=r
p q:j{mi(Bi).(Gi r)}i∈Iifp/negationslash=rand q/negationslash=r
(p→q :{mi(Bi).Gi}i∈I) r=/braceleftbigg
Gj r ifp=rand∃j∈I:mj=crash
p→q :{mi(Bi).(Gi r)}i∈Iifp/negationslash=rand q/negationslash=r
(p  q:j{mi(Bi).Gi}i∈I) r=/braceleftbigg
Gj r ifq=r
p  q:j{mi(Bi).(Gi r)}i∈Iifp/negationslash=rand q/negationslash=r
(µt.G) r=/braceleftbigg
µt.(G r) iffv(µt.G)/negationslash=∅orroles(G r)/negationslash=∅
end otherwise
t r=t end r=end
For simple cases, the removal of a role G rattaches crash annotations  on all occurrences
of the removed role rthroughout global type Ginductively.
We draw attention to some interesting cases: when we remove the sender role pfrom
a transmission preﬁx p→q, the result is a ‘pseudo-transmission’ en route preﬁx p  q:j
where mj=crash. This enables the receiver qto ‘receive’ the special crashafter the crash
ofp, hence triggering the crash handling branch. Recall that our deﬁnition of projection
requires that a crash handling branch be present whenever a crash may occur ( q/∈R).12 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
p/∈Rp∈roles(G)G/negationslash=µt.G/prime
/angbracketleftC;G/angbracketrightp −→R/angbracketleftC∪{p};G p/angbracketright[GR- ]/angbracketleftC;G{µt.G/t}/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright
/angbracketleftC;µt.G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright[GR-µ]
j∈Imj/negationslash=crash
/angbracketleftC;p→q:{mi(Bi).G/prime
i}i∈I/angbracketrightp⊕q:mj(Bj)−−−−−−→ R/angbracketleftC;p q:j{mi(Bi).G/prime
i}i∈I/angbracketright[GR-⊕]
j∈Imj/negationslash=crash
/angbracketleftC;p† q:j{mi(Bi).G/prime
i}i∈I/angbracketrightq&p:mj(Bj)−−−−−−→ R/angbracketleftC;G/prime
j/angbracketright[GR-&]
j∈Imj=crash
/angbracketleftC;p  q:j{mi(Bi).G/prime
i}i∈I/angbracketrightq⊙p−−→R/angbracketleftC;G/prime
j/angbracketright[GR-⊙]
j∈Imj/negationslash=crash
/angbracketleftC;p→q :{mi(Bi).G/prime
i}i∈I/angbracketrightp⊕q:mj(Bj)−−−−−−→ R/angbracketleftC;G/prime
j/angbracketright[GR- m]
∀i∈I:/angbracketleftC;G/prime
i/angbracketrightα− →R/angbracketleftC/prime;G/prime/prime
i/angbracketrightsubj(α)/∈{p,q}
/angbracketleftC;p→q†:{mi(Bi).G/prime
i}i∈I/angbracketrightα− →R/angbracketleftC/prime;p→q†:{mi(Bi).G/prime/prime
i}i∈I/angbracketright[GR-Ctx-i]
∀i∈I:/angbracketleftC;G/prime
i/angbracketrightα− →R/angbracketleftC/prime;G/prime/prime
i/angbracketrightsubj(α)/negationslash=q
/angbracketleftC;p† q:j{mi(Bi).G/prime
i}i∈I/angbracketrightα− →R/angbracketleftC/prime;p† q:j{mi(Bi).G/prime/prime
i}i∈I/angbracketright[GR-Ctx-ii]
Figure 7 Global Type Reduction Rules
When we remove the sender role pfrom a transmission en route preﬁx p q:j, the
resultretainsthe indexjthat was selected by p, instead of the index associated with crash
handling. This is crucial to our crash modelling: when a role crashes, the messages that the
rolehas sent to other roles are still available. We discuss alternative models later in §4.4.
In other cases, where removing the role rwould render a transmission (regardless of being
en route or not) meaningless, e.g. both sender and receiver have crashed, we simply remove
the preﬁx entirely. An example of role removal in a global type can be found in Appendix
§C.
We now give an LTS semantics to a global type G, by deﬁning the semantics with a tuple
/angbracketleftC;G/angbracketright, where Cis a set of crashedroles. The transition system is parameterised by reliability
assumptions, in the form of a ﬁxed set of reliable roles R. When unambiguous, we write G
as an abbreviation of /angbracketleft∅;G/angbracketright. We deﬁne the reduction rules of global types in Def. 6.
IDeﬁnition 6 (Global Type Reductions) .The global type (annotated with a set of crashed
rolesC) transition relationα− →Ris inductively deﬁned by the rules in Fig. 7, parameterised
by a ﬁxed set Rof reliable roles. We write /angbracketleftC;G/angbracketright − →R/angbracketleftC/prime;G/prime/angbracketrightif there exists αsuch
that/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright; we write/angbracketleftC;G/angbracketright − →Rif there exists C/prime,G/prime, andαsuch that
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright, and− →∗
Rfor the transitive and reﬂexive closure of − →R.
Rules [GR-⊕]and [GR-&]model sending and receiving messages respectively, as are standard
in existing works [12]. We add an ( highlighted ) extra condition that the message exchanged
not be a pseudo-message carrying the crashlabel. [GR-µ]is a standard rule handling recursion.
We introduce ( highlighted) rules to account for crash and consequential behaviour:
Rule [GR- ]models crashes, where a live ( p∈roles(G)), but unreliable ( p/∈R) role pmay
crash. The crashed role pis added into the set of crashed roles ( C∪{p}), and removed
from the global type, resulting in a global type G p.
Rule [GR-⊙]is forcrash detection , where a live role qmay detect that phas crashed at
reception, and then continues with the crash handling continuation labelled crash. ThisA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 13
rule only applies when the message en route is a pseudo-message, since otherwise a message
rests in the queue of the receiver and can be received despite the crash of the sender
(cf. [GR-&]).
Rule [GR- m]models the orphaning of a message sent from a live role pto a crashed role q.
Similar to the requirement in [GR-⊕], we add the side condition that the message sent is
not a pseudo-message.
Finally, rules [GR-Ctx-i] and [GR-Ctx-ii] allow non-interfering reductions of (intermediate)
global types under preﬁx, provided that all of the continuations can be reduced by that label.
IRemark 7 (Necessity of Cin Semantics). While we can obtain the set of crashed roles in any
global type Gviaroles (G), we need a separate Cfor bookkeeping purposes. To illustrate,
letG=p→q:{m.end,crash.end}, we can have the following reductions:
/angbracketleft∅;G/angbracketrightq −→∅/angbracketleft{q};p→q :{m.end,crash.end}/angbracketrightp⊕q:m−−−→∅/angbracketleft{q};end/angbracketright
While we can deduce qis a crashed role in the interim global type, the same information
cannot be recovered from the ﬁnal global type end.
4.3 Crash-Stop Semantics of Conﬁgurations
After giving semantics to global types, we now give an LTS semantics to conﬁgurations , i.e.
a collection of local types and communication queues across roles. We ﬁrst give a deﬁnition
of conﬁgurations in Def. 8, followed by their reduction rules in Def. 9.
IDeﬁnition 8 (Conﬁgurations) .A conﬁguration is a tuple Γ;∆, where Γis atyping context ,
denoting a partial mapping from roles to local types, deﬁned as: Γ::=∅/vextendsingle/vextendsingleΓ,p⊿T. We write
Γ[p/mapsto→T]for updates: Γ[p/mapsto→T](p) =TandΓ[p/mapsto→T](q) = Γ( q)(where p/negationslash=q).
Aqueue, denotedτ, is either a (possibly empty) sequence of messages M1·M2·····Mn,
or unavailable/circledivide. We write /epsilon1for an empty queue, and M·τ/primefor a non-empty queue with
messageMat the beginning. A queue message Mis of form m(B), denoting a message with
label mand payload B. We sometimes omit Bwhen the payload is not of speciﬁc interest.
We write ∆to denote a queue environment , a collection of peer-to-peer queues. A queue
from ptoqat∆is denoted ∆(p,q). We deﬁne updates ∆[p,q/mapsto→τ]similarly. We write ∆∅
for anemptyqueue environment, where ∆∅(p,q) =/epsilon1for any pandqin the domain.
We writeτ/prime·Mto append a message Mat the end of a queue τ/prime: the message is
appended to the sequence when τ/primeis available, or discarded when τ/primeis unavailable (i.e.
/circledivide·M=/circledivide). Additionally, we write ∆[·,q/mapsto→/circledivide]for making all the queues to qunavailable:
i.e.∆[p1,q/mapsto→/circledivide][p2,q/mapsto→/circledivide]···[pn,q/mapsto→/circledivide].
We give an LTS semantics of conﬁgurations in Def. 9. Similar to that of global types, we
model the semantics of conﬁgurations in an asynchronous (a.k.a. message passing) fashion,
using a queue environment to represent the communication queues among all roles.
IDeﬁnition 9 (Conﬁguration Semantics) .Theconﬁguration transition relationα− →is deﬁned
in Fig. 8. We write Γ; ∆α− →iﬀΓ;∆α− →Γ/prime;∆/primefor some Γ/primeand∆/prime. We deﬁne two reductions
→and→R(where Ris a ﬁxed set of reliable roles) as follows:
We write Γ;∆→Γ/prime;∆/primeforΓ;∆α− →Γ/prime;∆/primewithα∈{p&q:m(B),p⊕q:m(B),p⊙q}. We write
Γ; ∆→iﬀΓ;∆→Γ/prime;∆/primefor some Γ/prime;∆/prime, and Γ; ∆/negationslash→for its negation, and →∗for the
reﬂexive and transitive closure of →;
We write Γ;∆→RΓ/prime;∆/primeforΓ;∆α− →Γ/prime;∆/primewithα/∈{r |r∈R}. We write Γ; ∆→Riﬀ
Γ;∆→RΓ/prime;∆/primefor some Γ/prime;∆/prime, and Γ; ∆/prime/negationslash→Rfor its negation. We deﬁne →∗
Ras the
reﬂexive and transitive closure of →R.14 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Γ(p) =q⊕{mi(Bi).Ti}i∈Ik∈I
Γ; ∆p⊕q:mk(Bk)−−−−−−−→ Γ[p/mapsto→Tk]; ∆[p,q/mapsto→∆(p,q)·mk(Bk)][Γ-⊕]
Γ(p) =q&{mi(Bi).Ti}i∈Ik∈Im/prime=mkB/prime=Bk∆(q,p) =m/prime(B/prime)·τ/prime/negationslash=/circledivide
Γ; ∆p&q:mk(Bk)−−−−−−−→ Γ[p/mapsto→Tk]; ∆[q,p/mapsto→τ/prime][Γ-&]
Γ(p) =µt.TΓ[p/mapsto→T{µt.T/t}]; ∆α− →Γ/prime; ∆/prime
Γ; ∆α− →Γ/prime; ∆/prime[Γ-µ]Γ(p)/negationslash=end Γ(p)/negationslash=stop
Γ; ∆p −→Γ[p/mapsto→stop]; ∆[·,p/mapsto→/circledivide][Γ- ]
Γ(q) =p&{mi(Bi).Ti}i∈IΓ(p) =stopk∈Imk=crash ∆(p,q) =/epsilon1
Γ; ∆q⊙p−−→ Γ[q/mapsto→Tk]; ∆[Γ-⊙]
Figure 8 Conﬁguration Semantics
We ﬁrst explain the standard rules: rule [Γ-⊕](resp. [Γ-&]) says that a role can perform an
output(resp.input)transitionbyappending(resp.consuming)amessageatthecorresponding
queue. Recall that whenever a queue is unavailable, the resulting queue remains unavailable
after appending ( /circledivide·M=/circledivide). Therefore, the rule [Γ-⊕]covers delivery to both crashed and
live roles, whereas two separate rules are used in modelling global type semantics ( [GR-⊕]and
[GR- m]). We also include a standard rule [Γ-µ]for recursive types.
The key innovations are the ( highlighted ) rules modelling crashes and crash detection:
by rule [Γ- ], a role pmay crash and become stopat any time (unless it is already ended
orstopped). All of p’s receiving queues become unavailable /circledivide, so that future messages to
pwould be discarded. Rule [Γ-⊙]models crash detection and handling: if pis crashed and
stopped, another role qattempting to receive from pcan then take its crashhandling branch.
However, this rule only applies when the corresponding queue is empty: it is still possible to
receive messages sent before crashing via [Γ-&].
4.4 Alternative Modellings for Crash-Stop Failures
Before we dive into the relation between two semantics, let us have a short digression to
discuss our modelling choices and alternatives. In this work, we mostly follow the assumptions
laid out in [2], where a crash is detected at reception. However, they opt to use a synchronous
(rendez-vous) semantics, whereas we give an asynchronous (message passing) semantics,
which entails interesting scenarios that would not arise in a synchronous semantics.
Speciﬁcally, consider the case where a role psends a message to q, and then pcrashes after
sending, but before qreceives the message. The situation does not arise under a synchronous
semantics, since sending and receiving actions are combined into a single transmission action.
Intuitively, there are two possibilities to handle this scenario. The questions are whether
the message sent immediately before crashing is deliverable to q, and consequentially, at
what time does qdetect the crash of p.
In our semantics (Figs. 7 and 8), we opt to answer the ﬁrst question in positive: we argue
that this model is more consistent with our ‘passive’ crash detection design. For example, if
a role pnever receives from another role q, then pdoes not need to react in the event of q’s
crash. Following a similar line of reasoning, if the message sent by parrives in the receiving
queue of q, then qshould be able to receive the message, without triggering a crash detection
(although it may be triggered later). As a consequence, we require in [Γ-⊙]that the queue
∆(p,q)be empty, to reﬂect the idea that crash detection should be a ‘last resort’.
For an alternative model, we can opt to detect the crash after crash has occurred. This is
possibly better modelled with using outgoing queues (cf. [11]), instead of incoming queuesA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 15
in the semantics presented. Practically, this may be the scenario that a TCP connection is
closed (or reset) when a peer has crashed, and the content in the queue is lost. It is worth
noting that this kind of alternative model will not aﬀect our main theoretical results: the
operational correspondence between global and local type semantics, and furthermore, global
type properties guaranteed by projection.
4.5 Relating Global Type and Conﬁguration Semantics
We have given LTS semantics for both global types (Def. 6) and conﬁgurations (Def. 9), we
now relate these two semantics with the help of the projection operator (Def. 3).
We associate conﬁgurations Γ;∆with global types G(as annotated with a set of crashed
rolesC) by projection, written Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright. Naturally, there are two components of the
association: (1)the local types in Γneed to correspond to the projections of the global type
Gand the set of crashed roles C; and(2)the queues in ∆corresponds to the transmissions
en route in the global type Gand also the set of crashed roles C.
IDeﬁnition 10 (Association of Global Types and Conﬁgurations) .A conﬁguration Γ;∆is
associated with a (well-annotated w.r.t. R) global type/angbracketleftC;G/angbracketright, written Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, iﬀ
1.Γcan be split into disjoint (possibly empty) sub-contexts Γ = ΓG,Γ ,Γendwhere:
(A1) ΓGcontains projections of G:dom(ΓG)=roles(G), and∀p∈dom(ΓG):Γ(p)6
GRp;
(A2) Γ contains crashed roles: dom(Γ ) =C, and∀p∈dom(Γ ) : Γ( p) =stop;
(A3) Γendcontains only endendpoints:∀p∈Γend: Γ(p) =end.
2.(A4) ∆is associated with global type /angbracketleftC;G/angbracketright, given as follows:
i.Receiving queues for a role is unavailable if and only if it has crashed: ∀q:q∈
C⇐⇒ ∆(·,q) =/circledivide;
ii.IfG=endorG=µt.G/prime, then queues between all roles are empty (except receiving
queue for crashed roles): ∀p,q:q/∈C=⇒∆(p,q) =/epsilon1;
iii.IfG=p→q†:{mi(Bi).G/prime
i}i∈I, orG=p† q:j{mi(Bi).G/prime
i}i∈Iwith mj=crash(i.e.
a pseudo-message is en route), then (i)ifqis live, then the queue from ptoqis
empty: q†/negationslash=q =⇒∆(p,q) =/epsilon1, and(ii)∀i∈I: ∆is associated with /angbracketleftC;G/prime
i/angbracketright;
iv.IfG=p† q:j{mi(Bi).G/prime
i}i∈Iwith mj/negationslash=crash, then(i)the queue from ptoqbegins
with the message mj(Bj):∆(p,q)=mj(Bj)·τ;(ii)∀i∈I:removing the message
from the head of the queue, ∆[p,q/mapsto→τ]is associated with /angbracketleftC;G/prime
i/angbracketright.
We write Γ/subsetsqequalRGas an abbreviation of Γ; ∆∅/subsetsqequalR/angbracketleft∅;G/angbracketright. We sometimes say Γ(resp. ∆) is
associated with/angbracketleftC;G/angbracketrightfor stating Item 1 (resp. Item 2) is satisﬁed.
We demonstrate the relation between the two semantics via association, by showing two
main theorems: all possible reductions of a conﬁguration have a corresponding action in
reductions of the associated global type (Thm. 11); and the reducibility of a global type is
the same as its associated conﬁguration (Thm. 12).
ITheorem11 (CompletenessofAssociation) .Given associated global type Gand conﬁguration
Γ;∆:Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright. If Γ;∆α− →Γ/prime;∆/prime, whereα/negationslash=p for all p∈R, then there exists
/angbracketleftC/prime;G/prime/angbracketrightsuch that Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketrightand/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright.
Proof.By induction on conﬁguration reductions (Def. 9). See Appendix §E.5 for detailed
proof. J16 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
ITheorem 12 (Soundness of Association) .Given associated global type Gand conﬁguration
Γ;∆:Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright. If/angbracketleftC;G/angbracketright− →R, then there exists Γ/prime;∆/prime,αand/angbracketleftC/prime;G/prime/angbracketright, such that
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright,Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright, and Γ; ∆α− →Γ/prime; ∆/prime.
Proof.By induction on global type reductions (Def. 6). See Appendix §E.5 for detailed
proof. J
By Thms. 11 and 12, we obtain, as a corollary, that a global type Gis in operational corres-
pondence with the typing context Γ={p⊿GRp}p∈roles(G), which contains the projections
of all roles in G.
IRemark 13 (‘Weakness’ and ‘Suﬃciency’ of Soundness Theorem). Curious readers may
wonder why we proved a ‘ weak’ soundness theorem instead of one that is the dual of the
completeness theorem, e.g. as seen in the literature [12]. The reason is that we use the ‘full’
subtyping (Def. 30, notably [Sub-⊕]). A local type in the typing context may have fewer
branches to choose from than the projected local type, resulting in uninhabited sending
actions in the global type.
For example, let G=p→q:{m1.end;m2.end}. An associated typing context Γ(assuming
preliable) may have Γ(p)=q⊕{m1.end}6q⊕{m1.end;m2.end}(via [Sub-⊕]). The global
typeGmay make a transition p⊕q:m2, where an associated conﬁguration Γ; ∆∅cannot.
However, our soundness theorem is suﬃcient for concluding desired properties guaranteed
via association, e.g. safety, deadlock-freedom, and liveness, as illustrated in §4.6.
4.6 Properties Guaranteed by Projection
A key beneﬁt of our top-down approach of multiparty protocol design is that desirable
properties are guaranteed by the methodology. As a consequence, processes following the
local types obtained from projections are correct by construction . In this subsection, we
focus on three properties: communication safety ,deadlock-freedom , andliveness, and show
that the three properties are guaranteed from conﬁgurations associated with global types.
Communication Safety We begin by deﬁning communication safety for conﬁgurations
(Def. 14). We focus on two safety requirements: (i) each role must be able to handle any
message that may end up in their receiving queue (so that there are no label mismatches);
and (ii) each receiver must be able to handle the potential crash of the sender, unless the
sender is reliable.
IDeﬁnition 14 (Conﬁguration Safety) .Given a ﬁxed set of reliable roles R, we say that ϕ
is anR-safety property of conﬁgurations iﬀ, whenever ϕ(Γ; ∆), we have:
[S-⊕&]Γ(q) =p&{mi(Bi).S/prime
i}i∈Iand∆(p,q)/negationslash=/circledivideand∆(p,q)/negationslash=/epsilon1implies Γ; ∆q&p:m/prime(B/prime)−−−−−−−→ ;
[S- &]Γ(p) =stopandΓ(q) =p&{mi(Si).S/prime
i}i∈Iand∆(p,q) =/epsilon1implies Γ; ∆q⊙p−−→;
[S-µ]Γ(p) =µt.Simpliesϕ(Γ[p/mapsto→S{µt.S/t}]; ∆);
[S-→ ]Γ; ∆→RΓ/prime; ∆/primeimpliesϕ(Γ/prime; ∆/prime).
We say Γ; ∆isR-safe, ifϕ(Γ; ∆)holds for some R-safety property ϕ.
We use a coinductive view of the safety property [35], where the predicate of R-safe
conﬁgurations is the largest R-safety property, by taking the union of all safety properties ϕ.
For a conﬁguration Γ; ∆to beR-safe, it has to satisfy all clauses deﬁned in Def. 14.
By clause [S-⊕&], whenever a role qreceives from another role p, and a message is present
in the queue, the receiving action must be possible for some label m/prime. Clause [S- &]statesA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 17
that if a role qreceives from a crashed role p, and there is nothing in the queue, then qmust
have a crashbranch, and a crash detection action can be ﬁred. (Note that [S-⊕&]applies
when the queue is non-empty, despite the crash of sender p.) Finally, clause [S-µ]extends
the previous clauses by unfolding any recursive entries; and clause [S-→ ]states that any
conﬁguration Γ/prime;∆/primewhich Γ;∆transitions to must also be R-safe. By using transition →R,
we ignore crash transitions p for any reliable role p∈R.
IExample 15. Recall the local types TC,TL, andTIof the Simpler Logging example in §2.
The conﬁguration Γ;∆, where Γ=C⊿TC,L⊿TL,I⊿TIand ∆=∆∅, is{L,I}-safe. This can be
veriﬁed by checking its reductions. For example, in the case where Ccrashes immediately, we
have: Γ;∆C −→Γ[C/mapsto→stop];∆[·,C/mapsto→/circledivide]→∗Γ[C/mapsto→stop][L/mapsto→end][I/mapsto→end];∆[·,C/mapsto→/circledivide]and each
reductum satisﬁes all clauses of Def. 14. Full reductions are available in Appendix §C, Ex. 33.
Deadlock-Freedom The property of deadlock-freedom, sometimes also known as progress,
describes whether a conﬁguration can keep reducing unless it is a terminal conﬁguration. We
give its formal deﬁnition in Def. 16.
IDeﬁnition 16 (Conﬁguration Deadlock-Freedom) .Given a set of reliable roles R, we say
that a conﬁguration Γ;∆isR-deadlock-free iﬀ:1.Γ;∆isR-safe; and, 2.IfΓ;∆can reduce
to a conﬁguration Γ/prime;∆/primewithout further reductions: Γ;∆→∗
RΓ/prime;∆/prime/negationslash→R, then:a.Γ/primecan be
split into two disjoint contexts, one with only endentries, and one with only stopentries:
Γ/prime=Γ/prime
end,Γ/prime
 , where dom(Γ/prime
end)={p|Γ/prime(p) =end}anddom/parenleftBig
Γ/prime
 /parenrightBig
={p|Γ/prime(p) =stop}; and,
b.∆/primeis empty for all pairs of roles, except for the receiving queues of crashed roles, which
are unavailable:∀p,q: ∆/prime(·,q) =/circledivideifΓ/prime(q) =stop, and ∆/prime(p,q) =/epsilon1, otherwise.
It is worth noting that a (safe) conﬁguration that reduces inﬁnitely satisﬁes deadlock-
freedom, as Item 2 in the premise does not hold. Otherwise, whenever a terminal conﬁguration
is reached, it must satisfy Item 2a that all local types in the typing context be terminated
(either successfully end, or crashed stop), and Item 2b that all queues be empty (unless
unavailable due to crash). As a consequence, a deadlock-free conﬁguration Γ;∆either does
not stop reducing, or terminates in a stable conﬁguration.
Liveness The property of liveness describes that every pending output/external choice is
eventually triggered by means of a message transmission or crash detection. Our liveness
property is based on fairness, which guarantees that every enabled message transmission,
including crash detection, is performed successfully. We give the deﬁnitions of non-crashing,
fair, and live paths of conﬁgurations respectively in Def. 17, and use these paths to formalise
the liveness for conﬁgurations in Def. 18.
IDeﬁnition 17 (Non-crashing, Fair, Live Paths) .Anon-crashing path is a possibly inﬁnite
sequence of conﬁgurations (Γn;∆n)n∈N, whereN={0,1,2,...}is a set of consecutive
natural numbers, and ∀n∈N,Γn;∆n→Γn+1;∆n+1. We say that a non-crashing path
(Γn; ∆n)n∈Nisfairiﬀ,∀n∈N:
(F1) Γn;∆np⊕q:m(B)−−−−−−→ implies∃k,m/prime,B/primesuch thatn≤k∈Nand Γk;∆kp⊕q:m/prime(B/prime)−−−−−−−→
Γk+1; ∆k+1;
(F2) Γn; ∆np&q:m(B)−−−−−−→ implies∃ksuch thatn≤k∈NandΓk; ∆kp&q:m(B)−−−−−−→ Γk+1; ∆k+1;
(F3) Γn; ∆np⊙q−−→implies∃ksuch thatn≤k∈NandΓk; ∆kp⊙q−−→ Γk+1; ∆k+1.
We say that a non-crashing path (Γn; ∆n)n∈Nisliveiﬀ,∀n∈N:18 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
(L1) ∆n(p,q)=m(B)·τ/negationslash=/circledivideand m/negationslash=crashimplies∃ksuch thatn≤k∈Nand
Γk; ∆kq&p:m(B)−−−−−−→ Γk+1; ∆k+1;
(L2) Γn(p) =q&{mi(Bi).Ti}i∈Iimplies∃k,m/prime,B/primesuch thatn≤k∈Nand
Γk; ∆kp&q:m/prime(B/prime)−−−−−−−→ Γk+1; ∆k+1orΓk; ∆kp⊙q−−→ Γk+1; ∆k+1.
A non-crash path is a (possibly inﬁnite) sequence of reductions of a conﬁguration without
crashes. A non-crash path is fair if along the path, every internal choice eventually sends
a message (F1), every external choice eventually receives a message (F2), and every crash
detection is eventually performed (F3). A non-crashing path is live if along the path, every
non-crash message in the queue is eventually consumed (L1), and every hanging external
choice eventually consumes a message or performs a crash detection (L2).
IDeﬁnition 18 (Conﬁguration Liveness) .Given a set of reliable roles R, we say that a
conﬁguration Γ;∆isR-liveiﬀ:1.Γ;∆isR-safe; and, 2.Γ;∆→∗
RΓ/prime;∆/primeimplies all
non-crashing paths starting with Γ/prime; ∆/primethat are fair are also live.
A conﬁguration Γ;∆isR-live when it is R-safe and any reductum of Γ;∆(via transition
→∗
R) consistently leads to a live path if it is fair.
PropertiesbyProjection Weconcludebyshowingtheguaranteeofsafety, deadlock-freedom,
and liveness in conﬁgurations associated with global types in Lem. 19. Furthermore, as a
corollary, Thm. 20 demonstrates that a typing context projected from a global type (without
runtime constructs) is inherently safe, deadlock-free, and live by construction. The detailed
proofs for Lem. 19 and Thm. 20 are available in Appendix §E.6.
ILemma 19. IfΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, then Γ; ∆isR-safe,R-deadlock-free, and R-live.
ITheorem 20 (Safety, Deadlock-Freedom, and Liveness by Projection) .LetGbe a global
type without runtime constructs, and Rbe a set of reliable roles. If Γis a typing context
associated with the global type G:Γ/subsetsqequalRG, then Γ;∆∅isR-safe,R-deadlock-free, and R-live.
5 Typing System with Crash-Stop Semantics
In this section, we present a type system for our asynchronous multiparty session calculus.
Our typing system is extended from the one in [15] with crash-stop failures. We introduce
the typing rules in §5.1, and show various properties of typed sessions: subject reduction,
session ﬁdelity, deadlock-freedom, and liveness in §5.2.
5.1 Typing Rules
Our type system uses three kinds of typing judgements: (1)for processes; (2)for queues; and
(3)for sessions, and is deﬁned inductively by the typing rules in Fig. 9. Typing judgments
for processes are of form Θ/turnstileleftP:T, where Θis a typing context for variables, deﬁned as
Θ::=∅/vextendsingle/vextendsingleΘ,x:B/vextendsingle/vextendsingleΘ,X:T.
With regard to queues, we use judgments of the form /turnstilelefth:δ, where we use δto denote
a partially applied queue lookup function. We write δ=∆(−,p)to describe the incoming
queue for a role p, as a partially applied function δ=∆(−,p)such thatδ(q)=∆(q,p). We
writeδ1·δ2to denote the point-wise application of concatenation. For empty queues ( /epsilon1),
unavailable queues ( /circledivide), and queue concatenations ( ·), we simply lift the process-level queue
constructs to type-level counterparts. For a singleton message (q,m(v)), the appropriateA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 19
/turnstileleft/epsilon1:/epsilon1[t-/epsilon1]/turnstileleft/circledivide:/circledivide[t-/circledivide]/turnstilelefth1:δ1/turnstilelefth2:δ2
/turnstilelefth1·h2:δ1·δ2[t-·]
/turnstileleftv:B δ (q) =m(B)∀r/negationslash=q:δ(r) =/epsilon1
/turnstileleft(q,m(v)) :δ[t-msg]
Θ/turnstileleft :stop[t- ]Θ/turnstileleft0:end[t-0]Θ/turnstilelefte:BΘ/turnstileleftP:T
Θ/turnstileleftq!m/angbracketlefte/angbracketright.P:q⊕m(B).T[t-out]
∀i∈IΘ,xi:Bi/turnstileleftPi:Ti
Θ/turnstileleft/summationtext
i∈Iq?mi(xi).Pi:q&{mi(Bi).Ti}i∈I[t-ext]Θ/turnstilelefte: bool Θ/turnstileleftPi:T(i= 1,2)
Θ/turnstileleftifethenP1elseP2:T[t-cond]
Θ,X:T/turnstileleftP:T
Θ/turnstileleftµX.P :T[t-rec]Θ,X:T/turnstileleftX:T[t-var]Θ/turnstileleftP:T T6T/prime
Θ/turnstileleftP:T/prime[t-sub]
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright ∀i∈I/turnstileleftPi: Γ(pi)/turnstilelefthi: ∆(−,pi)dom(Γ)⊆{pi|i∈I}
/angbracketleftC;G/angbracketright/turnstileleft/producttext
i∈I(pi/triangleleftPi|pi/trianglelefthi)[t-sess]
Figure 9 Typing rules for queues, processes, and sessions.
partial queue δwould be a singleton of m(B)(whereBis the type of v) for q, and an empty
queue (/epsilon1) for any other role.
Finally, weusejudgmentsoftheform /angbracketleftC;G/angbracketright/turnstileleftMforsessions. Weuseaglobaltype-guided
judgment, eﬀectively asserting that all participants in the session respect the prescribed
global type, as is the case in [14]. As highlighted , the global type with crashed roles /angbracketleftC;G/angbracketright
must have some associated conﬁguration Γ;∆, used to type the processes and the queues
respectively. Moreover, all the entries in the conﬁguration must be present in the session.
Most rules in Fig. 9 assign the corresponding session type according to the behaviour of
the process. For example, ( highlighted ) rule [t-/circledivide]assigns the unavailable queue type /circledivideto
a unavailable queue /circledivide; rules [t-out]and [t-ext]assign internal and external choice types to
input and output processes; ( highlighted ) rule [t- ](resp. [t-0]) assigns the crash termination
stop(resp. successful termination end) to a crashed process  (resp. inactive process 0).
IExample 21. Consider the process that acts as the role Cin our Simpler Logging example
(§2 and Ex. 15): PC=I!read.I?report (x).0, and a message queue hC=/epsilon1. ProcessPChas the
typeTC, and queue hChas the type /epsilon1, which can be veriﬁed in the standard way. If we follow a
crash reduction, e.g. by the rule [r- ], the session evolves as C/triangleleftPC|C/trianglelefthC→RC/triangleleft |C/triangleleft/circledivide, where,
by[t- ],PCis typed by stop, andhCis typed by/circledivide. Full example is available in Appendix
§C, Ex. 34.
5.2 Properties of Typed Sessions
We present the main properties of typed sessions: subject reduction (Thm. 22), session ﬁdelity
(Thm. 23), deadlock-freedom (Thm. 25), and liveness(Thm. 27).
Subject reduction states that well-typedness of sessions are preserved by reduction. In
other words, a session governed by a global type continues to be governed by a global type.
ITheorem 22 (Subject Reduction) .If/angbracketleftC;G/angbracketright/turnstileleftMandM→ RM/prime, then either/angbracketleftC;G/angbracketright/turnstileleft
M/prime, or there exists /angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketrightand/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Proof.By induction on the derivation of M → RM/prime. See Appendix § F for detailed
proof. J
Session ﬁdelity states the opposite implication with regard to subject reduction: sessions
respect the progress of the governing global type .20 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
ITheorem 23 (Session Fidelity) .If/angbracketleftC;G/angbracketright/turnstileleftMand/angbracketleftC;G/angbracketright− →R, then there exists M/prime
and/angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright,M→ R∗M/primeand/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Proof.Byinductiononthederivationof /angbracketleftC;G/angbracketright− →R. SeeAppendix§Ffordetailedproof. J
Sessiondeadlock-freedom means that the ‘successful’ termination of a session may include
crashed processes and their respective unavailable incoming queues – but reliable roles (which
cannot crash) can only successfully terminate by reaching inactive processes with empty
incoming queues. We formalise the deﬁnition of deadlock-free sessions in Def. 24 and show
that a well-typed session is deadlock-free in Thm. 25. The proof of Thm. 25 is available
in Appendix §F.
IDeﬁnition 24 (Deadlock-Free Sessions) .A sessionMisdeadlock-free iﬀM→ R∗M/prime/negationslash→R
implies eitherM/prime≡p/triangleleft0|p/triangleleft/epsilon1, orM/prime≡p/triangleleft |p/triangleleft/circledivide.
ITheorem 25 (Session Deadlock-Freedom) .If/angbracketleftC;G/angbracketright/turnstileleftM, thenMis deadlock-free.
Finally, we show that well-typed sessions guarantee the property of liveness: a session is
livewhen all its input processes will be performed eventually, and all its queued messages will
be consumed eventually. We formalise the deﬁnition of live sessions in Def. 26 and conclude
by showing that a well-typed session is live in Thm. 27. The proof of Thm. 27 is available
in Appendix §F.
IDeﬁnition 26 (Live Sessions) .A sessionMisliveiﬀM→ R∗M/prime≡p/triangleleftP|p/trianglelefthp|M/prime/prime
implies:1.ifhp=(q,m(v))·h/prime
p, then∃P/prime,M/prime/prime/prime:M/prime→R∗p/triangleleftP/prime|p/trianglelefth/prime
p|M/prime/prime/prime; and2.if
P=/summationtext
i∈Iq?mi(xi).Pi, then∃k∈I,w,h/prime
p,M/prime/prime/prime:M/prime→R∗p/triangleleftPk{w/xk}|p/trianglelefth/prime
p|M/prime/prime/prime.
ITheorem 27 (Session Liveness) .If/angbracketleftC;G/angbracketright/turnstileleftM, thenMis live.
6 Teatrino: Generating Scala Programs from Protocols
In this section, we present our toolchain Teatrino that implements our extended MPST
theory with crash-stop failures. Teatrino processes protocols represented in the Scribble
protocol description language, and generates protocol-conforming Scala code that uses the
Effpiconcurrency library. A user speciﬁes a multiparty protocol in Scribble as input,
introduced in §6.1. We show the style of our generated code in §6.2, and how a developer can
use the generated code to implement multiparty protocols. As mentioned in §2, generating
channels for each process and type poses an interesting challenge, explained in §6.3.
6.1 Specifying a Multiparty Protocol in Scribble
TheScribble Language [44] is a multiparty protocol description language that relates closely
to MPST theory (cf. [31]), and provides a programmatic way to express global types. As an
example, Fig. 10 describes the following global type of a simple distributed logging protocol:
G=µt0.u→l:/braceleftbig
write (str).t0,read.l→u:report (Log).t0,crash.end/bracerightbig
.
The global type is described by a Scribble global protocol , with roles declared on Line 1.
A transmission in the global type (e.g. u→l:{···}) is in the form of an interaction statement
(e.g. ... from U to L; ), except that choice (i.e. with an index set |I|>1) must be marked
explicitly by a choiceconstruct (Line 2). Recursions and type variables in the global types
are in the forms of recand continue statements, respectively.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 21
1global protocol SimpleLogger(role U, reliable role L)
2{ rec t0 { choice at U { write(String) from U to L;
3 continue t0; }
4 or { read from U to L;
5 report(Log) from L to U;
6 continue t0; }
7 or { crash from U to L; } } }
Figure 10 A Simple Logger protocol in Scribble .
In order to express our new theory, we need two extensions to the language: (1)a reserved
label crashto mark crash handling branches (cf. the special label crashin the theory), e.g. on
Line 7; and (2)areliable keyword to mark the reliable roles in the protocol (cf. the reliable
role set Rin the theory). Roles are assumed unreliable unless declared using the reliable
keyword, e.g. Lon Line 1.
6.2 Generating Scala Code from Scribble Protocols
The Eﬀpi Concurrency Library [40] provides an embedded Domain Speciﬁc Language (DSL)
oﬀering a simple actor-based API. The library utilises advanced type system features in
Scala 3, and provides both type-level and value-level constructs for processes and channels.
In particular, the type-level constructs reﬂect the behaviour of programs (i.e. processes), and
thus can be used as speciﬁcations. Following this intuition, we generate process types that
reﬂect local types from our theory, as well as a tentative process implementing that type (by
providing some default values where necessary).
Generated Code To illustrate our approach, we continue with the Simple Logger example
from §6.1, and show the generated code in Fig. 11. The generated code can be divided
into ﬁve sections: (i)label and payload declarations, (ii)recursion variable declarations,
(iii)local type declarations, (iv)role-implementing functions, and (v)an entry point.
Sections (i)and(ii)contain boilerplate code, where we generate type declarations for
various constructs needed for expressing local types and processes. We draw attention to the
keysections(iii)and(iv), where we generate a representation of local types for each role, as
well as a tentative process inhabiting that type.
Local Types and Eﬀpi Types We postpone the discussion about channels in Effpito §6.3.
For now, we compare the generated Effpitype and the projected local type, and also give a
quick primer3onEffpiconstructs. The projected local types of the roles uandlare shown
as follows:
G{l}u=µt0.l⊕/braceleftbig
write (str).t0,read.l&report (Log).t0/bracerightbig
G{l}l=µt0.u&/braceleftbig
write (str).t0,read.u⊕report (Log).t0,crash.end/bracerightbig
Thelocaltypesarerecursive, andthe Effpitypeimplementsrecursionwith Rec[RecT0, ...]
andLoop[RecT0] , using the recursion variable RecT0declared in section (ii).
For role u, The inner local type is a sending type towards role l, and we use an Effpi
process output type Out[A, B] , which describes a process that uses a channel of type Ato
send a value of type B. For each branch, we use a separate output type, and connect it to
3A more detailed description of constructs can be found in [39].22 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
1// (i) label and payload declarations
2case class Log() // payload type
3case class Read() // label types
4case class Report(x : Log)
5case class Write(x : String)
6// (ii) recursion variable declarations
7sealed abstract class RecT0[A]() extends RecVar[A]("RecT0")
8case object RecT0 extends RecT0[Unit]
9// (iii) local type declarations
10type U[C0 <: OutChan[Read | Write], C1 <: InChan[Report]] =
11 Rec[RecT0,
12 ( (Out[C0, Read] >>: In[C1, Report, (x0 : Report) => Loop[RecT0]])
13 | (Out[C0, Write] >>: Loop[RecT0]) )]
14
15type L[C0 <: InChan[Read | Write], C1 <: OutChan[Report]] =
16 Rec[RecT0,
17 InErr[C0, Read | Write, (x0 : Read | Write) => L0[x0.type, C1],
18 (err : Throwable) => PNil]]
19
20type L0[X0 <: Read | Write, C1 <: OutChan[Report]] <: Process =
21 X0 match { case Read => Out[C1, Report] >>: Loop[RecT0]
22 case Write => Loop[RecT0] }
23// (iv) role-implementing functions
24def u(c0 : OutChan[Read | Write],
25 c1 : InChan[Report]) : U[c0.type, c1.type] = {
26 rec(RecT0) {
27 val x0 = 0
28 if (x0 == 0) {
29 send(c0, new Read()) >> receive(c1) {(x1 : Report) => loop(RecT0) }
30 } else {
31 send(c0, new Write("")) >> loop(RecT0)
32 } } }
33
34def l(c0 : InChan[Read | Write],
35 c1 : OutChan[Report]) : L[c0.type, c1.type] =
36 rec(RecT0) {
37 receiveErr(c0)((x0 : Read | Write) => l0(x0, c1),
38 (err : Throwable) => nil) }
39
40def l0(x : Read | Write, c1 : OutChan[Report]) : L0[x.type, c1.type] =
41 x match { case y : Read => send(c1, new Report(new Log())) >> loop(RecT0)
42 case y : Write => loop(RecT0) }
43// (v) an entry point (main object)
44object Main {
45 def main() : Unit = {
46 var c0 = Channel[Read | Write]()
47 var c1 = Channel[Report]()
48 eval(par(u(c0, c1), l(c0, c1)))
49} }
Figure 11 Generated Scalacode for the Simple Logger protocol in Fig. 10A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 23
the type of the continuation using a sequential composition operator ( >>:). The diﬀerent
branches are then composed together using a union type ( |) from the Scala3 type system.
Recall that the role lis declared reliable, and thus the reception labelled reportfrom
latudoes not need to contain a crash handler. We use an Effpiprocess input type
In[A, B, C] , which describes a process that uses a channel of type Ato receive a value of
type B, and uses the received value in a continuation of type C.
For role l, the reception type is more complex for two reasons: (1)role uis unreliable,
necessitating crash handling; and (2)the reception contains branching behaviour (cf. the
reception ubeing a singleton), with labels writeandread. For(1), we extend Effpiwith a
variant of the input process type InErr[A, B, C, D] , where Dis the type of continuation
in case of a crash. For (2), the payload type is ﬁrst received as an union (Line 17), and then
matched to select the correct continuation according to the type (Line 21).
From Types To Implementations Since Effpitype-level and value-level constructs are
closely related, we can easily generate the processes from the processes types. Namely, by
matchingthetype Out[..., ...] withtheprocess send(..., ...) ; thetype In[..., ...]
with the process receive(...) {... => ...} ; and similarly for other constructs. Whilst
executable, the generated code represents a skeleton implementation, and the programmer is
expected to alter the code according to their requirements.
We also introduce a new crash handling receive process receiveErr , to match the
new InErrtype. Process crashes are modelled by (caught) exceptions and errors in role-
implementing functions, and crash detection is achieved via timeouts. Timeouts are set by
the programmer in an (implicit) argument to each receiveErr call.
Finally, the entry point (main object) in section (v)composes the role-implementing
functions together with parconstruct in Effpi, and connects the processes with channels.
6.3 Generating Eﬀpi Channels from Scribble Protocols
As previously mentioned, Effpiprocesses use channels to communicate, and the type of
the channel is reﬂected in the type of the process. However, our local types do not have any
channels; instead, they contain a partner role with which to communicate. This poses an
interesting challenge, and we explain the channel generation procedure in this section.
We draw attention to the generated code in Fig. 11 again, where we now focus on the
parameters C0in the generated types UandL. In the type U, the channel type C0needs to
be a subtype of OutChan[Read | Write] (Line 10), and we see the channel is used in the
output processes types, e.g. Out[C0, Read] (Line 12, note that output channels subtyping
is covariant on the payload type). Dually, in the type L, the channel type C0needs to be a
subtype of InChan[Read | Write] (Line 15), and we see the channel is used in the input
process type, i.e. InErr[C0, Read | Write, ..., ...] (Line 17).
Similarly, a channel c0is needed in the role-implementing functions uandlas arguments,
and the channel is used in processes send(c0, ...) andreceiveErr(c0) ... . Finally, in
the entry point, we create a bidirectional channel c0 = Channel[Read | Write]() (Line 46),
and pass it as an argument to the role-implementing functions uandl(Line 48), so that the
channel can be used to link two role-implementing processes together for communication.
Generating the channels correctly is crucial to the correctness of our approach, but
non-trivial since channels are implicit in the protocols. In order to do so, a simple approach is
to traverse each interaction in the global protocol, and assign a channel to each accordingly.
This simple approach would work for the example we show in Fig. 10; however, it would
not yield the correct result when merging occurs during projection, which we explain using24 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Table 1Overview of All Variants for Each Example.
Name Var. RComms. Crash Branches Max Cont. Len.
PingPong
R={p,q}(a)R 2 0 4
(b)∅ 2 2 4
Adder
R={p,q}(c)R 5 0 6
(d)∅ 5 5 6
TwoBuyer
R={p,q,r}(e)R 7 0 8
(f) {r}18 6 12
OAuth
R={c,a,s}(g)R 12 0 11
(h){s,a}21 8 11
(i) {s}26 13 11
(j)∅ 30 28 11
TravelAgency
R={c,a,s}(k)R 8 0 6
(l) {a,s}9 3 6
(m) {a} 9 4 6
DistLogger
R={l,c,i}(n)R 10 0 7
(o){i,c}15 2 7
(p) {i}16 4 7
CircBreaker
R={s,a,r}(q)R 18 0 10
(r){a,s}24 3 10
(s){a,s}23 3 11
an example. For clarity and convenience, we use annotated global and local types, where
we assign an identiﬁer for each interaction to signify the channel to use, and consider the
following global type: G=p0− →q:/braceleftBig
left.p1− →r:left.end,right.p2− →r:right.end/bracerightBig
.
The global type describes a simple protocol, where role pselects a label leftorright
toq, and qpasses on the same label to r. As a result, the projection on r(assuming
all roles reliable) should be a reception from qwith branches labelled leftorright, i.e.
p&1,2{left.end,right.end}. Here, we notice that the interaction between qandrshould
take place on a single channel, instead of two separate channels annotated 1and2.
Whenmerging behaviour occurs during projection, we need to use the same channel
in those interactions to achieve the correct behaviour. After traversing the global type
to annotate each interaction, we merge annotations involved in merges during projection.
Additional technical details are included in Appendix §G.
7 Evaluation
We evaluate our toolchain Teatrino from two perspectives: expressivity andfeasibility . For
expressivity, we use examples from session type literature, and extend them to include crash
handling behaviour using two patterns: failover and graceful failure. For feasibility, we show
that our tool generates Scalacode within negligible time.
We note that we do notevaluate the performance of the generated code. The generated
code uses the Effpiconcurrency library to implement protocols, and any performance
indication would depend and reﬂect on the performance of Effpi, instead of Teatrino .
Expressivity We evaluate our approach with examples in session type literature: PingPong ,
Adder,TwoBuyer [20], OAuth[32], TravelAgency [22], DistLogger [26], and CircBreaker [26].
Notably, the last two are inspired by real-world patterns in distributed computing. We giveA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 25
(a)(b)(c)(d)(e)(k)(l)(m)(n)(g)(o)(p)(f)(q)(h)(s)(r)(i)(j)00.511.5Time (ms)Parsing EﬀpiIR CodeGen
Figure 12 Average Generation Times for All Variants in Table 1.
details of the examples in Appendix §H.1.
We begin with the fully reliable version of the examples, and extend them to include
crash handling behaviour. Recall that our extended theory subsumes the original theory,
when all roles are assumed reliable. Therefore, the fully reliable versions can act both as a
sanity check, to ensure the code generation does not exclude good protocols in the original
theory, and as a baseline to compare against.
To add crash handling behaviour, we employ two patterns: failoverandgraceful failure .
In the former scenario, a crashed role has its functions taken over by another role, acting as a
substitute to the crashed role [2]. In the latter scenario, the protocol is terminated peacefully,
possibly involving additional messages for notiﬁcation purposes. Using the example from §2,
the fully reliable protocol in Eq. (1) is extended to one with graceful failure in Eq. (2).
We show a summary of the examples in Table 1. For each example, we give the set of
all rolesRand vary the set of reliable roles ( R). Each variant is given an identiﬁer (Var.),
and each example always has a fully reliable variant where R=R. We give the number of
communication interactions (Comms.), the number of crashbranches added (Crash Branches),
and the length of the longest continuation (Max Cont. Len.) in the given global type.
The largest of our examples in terms of concrete interactions is OAuth, with Variant (i)
having 26 interactions and (j)having 30 interactions. This represents a 2.17×and2.5×
increase over the size of the original protocol, and is a consequence of the conﬂuence of two
factors: the graceful failure pattern, and low degree of branching in the protocol itself. The
TwoBuyer Variant (f)represents the greatest increase ( 2.57×) in interactions, a result of
implementing the failover pattern. The CircBreaker variants are also notable in that they are
large in terms of both interactions and branching degree – both aﬀect generation times.
Feasibility In order to demonstrate the feasibility of our tool Teatrino , we give generation
times using our prototype for all protocol variants and examples, plotted in Fig. 12. We
show that Teatrino is able to complete the code generation within milliseconds, which does
not pose any major overhead for a developer.
In addition to total generation times, we report measurements for three main constituent
phases of Teatrino : parsing, EﬀpiIR generation, and code generation. EﬀpiIR generation
projects and transforms a parsed global type into an intermediate representation, which is
then used to generate concrete Scalacode.
For all variants, the code generation phase is the most expensive phase. This is likely
a consequence of traversing the given EﬀpiIR representation of a protocol twice – once for
local type declarations and once for role-implementing functions. More details on generation
time, including how they are measured, can be found in Appendix §H.2.26 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
8 Related Work
We summarise related work on both theory and implementations of session types with failure
handling, as well as other MPST implementations targeting Scalawithout failures.
We ﬁrst discuss closest related work [2,27,33,43], where multiparty session types are
extended to model crashes or failures. Both [33] and [27] are exclusively theoretical.
[33] proposes an MPST framework to model ﬁne-grained unreliability: each transmission
in a global type is parameterised by a reliability annotation, which can be one of unreliable
(sender/receiver can crash, and messages can be lost), weakly reliable (sender/receiver can
crash, messages are not lost), or reliable (no crashes or message losses). [43] utilises MPST as
a guidance for fault-tolerant distributed system with recovery mechanisms. Their framework
includes various features, such as sub-sessions, event-driven programming, dynamic role
assignments, and, most importantly, failure handling. [2] develops a theory of multiparty
session types with crash-stop failures: they model crash-stop failures in the semantics of
processes and session types, where the type system uses a model checker to validate type
safety. [27] follow a similar framework to [2]: they model an asynchronous semantics, and
support more patterns of failure, including message losses, delays, reordering, as well as link
failures and network partitioning. However, their typing system suﬀers from its genericity,
when type-level properties become undecidable [27, §4.4].
Other session type works on modelling failures can be brieﬂy categorised into two: using
aﬃne types or exceptions [13,26,29], and using coordinators or supervision [1,42]. The former
adapts session types to an aﬃnerepresentation, in which endpoints may cease prematurely;
the latter, instead, are usually reliant on one or more reliableprocesses that coordinate in
the event of failure. The works [1,29,42] are limited to theory.
[29] ﬁrst proposes the aﬃne approach to failure handling. Their extension is primarily
comprised of a cancel operator , which is semantically similar to our crash construct: it repres-
ents a process that has terminated early. [13] presents a concurrent λ-calculus based on [29],
with asynchronous session-typed communication and exception handling, and implements
their approach as parts of the Linkslanguage. [26] proposes a framework of aﬃnemultiparty
session types, and provides an implementation of aﬃne MPST in the Rustprogramming
language. They utilise the aﬃne type system and Resulttypes of Rust, so that the type
system enforces that failures are handled.
Coordinator model approaches [1,42] often incorporate interrupt blocks (or similar con-
structs) to model crashes and failure handling. [1] extends the standard MPST syntax with
optional blocks , representing regions of a protocol that are susceptible to communication fail-
ures. In their approach, if a process Pexpects a value from an optional block which fails, then
adefault value is provided to P, soPcan continue running. This ensures termination and
deadlock-freedom. Although this approach does not feature an explicit reliable coordinator
process, we describe it here due to the inherent coordination required for multiple processes
to start and end an optional block. [42] similarly extends the standard global type syntax
with atry-handle construct, which is facilitated by the presence of a reliable coordinator
process, and via a construct to specify reliable processes. When the coordinator detects a
failure, it broadcasts notiﬁcations to all remaining live processes; then, the protocol proceeds
according to the failure handling continuation speciﬁed as part of the try-handle construct.
Other related MPST implementations include [8,16,17]. [17] designs a framework for
MPST-guided, safe actor programming. Whilst the MPST protocol does not include any
failure handling, the actors may fail or raise exceptions, which are handled in a similar way to
what we summarise as the aﬃne technique. [8] revisits API generation techniques in ScalaA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 27
for MPST. In addition to the traditional local type/automata-based code generation [21,37],
they propose a new technique based on sets of pomsets, utilising Scala3 match types [3].
[16] presents Choral , a programming language for choreographies (multiparty protocols).
Choral supports the handling of local exceptions in choreographies, which can be used to
program reliable channels over unreliable networks, supervision mechanisms, etc.for fallible
communication. They utilise automatic retries to implement channel APIs.
9 Conclusion and Future Work
To overcome the challenge of accounting for failure handling in distributed systems using
session types, we propose Teatrino , a code generation toolchain. It is built on asynchronous
MPST with crash-stop semantics, enabling the implementation of multiparty protocols that
are resilient to failures. Desirable global type properties such as deadlock-freedom, protocol
conformance, and liveness are preserved by construction in typed processes, even in the
presence of crashes. Our toolchain Teatrino , extends Scribble andEffpito support
crash detection and handling, providing developers with a lightweight way to leverage our
theory. The evaluation of Teatrino demonstrates that it can generate Scalacode with
minimal overhead, which is made possible by the guarantees provided by our theory.
This work is a new step towards modelling and handling real-world failures using session
types, bridging the gap between their theory and applications. As future work, we plan to
studys diﬀerent crash models (e.g. crash-recover) and failures of other components (e.g. link
failures). These further steps will contribute to our long-term objective of modelling and
type-checking well-known consensus algorithms used in large-scale distributed systems.
References
1Manuel Adameit, Kirstin Peters, and Uwe Nestmann. Session types for link failures. In Ahmed
BouajjaniandAlexandraSilva, editors, Formal Techniques for Distributed Objects, Components,
and Systems - 37th IFIP WG 6.1 International Conference, FORTE 2017, Held as Part of
the 12th International Federated Conference on Distributed Computing Techniques, DisCoTec
2017, Neuchâtel, Switzerland, June 19-22, 2017, Proceedings , volume 10321 of Lecture Notes
in Computer Science , pages 1–16. Springer, 2017. doi:10.1007/978-3-319-60225-7\_1 .
2Adam D. Barwell, Alceste Scalas, Nobuko Yoshida, and Fangyi Zhou. Generalised Multiparty
Session Types with Crash-Stop Failures. In Bartek Klin, Sławomir Lasota, and Anca Muscholl,
editors,33rd International Conference on Concurrency Theory (CONCUR 2022) , volume
243 ofLeibniz International Proceedings in Informatics (LIPIcs) , pages 35:1–35:25, Dagstuhl,
Germany, 2022. Schloss Dagstuhl – Leibniz-Zentrum für Informatik. URL: https://drops.
dagstuhl.de/opus/volltexte/2022/17098 ,doi:10.4230/LIPIcs.CONCUR.2022.35 .
3Olivier Blanvillain, Jonathan Immanuel Brachthäuser, Maxime Kjaer, and Martin Odersky.
Type-level programming with match types. Proc. ACM Program. Lang. , 6(POPL):1–24, 2022.
doi:10.1145/3498698 .
4Olav Bunte, Jan Friso Groote, Jeroen J. A. Keiren, Maurice Laveaux, Thomas Neele, Erik P.
de Vink, Wieger Wesselink, Anton Wijs, and Tim A. C. Willemse. The mCRL2 Toolset
for Analysing Concurrent Systems. In Tomáš Vojnar and Lijun Zhang, editors, Tools and
Algorithms for the Construction and Analysis of Systems , pages 21–39, Cham, 2019. Springer
International Publishing.
5Christian Cachin, Rachid Guerraoui, and Luís E. T. Rodrigues. Introduction to Reliable and
Secure Distributed Programming (2. ed.) . Springer, 2011. doi:10.1007/978-3-642-15260-3 .
6David Castro-Perez, Raymond Hu, Sung-Shik Jongmans, Nicholas Ng, and Nobuko Yoshida.
Distributed programming using role-parametric session types in go: statically-typed endpoint28 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
APIs for dynamically-instantiated communication structures. Proc. ACM Program. Lang. ,
3(POPL):29:1–29:30, 2019. doi:10.1145/3290342 .
7Tushar Deepak Chandra and Sam Toueg. Unreliable Failure Detectors for Reliable Distributed
Systems. J. ACM, 43(2):225–267, March 1996. doi:10.1145/226643.226647 .
8Guillermina Cledou, Luc Edixhoven, Sung-Shik Jongmans, and José Proença. API Generation
for Multiparty Session Types, Revisited and Revised Using Scala 3. In Karim Ali and
Jan Vitek, editors, 36th European Conference on Object-Oriented Programming (ECOOP
2022), volume 222 of Leibniz International Proceedings in Informatics (LIPIcs) , pages 27:1–
27:28, Dagstuhl, Germany, 2022. Schloss Dagstuhl – Leibniz-Zentrum für Informatik. URL:
https://drops.dagstuhl.de/opus/volltexte/2022/16255 .
9Zak Cutner, Nobuko Yoshida, and Martin Vassor. Deadlock-Free Asynchronous Message
Reordering in Rust with Multiparty Session Types. In 27th ACM SIGPLAN Symposium on
Principles and Practice of Parallel Programming , volume abs/2112.12693 of PPoPP ’22 , pages
261–246. ACM, 2022. doi:10.1145/3503221.3508404 .
10Romain Demangeon, Kohei Honda, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida.
Practical interruptible conversations: distributed dynamic veriﬁcation with multiparty ses-
sion types and Python. Formal Methods Syst. Des. , 46(3):197–225, 2015. doi:10.1007/
s10703-014-0218-8 .
11Romain Demangeon and Nobuko Yoshida. On the Expressiveness of Multiparty Sessions. In
Prahladh Harsha and G. Ramalingam, editors, 35th IARCS Annual Conference on Foundations
of Software Technology and Theoretical Computer Science (FSTTCS 2015) , volume 45 of
Leibniz International Proceedings in Informatics (LIPIcs) , pages 560–574, Dagstuhl, Germany,
2015. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. URL: http://drops.dagstuhl.de/
opus/volltexte/2015/5621 ,doi:10.4230/LIPIcs.FSTTCS.2015.560 .
12Pierre-Malo Deniélou and Nobuko Yoshida. Multiparty Compatibility in Communicating
Automata: Characterisation and Synthesis of Global Session Types. In 40th International
Colloquium on Automata, Languages and Programming , volume 7966 of LNCS, pages 174–186,
Berlin, Heidelberg, 2013. Springer. doi:10.1007/978-3-642-39212-2\_18 .
13Simon Fowler, Sam Lindley, J. Garrett Morris, and Sára Decova. Exceptional Asynchronous
Session Types: Session Types without Tiers. Proc. ACM Program. Lang. , 3(POPL):28:1–28:29,
2019. doi:10.1145/3290341 .
14Silvia Ghilezan, Svetlana Jaksic, Jovanka Pantovic, Alceste Scalas, and Nobuko Yoshida.
Precise subtyping for synchronous multiparty sessions. J. Log. Algebraic Methods Program. ,
104:127–173, 2019. doi:10.1016/j.jlamp.2018.12.002 .
15Silvia Ghilezan, Jovanka Pantović, Ivan Prokić, Alceste Scalas, and Nobuko Yoshida. Precise
Subtyping for Asynchronous Multiparty Sessions. Proc. ACM Program. Lang. , 5(POPL),
January 2021. doi:10.1145/3434297 .
16Saverio Giallorenzo, Fabrizio Montesi, and Marco Peressotti. Choreographies as objects. CoRR,
abs/2005.09520, 2020. URL: https://arxiv.org/abs/2005.09520 ,arXiv:2005.09520 .
17Paul Harvey, Simon Fowler, Ornela Dardha, and Simon J. Gay. Multiparty Session Types
for Safe Runtime Adaptation in an Actor Language. In Anders Møller and Manu Sridharan,
editors,35th European Conference on Object-Oriented Programming (ECOOP 2021) , volume
194 ofLeibniz International Proceedings in Informatics (LIPIcs) , pages 10:1–10:30, Dagstuhl,
Germany, 2021. Schloss Dagstuhl – Leibniz-Zentrum für Informatik. URL: https://drops.
dagstuhl.de/opus/volltexte/2021/14053 ,doi:10.4230/LIPIcs.ECOOP.2021.10 .
18KoheiHonda, VascoT.Vasconcelos, andMakotoKubo. Languageprimitivesandtypediscipline
for structured communication-based programming. In Chris Hankin, editor, Programming
Languages and Systems , pages 122–138, Berlin, Heidelberg, 1998. Springer Berlin Heidelberg.
doi:10.1007/BFb0053567 .
19Kohei Honda, Nobuko Yoshida, and Marco Carbone. Multiparty Asynchronous Session Types.
In35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages ,
pages 273–284. ACM, 2008. doi:10.1145/1328897.1328472 .A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 29
20Kohei Honda, Nobuko Yoshida, and Marco Carbone. Multiparty Asynchronous Session Types.
Journal of the ACM , 63:1–67, 2016. doi:10.1145/2827695 .
21Raymond Hu and Nobuko Yoshida. Hybrid Session Veriﬁcation through Endpoint API
Generation. In 19th International Conference on Fundamental Approaches to Software
Engineering , volume 9633 of LNCS, pages 401–418, Berlin, Heidelberg, 2016. Springer.
doi:10.1007/978-3-662-49665-7\_24 .
22Raymond Hu, Nobuko Yoshida, and Kohei Honda. Session-Based Distributed Programming
in Java. In Jan Vitek, editor, ECOOP 2008 - Object-Oriented Programming, 22nd European
Conference, Paphos, Cyprus, July 7-11, 2008, Proceedings , volume 5142 of Lecture Notes in
Computer Science , pages 516–541. Springer, 2008. doi:10.1007/978-3-540-70592-5_22 .
23Keigo Imai, Rumyana Neykova, Nobuko Yoshida, and Shoji Yuen. Multiparty Session Program-
ming with Global Protocol Combinators. In 34th European Conference on Object-Oriented
Programming , volume 166 of LIPIcs, pages 9:1–9:30. Schloss Dagstuhl–Leibniz-Zentrum f"ur
Informatik, 2020. doi:10.4230/LIPIcs.ECOOP.2020.9 .
24Dimitrios Kouzapas, Ornela Dardha, Roly Perera, and Simon J. Gay. Typechecking protocols
with mungo and stmungo. In James Cheney and Germán Vidal, editors, Proceedings of the 18th
International Symposium on Principles and Practice of Declarative Programming, Edinburgh,
United Kingdom, September 5-7, 2016 , pages 146–159. ACM, 2016. doi:10.1145/2967973.
2968595.
25Nicolas Lagaillardie, Rumyana Neykova, and Nobuko Yoshida. Implementing Multiparty
Session Types in Rust. In Simon Bliudze and Laura Bocchi, editors, Coordination Models and
Languages - 22nd IFIP WG 6.1 International Conference, COORDINATION 2020, Held as
Part of the 15th International Federated Conference on Distributed Computing Techniques,
DisCoTec 2020, Valletta, Malta, June 15-19, 2020, Proceedings , volume 12134 of Lecture Notes
in Computer Science , pages 127–136. Springer, 2020. doi:10.1007/978-3-030-50029-0\_8 .
26Nicolas Lagaillardie, Rumyana Neykova, and Nobuko Yoshida. Stay Safe Under Panic: Aﬃne
Rust Programming with Multiparty Session Types. In Karim Ali and Jan Vitek, editors,
36th European Conference on Object-Oriented Programming (ECOOP 2022) , volume 222 of
Leibniz International Proceedings in Informatics (LIPIcs) , pages 4:1–4:29, Dagstuhl, Germany,
2022. Schloss Dagstuhl – Leibniz-Zentrum für Informatik. URL: https://drops.dagstuhl.
de/opus/volltexte/2022/16232 .
27Matthew Alan Le Brun and Ornela Dardha. MAG π: Types for Failure-Prone Communication.
2023. To appear in ESOP ’23. URL: https://arxiv.org/abs/2301.10827 .
28Anson Miu, Francisco Ferreira, Nobuko Yoshida, and Fangyi Zhou. Communication-Safe Web
Programming in TypeScript with Routed Multiparty Session Types. In International Confer-
ence on Compiler Construction , CC, pages 94–106, 2021. doi:10.1145/3446804.3446854 .
29Dimitris Mostrous and Vasco T. Vasconcelos. Aﬃne Sessions. Logical Methods in Computer
Science, Volume 14, Issue 4, November 2018. URL: https://lmcs.episciences.org/4973 ,
doi:10.23638/LMCS-14(4:14)2018 .
30Rumyana Neykova and Nobuko Yoshida. Multiparty Session Actors. Logical Methods in
Computer Science , 13:1–30, 2017. doi:10.23638/LMCS-13(1:17)2017 .
31Rumyana Neykova and Nobuko Yoshida. Featherweight Scribble , pages 236–259. Springer
International Publishing, Cham, 2019. doi:10.1007/978-3-030-21485-2_14 .
32Rumyana Neykova, Nobuko Yoshida, and Raymond Hu. SPY: Local Veriﬁcation of Global
Protocols. In Axel Legay and Saddek Bensalem, editors, Runtime Veriﬁcation , pages 358–363,
Berlin, Heidelberg, 2013. Springer Berlin Heidelberg. doi:10.1007/978-3-642-40787-1\_25 .
33Kirstin Peters, Uwe Nestmann, and Christoph Wagner. Fault-tolerant multiparty session
types. In Mohammad Reza Mousavi and Anna Philippou, editors, Formal Techniques for Dis-
tributed Objects, Components, and Systems , pages 93–113, Cham, 2022. Springer International
Publishing.
34Benjamin C. Pierce. Types and Programming Languages . The MIT Press, 1st edition, 2002.30 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
35Davide Sangiorgi. Introduction to Bisimulation and Coinduction . Cambridge University Press,
2011. doi:10.1017/CBO9780511777110 .
36Alceste Scalas, Ornela Dardha, Raymond Hu, and Nobuko Yoshida. A Linear Decomposition
of Multiparty Sessions for Safe Distributed Programming. In 31st European Conference on
Object-Oriented Programming , volume 74 of LIPIcs, pages 24:1–24:31. Schloss Dagstuhl, 2017.
doi:10.4230/LIPIcs.ECOOP.2017.24 .
37Alceste Scalas, Ornela Dardha, Raymond Hu, and Nobuko Yoshida. A Linear Decomposition
of Multiparty Sessions for Safe Distributed Programming. In Peter Müller, editor, 31st
European Conference on Object-Oriented Programming (ECOOP 2017) , volume 74 of Leibniz
International Proceedings in Informatics (LIPIcs) , pages 24:1–24:31, Dagstuhl, Germany, 2017.
Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. URL: http://drops.dagstuhl.de/opus/
volltexte/2017/7263 ,doi:10.4230/LIPIcs.ECOOP.2017.24 .
38Alceste Scalas and Nobuko Yoshida. Less is More: Multiparty Session Types Revisited. Proc.
ACM Program. Lang. , 3(POPL):30:1–30:29, January 2019. doi:10.1145/3290343 .
39Alceste Scalas, Nobuko Yoshida, and Elias Benussi. Eﬀpi: veriﬁed message-passing programs in
Dotty. In Jonathan Immanuel Brachthäuser, Sukyoung Ryu, and Nathaniel Nystrom, editors,
Proceedings of the Tenth ACM SIGPLAN Symposium on Scala, Scala@ECOOP 2019, London,
UK, July 17, 2019 , pages 27–31. ACM, 2019. doi:10.1145/3337932.3338812 .
40Alceste Scalas, Nobuko Yoshida, and Elias Benussi. Verifying Message-Passing Programs with
Dependent Behavioural Types. In Proceedings of the 40th ACM SIGPLAN Conference on
Programming Language Design and Implementation , PLDI 2019, pages 502–516, New York,
NY, USA, 2019. Association for Computing Machinery. doi:10.1145/3314221.3322484 .
41Rob van Glabbeek, Peter Höfner, and Ross Horne. Assuming Just Enough Fairness to make
Session Types Complete for Lock-freedom. In 36th Annual ACM/IEEE Symposium on Logic
in Computer Science, LICS 2021, Rome, Italy, June 29 - July 2, 2021 , pages 1–13. IEEE,
2021. doi:10.1109/LICS52264.2021.9470531 .
42Malte Viering, Tzu-Chun Chen, Patrick Eugster, Raymond Hu, and Lukasz Ziarek. A Typing
Discipline for Statically Veriﬁed Crash Failure Handling in Distributed Systems. In Amal
Ahmed, editor, Programming Languages and Systems , pages 799–826, Cham, 2018. Springer
International Publishing.
43Malte Viering, Raymond Hu, Patrick Eugster, and Lukasz Ziarek. A Multiparty Session
Typing Discipline for Fault-Tolerant Event-Driven Distributed Programming. Proc. ACM
Program. Lang. , 5(OOPSLA), October 2021. doi:10.1145/3485501 .
44Nobuko Yoshida, Raymond Hu, Rumyana Neykova, and Nicholas Ng. The scribble protocol
language. In 8th International Symposium on Trustworthy Global Computing - Volume
8358, TGC 2013, pages 22–41, Berlin, Heidelberg, 2014. Springer-Verlag. doi:10.1007/
978-3-319-05119-2_3 .
45Nobuko Yoshida, Fangyi Zhou, and Francisco Ferreira. Communicating Finite State Machines
and an Extensible Toolchain for Multiparty Session Types. In Evripidis Bampis and Aris
Pagourtzis, editors, Fundamentals of Computation Theory , pages 18–35, Cham, 2021. Springer
International Publishing.
46Fangyi Zhou, Francisco Ferreira, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida.
Statically Veriﬁed Reﬁnements for Multiparty Protocols. Proc. ACM Program. Lang. ,
4(OOPSLA):148:1–148:30, 2020. doi:10.1145/3428216 .A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 31
h1·(q1,m1(v1))·(q2,m2(v2))·h2≡h1·(q2,m2(v2))·(q1,m1(v1))·h2(ifq1/negationslash=q2)
/epsilon1·h≡h h·/epsilon1≡h h 1·(h2·h3)≡(h1·h2)·h3µX.P≡P{µX.P/X}
p/triangleleft0|p/triangleleft/epsilon1|M≡M M 1|M 2≡M 2|M 1 (M1|M 2)|M 3≡M 1|(M2|M 3)
P≡Qandh1≡h2=⇒ p/triangleleftP|p/trianglelefth1|M≡ p/triangleleftQ|p/trianglelefth2|M
Figure 13 Structural congruence rules for queues, processes, and sessions.
A Structural Congruence
The congruence relation of our session calculus is formalised in Fig. 13.
B Auxiliary Deﬁnitions
B.1 Well-Annotated Global Types
We introduce an auxiliary concept of well-annotated global types in Def. 28, as a consistency
requirement for crash annotations  in a global type G, and the set of crashed roles C, and a
ﬁxed set of reliable roles R. We show that well-annotatedness w.r.t. Ris preserved by global
type reductions in Lem. 29. It follows that, a global type Gwithout runtime construct is
trivially well-annotated, and all reduct global types G− →∗
RG/primeare also well-annotated. The
proof of Lem. 29 is available in Appendix §E.3.
IDeﬁnition 28 (Well-Annotated Global Types) .A global type Gwith crashed roles Cis
well-annotated w.r.t. a (ﬁxed) set of reliable roles R, iﬀ:
(WA1) No reliable roles are crashed, roles (G)∩R=∅; and,
(WA2) All roles with crash annotations are in the crashed set, roles (G)⊆C; and,
(WA3) A role cannot be live and crashed simultaneously, roles(G)∩roles (G) =∅.
ILemma 29 (Preservation of Well-Annotated Global Types) .If/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright, and
/angbracketleftC;G/angbracketrightis well-annotated w.r.t. R, then/angbracketleftC/prime;G/prime/angbracketrightis also well-annotated w.r.t. R.
B.2 Local Type Subtyping
We deﬁne a subtyping relation6on local types in Def. 30. Our subtyping relation is mostly
standard [38, Def. 2.5], except for the ( highlighted ) addition of the rule [Sub- stop]and extra
requirements in [Sub- &]. In [Sub- &], we add two additional requirements: (1)the supertype
cannot be a “pure” crash handling branch; and (2)if the subtype has a crash handling
branch, then the supertype must also have one. For simplicity, we do not consider subtyping
on basic types B.
IDeﬁnition 30 (Subtyping) .The subtyping relation 6is coinductively deﬁned:
end6end[Sub- end]∀i∈I Ti6T/prime
i{mk|k∈I}/negationslash={crash}@j∈J:mj=crash
p&{mi(Bi).Ti}i∈I∪J6p&{mi(Bi).T/prime
i}i∈I[Sub- &]
stop6stop[Sub- stop]∀i∈I Ti6T/prime
i
p⊕{mi(Bi).Ti}i∈I6p⊕{mi(Bi).T/prime
i}i∈I∪J[Sub-⊕]
T{µt.T/t}6T/prime
µt.T6T/prime[Sub-µL]T6T/prime/braceleftbig
µt.T/prime/t/bracerightbig
T6µt.T/prime[Sub-µR]32 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
C Additional Examples
IExample 31. We now illustrate our operational semantics of sessions with an example.
Consider the session:
p/triangleleftP|p/triangleleft/epsilon1|q/triangleleftQ|q/triangleleft/epsilon1
whereP=q!m/angbracketleft“abc”/angbracketright./summationtext/braceleftbigg
q?m/prime(x).0
q?crash.0/bracerightbigg
andQ=/summationtext/braceleftbigg
p?m(x).p!m/prime/angbracketleft42/angbracketright.0
p?crash.0/bracerightbigg
.
In this session, the process Qforqreceives a message sent from ptoq; the process Pfor
psends a message from ptoq, and then receives a message sent from qtop.
On a successful reduction (without crashes), we have:
p/triangleleftP|p/triangleleft/epsilon1|q/triangleleftQ|q/triangleleft/epsilon1→ p/triangleleft/summationtext/braceleftbigg
q?m/prime(x).0
q?crash.0/bracerightbigg
|p/triangleleft/epsilon1|q/triangleleftQ|q/triangleleft(p,m(“abc”))
→ p/triangleleft/summationtext/braceleftbigg
q?m/prime(x).0
q?crash.0/bracerightbigg
|p/triangleleft/epsilon1|q/triangleleftp!m/prime/angbracketleft42/angbracketright.0|q/triangleleft/epsilon1
→ p/triangleleft/summationtext/braceleftbigg
q?m/prime(x).0
q?crash.0/bracerightbigg
|p/triangleleft(q,m/prime(42))|q/triangleleft0|q/triangleleft/epsilon1
→ p/triangleleft0|p/triangleleft/epsilon1|q/triangleleft0|q/triangleleft/epsilon1
LetR=∅(i.e. each role is unreliable). Suppose that Pcrashes before sending, which leads
to the reduction:
p/triangleleftP|p/triangleleft/epsilon1|q/triangleleftQ|q/triangleleft/epsilon1→Rp/triangleleft |p/triangleleft/circledivide|q/triangleleftQ|q/triangleleft/epsilon1→p/triangleleft |p/triangleleft/circledivide|q/triangleleft0|q/triangleleft/epsilon1
We can observe that when the output (sending) process Plocated at an unreliable role p
crashes (by [r- ]),palso crashes ( p/triangleleft ), with an unavailable incoming message queue ( p/triangleleft/circledivide).
Subsequently, the input (receiving) process Qlocated at qcan detect and handle the crash
by[r-rcv-⊙]via its handling branch.
IExample 32. We remove role Cin the global type Gin (2) (deﬁned in §2).
G C=L→I:trigger.C  I:crash.I→L:fatal.end
Role Cnow carries a crash annotation  in the resulting global type, denoting it has crashed.
Crash annotations change the reductions available for global types.
IExample 33. Recall the local types of the Simpler Logging example in §2:
TC=I⊕read.I&report (log).endTL=I⊕trigger.I&/braceleftbigg
fatal.end
read.I⊕report (log).end/bracerightbigg
TI=L&trigger.C&/braceleftbigg
read.L⊕read.L&report (log).C⊕report (log).end
crash.L⊕fatal.end/bracerightbigg
The conﬁguration Γ;∆, where Γ=C⊿TC,L⊿TL,I⊿TIand∆=∆∅, is{L,I}-safe. This can
be veriﬁed by checking its possible reductions. For example, in the case where Ccrashes
immediately, we have:A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 33
Γ; ∆C −→ Γ[C/mapsto→stop]; ∆[·,C/mapsto→/circledivide]
L⊕I:trigger−−−−−−−→ Γ[C/mapsto→stop][L/mapsto→I&/braceleftbigg
fatal.end
read.I⊕report (log).end/bracerightbigg
]; ∆[·,C/mapsto→/circledivide][L,I/mapsto→trigger ]
I&L:trigger−−−−−−−→ Γ[C/mapsto→stop][L/mapsto→I&/braceleftbigg
fatal.end
read.I⊕report (log).end/bracerightbigg
]
[I/mapsto→C&/braceleftbigg
read.L⊕read.L&report (log).C⊕report (log).end
crash.L⊕fatal.end/bracerightbigg
]; ∆[·,C/mapsto→/circledivide]
I⊙C−−→ Γ[C/mapsto→stop][L/mapsto→I&/braceleftbigg
fatal.end
read.I⊕report (log).end/bracerightbigg
][I/mapsto→L⊕fatal.end]; ∆[·,C/mapsto→/circledivide]
I⊕L:fatal−−−−−−→ Γ[C/mapsto→stop][L/mapsto→I&/braceleftbigg
fatal.end
read.I⊕report (log).end/bracerightbigg
][I/mapsto→end];
∆[·,C/mapsto→/circledivide][I,L/mapsto→fatal ]
L&I:fatal−−−−−−→ Γ[C/mapsto→stop][L/mapsto→end][I/mapsto→end]; ∆[·,C/mapsto→/circledivide]
and each reductum satisﬁes all clauses of Def. 14. The cases where Ccrashes after sending
thereadingmessage to Iare similar. There are no other crash reductions to consider, since
both Land Iare assumed to be reliable. The cases where no crashes occur are similar as
well, except that [Γ-⊙]and [Γ- ]are not applied in the non-crash reductions.
IExample 34. Consider our Simpler Logging example (§2 and Ex. 15). Speciﬁcally, consider
the processes that act as the roles C,L, and Irespectively:
PC=I!read.I?report (x).0PL=I!trigger./summationtext/braceleftbigg
I?fatal.0
I?read.I!report/angbracketleftlog/angbracketright.0/bracerightbigg
PI=L?trigger./summationtext/braceleftbigg
C?read.L!read.L?report (x).C!report/angbracketleftlog/angbracketright.0
C?crash.L!fatal.0/bracerightbigg
and message queues hC=hL=hI=/epsilon1, and the conﬁguration Γ; ∆as in Ex. 15.
ProcessPC(resp.PL,PI) has the type Γ(C)(resp. Γ(L),Γ(I)), and queue hC(resp.hL,
hI) has the type ∆(−,C)(resp. ∆(−,L),∆(−,I)), which can be veriﬁed in the standard
way. Then, together with the association Γ; ∆/subsetsqequal{L,I}/angbracketleft∅;Gs/angbracketright, we can use [t-sess]to assert
that the session C/triangleleftP C|C/trianglelefthC|L/triangleleftP L|L/trianglelefthL|I/triangleleftP I|I/trianglelefthIis governed by the global
type/angbracketleft∅;Gs/angbracketright. If we follow a crash reduction, e.g. by the rule [r- ], the session evolves as
C/triangleleftPC|C/trianglelefthC|L/triangleleftPL|L/trianglelefthL|I/triangleleftPI|I/trianglelefthI→RC/triangleleft |C/triangleleft/circledivide|L/triangleleftPL|L/trianglelefthL|I/triangleleftPI|I/trianglelefthI,
where, by [t- ],PCis typed by stop, andhCis typed by/circledivide.
D Additional Related Work
Peters et al. [33]propose an MPST framework to model ﬁne-grained unreliability. In
their work, each transmission in a global type is parameterised by a reliability annotation,
which can be one of unreliable (sender/receiver can crash, and messages can be lost), weakly
reliable (sender/receiver can crash, messages are not lost), or reliable (no crashes or message
losses). The design choice taken in our work roughly falls under weakly reliable in their work,
where a crashhandling branch (in their work, a default branch) needs to be present to handle
failures. In our work, the reliability assumptions operate on a coarse level, but nonetheless
areconsistent within a given global type – if a role pis assumed reliable, p∈R, then it
does not crash for the duration of the protocol, and vice versa. Therefore, in a transmission
p→q, our model allows oneof the two roles to be unreliable, whereas their work does not
permit the ‘mixing’ of reliability of sending and receiving roles.
Viering et al. [43]utilise MPST as a guidance for fault-tolerant distributed system
with recovery mechanisms. Their framework includes various features, such as sub-sessions,
event-driven programming, dynamic role assignments, and most importantly failure handling.
Our work handles unreliability in distributed programming, with the following diﬀerences:34 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
1.Failure detection assumptions andmodelsare diﬀerent: in our work, we assume a perfect
failure detector, where all detected crashes are genuine. Their work uses a less strict
assumption to allow false suspicions . This diﬀerence subsequently gives rise to how failures
are handled in both approaches: in our work, we use a special crashhandling branch in
global types to specify how the global protocol should progress after a crash has been
detected. In contrast, they use a try-catch construct in global types. In such a try-catch
construct, crash detection within a sub-session G1is speciﬁed G1with p@q. G2, where
G2is a global type for failure handling (where pcannot occur), and qis amonitor that
monitors pfor possible failures. Moreover, the well-formedness condition (2) in [43, §4.1]
requires the ﬁrst message in G2to be a message broadcast of failure notiﬁcation from the
monitor qto all roles participating in the sub-session (except the crashed role p).
On this matter, we consider our framework more ﬂexiblewhen detecting and handling
crashes: every communication construct can have a crash handling branch (when the
receiver is not assumed reliable), and the failure broadcast is not necessary (failure
detection only occurs when receiving from a crashed role).
2.Themergeoperators, used when projecting global types to obtain local types, are diﬀerent:
we use a more expressive fullmerge operator (Def. 3), whereas they use a plainmerge
operator, i.e. requiring all continuations to project to the samelocal type.
3.Reliability assumptions are diﬀerent: in our work, we support a range of assumptions
from every role being unreliable, to totally reliable (as in the literature). In their work,
they require at least one reliable role, because they use a monitoring tree for detecting
crashes. Our work allows a role to detect the crash of its communication partner during
reception, thus requiring neither such trees nor reliable roles.
4.They provide a toolchain for implement fault-tolerant protocols targeting Scala. Spe-
ciﬁcally, they use an event-driven style of API, in a similar style to [46], in contrast to
previous work in Scala[37]. We instead use the Effpilibrary, which ﬁts our needs to
encode local types, and it can be easily adapted to implement crash detection.
Barwell et al. [2]develop a theory of multiparty session types with crash-stop failures.
Their theory models crash-stop failures in the semantics of processes and session types, where
the type system uses a model checker to validate type safety. Our theory follows a similar
model of crash-stop failures, but diﬀers in the following:
1.We model an asynchronous (message-passing) semantics, whereas they model a synchron-
ous (rendezvous) semantics. We focus on the asynchronous systems, where a message can
be buﬀered while in transit, as most of the interactions in the real distributed world are
asynchronous;
2.We follow a top-down methodology, beginning with protocol speciﬁcation using global
types, whereas they follow [38] to analyse only local types. Our method dispenses with
the need to use a model checker. More speciﬁcally, it is not feasible to model check
asynchronous systems with buﬀers, since the model may be inﬁnite [38, Appendix §G].
3.We present an toolkit in our work to implement multiparty session type APIs that
can handle crash-stop failures in Scala, whereas they do not produce any APIs for
end-users to program with, as their toolchain mainly concerns with validating types for
safety and liveness properties via model-checking. Their framework cannot be scaled
to real distributed systems since model-checking does not allow veriﬁcation of inﬁnite
asynchronous queues.
Le Brun and Dardha [27] follow a similar framework to [2]. They model an asyn-
chronous semantics, and support more patterns of failure, including message losses, delays,
reordering, as well as link failures and network partitioning. However, their typing systemA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 35
suﬀers from its genericity, when type-level properties become undecidable [27, §4.4]. Our
work uses global types for guidance, and recovers decidability of properties at a small expense
of expressivity.
Mostrous and Vasconcelos [29] ﬁrst proposed the aﬃne approach to failure handling.
They present a π-calculus with aﬃne binary sessions (i.e. limited to two participants) and
concomitant reduction rules that represent a minimal extension to standard (binary) session
types. Their extension is primarily comprised of a cancel operator , which is semantically
similar to our crash construct: it represents a process that has terminated early. Besides
these similarities, our work diﬀers from [29] in several ways:
1.We address multiparty protocols and sessions rather than binary session types;
2.In [29], a cancel operator can have an arbitrary session type; consequently, crashes are
not visible at the type level. Instead, we type crashed session endpoints with the special
type stop, which lets us model crashes in the type semantics, and helps us in ensuring
that a process implements its failure handling as expected in its (global or local) type;
3.The reduction rules of [29] do not permit a process to terminate early arbitrarily: cancel-
lations must be raised explicitly by the programmer (or automatically by attempting to
receive messages from crashed endpoints);
4.Finally, cancellations in [29] may be caught and handled via a do-catch construct. This
construct catches only the ﬁrst cancellation and cannot be nested, thus providing little
help in handling failure across multiple roles. Our global and local types seamlessly
support protocols where the failure of a role is detected (and handled) while handling the
failure of another role.
Fowler et al. [13]present a concurrent λ-calculus, EGV, with asynchronous session-typed
communication and exception handling, and implement their approach as parts of the Links
language. Their approach is based on [29], and therefore shares many of the same diﬀerences
to our approach: the use of the cancel operator and binary session types, and the lack of
a reduction rule enabling a process to crash arbitrarily; the cancel operator used in EGV
takes an arbitrary session type – whereas we reﬂect the crashed status with the dedicated
stoptype. Similar to our work, [13] has asynchronous communication channels: messages are
queued when sent, and delivered at a later stage.
Lagaillardie et al. [26]propose a framework of aﬃnemultiparty session types, and provide
an implementation of aﬃne MPST in the Rustprogramming language. They utilise the
aﬃne type system and Resulttypes of Rust, so that the type system enforces that failures
are handled. In their system, a multiparty session can terminate prematurely. While their
theory can be used to model crash-stop failures, such failures are not built in the semantics,
so manual encoding of failures is necessary. Moreover, there is no way to recover from a
cancellation (i.e. failure) besides propagating the cancellation. In our work, we provide
the ability to follow a diﬀerent protocol when a crash is detected, which gives rise to more
ﬂexibility and expressivity.
Coordinator model approaches [1,42] often incorporate interrupt blocks (or similar con-
structs) to model crashes and failure handling.
Adameit et al. [1]extend the standard MPST syntax with optional blocks , representing
regions of a protocol that are susceptible to communication failures. In their approach, if a
processPexpects a value from an optional block which fails, then a default value is provided
toP, soPcan continue running. This ensures termination and deadlock-freedom. Although
this approach does not feature an explicit reliable coordinator process, we describe it here
due to the inherent coordination required for multiple processes to start and end an optional36 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
block. Our approach diﬀers in three key ways:
1.we model crash-stop process failures instead of impermanent link failures;
2.we extend the semantics of communications in lieu of introducing a new syntactic construct
to enclose the potentially crashing regions of a protocol. Our global type projections
and typing context safety ensure that crash detection is performed at every pertinent
communication point;
3.we allow crashes to signiﬁcantly aﬀect the evolution of protocols: our global and local
types can have crash detection branches specifying signiﬁcantly diﬀerent behaviours w.r.t.
non-crashing executions. Conversely, the approach in [1] does not discriminate between
the presence and absence of failures: both have the same protocol in the optional block’s
continuation.
Viering et al. [42]similarly extend the standard global type syntax with a try-handle
construct, which is facilitated by the presence of a reliable coordinator process, and via a
construct to specify reliable processes. When the coordinator detects a failure, it broadcasts
notiﬁcations to all remaining live processes; then, the protocol proceeds according to the
failure handling continuation speciﬁed as part of the try-handle construct. Our approach
and[42]shareseveralmodellingchoices: crash-stopsemantics, perfectlinks, andthepossibility
of specifying reliable processes. However, unlike [42], our approach does notdepend on
a reliable coordinator that broadcasts failure notiﬁcations: all roles in a protocol can be
unreliable, all processes may crash.
Besides the diﬀerences discussed above, we decided not to adopt coordinator processes nor
failurebroadcastsinordertoavoidtheirinherentdrawbacks. Theuseofacoordinatorrequires
additional run-time resources and increases the overall complexity of a distributed system.
Furthermore, the broadcasting of failure notiﬁcations introduces an eﬀective synchronisation
point for all roles, with additional overheads. Such synchronisation points may also make it
harder to extend the theory to support scenarios with unreliable communication.
Other related MPST implementations include [8,17]. Harvey et al. [17]design a
framework for MPST-guided, safe actor programming. Whilst the MPST protocol does not
include any failure handling, the actors may fail or raise exceptions, which are handled in a
similar way to what we summarise as the aﬃne technique. Cledou et al. [8]revisit API
generation techniques in Scalafor MPST. In addition to the traditional local type/automata-
based code generation [21,37], they propose a technique based on sets of pomsets, utilising
match types [3] in Scala3. Our approach sticks to the traditional approach guided by local
types, but also utilises match types. Whereas the global and local types in their work allow
for sequential composition (i.e. semi-colon operator ;), we opt to stick to traditional MPST
for simplicity, since the main goal of our work is to model crash-stop failures.
Giallorenzo et al. [16]present Choral , a programming language for choreographies
(multiparty protocols). Choral supports the handling of local exceptions in choreographies,
which can be used to program reliable channels over unreliable networks, supervision mech-
anisms, and other methods for fallible communication. They utilise automatic retries in the
implementation of channel APIs . Additionally, these APIs have equivalent versions that
wrap results in Resultobjects. These objects are essentially sum types that combine the
transmitted value type with an error type, similar to the approach used in GoandRust.
As future work, we plan to integrate our theory in Choral , enabling us to develop more
reliable distributed applications.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 37
E Proofs for §4
Withregardtorecursiveglobaltypes,wedeﬁnetheir unfolding asunf(µt.G)=unf(G{µt.G/t}),
andunf(G)=Gotherwise. A recursive type µt.Gmust be guarded (or contractive), i.e. the
unfolding leads to a progressive preﬁx, e.g. a transmission. Unguarded types, such as µt.t
andµt.µt/prime.t, are excluded. Similar deﬁnitions and requirements apply for local types.
E.1 Active and Crashed Roles
IDeﬁnition 35 (Active and Crashed Roles) .We deﬁne roles(G)for the set of activeroles in
a global type G, and roles (G)for the set of crashedroles, as the smallest set such that:
roles( p→q:{mi(Bi).Gi}i∈I) ={p,q}∪/uniontext
i∈Iroles(Gi) roles (p→q:{mi(Bi).Gi}i∈I) =/uniontext
i∈Iroles (Gi)
roles( p→q :{mi(Bi).Gi}i∈I) ={p}∪/uniontext
i∈Iroles(Gi) roles (p→q :{mi(Bi).Gi}i∈I) ={q}∪/uniontext
i∈Iroles (Gi)
roles( p† q:j{mi(Bi).Gi}i∈I) ={q}∪/uniontext
i∈Iroles(Gi) roles (p† q:j{mi(Bi).Gi}i∈I) =/uniontext
i∈Iroles (Gi)
roles( end) = roles( t) =∅ roles (end) = roles (t) =∅
roles(µt.G) = roles(G{µt.G/t}) roles (µt.G) = roles (G{µt.G/t})
IRemark 36. Even if poccurs crashed in a communication in transit, we do not consider
pas crashed unless it appears crashed in a continuation: roles (p  q:j{mi(Bi).Gi}i∈I)=/uniontext
i∈Iroles (Gi).
ILemma 37. Ifp∈roles(G), then p/∈roles(G p)androles(G p)⊆roles(G).
Proof.By induction on Def. 5. We detail interesting cases here:
1.
roles(( p→q:{mi(Bi).Gi}i∈I) p) = roles( p  q:j{mi(Bi).(Gi p)}i∈I) ={q}∪/uniontext
i∈Iroles(Gi p).
Therequiredresultfollowsbyinductivehypothesisthat p/∈roles(Gi p),and roles(Gi p)⊆
roles(Gi).
2.
roles(( p  q:j{mi(Bi).Gi}i∈I) q) = roles(Gj q)
Therequiredresultfollowsbyinductivehypothesisthat q/∈roles(Gj q),and roles(Gj q)⊆
roles(Gj).
The rest of the cases are similar or straightforward. J
ILemma 38. Ifp∈roles(G), then roles (G p)\{p}⊆roles (G).
Proof.By induction on Def. 5. We detail interesting cases here:
1.
roles ((p→q:{mi(Bi).Gi}i∈I) p) = roles (p  q:j{mi(Bi).(Gi p)}i∈I) =/uniontext
i∈Iroles (Gi p).
The required result follows by inductive hypothesis that roles (Gi p)\{p}⊆roles (Gi).38 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
2.
roles ((p  q:j{mi(Bi).Gi}i∈I) q) = roles (Gj q)
The required result follows by inductive hypothesis that roles (Gj q)\{q}⊆roles (Gj).
The rest of the cases are similar or straightforward. J
ILemma 39. IfG/negationslash=µt.G/primeand p∈roles(G), thenGRp/negationslash=end.
Proof.We know that G/negationslash=end; otherwise, we may have roles(G)=∅, a contradiction to
p∈roles(G). By induction on the structure of G:
CaseG=q→r:{mi(Bi).Gi}i∈I: we perform case analysis on p:
p=q: we haveGRp=r⊕{mi(Bi).(GiRp)}i∈{j∈I|mj/negationslash=crash}/negationslash=end.
p=r: we haveGRp=q&{mi(Bi).(GiRp)}i∈I/negationslash=end.
p/negationslash=qand p/negationslash=r: we haveGRp=d
i∈IGiRp. Since p∈roles(G),p/negationslash=q, and
p/negationslash=r, there exists j∈Isuch that p∈roles(Gj). Then, by applying inductive
hypothesis, GjRp/negationslash=end, and therefore, we have GRp=d
i∈IGiRp=GjRp/intersectionsqd
i∈I\{j}GiRp/negationslash=end.
CaseG=q r:j{mi(Bi).Gi}i∈I: we perform case analysis on p:
p/negationslash=qand p/negationslash=r: we haveGRp=d
i∈IGiRp. Since p∈roles(G),p/negationslash=q, and
p/negationslash=r, there exists k∈Isuch that p∈roles(Gk). Then, by applying inductive
hypothesis, GkRp/negationslash=end, and therefore, we have GRp=d
i∈IGiRp=GkRp/intersectionsqd
i∈I\{k}GiRp/negationslash=end, as desired. Meanwhile, we obtain that ∀l∈I:GlRp/negationslash=end.
p=q: we haveGRp=GjRp, which follows that GRp/negationslash=endby the fact that
∀l∈I:GlRp/negationslash=end.
p=r: we haveGRp=q&{mi(Bi).(GiRp)}i∈I/negationslash=end.
Other cases are similar. J
ILemma 40. Ifp/∈roles(G)and p/∈roles (G), thenGRp=end.
Proof.By induction on the structure of G:
CaseG=q→r:{mi(Bi).Gi}i∈I: since p/∈roles(G)and p/∈roles (G), we have p/negationslash=q,
p/negationslash=r, and for all i∈I,p/∈roles(Gi)and p/∈roles (Gi)by Def. 35. Thus, GRp=d
i∈IGiRp=endby applying inductive hypothesis and end/intersectionsqend=end.
CaseG=µt.G/prime: since p/∈roles(G)and p/∈roles (G), we have p/∈roles(G/prime)and
p/∈roles (G/prime)by Def. 35. We have two further subcases to consider:
Iffv(µt.G/prime)/negationslash=∅, we haveGRp=µt.(G/primeRp)=µt.end=endby applying inductive
hypothesis.
Otherwise, we have GRp=endimmediately.
Other cases are similar or trivial. J
E.2 Subtyping
ILemma 41 (Subtyping is Reﬂexive) .For any closed, well-guarded local type T,T6T
holds.
Proof.By induction on the structure of local type T. JA.D. Barwell, P. Hou, N. Yoshida, F. Zhou 39
ILemma 42 (Subtyping is Transitive) .For any closed, well-guarded local type S,T,U, if
S6TandT6Uhold, thenS6Uholds.
Proof.By induction on the structure of local type S. J
ILemma 43. For any closed, well-guarded local type T,1.unf(T)6T; and2.T6unf(T).
Proof. 1. IfT=µt.T/prime,unf(T)6Tholds by [Sub-µR]. Otherwise, by Lem. 41. 2.IfT=µt.T/prime,
T6unf(T)holds by [Sub-µL]. Otherwise, by Lem. 41. J
ILemma 44. Given a collection of mergable local types Ti(i∈I). For allj∈I,d
i∈ITi6
Tjholds.
Proof.By Lem. 42, we have that subtyping is transitive. Hence, it is suﬃcient to show
that a relation R={(T1/intersectionsqT2,T1),(T1/intersectionsqT2,T2)|T1,T2are local types s.t. T1/intersectionsqT2is deﬁned}
is a subset of the subtyping relation 6. Then we apply induction on on the structure of
T1/intersectionsqT2. J
ILemma 45. Given a collection of mergable local types Ti(i∈I). If for all i∈I,Ti6S
for some local type S, thend
i∈ITi6S.
Proof.The proof is similar to that of Lem. 44. By induction on the structure of T1/intersectionsqT2.J
ILemma 46. Given a collection of mergable local types Ti(i∈I). If for all i∈I,S6Ti
for some local type S, thenS6d
i∈ITi.
Proof.The proof is similar to that of Lem. 44. By induction on the structure of S.J
ILemma 47. Given two collections of mergable local types Si,Ti(i∈I). If for all i∈I,
Si6Ti, thend
i∈ISi6d
i∈ITi.
Proof.The proof is similar to that of Lem. 44. By induction on the structure of S1/intersectionsqS2.J
ILemma 48. Ifp,q∈roles(G)with p/negationslash=qand q/∈R, thenGRp6(G q)Rp.
Proof.We construct a relation R={(GRp,(G q)Rp)|p,q∈R,p/negationslash=q,q∈R}, and
show thatR⊆6. By induction on the structure of G:
CaseG=p→q:{mi(Bi).Gi}i∈I: we perform case analysis on the role being projected
upon:
On LHS, we have GRp=q⊕{mi(Bi).(GiRp)}i∈{j∈I|mj/negationslash=crash}.
On RHS, we perform case analysis on the role being removed:
1.we haveG q=p→q :{mi(Bi).(Gi q)}i∈I, and thus
(G q)Rp=q⊕{mi(Bi).((Gi q)Rp)}i∈{j∈I|mj/negationslash=crash}, apply [Sub-⊕]and coinduct-
ive hypothesis.
2.(r/negationslash=q) we haveG r=p→q:{mi(Bi).(Gi r)}i∈I, and thus
(G r)Rp=q⊕{mi(Bi).((Gi r)Rp)}i∈{j∈I|mj/negationslash=crash}, apply [Sub-⊕]and coinduct-
ive hypothesis.
On LHS, we have GRq=p&{mi(Bi).(GiRq)}i∈I.
On RHS, we perform case analysis on the role being removed:
1.we haveG p=p  q:j{mi(Bi).(Gi p)}i∈I, and thus
(G p)Rq=p&{mi(Bi).((Gi p)Rq)}i∈I, apply [Sub- &]and coinductive hypo-
thesis.40 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
2.(r/negationslash=p) we haveG r=p→q:{mi(Bi).(Gi r)}i∈I, and thus
(G r)Rq=p&{mi(Bi).((Gi r)Rq)}i∈I, apply [Sub- &]and coinductive hypo-
thesis.
(r/∈{p,q}) On LHS, we have GRr=d
i∈IGiRr.
On RHS, we perform case analysis on the role being removed:
1.wehaveG p=p  q:j{mi(Bi).(Gi p)}i∈I,andthus (G p)Rr=d
i∈I((Gi p)Rr),
apply Lem. 47 and coinductive hypothesis.
2.wehaveG q=p→q :{mi(Bi).(Gi q)}i∈I,andthus (G q)Rr=d
i∈I((Gi q)Rr),
apply Lem. 47 and coinductive hypothesis.
3.(s/∈{p,q,r}) we haveG s=p→q:{mi(Bi).(Gi s)}i∈I, and thus (G s)Rr=d
i∈I((Gi s)Rr), apply Lem. 47 and coinductive hypothesis.
CaseG=µt.G/prime: by coinductive hypothesis.
Other cases are similar or trivial. J
ILemma 49 (Inversion of Subtyping) .
1.IfS6p⊕{mi(Bi).Ti}i∈I, then unf(S)=p⊕/braceleftbig
m/primej(B/prime
j).T/prime
j/bracerightbig
j∈J, andJ⊆I, and∀i∈J:
mi=m/primei,Bi=B/prime
iandT/prime
i6Ti.
2.IfS6p&{mi(Bi).Ti}i∈I, then unf(S)=p&/braceleftbig
m/primej(B/prime
j).T/prime
j/bracerightbig
j∈J, andI⊆J, and∀i∈I:
mi=m/primei,Bi=B/prime
iandT/prime
i6Ti.
Proof.By Lem. 43, the transitivity of subtyping, and Def. 30 ( [Sub- &],[Sub-⊕]).J
E.3 Semantics of Global Types
ILemma 50 (No Revival Or Sudden Death) .If/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright,
1.Ifp∈roles (G/prime)andα/negationslash=p , then p∈roles (G);
2.Ifp∈roles(G/prime)andα/negationslash=p , then p∈roles(G);
3.Ifp∈roles (G/prime)andα=p , then p∈roles(G).
Proof. 1. By induction on global type reductions: since α/negationslash=p , we start from [GR-µ].
Case [GR-µ]: we have G=µt.G/prime/primeand/angbracketleftC;G/prime/prime{µt.G/prime/prime/t}/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketrightby[GR-µ]and
its inversion. Hence, by /angbracketleftC;G/prime/prime{µt.G/prime/prime/t}/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright,p∈roles (G/prime), and induct-
ive hypothesis, we have p∈roles (G/prime/prime{µt.G/prime/prime/t}). Therefore, by roles (µt.G/prime/prime)=
roles (G/prime/prime{µt.G/prime/prime/t}), we conclude with p∈roles (G), as desired.
Case [GR-&]: we haveG=p† q:j{mi(Bi).G/prime
i}i∈IandG/prime=G/prime
jby[GR-&]. It follows
that roles (G)=/uniontext
i∈Iroles (G/prime
i)androles (G/prime)=roles (G/prime
j)withj∈I, and hence,
roles (G/prime)⊆roles (G). Therefore, by p∈roles (G/prime), we conclude with p∈roles (G),
as desired.
Case [GR-Ctx-i]: we haveG=p→q†:{mi(Bi).G/prime
i}i∈I,G/prime=p→q†:{mi(Bi).G/prime/prime
i}i∈I,∀i∈
I:/angbracketleftC;G/prime
i/angbracketrightα− →R/angbracketleftC/prime;G/prime/prime
i/angbracketright, and subj(α)/∈ {p,q}by[GR-Ctx-i] and its inversion. It
follows that roles (G)=/uniontext
i∈Iroles (G/prime
i),roles (G/prime)=/uniontext
i∈Iroles (G/prime/prime
i), andα/negationslash=p .
Then by∀i∈I:/angbracketleftC;G/prime
i/angbracketrightα− →R/angbracketleftC/prime;G/prime/prime
i/angbracketright,α/negationslash=p , and inductive hypothesis, we have
∀i∈I:ifp∈roles (G/prime/prime
i),then p∈roles (G/prime
i). Therefore, by p∈/uniontext
i∈Iroles (G/prime/prime
i), we
conclude with p∈/uniontext
i∈Iroles (G/prime
i) = roles (G), as desired.
Other cases are similar.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 41
2.Similar to the proof of (1).
3.The proof is trivial by [GR- ]and its inversion. J
ILemma 29 (Preservation of Well-Annotated Global Types) .If/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright, and
/angbracketleftC;G/angbracketrightis well-annotated w.r.t. R, then/angbracketleftC/prime;G/prime/angbracketrightis also well-annotated w.r.t. R.
Proof.By induction on global type reductions:
Case [GR- ]: we have C/prime=C∪{p},G/prime=G p,p/∈R,p∈roles(G), andG/negationslash=µt.G/primeby
[GR- ]and its inversion.
Item (WA1): from the premise, we have roles (G)∩R=∅. Since p∈roles(G), by Lem. 38,
we have roles (G p)\{p}⊆roles (G). Then we consider two cases:
ifp∈roles (G p), then roles (G p)={p}∪(roles (G p)\{p}). Hence, by p/∈R,
roles (G p)\{p}⊆roles (G), and roles (G)∩R=∅, we have roles (G p)∩R=∅.
ifp/∈roles (G p), then roles (G p)=roles (G p)\{p}. Hence, by roles (G p)\{p}⊆
roles (G)androles (G)∩R=∅, we have roles (G p)∩R=∅.
Therefore, by G/prime=G p, we conclude with roles (G/prime)∩R=∅, as desired.
Item (WA2): from the premise, we have roles (G)⊆C. Since p∈roles(G), by Lem. 38,
we have roles (G p)\{p}⊆roles (G). Then we consider two cases:
ifp∈roles (G p),then roles (G p)={p}∪(roles (G p)\{p}). Hence,by roles (G p)\
{p}⊆roles (G)androles (G)⊆C, we have roles (G p)⊆C∪{p}.
ifp/∈roles (G p), then roles (G p)=roles (G p)\{p}. Hence, by roles (G p)\{p}⊆
roles (G)androles (G)⊆C, we have roles (G p)⊆C∪{p}.
Therefore, by G/prime=G pandC/prime=C∪{p}, we conclude with roles (G/prime)⊆C/prime, as desired.
Item (WA3): from the premise, we have roles(G)∩roles (G)=∅. Since p∈roles(G), by
Lem.37, Lem.38, wehave roles(G p)⊆roles(G),p/∈roles(G p), and roles (G p)\{p}⊆
roles (G). Then we consider two cases:
ifp∈roles (G p), then roles (G p)={p}∪(roles (G p)\{p}). Hence, by roles(G)∩
roles (G)=∅,p/∈roles(G p),roles (G p)\{p} ⊆ roles (G), and roles(G p)⊆
roles(G), we have roles (G p)∩roles(G p) =∅.
ifp/∈roles (G p), then roles (G p)=roles (G p)\{p}. Hence, by roles(G)∩
roles (G)=∅,roles (G p)\{p}⊆ roles (G), and roles(G p)⊆roles(G), we have
roles (G p)∩roles(G p) =∅.
Therefore, by G/prime=G p, we conclude with roles(G/prime)∩roles (G/prime) =∅, as desired.
Case [GR-µ]: we have G=µt.G/prime/primeand/angbracketleftC;G/prime/prime{µt.G/prime/prime/t}/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketrightby[GR-µ]and its
inversion. From the premise, we also have /angbracketleftC;µt.G/prime/prime/angbracketrightis well-annotated. Hence, by
roles (µt.G/prime/prime)=roles (G/prime/prime{µt.G/prime/prime/t}),roles(µt.G/prime/prime)=roles(G/prime/prime{µt.G/prime/prime/t}), and/angbracketleftC;µt.G/prime/prime/angbracketright
is well-annotated, we have roles (G/prime/prime{µt.G/prime/prime/t})∩R=∅,roles (G/prime/prime{µt.G/prime/prime/t})⊆C, and
roles(G/prime/prime{µt.G/prime/prime/t})∩roles (G/prime/prime{µt.G/prime/prime/t})=∅. It follows directly that /angbracketleftC;G/prime/prime{µt.G/prime/prime/t}/angbracketrightis
well-annotated. Therefore, by /angbracketleftC;G/prime/prime{µt.G/prime/prime/t}/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketrightand inductive hypothesis, we
conclude with/angbracketleftC/prime;G/prime/angbracketrightis well-annotated, as desired.
Other cases are similar. J
ILemma 51./angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright, iﬀ/angbracketleftC; unf(G)/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright.
Proof.By inverting or applying [GR-µ]when necessary. J
ILemma 52 (Progress of Global Types) .If/angbracketleftC;G/angbracketright(whereGis a projectable global type) is
well-annotated, and G/negationslash=end, then there exists G/prime,C/primesuch that/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright.42 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Proof.By Lem. 51, we only consider unfoldings.
Ifunf(G) =end, the premise does not hold.
Case unf(G)=p→q:{mi(Bi).Gi}i∈I, apply [GR-⊕]. We can pick any mi/negationslash=crashto reduce
the global type (note that our syntax prohibits singleton crashbranches).
Case unf(G)=p→q :{mi(Bi).Gi}i∈I, apply [GR- m]. We can pick any mi/negationslash=crashto
reduce the global type (note that our syntax prohibits singleton crashbranches).
Case unf(G)=p† q:j{mi(Bi).Gi}i∈I. Ifmj=crash, then it pmust have crashed, apply
[GR-⊙]. Otherwise, apply [GR-&]. J
E.4 Semantics of Conﬁgurations
ILemma 53. IfΓ; ∆→ Γ/prime; ∆/primewith Γ; ∆α− →Γ/prime; ∆/prime, then
1.dom(Γ) = dom(Γ/prime); and
2.for all p∈dom(Γ) with p/negationslash= subj(α), we have Γ(p) = Γ/prime(p).
Proof.Trivial by induction on reductions of conﬁguration. J
ILemma 54. IfΓ;∆α− →Γ/prime;∆/prime, then for any p,q∈dom(Γ)with subj(α)/∈{p,q}, we have
∆(p,q) = ∆/prime(p,q).
Proof.Trivial by induction on reductions of conﬁguration. J
ILemma 55 (Inversion of Typing Context Reduction) .
1.IfΓ;∆p⊕q:mk(Bk)−−−−−−−→ Γ/prime;∆/prime, then unf(Γ( p))=q⊕{mi(Bi).Ti}i∈I,k∈I, and Γ/prime(p)=Tk;
2.IfΓ;∆q&p:mk(Bk)−−−−−−−→ Γ/prime;∆/prime, then unf(Γ( q))=p&{mi(Bi).Ti}i∈I,k∈I, and Γ/prime(q)=Tk.
Proof.By applying and inverting [Γ-⊕]and [Γ-&]. J
ILemma 56 (Determinism of Conﬁguration Reduction) .IfΓ;∆α− →Γ/prime;∆/primeand Γ;∆α− →
Γ/prime/prime; ∆/prime/prime, then Γ/prime= Γ/prime/primeand∆/prime= ∆/prime/prime.
Proof.Trivial by induction on reductions of conﬁguration. J
ILemma 57. IfΓ1; ∆α− →Γ/prime
1; ∆/prime
1and Γ2; ∆α− →Γ/prime
2; ∆/prime
2, then ∆/prime
1= ∆/prime
2.
Proof.Trivial by induction on reductions of conﬁguration. J
E.5 Relating Semantics
IProposition 58. Γ; ∆/subsetsqequalR/angbracketleftC;µt.G/angbracketrightif and only if Γ; ∆/subsetsqequalR/angbracketleftC;G{µt.G/t}/angbracketright.
Proof.By Lem. 43. J
IProposition59. IfΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightandΓ(p)=µt.T, then Γ[p/mapsto→T{µt.T/t}]; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
Proof.By Lem. 43. J
IProposition 60. Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightif and only if Γ; ∆/subsetsqequalR/angbracketleftC; unf(G)/angbracketright.
Proof.By applying Prop. 58 as many times as necessary. J
ILemma 61 (Inversion of Projection) .Given a local type S, which is a subtype of projection
from a global type Gon a role pwith respect to a set of reliable roles R, i.e.S6(GRp),
then:A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 43
1.Ifunf(S) =q⊕{mi(Bi).S/prime
i}i∈I, then either
a.unf(G)=p→q†:{mi(B/prime
i).Gi}i∈I/prime, whereI⊆I/prime, and for all i∈I:mi=mi,S/prime
i6
(GiRp), andBi=B/prime
i; or,
b.unf(G)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, or unf(G)=s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, where for
allj∈J:S6(GjRp), with p/negationslash=sandp/negationslash=t.
2.Ifunf(S) =q&{mi(Bi).S/prime
i}i∈I, then either
a.unf(G)=q→p†:{mi(B/prime
i).Gi}i∈I/prime, orunf(G)=q† p:j{mi(B/prime
i).Gi}i∈I/prime, whereI/prime⊆I,
and for all i∈I/prime:mi=mi,S/prime
i6(GiRp),B/prime
i=Bi, and q/∈Rimplies∃k∈I/prime:mk=
crash; or,
b.unf(G)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, or unf(G)=s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, where for
allj∈J:S6(GjRp), with p/negationslash=sandp/negationslash=t.
3.IfS=end, then p/∈roles(G).
Proof.By the deﬁnition of global type projection (Def. 3). J
ILemma 62 (Existence of Crash Handling Branch Under Projection) .If role qis unreliable,
q/∈R, and a global type projects onto pwith an external choice from q,unf(GRp)=
q&{mi(Si).S/prime
i}i∈I, then there must be a crash handling branch, ∃j∈I:mj=crash.
Proof.By induction on Item 2 of Lem. 61. J
ILemma 63. If a local type Tis a subtype of an external choice with a matching role,
obtained via projection from a global type G, i.e.,T=p&{mi(Bi).Ti}i∈I6GRq,unf(G)
is of the form s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈Jors† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, and a queue environment
∆is associated with /angbracketleftC;G/angbracketright, then there exists a global type /angbracketleftC/prime;G/prime/angbracketrightand a queue environ-
ment ∆/primesuch thatGRq6G/primeRq,unf(G/prime)is of the form p† q:j{mi(B/prime
i).Gi}i∈I/primeor
p→q†:{mi(B/prime
i).Gi}i∈I/prime, and ∆/primeis associated with /angbracketleftC/prime;G/prime/angbracketrightwith ∆/prime(p,q) = ∆( p,q).
Proof.By induction on Item 2 of Lem. 61.
Apply Item 2 of Lem. 61 on the premise, we have ∀j∈J:T=p&{mi(Bi).Ti}i∈I6
GjRqwith q/negationslash=sandq/negationslash=t, which follows that GRq=d
j∈JGjRq. Then, by Lem. 44,
we get∀j∈J:GRq6GjRq. We take an arbitrary Gjwithj∈J. By applying Item 2
of Lem. 61 again, we have two cases.
Case (1): unf(Gj) =p† q:l{mi(B/prime
i).Gi}i∈I/primeorunf(Gj) =p→q†:{mi(B/prime
i).Gi}i∈I/prime.
SinceGRq6GjRq, we only need to show that there exists ∆/primesuch that ∆/primeis
associated with/angbracketleftC;Gj/angbracketrightand∆/prime(p,q) = ∆( p,q). We consider two subcases:
unf(G)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J: by Def. 10, we have that ∆is associated with Gj.
We take ∆/primeas∆.
unf(G)=s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, we perform case analysis on mk=crashand mk/negationslash=
crash:
∗mk=crash: by Def. 10, we have that ∆is associated with /angbracketleftC;Gj/angbracketright. We take ∆/primeas∆.
∗mk/negationslash=crash: by Def. 10, we have that ∆(s,t)=mk(B/prime
k)·τand∆[s,t/mapsto→τ]is associated
with/angbracketleftC;Gj/angbracketright. We take ∆/prime=∆[s,t/mapsto→τ]. Since q/negationslash=sandq/negationslash=t, it is straightforward
that ∆/prime(p,q) = ∆( p,q), as required.
Case (2): unf(Gj) =r→u†:{ml(B/prime
l).Gl}l∈Lorr† u:k{ml(B/prime
l).Gl}l∈L.
We can construct a queue environment ∆/primeas in case (1), which is associated with /angbracketleftC;Gj/angbracketright.
The thesis is then proved by applying inductive hypothesis on /angbracketleftC;Gj/angbracketrightand∆/prime.J44 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
ILemma 64. If∆is associated with /angbracketleftC;G/angbracketrightandp∈roles(G), then ∆[·,p/mapsto→/circledivide]is associated
with/angbracketleftC∪{p};G p/angbracketright.
Proof.We denote ∆/prime=∆[·,p/mapsto→/circledivide]in the subsequent proof. To show association, there are
two parts: namely a shape-dependent part, and a shape-independent part.
We ﬁrst show shape-independent part, which shared for all cases: that a crashed role ris
inC∪{p}iﬀ∆/prime(·,r)=/circledivide. It follows that the roles r∈Chave the requirements satisﬁed
from the premise, and we set ∆/prime=∆[·,p/mapsto→/circledivide], and that pis in the new set of crashed roles.
Shape-dependent part are by induction on the deﬁnition of G p:
Case (p→q:{mi(Bi).Gi}i∈I) p=p  q:j{mi(Bi).(Gi p)}i∈Iwherej∈Iandmj=crash:
Since ∆is associated with /angbracketleftC;G/angbracketright, we that∀i∈I:∆is associated with /angbracketleftC;G/prime
i/angbracketright, and
∆(p,q) =/epsilon1.
By inductive hypothesis, we have ∆/primeis associated with /angbracketleftC;(Gi p)/angbracketright. Moreover, since
mj=crash, we can show that ∆/prime(p,q) = ∆( p,q) =/epsilon1.
Case (p q:j{mi(Bi).Gi}i∈I) q=Gj q:
Subcase mj=crash: by inductive hypothesis, we know ∆/primeis associated with /angbracketleftC∪{q};G/prime
j/angbracketright,
as required.
Subcase mj/negationslash=crash: from association, we have ∆(p,q)=mj(Bj)·τand∆[p,q/mapsto→τ]is
associated with/angbracketleftC;G/prime
j/angbracketright.
By inductive hypothesis, we know ∆[p,q/mapsto→τ][·,q/mapsto→/circledivide]is associated with /angbracketleftC∪{q};G/prime
j q/angbracketright.
Since ∆[p,q/mapsto→τ][·,q/mapsto→/circledivide]=∆[·,q/mapsto→/circledivide]=∆/prime, so∆/primeis associated with /angbracketleftC∪{q};G/prime
j q/angbracketright.
Case (p→q :{mi(Bi).Gi}i∈I) p=Gj p, wherej∈Iandmj=crash:
Since ∆is associated with /angbracketleftC;G/angbracketright, we have that ∆is associated with /angbracketleftC;Gj/angbracketright.
By inductive hypothesis, we have ∆/primeis associated with /angbracketleftC∪{p};Gj p/angbracketright, as required.
Other cases follows directly by inductive hypothesis or trivially. J
ILemma65. IfΓ;∆α− →Γ/prime;∆/prime,Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright,Γ1; ∆/subsetsqequalR/angbracketleftC;G1/angbracketright,Γ(subj(α))=Γ1(subj(α)),
and Γ/prime
1= Γ1[subj(α)/mapsto→Γ/prime(subj(α))], then Γ1; ∆α− →Γ/prime
1; ∆/prime.
Proof.Trivial by induction on reductions of conﬁguration. J
We deﬁneImi\crashto be an index set with the special label crashremoved, i.e. Imi\crash=
{i∈I|mi/negationslash=crash}.
ITheorem 12 (Soundness of Association) .Given associated global type Gand conﬁguration
Γ;∆:Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright. If/angbracketleftC;G/angbracketright− →R, then there exists Γ/prime;∆/prime,αand/angbracketleftC/prime;G/prime/angbracketright, such that
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright,Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright, and Γ; ∆α− →Γ/prime; ∆/prime.
Proof.By induction on reductions of global type /angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright.
Case [GR- ]:
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (3)
/angbracketleftC;G/angbracketright− →R (4)
p/∈R (5)
p∈roles(G) (6)
G/negationslash=µt.G/prime(7)
α=p (8)
C/prime=C∪{p} (9)
G/prime=G p (10)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 45
LetΓ/prime; ∆/prime= Γ[p/mapsto→stop]; ∆[·,p/mapsto→/circledivide]. We show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime/prime;G/prime/prime/angbracketrightand Γ; ∆α− →Γ/prime; ∆/prime.
For the ﬁrst part: By association (3), we know that Γ(p)6GRp. ByG/negationslash=µt.G/prime,
p∈roles(G), and Lem. 39, we know that GRp/negationslash=end, which gives Γ(p)/negationslash=end. By
p∈roles(G), we also know that p/∈C, which gives Γ(p)/negationslash=stop. Thus we apply [Γ- ]to
obtain the thesis.
For the second part:
(A1) From association (3), we know that ∀q∈roles(G) : Γ( q)6GRq.
By Lem. 37, we know roles(G p)⊆roles(G).
For any q∈roles(G p), we apply Lem. 48, to obtain GRq6(G p)Rq
Thus we have, by transitivity of subtyping, ∀q∈roles(G p):Γ(q)6GRq6
(G p)Rq, as required.
(A2)From association (3), we know that∀q∈C:Γ(q)=stop, and they are unchanged in
Γ/prime.
Moreover, we have updated Γ/prime(p) =stop.
This completes the consideration of the set C/prime(9).
(A3) No change here.
(A4) By Lem. 64.
Case [GR-µ]:
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (11)
G=µt.G0 (12)
/angbracketleftC;G/angbracketright− →R (13)
/angbracketleftC;G0{µt.G0/t}/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright (14)
By Prop. 58, we have Γ; ∆/subsetsqequalR/angbracketleftC;G0{µt.G0/t}/angbracketright, and we can apply inductive hypothesis to
obtain the desired result.
Case [GR-⊕]:
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (15)
G=p→q:{mi(Bi).Gi}i∈I (16)
/angbracketleftC;G/angbracketright− →R (17)
j∈I (18)
mj/negationslash=crash (19)
α=p⊕q:mj(Bj) (20)
C/prime=C (21)
G/prime=p q:j{mi(Bi).Gi}i∈I (22)
Byassociation (15)andp∈roles(G),weknowthat Γ(p)6GRp=q⊕{mi(Bi).(GiRp)}i∈Imi\crash.
Then by Lem. 49, we obtain that Γ(p)=q⊕{mi(Bi).Ti}i∈I/prime, whereI/prime⊆Imi\crashand
∀i∈I/prime:Ti6GiRp. Note that here for any i∈I/prime:mi=mi.
Since the crashlabel cannot appear in the internal choices, it holds that for any i∈I/prime,
mi/negationslash=crash. Therefore, with ∀i∈I/prime:mi=mi, we can set j∈I/primewith mj=mj/negationslash=crashand
α=p⊕q:mj(Bj) =p⊕q:mj(Bj).
LetΓ/prime;∆/prime=Γ[p/mapsto→Tj];∆[p,q/mapsto→∆(p,q)·mj(Bj)]. Weshow Γ;∆α− →Γ/prime;∆/primeandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.46 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
For the ﬁrst part: we apply [Γ-⊕]on those we have: Γ(p)=q⊕{mi(Bi).Ti}i∈I/primeandj∈I/prime,
to obtain the thesis.
For the second part:
(A1) We want to show ∀r∈roles(G/prime) : Γ/prime(r)6G/primeRr. We consider three subcases:
r=p: since Γ/prime(p)=Tj,j∈I/prime, and∀i∈I/prime:Ti6GiRp, we have Γ/prime(p)6
GjRp=G/primeRp, as desired.
r=q: byassociation (15),wehave Γ/prime(q)=Γ(q)6GRq=p&{mi(Bi).(GiRq)}i∈I=
G/primeRq, as desired.
r/negationslash=qand r/negationslash=p: by association (15), it holds that Γ/prime(r)=Γ(r)6GRr=d
i∈IGiRr=G/primeRr, as desired.
(A2) No change here.
(A3) No change here.
(A4)Wearelefttoshow ∆/prime=∆[p,q/mapsto→∆(p,q)·mj(Bj)]isassociatedwith /angbracketleftC;p q:j{mi(Bi).Gi}i∈I/angbracketright.
Since ∆is associated with /angbracketleftC;p→q:{mi(Bi).Gi}i∈I/angbracketright, by Def. 10, we have ∆(p,q)=/epsilon1
and∀i∈I: ∆is associated with /angbracketleftC;Gi/angbracketright.
Since mj/negationslash=crash, we just need to show that ∆/prime(p,q)=mj(Bj), which follows dir-
ectly from ∆/prime=∆[p,q/mapsto→∆(p,q)·mj(Bj)],mj=mj, and ∆(p,q)=/epsilon1, and∀i∈
I:∆/prime[p,q/mapsto→/epsilon1]is associated with /angbracketleftC;Gi/angbracketright, which follows from ∆/prime[p,q/mapsto→/epsilon1]=∆and
∀i∈I: ∆is associated with /angbracketleftC;Gi/angbracketright.
Case [GR-&]:
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (23)
G=p† q:j{mi(Bi).Gi}i∈I (24)
/angbracketleftC;G/angbracketright− →R (25)
j∈I (26)
mj/negationslash=crash (27)
α=q&p:mj(Bj) (28)
C/prime=C (29)
G/prime=Gj (30)
Byassociation (23)andq∈roles(G),weknowthat Γ(q)6GRq=p&{mi(Bi).(GiRq)}i∈I.
Note that here for any i∈I:mi=mi. Furthermore, by Lem. 49, we obtain that
Γ(q)=p&{mi(Bi).Ti}i∈I/prime, whereI⊆I/primeand∀i∈I:Ti6GiRq. From association (23),
we also get that ∆(p,q) =mj(Bj)·τ=mj(Bj)·τ.
LetΓ/prime; ∆/prime= Γ[q/mapsto→Tj]; ∆[p,q/mapsto→τ]. We show Γ; ∆α− →Γ/prime; ∆/primeand Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.
For the ﬁrst part: we apply [Γ-&]on those we have: Γ(q)=p&{mi(B/prime
i).Ti}i∈I/prime,j∈I⊆I/prime,
mj=mj, and ∆(p,q) =mj(Bj)·τ, to obtain the thesis.
For the second part:
(A1) We want to show ∀r∈roles(Gj) : Γ/prime(r)6GjRr. We consider three subcases:
r=q(meaning that q∈roles(Gj)): since Γ/prime(q)=Tjand∀i∈I:Ti6GiRq, we
have Γ/prime(q)6GjRq, as desired.
r=p(meaning that p†=pand p∈roles(Gj)): by association (23), we have
Γ/prime(p) = Γ( p)6GRp=GjRp, as desired.
r/negationslash=qand r/negationslash=p: by association (23), it holds that Γ/prime(r)=Γ(r)6GRr=d
i∈IGiRr. Then, by applying Lem. 44 and transitivity of subtyping, we conclude
with Γ/prime(r)6GjRr, as desired.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 47
(A2) No change here.
(A3)No change here if q∈roles(Gj)and p∈roles(Gj). Otherwise, if q/∈roles(Gj): with
q/∈roles (Gj), by Lem. 40, we have GjRq=end. Furthermore, by the fact that
∀i∈I:Ti6GiRq, it holds that Tj=end, and thus, Γ/prime(q)=end, as desired. The
argument for p/∈roles(Gj)andp†=pfollows similarly.
(A4)Since ∆is associated with /angbracketleftC;p† q:j{mi(Bi).Gi}i∈I/angbracketrightand mj/negationslash=crash, by Def. 10,
we have that ∆(p,q)=mj(Bj)·τand∀i∈I:∆[p,q/mapsto→τ]is associated with /angbracketleftC;Gi/angbracketright,
which follows that ∆/prime= ∆[ p,q/mapsto→τ]is associated with /angbracketleftC;Gj/angbracketright, as desired.
Case [GR-⊙]:
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (31)
G=p  q:j{mi(Bi).Gi}i∈I (32)
/angbracketleftC;G/angbracketright− →R (33)
j∈I (34)
mj=crash (35)
α=q⊙p (36)
C/prime=C (37)
G/prime=Gj (38)
Byassociation (31)andq∈roles(G),weknowthat Γ(q)6GRq=p&{mi(Bi).(GiRq)}i∈I.
Note that here for any i∈I:mi=mi. Furthermore, by Lem. 49, we obtain that
Γ(q) =p&{mi(B/prime
i).Ti}i∈I/prime, whereI⊆I/primeand∀i∈I:Bi=B/prime
iandTi6GiRq.
LetΓ/prime; ∆/prime= Γ[q/mapsto→Tj]; ∆. We show Γ; ∆α− →Γ/prime; ∆/primeand Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.
For the ﬁrst part: By association (31),p∈C, and mj=crash(35), we know that
Γ(p)=stopand∆(p,q)=/epsilon1. Sincej∈I(34),mj=crash(35), and∀i∈I:mi=mi,
we have mj=crash. We also get j∈I/primefromj∈IandI⊆I/prime. Thus, together with
Γ(q) =p&{mi(B/prime
i).Ti}i∈I/prime, we apply [Γ-⊙]to obtain the thesis.
For the second part:
(A1) We want to show ∀r∈roles(Gj) : Γ/prime(r)6GjRr. We consider two subcases:
r=q(meaning that q∈roles(Gj)): since Γ/prime(q)=Tj,∀i∈I:Ti6GiRq, and
j∈I(34), we have Γ/prime(q)6GjRq, as desired.
r/negationslash=q: since p∈C, we know p/∈roles(Gj), and thus, r/negationslash=p. Furthermore, by
association (31), it holds that Γ/prime(r)=Γ(r)6GRr=d
i∈IGiRr. Then, by
applying Lem. 44 and transitivity of subtyping, we can conclude with Γ/prime(r)6GjRr,
as desired.
(A2) No change here.
(A3)No change here if q∈roles(Gj). Otherwise, if q/∈roles(Gj): with q/∈roles (Gj), by
Lem. 40, we have GjRq=end. Furthermore, by the fact that ∀i∈I:Ti6GiRq,
it holds that Tj=end, and thus, Γ/prime(q) =end, as desired.
(A4)Since ∆is associated with /angbracketleftC;p  q:j{mi(Bi).Gi}i∈I/angbracketrightandmj=crash, by Def. 10, we
have that∀i∈I:∆is associated with /angbracketleftC;Gi/angbracketright, which follows that ∆/prime=∆is associated
with/angbracketleftC;Gj/angbracketright, as desired.
Case [GR- m]:48 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (39)
G=p→q :{mi(Bi).Gi}i∈I (40)
/angbracketleftC;G/angbracketright− →R (41)
j∈I (42)
mj/negationslash=crash (43)
α=p⊕q:mj(Bj) (44)
C/prime=C (45)
G/prime=Gj (46)
Byassociation (39)andp∈roles(G),weknowthat Γ(p)6GRp=q⊕{mi(Bi).(GiRp)}i∈Imi\crash.
Then by Lem. 49, we obtain that Γ(p)=q⊕{mi(Bi).Ti}i∈I/prime, whereI/prime⊆Imi\crashand
∀i∈I/prime:Ti6GiRp. Note that here for any i∈I/prime:mi=mi.
Since the crashlabel cannot appear in the internal choices, it holds that for any i∈I/prime,
mi/negationslash=crash. Therefore, with ∀i∈I/prime:mi=mi, we can set j∈I/primewith mj=mj/negationslash=crashand
α=p⊕q:mj(Bj) =p⊕q:mj(Bj).
LetΓ/prime;∆/prime=Γ[p/mapsto→Tj];∆[p,q/mapsto→∆(p,q)·mj(Bj)]. Weshow Γ;∆α− →Γ/prime;∆/primeandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.
For the ﬁrst part: we apply [Γ-⊕]on those we have: Γ(p)=q⊕{mi(Bi).Ti}i∈I/primeandj∈I/prime,
to obtain the thesis.
For the second part:
(A1) We want to show ∀r∈roles(G/prime) : Γ/prime(r)6G/primeRr. We consider two subcases:
r=p(meaning that p∈roles(Gj)): since Γ/prime(p)=Tj,∀i∈I/prime:Ti6GiRp, and
j∈I/prime, we have Γ/prime(p)6GjRp, as desired.
r/negationslash=p: since q∈C, we know q/∈roles(Gj), and thus, r/negationslash=q. Furthermore, by
association (39), it holds that Γ/prime(r)=Γ(r)6GRr=d
i∈IGiRr. Then, by
applying Lem. 44 and transitivity of subtyping, we can conclude with Γ/prime(r)6GjRr,
as desired.
(A2) No change here.
(A3)No change here if p∈roles(Gj). Otherwise, if p/∈roles(Gj): with p/∈roles (Gj), by
Lem. 40, we have GjRp=end. Furthermore, by the fact that ∀i∈I/prime:Ti6GiRp,
it holds that Tj=end, and thus, Γ/prime(p) =end, as desired.
(A4) We are left to show ∆/prime= ∆[ p,q/mapsto→∆(p,q)·mj(Bj)]is associated with /angbracketleftC;Gj/angbracketright.
Since ∆is associated with /angbracketleftC;p→q :{mi(Bi).Gi}i∈I/angbracketright, by Def. 10, we have ∆(p,q)=/circledivide
and∀i∈I:∆is associated with /angbracketleftC;Gi/angbracketright. It follows from ∆(p,q)=/circledividethat ∆/prime=
∆[p,q/mapsto→∆(p,q)·mj(Bj)]=∆[p,q/mapsto→/circledivide· mj(Bj)]=∆[p,q/mapsto→/circledivide]=∆. Hence, with
∀i∈I:∆is associated with /angbracketleftC;Gi/angbracketright, we conclude that ∆/prime=∆is associated with
/angbracketleftC;Gj/angbracketright, as desired.
Case [GR-Ctx-i]:A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 49
From the premise we have
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (47)
G=p→q†:{mi(Bi).Gi}i∈I (48)
/angbracketleftC;G/angbracketright− →R (49)
∀i∈I:/angbracketleftC;Gi/angbracketrightα− →R/angbracketleftC/prime;G/prime
i/angbracketright (50)
subj(α)/∈{p,q} (51)
G/prime=p→q†:{mi(Bi).G/prime
i}i∈I (52)
We consider two subcases depending on whether qhas crashed.
q†=q:
Forp,wehaveGRp=q⊕{mi(Bi).(GiRp)}i∈Imi\crashandG/primeRp=q⊕{mi(Bi).(G/prime
iRp)}i∈Imi\crash.
Forq,wehaveGRq=p&{mi(Bi).(GiRq)}i∈IandG/primeRq=p&{mi(Bi).(G/prime
iRq)}i∈I.
Take an arbitrary j∈I. Let Γj(p)=GjRp,Γj(q)=GjRq,Γj(r)=Γ(r)for
r∈dom(Γ)\{p,q},∆j= ∆. We show Γj; ∆j/subsetsqequalR/angbracketleftC;Gj/angbracketright.
(A1) We want to show ∀s∈roles(Gj) : Γj(s)6GjRs. We consider three subcases:
∗s=p(meaning that p∈roles(Gj)): trivial by Γj(p)=GjRpand the reﬂexivity
of subtyping.
∗s=q(meaning that q∈roles(Gj)): trivial by Γj(q)=GjRqand the reﬂexivity
of subtyping.
∗s/negationslash=pand s/negationslash=q: by association (47)and Γj(s)=Γ(s), we have Γj(s)6d
i∈IGiRs. Then, by Lem. 44 and transitivity of subtyping, we conclude Γj(s)6
GjRs, as desired.
(A2) No change here.
(A3)No change here if p∈roles(Gj)andq∈roles(Gj). Otherwise, consider the case that
p/∈roles(Gj): with p/∈roles (Gj), by Lem. 40, we have GjRp=end. Therefore,
we know from Γj(p)=GjRpthat Γj(p)=end, as required. The argument for
q/∈roles(Gj)follows similarly.
(A4) Trivial by association (47), Def. 10, and ∆j= ∆.
Byinductivehypothesis,thereexists Γ/prime
j;∆/prime
jsuchthat Γj;∆jα− →Γ/prime
j;∆/prime
jandΓ/prime
j; ∆/prime
j/subsetsqequalR/angbracketleftC/prime;G/prime
j/angbracketright.
Since subj(α)/∈{p,q}, we apply Lem. 53, which gives Γj(p)=Γ/prime
j(p)andΓj(q)=Γ/prime
j(q).
We now construct a conﬁguration Γ/prime;∆/primeand show Γ;∆α− →Γ/prime;∆/primeandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.
LetΓ/prime(p)=Γ(p),Γ/prime(q)=Γ(q),Γ/prime(r)=d
i∈IΓ/prime
i(r)forr∈dom(Γ)\{p,q},∆/prime=∆/prime
j
with an arbitrary j∈I.
For the ﬁrst part that Γ; ∆α− →Γ/prime; ∆/prime:
We know that for any i∈I,Γ/prime
iis obtained from Γiby updating subj(α)to a ﬁxed type
T. It follows that for any i,k∈Iand for any r/∈{p,q},Γ/prime
i(r)=Γ/prime
k(r), and hence,d
i∈IΓ/prime
i(r)=Γ/prime
j(r)with an arbitrary j∈J. Therefore, we have that Γ/primeis obtained
from Γby updating subj(α)toΓ/prime
j(subj(α)), i.e., Γ/prime= Γ[subj(α)/mapsto→Γ/prime
j(subj(α))].
WeapplyLem.65on Γj;∆jα− →Γ/prime
j;∆/prime
j,Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright,Γj; ∆j/subsetsqequalR/angbracketleftC;Gj/angbracketright,Γ(subj(α))=
Γj(subj(α)), and Γ/prime= Γ[subj(α)/mapsto→Γ/prime
j(subj(α))]to get the thesis.
For the second part that Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright:
(A1) We want to show ∀r∈roles(G/prime) : Γ/prime(r)6G/primeRr. We consider three subcases:
∗r=p: by association (47)and Lem. 49, we obtain Γ(p)=q⊕{mi(Bi).Ti}i∈I/prime
whereI/prime⊆Imi\crashand∀i∈I/prime:Ti6GiRp. Since Γi(p)=GiRp=Γ/prime
i(p)for
eachi∈I, with association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketright, we getGiRp=Γ/prime
i(p)6G/prime
iRp.50 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Then by transitivity of subtyping, it holds that ∀i∈I/prime:Ti6G/prime
iRp, which
follows that q⊕{mi(Bi).Ti}i∈I/prime6q⊕{mi(Bi).(G/prime
iRp)}i∈Imi\crash, as desired.
∗r=q: by association (47)and Lem. 49, we obtain Γ(q)=p&{mi(Bi).Ti}i∈I/primewhere
I⊆I/primeand∀i∈I:Ti6GiRq. Since Γi(q)=GiRq=Γ/prime
i(q)for eachi∈I,
with association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketright, we getGiRq=Γ/prime
i(q)6G/prime
iRq. Then by
transitivity of subtyping, it holds that ∀i∈I:Ti6G/prime
iRq, which follows that
p&{mi(Bi).Ti}i∈I/prime6p&{mi(Bi).(G/prime
iRq)}i∈I, as desired.
∗r/negationslash=pand r/negationslash=q: by association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketrightfor eachi∈I, it holds that
Γ/prime
i(r)6G/prime
iRrfor eachi∈I. Then by applying Lem. 47, we conclude with
Γ/prime(r) =d
i∈IΓ/prime
i(r)6d
i∈IG/prime
iRr=G/primeRr, as desired.
(A2)By association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketrightfor eachi∈I, it holds that∀r∈C/prime:Γ/prime
i(r)=stop,
which follows that for any r∈C/prime,Γ/prime(r) =d
i∈IΓ/prime
i(r) =stop, as desired.
(A3)For any endpoint rinG/prime,ris an endpoint in each G/prime
iwithi∈I. Then by association
Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketright, we have Γ/prime
i(r)=end, which follows Γ/prime(r)=d
i∈IΓ/prime
i(r)=end, as
desired.
(A4)By Lem. 57, it holds that for any i,j∈I,∆/prime
i=∆/prime
j. Take an arbitrary ∆/prime
jwithj∈I.
Note here ∆/prime=∆/prime
j. With the fact that ∆/prime
iis associated with G/prime
ifor anyi∈I, we have
that∀i∈I:∆/prime
jis associated with G/prime
i, and hence,∀i∈I:∆/primeis associated with G/prime
i.
We are left to show that ∆/prime(p,q)=/epsilon1, which is obtained by applying Lem. 54 on
∆(p,q) =/epsilon1andΓj; ∆α− →Γ/prime
j; ∆/prime
jwith subj(α)/∈{p,q}.
q†=q :
Note that q∈C. For p, we haveGRp=q⊕{mi(Bi).(GiRp)}i∈Imi\crashandG/primeRp=
q⊕{mi(Bi).(G/prime
iRp)}i∈Imi\crash. Take an arbitrary j∈I. Let Γj(p)=GjRp,Γj(q)=
stop,Γj(r) = Γ( r)forr∈dom(Γ)\{p,q},∆j= ∆. We show Γj; ∆j/subsetsqequalR/angbracketleftC;Gj/angbracketright.
(A1) We want to show ∀s∈roles(Gj) : Γj(s)6GjRs. We consider two subcases:
∗s=p(meaning that p∈roles(Gj)): trivial by Γj(p)=GjRpand the reﬂexivity
of subtyping.
∗s/negationslash=p: since q∈C, we have s/negationslash=q. By association (47)andΓj(s)=Γ(s), we
have Γj(s)6d
i∈IGiRs. Then, by Lem. 44 and transitivity of subtyping, we
conclude Γj(s)6GjRs, as desired.
(A2) No change here.
(A3)No change here if p∈roles(Gj). Otherwise, consider the case that p/∈roles(Gj):
with p/∈roles (Gj), by Lem. 40, we have GjRp=end. Therefore, we know from
Γj(p) =GjRpthat Γj(p) =end, as required.
(A4) Trivial by association (47), Def. 10, and ∆j= ∆.
Byinductivehypothesis,thereexists Γ/prime
j;∆/prime
jsuchthat Γj;∆jα− →Γ/prime
j;∆/prime
jandΓ/prime
j; ∆/prime
j/subsetsqequalR/angbracketleftC/prime;G/prime
j/angbracketright.
Since subj(α)/∈{p,q}, we apply Lem. 53, which gives Γj(p)=Γ/prime
j(p)andΓj(q)=
Γ/prime
j(q) =stop. We know from Γ/prime
j(q) =stopandΓ/prime
j; ∆/prime
j/subsetsqequalR/angbracketleftC/prime;G/prime
j/angbracketrightthat q∈C/prime.
We now construct a conﬁguration Γ/prime;∆/primeand show Γ;∆α− →Γ/prime;∆/primeandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.
LetΓ/prime(p)=Γ(p),Γ/prime(q)=Γ(q)=stop,Γ/prime(r)=d
i∈IΓ/prime
i(r)forr∈dom(Γ)\{p,q},
∆/prime= ∆/prime
jwith an arbitrary j∈I.
For the ﬁrst part that Γ; ∆α− →Γ/prime; ∆/prime:
We know that for any i∈I,Γ/prime
iis obtained from Γiby updating subj(α)to a ﬁxed type
T. It follows that for any i,k∈Iand for any r/∈{p,q},Γ/prime
i(r)=Γ/prime
k(r), and hence,d
i∈IΓ/prime
i(r)=Γ/prime
j(r)with an arbitrary j∈J. Therefore, we have that Γ/primeis obtained
from Γby updating subj(α)toΓ/prime
j(subj(α)), i.e., Γ/prime= Γ[subj(α)/mapsto→Γ/prime
j(subj(α))].A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 51
WeapplyLem.65on Γj;∆jα− →Γ/prime
j;∆/prime
j,Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright,Γj; ∆j/subsetsqequalR/angbracketleftC;Gj/angbracketright,Γ(subj(α))=
Γj(subj(α)), and Γ/prime= Γ[subj(α)/mapsto→Γ/prime
j(subj(α))]to get the thesis.
For the second part that Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright:
(A1) We want to show ∀r∈roles(G/prime) : Γ/prime(r)6G/primeRr. We consider two subcases:
∗r=p: by association (47)and Lem. 49, we obtain Γ(p)=q⊕{mi(Bi).Ti}i∈I/prime
whereI/prime⊆Imi\crashand∀i∈I/prime:Ti6GiRp. Since Γi(p)=GiRp=Γ/prime
i(p)for
eachi∈I, with association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketright, we getGiRp=Γ/prime
i(p)6G/prime
iRp.
Then by transitivity of subtyping, it holds that ∀i∈I/prime:Ti6G/prime
iRp, which
follows that q⊕{mi(Bi).Ti}i∈I/prime6q⊕{mi(Bi).(G/prime
iRp)}i∈Imi\crash, as desired.
∗r/negationslash=p: since q∈C/prime, we have r/negationslash=q. By association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketrightfor each
i∈I, it holds that Γ/prime
i(r)6G/prime
iRrfor eachi∈I. Then by applying Lem. 47, we
conclude with Γ/prime(r) =d
i∈IΓ/prime
i(r)6d
i∈IG/prime
iRr=G/primeRr, as desired.
(A2) We want to show ∀r∈C/prime: Γ/prime(r) =stop. We consider two subcases:
∗r=q: trivial by Γ/prime(q) =stop.
∗r/negationslash=q: by association Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketrightfor eachi∈I, it holds that∀r∈C/prime:
Γ/prime
i(r)=stop, which follows that for any r∈C/primewith r/negationslash=q,Γ/prime(r)=d
i∈IΓ/prime
i(r)=
stop, as desired.
(A3)For any endpoint rinG/prime,ris an endpoint in each G/prime
iwithi∈I. Then by association
Γ/prime
i; ∆/prime
i/subsetsqequalR/angbracketleftC/prime;G/prime
i/angbracketright, we have Γ/prime
i(r)=end, which follows Γ/prime(r)=d
i∈IΓ/prime
i(r)=end, as
desired.
(A4)By Lem. 57, it holds that for any i,j∈I,∆/prime
i=∆/prime
j. Take an arbitrary ∆/prime
jwithj∈I.
Note here ∆/prime=∆/prime
j. With the fact that ∆/prime
iis associated with G/prime
ifor anyi∈I, we have
that∀i∈I:∆/prime
jis associated with G/prime
i, and hence,∀i∈I:∆/primeis associated with G/prime
i.
We are left to show that ∆/prime(p,q)=/circledivide, which is obtained by applying Lem. 54 on
∆(p,q) =/circledivideandΓj; ∆α− →Γ/prime
j; ∆/prime
jwith subj(α)/∈{p,q}.
Case [GR-Ctx-ii] : similar to the case [GR-Ctx-i]. J
ITheorem11 (CompletenessofAssociation) .Given associated global type Gand conﬁguration
Γ;∆:Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright. If Γ;∆α− →Γ/prime;∆/prime, whereα/negationslash=p for all p∈R, then there exists
/angbracketleftC/prime;G/prime/angbracketrightsuch that Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketrightand/angbracketleftC;G/angbracketrightα− →R/angbracketleftC/prime;G/prime/angbracketright.
Proof.By induction on reductions of conﬁguration Γ; ∆α− →Γ/prime; ∆/prime.
Case [Γ-⊕]:
From the premise, we have:
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (53)
Γ(p) =q⊕{mi(Bi).Ti}i∈I (54)
α=p⊕q:mk(Bk) (55)
k∈I (56)
Γ/prime= Γ[p/mapsto→Tk] (57)
∆/prime= ∆[ p,q/mapsto→∆(p,q)·mk(Bk)] (58)
Apply Lem. 61 Item 1 on (54), we have two cases.
Case (1):
unf(G) =p→q†:{mi(B/prime
i).Gi}i∈I/prime (59)
I⊆I/prime(60)
∀i∈I:mi=mi,Ti6(GiRp),Bi=B/prime
i (61)52 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
We have two further subcases here: namely q†=qandq†=q .
∗In the case of q†=q, we havek∈I⊆I/primeand crashdoes not appear in internal
choices, we apply [GR-⊕](via Lem. 51) to get:
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC;p q:k{mi(B/prime
i).Gi}i∈I/prime/angbracketright (62)
We are now left to show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;p q:k{mi(B/prime
i).Gi}i∈I/prime/angbracketright.
Note thatG/prime=p q:k{mi(B/prime
i).Gi}i∈I/primehere. By Def. 35, we have roles(G)=roles(G/prime)
androles (G)=roles (G/prime). Furthermore, with dom(Γ) =dom(Γ/prime)andp∈roles(G),
we can set Γ/prime= ΓG[p/mapsto→Tk],Γ ,Γend.
(A1)First, we want to show that dom(ΓG[p/mapsto→Tk])={p|p∈roles(G/prime))}, which follows
directly from the fact that dom(ΓG)={p|p∈roles(G))},roles(G)=roles(G/prime),
anddom(ΓG[p/mapsto→Tk]) = dom(Γ G).
Then, we are left to show ∀r∈roles(G/prime):ΓG[p/mapsto→Tk](r)6G/primeRr. We consider
two cases:
·r=p: we haveG/primeRp=GkRp. By(61), we obtain that ΓG[p/mapsto→Tk](p)=
Tk6GkRp=G/primeRp, as desired.
·r/negationslash=p: since Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, we have that ΓG(r)6GRr=d
i∈I/primeGiRr.
Furthermore, by ΓG[p/mapsto→Tk](r)=ΓG(r)andG/primeRr=d
i∈I/primeGiRr, we have
that ΓG[p/mapsto→Tk](r)6G/primeRr, as desired.
(A2) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A3) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A4)By(58), we have ∆/prime(p,q)=∆(p,q)·mk(Bk). Then we only need to show that ∀i∈
I/prime:∆/prime[p,q/mapsto→∆(p,q)](note that ∆/prime[p,q/mapsto→∆(p,q)]=∆)is associated with /angbracketleftC;Gi/angbracketright,
which follows directly from the fact that ∆is associated with /angbracketleftC;G/angbracketrightand Def. 10.
∗In the case of q†=q , we havek∈I⊆I/prime,q∈C, and crashdoes not appear in
internal choices. We apply [GR- m](via Lem. 51) to get:
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC;Gk/angbracketright (63)
We are now left to show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;Gk/angbracketright.
Note thatG/prime=Gkhere.
(A1)We need to show that ∀r∈roles(Gk):Γ/prime(r)6GkRr. We consider two subcases:
·r=p, which means that p∈roles(Gk): by(57)and(61), we have Γ/prime(p)=
Tk6GkRp, as desired.
·r/negationslash=p: with q/∈roles(Gk), we have r/negationslash=q, and hence, GRr=d
i∈I/primeGiRr.
Furthermore, by (57)and Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, it holds that Γ/prime(r)=Γ(r)6
GRr=d
i∈I/primeGiRr. Then, by Lem. 44 and transitivity of subtyping,
we can conclude that Γ/prime(r)6GkRr, as desired.
(A2) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A3)Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightand the fact that if p/∈roles(Gk), then Γ/prime(p)=end:
with p/∈roles (Gk), by Lem. 40, we have GkRp=end. Furthermore, by (61),
it holds that Tk=end, and thus, Γ/prime(p) =end, as desired.
(A4)Since q∈C,byDef.10, wehave ∆(·,q)=/circledivide. Hence, ∆/prime=∆[p,q/mapsto→∆(p,q)·mk(Bk)]=
∆[p,q/mapsto→/circledivide· mk(Bk)]=∆[p,q/mapsto→/circledivide]=∆. Then we only need to show that ∆is
associated with/angbracketleftC;Gk/angbracketright, which follows directly from the fact that ∆is associated
with/angbracketleftC;G/angbracketrightand Def. 10.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 53
Case (2):
unf(G) =s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈Jorunf(G) =s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J(64)
∀j∈J: Γ(p)6GjRp (65)
p/negationslash=sand p/negationslash=t (66)
Weconsidertwosubcases: unf(G)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈Jandunf(G)=s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J.
∗In the case of unf(G) =s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J:
First, we take an arbitrary index j∈Jand construct a conﬁguration Γj;∆jsuch
that Γj; ∆jp⊕q:mk(Bk)−−−−−−−→ Γ/prime
j; ∆/prime
jandΓj; ∆j/subsetsqequalR/angbracketleftC;Gj/angbracketright.
We know from s∈roles(G)and Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, that Γ(s)6unf(G)Rsand
unf(G)Rs=t⊕/braceleftbig
mj(B/prime
j).(GjRs)/bracerightbig
j∈Jmj\crash. Byinverting [Sub-⊕](applyingLem.43
where necessary), we have unf(Γ( s))=t⊕/braceleftbig
mj(B/prime/prime
j).T/prime/prime
j/bracerightbig
j∈Js, whereJs⊆Jmj\crash,
and∀j∈Js:T/prime/prime
j6(GjRs).
To construct Γj, let Γj(s)=T/prime/prime
jifj∈JsandΓj(s)=GjRsotherwise. In either
case, we have Γj(s)6GjRs, as required.
We have two further subcases here: namely t†=tandt†=t .
·Ift†=t,weknowfrom t∈roles(G)andΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright,that Γ(t)6unf(G)Rt=
s&/braceleftbig
mj(B/prime
j).(GjRt)/bracerightbig
j∈J. By inverting [Sub- &](applying Lem. 43 where neces-
sary), we have unf(Γ( t))=s&/braceleftbig
mj(B/prime/prime
j).U/prime/prime
j/bracerightbig
j∈Jt, whereJ⊆Jt, and∀j∈J:
U/prime/prime
j6(GjRt).
To construct Γj, letΓj(t) =U/prime/prime
j, and we have Γj(t)6GjRt, as required.
·Ift†=t , letΓj(t) = Γ( t) =stop, as required.
Forroles r∈(roles(Gj)∪C), where r/∈{s,t}, theirtypingcontextentrydonotchange,
i.e.Γj(r)=Γ(r). For crashed roles r∈C, we have stop=Γ(r)=Γj(r)=stop, as
required. For non-crashed roles r∈roles(Gj), we have Γj(r)=Γ(r)6GRr=d
j∈J(GjRr)6GjRr(applying Lem. 44).
We know from Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightand unf(G)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, that ∆is
associated with Gj. Hence, to construct ∆j, just let ∆j=∆. Notice that{p,q}∈
roles(Gj), sotheyarestillabletoperformthecommunicationaction Γj;∆jp⊕q:mk(Bk)−−−−−−−→
Γ/prime
j; ∆/prime
j.
We apply inductive hypothesis on Γj;∆j, and obtain/angbracketleftC;Gj/angbracketrightp⊕q:mk(Bk)−−−−−−→ R/angbracketleftC;G/prime
j/angbracketrightand
Γ/prime
j; ∆/prime
j/subsetsqequalR/angbracketleftC;G/prime
j/angbracketright.
We apply [GR-Ctx-i] (via Lem. 51) to get:
/angbracketleftC;G/angbracketrightp⊕q:mk(Bk)−−−−−−→ R/angbracketleftC;s→t†:/braceleftbig
mj(B/prime
j).G/prime
j/bracerightbig
j∈J/angbracketright (67)
We are now left to show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;s→t†:/braceleftbig
mj(B/prime
j).G/prime
j/bracerightbig
j∈J/angbracketright.
Note thatG/prime=s→t†:/braceleftbig
mj(B/prime
j).G/prime
j/bracerightbig
j∈Jhere.
(A1)For role s, we know that unf(Γ( s))=t⊕/braceleftbig
mj(B/prime/prime
j).T/prime/prime
j/bracerightbig
j∈Js, whereJs⊆Jmj\crash,
∀j∈Js:T/prime/prime
j6(GjRs), andB/prime/prime
j=B/prime
j.
Since s/∈subj( p⊕q:mk(Bk)), we apply Lem. 53 on ΓandΓjfor allj∈Js. For all
j∈Js, We haveT/prime/prime
j=Γj(s)=Γ/prime
j(s)(from Lem. 53) and Γ/prime
j(s)6G/prime
jRs(from
inductive hypothesis). Therefore, we have T/prime/prime
j6G/prime
jRs. We now apply Lem. 53
onΓ, which gives unf(Γ(s[s]))=unf(Γ/prime(s[s]))=t⊕/braceleftbig
mj(B/prime/prime
j).T/prime/prime
j/bracerightbig
j∈Js. We can
now apply [Sub-⊕]to conclude Γ/prime(s)6G/primeRs, as required.54 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
For role t(where t†=t), we know that unf(Γ( t))=s&/braceleftbig
mj(B/prime/prime
j).U/prime/prime
j/bracerightbig
j∈Jt, where
J⊆Jt,∀j∈J:U/prime/prime
j6(GjRt), andB/prime
j=B/prime/prime
j. Since t/∈subj( p⊕q:mk(Bk)),
we apply Lem. 53 on Γand Γjfor allj∈J. For allj∈JWe haveU/prime/prime
j=
Γj(t)=Γ/prime
j(t)(from Lem. 53) and Γ/prime
j(t)6G/prime
jRt(from inductive hypothesis).
Therefore, we have U/prime/prime
j6G/prime
jRt. We now apply Lem. 53 on Γ, which gives
unf(Γ( t))=unf(Γ/prime(t))=s&/braceleftbig
mj(B/prime/prime
j).U/prime/prime
j/bracerightbig
j∈Jt. We can now apply [Sub- &]to
conclude Γ/prime(t)6G/primeRt, as required.
For other role r∈roles(G/prime)(where r/∈{s,t}), we need to show Γ/prime(r)6G/primeRr.
We know what G/primeRr=d
j∈JG/prime
jPr. Ifr/∈{p,q}, we apply Lem. 53 on Γj,
obtaining Γj(r)=Γ/prime
j(r). The inductive hypothesis gives Γ/prime
j(r)6G/prime
jRr, we
apply Lem. 45 to obtain Γ/prime
j(r)6G/primeRr=d
j∈JG/prime
jPr. Note that Γ/prime
j(r)=Γj(r)
by Lem. 53, and Γj(r)=Γ(r)by construction. Therefore, we have Γ/prime(r)=Γ(r)6
G/primeRr, as required.
We are left to consider the cases of pandq. We know what G/primeRp=d
j∈JG/prime
jPp
and{p,q}⊆roles(G/prime). The inductive hypothesis gives Γ/prime
j(p)6G/prime
jRp, we apply
Lem. 45 to obtain Γ/prime
j(p)6G/primeRp=d
j∈JG/prime
jPp. We now apply Lem. 56 on
Γand all Γj, which gives Γ/prime
j=Γ/primefor allj. Therefore, we have Γ/prime(p)6G/primeRp.
Note that Γ/prime(p) = Γ/prime
j(p) =Tk(as in (57) ). The argument qfollows similarly.
(A2)For crashed roles r∈C, we have Γ/prime(r)=Γ(r)=stop(applying Lem. 53). Note
that if t†=t ,t∈C.
(A3) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A4)Weknowfrom ∆j=∆andΓj;∆jp⊕q:mk(Bk)−−−−−−−→ Γ/prime
j;∆/prime
j,that ∆/prime
j=∆j[p,q/mapsto→∆j(p,q)·mk(Bk)]=
∆[p,q/mapsto→∆(p,q)·mk(Bk)]=∆/prime. Furthermore, by inductive hypothesis, ∆/prime
jis as-
sociated with/angbracketleftC;G/prime
j/angbracketright, which follows that ∀j∈J:∆/primeis associated with /angbracketleftC;G/prime
j/angbracketright.
We are left to show that if t†/negationslash=t , then ∆/prime(s,t)=/epsilon1, which follows directly from
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightand∆/prime(s,t) = ∆( s,t).
In the case of unf(G) =s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J:
Similar to that of the previous subcase that unf(G)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, applying
[GR-Ctx-ii] instead.
Case [Γ-&]:
From the premise, we have:
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (68)
Γ(p) =q&{mi(Bi).Ti}i∈I(69)
α=p&q:mk(Bk) (70)
k∈I (71)
m/prime=mk (72)
B/prime=Bk (73)
∆(q,p) =m/prime(B/prime)·τ/prime/negationslash=/circledivide (74)
Γ/prime= Γ[p/mapsto→Tk] (75)
∆/prime= ∆[ q,p/mapsto→τ/prime] (76)
Apply Lem. 61 Item 2 on (69), we have two cases.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 55
Case (1):
unf(G) =q† p:j{mi(B/prime
i).Gi}i∈I/primeorunf(G) =q→p†:{mi(B/prime
i).Gi}i∈I/prime (77)
I/prime⊆I (78)
∀i∈I/prime:mi=mi,Ti6(GiRp),B/prime
i=Bi (79)
q/∈Rimplies∃l∈I/prime:ml=crash (80)
First, we show that in this case, unf(G)cannot be of the form q→p†:{mi(B/prime
i).Gi}i∈I/prime.
There are two subcases to be considered: p†=pandp†=p .
∗In the case of p†=p , we have p∈C. Hence, by applying Def. 10 on (68), we have
that ∆(·,p) =/circledivide, a desired contradiction to (74).
∗In the case of p†=p, by association, it holds that ∆(q,p)=/epsilon1, a desired contradiction
to (74).
Therefore, we only need to consider the case that unf(G) =q† p:j{mi(B/prime
i).Gi}i∈I/prime.
Then we want to show that mj/negationslash=crash, which is proved by contradiction. Assume
that mj=crash, by association, we have that ∆(q,p)=/epsilon1, a desired contradiction to
(74). Moreover, we want to show that j=k. By association and mj/negationslash=crash, we have
∆(q,p)=mj(Bj)·τ=mk(B/prime)·τ/prime. Then by (79), it holds that mj=mj=mk. Furthermore,
byj,k∈Iand the requirement that labels in local types must be pair-wise distinct, we
havej=k, as required. Note that k∈I/primehere.
We can now apply [GR-&](via Lem. 51) to get:
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC;Gk/angbracketright (81)
We are left to show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;Gk/angbracketright.
(A1)We need to show that ∀r∈roles(Gk):Γ/prime(r)6GkRr. We consider three subcases:
∗r=q, which means that q†=qand q∈roles(Gk): by(75),Γ/prime(q)=Γ(q). Then
by association, we have Γ(q)6GRq=GkRq, as desired.
∗r=p, which means that p∈roles(Gk): by(75)and(79), we have Γ/prime(p)=Tk6
GkRp, as desired.
∗r/negationslash=qandr/negationslash=p:GRr=d
i∈I/primeGiRr. Furthermore, by (75)andΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright,
it holds that Γ/prime(r)=Γ(r)6GRr=d
i∈I/primeGiRr. Then, by Lem. 44 and trans-
itivity of subtyping, we can conclude that Γ/prime(r)6GkRr, as desired.
(A2)Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright. Note that in the case of q†=q , we have q∈C, and
hence, Γ/prime(q) = Γ( q) =stop.
(A3)Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightand the fact that if p/∈roles(Gk), then Γ/prime(p)=end: with
p/∈roles (Gk), by Lem. 40, we have GkRp=end. Furthermore, by (79), it holds
thatTk=end, and thus, Γ/prime(p)=end, as desired. The argument for the case that
q†=qandq/∈roles(Gk)follows similarly.
(A4)Since ∆is associated with /angbracketleftC;q† p:j{mi(B/prime
i).Gi}i∈I/prime/angbracketrightand mj/negationslash=crash, by Def. 10,
we have that ∆(q,p)=mj(Bj)·τand∀i∈I/prime:∆[q,p/mapsto→τ]is associated with /angbracketleftC;Gi/angbracketright,
which follows that τ=τ/prime(in(74)) and ∆/prime=∆[q,p/mapsto→τ/prime]=∆[q,p/mapsto→τ]is associated
with/angbracketleftC;Gk/angbracketright, as required.
Case (2): similar to the case (2) in Case [Γ-⊕].
Case [Γ- ]:56 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
From the premise, we have:
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (82)
Γ(p)/negationslash=end (83)
Γ(p)/negationslash=stop (84)
α=p (85)
Γ/prime= Γ[p/mapsto→stop] (86)
∆/prime= ∆[·,p/mapsto→/circledivide] (87)
By (84), we know that p/∈Candp∈roles(G). The premise requires that α/negationslash=p for all
p∈R, therefore, p/∈R. We apply [GR- ](via Lem. 51) to get:
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC∪{p};G p/angbracketright (88)
We are now left to show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC∪{p};G p/angbracketright.
Note thatG/prime=G pandC/prime=C∪{p}here. By (86), we can set Γ/prime=Γ/prime
G/prime,Γ/prime
 ,Γ/prime
end, where
dom(Γ/prime
G/prime)={q|q∈roles(G p)}={q|q∈roles(G)}\{p}=dom(ΓG)\{p},dom/parenleftBig
Γ/prime
 /parenrightBig
=
C∪{p}=dom(Γ )∪{p}, and dom(Γ/prime
end)=dom(Γ end). Meanwhile, we have Γ/prime(q)=Γ(q)
ifq/negationslash=p.
(A1)We want to show that for any q∈roles(G p), we have Γ/prime(q)=Γ(q)6GRq6
(G p)Rqby Lem. 48 and Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A2) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightand (86), i.e., Γ/prime(p) =stop.
(A3) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A4)Since ∆is associated with /angbracketleftC;G/angbracketright, by Def. 10, we have that for any q∈C,∆(·,q)=/circledivide.
Then, with (87), we have that for any q∈C∪{p},∆/prime(·,q)=∆[·,p/mapsto→/circledivide](·,q)=/circledivide,
which follows directly that ∆/primeis associated with /angbracketleftC∪{p};G p/angbracketright.
Case [Γ-⊙]:
From the premise, we have:
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (89)
Γ(q) =p&{mi(Bi).Ti}i∈I(90)
Γ(p) =stop (91)
α=q⊙p (92)
k∈I (93)
mk=crash (94)
∆(p,q) =/epsilon1 (95)
Γ/prime= Γ[q/mapsto→Tk] (96)
∆/prime= ∆ (97)
Since Γ(p)=stop, we have p∈Candp/∈R. Apply Lem. 61 Item 2 on (90), we have two
cases.
Case (1):
unf(G) =p  q:j{mi(B/prime
i).Gi}i∈I/prime (98)
I/prime⊆I (99)
∀i∈I/prime:mi=mi,Ti6(GiRq),B/prime
i=Bi (100)
p/∈Rimplies∃l∈I/prime:ml=crash (101)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 57
Then we want to show that mj=crash, which is proved by contradiction. Assume that
mj/negationslash=crash, by association, we have that ∆(p,q)=mj(Bj)·τ, a desired contradiction to
(95). Moreover, we want to show that j=k. By(100), we have mj=mj, which means
that mj=crash. Since mj=mk=crashandj,k∈I, by the requirement that labels in
local types must be pair-wise distinct, we have j=k, as required. Note that k∈I/prime
here.
We can now apply [GR-⊙](via Lem. 51) to get:
/angbracketleftC;G/angbracketrightα− →R/angbracketleftC;Gk/angbracketright (102)
We are left to show Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;Gk/angbracketright.
(A1) We need to show that ∀r∈roles(Gk) : Γ/prime(r)6GkRr. We consider two subcases:
∗r=q, which means that q∈roles(Gk): by(96)and(100), we have Γ/prime(q)=Tk6
GkRq, as desired.
∗r/negationslash=q: with p/∈roles(Gk), we have r/negationslash=p, and hence, GRr=d
i∈I/primeGiRr.
Furthermore, by (96)andΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, it holds that Γ/prime(r)=Γ(r)6GRr=d
i∈I/primeGiRr. Then, by Lem. 44 and transitivity of subtyping, we can conclude
that Γ/prime(r)6GkRr, as desired.
(A2) Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright.
(A3)Trivial by Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketrightand the fact that if q/∈roles(Gk), then Γ/prime(q)=end: with
q/∈roles (Gk), by Lem. 40, we have GkRq=end. Furthermore, by (100), it holds
thatTk=end, and thus, Γ/prime(q) =end, as desired.
(A4)Since ∆is associated with /angbracketleftC;p  q:j{mi(B/prime
i).Gi}i∈I/prime/angbracketrightand mj=crash, by Def. 10,
we have that∀i∈I/prime:∆is associated with /angbracketleftC;Gi/angbracketright, which follows that ∆/prime=∆is
associated with/angbracketleftC;Gk/angbracketright, as required.
Case (2): similar to the case (2) in Case [Γ-⊕].
Case [Γ-µ]: by induction and Prop. 60. J
E.6 Properties by Projection
Safety by Projection
ILemma 66. IfΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, then Γ; ∆isR-safe.
Proof.Letϕ={Γ/prime; ∆/prime|∃C/prime,G/prime:/angbracketleftC;G/angbracketright− →∗
R/angbracketleftC/prime;G/prime/angbracketrightandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright}. Take any
Γ/prime;∆/prime∈ϕ, we show that Γ/prime;∆/primesatisﬁes all clauses in Def. 14, which means that ϕis
anR-safety property. Then we can conclude that, since ϕ(Γ; ∆)holds, Γ; ∆isR-safe.
By deﬁnition of ϕ, there exists/angbracketleftC/prime;G/prime/angbracketrightwith/angbracketleftC;G/angbracketright− →∗
R/angbracketleftC/prime;G/prime/angbracketrightandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright.
[S-⊕&]From the premise, we have
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright (103)
Γ/prime(q) =p&{mi(Bi).Ti}i∈I(104)
∆/prime(p,q)/negationslash=/circledivide (105)
∆/prime(p,q)/negationslash=/epsilon1 (106)
Apply Item 2 of Lem. 61 on (104), we have two cases.58 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Case (1):
unf(G/prime) =p† q:j{mi(B/prime
i).Gi}i∈I/primeorunf(G/prime) =p→q†:{mi(B/prime
i).Gi}i∈I/prime(107)
I/prime⊆I (108)
∀i∈I/prime:mi=mi,Ti6(GiRq),B/prime
i6Bi (109)
First, we show that unf(G/prime)cannot be the form of p→q†:{mi(B/prime
i).Gi}i∈I/prime. We prove
this by contradiction on two subcases: q†=qandq†=q :
∗q†=q: by association (103), we have ∆/prime(p,q)=/epsilon1, a desired contradiction to (106).
∗q†=q : we have q∈C. Hence, by association (103), we have ∆/prime(·,q)=/circledivide, a desired
contradiction to (105).
It follows that unf(G/prime)=p† q:j{mi(B/prime
i).Gi}i∈I/prime. We are left to show that j∈I,
B/prime
j6Bj, and ∆/prime(p,q)=mj(B/prime
j)·τ, and then by applying [Γ-&], we can conclude with
Γ/prime; ∆/primeq&p:mj(Bj)−−−−−−−→ . We consider two subcases: mj=crashandmj/negationslash=crash:
∗mj=crash: by association, ∆/prime(p,q) =/epsilon1, a desired contradiction to (106).
∗mj/negationslash=crash: by association, ∆/prime(p,q)=mj(B/prime
j)·τ. Moreover, with (108)and(109), we
obtain that j∈I,B/prime
j6Bj, and mj=mj, which follows that ∆/prime(p,q)=mj(B/prime
j)·τ, as
desired.
Case (2): unf(G/prime)=s→t†:/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J, orunf(G/prime)=s† t:k/braceleftbig
mj(B/prime
j).Gj/bracerightbig
j∈J,
where for all j∈J:Γ/prime(q)6(GjRq), with q/negationslash=sandq/negationslash=t.
We apply Lem. 63 to get that there exists a global type /angbracketleftC/prime/prime;G/prime/prime/angbracketrightand a queue environ-
ment ∆/prime/primesuch that Γ/prime(q)6G/prime/primeRq,unf(G/prime/prime)is of the form p† q:j{mi(B/prime
i).Gi}i∈I/primeor
p→q†:{mi(B/prime
i).Gi}i∈I/prime, and ∆/prime/primeis associated with /angbracketleftC/prime/prime;G/prime/prime/angbracketrightwith ∆/prime/prime(p,q)=∆/prime(p,q).
The following proof argument is similar to that for Case (1).
[S- &]From the premise, we have Γ/prime(q)=p&{mi(Bi).Ti}i∈I,Γ/prime(p)=stop, and ∆/prime(p,q)=/epsilon1. We
just need to show that there exists k∈Iwith mk=crash, and then by applying [Γ-⊙],
we can conclude with Γ/prime; ∆/primeq⊙p−−→. By the association that Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright, we have
Γ/prime(q)=p&{mi(Bi).Ti}i∈I6G/primeRq. Moreover, with p/∈R, which follows directly from
Γ/prime(p) =stop, we can apply Lem. 62 to get ∃k∈I:mk=crash, as desired.
[S-µ]LetΓ/prime/prime;∆/prime/primebe constructed from Γ/prime;∆/primewith Γ/prime/prime=Γ/prime[p/mapsto→S{µt.S/t}]and∆/prime/prime=∆/prime. We
want to show that Γ/prime/prime; ∆/prime/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright. From the premise, we have Γ/prime(p)=µt.S. Then
by association that Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright, it holds that Γ/prime(p)=µt.S6G/primeRp. Hence,
by inverting [Sub-µL], we have Γ/prime/prime(p)=S{µt.S/t}6G/primeRp. Therefore, by Def. 10, we
conclude with Γ/prime/prime; ∆/prime/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright, as desired.
[S-→ ]From the premise, we have Γ/prime;∆/prime→RΓ/prime/prime;∆/prime/prime. Hence, by Thm. 11, there exists /angbracketleftC/prime/prime;G/prime/prime/angbracketright
with/angbracketleftC/prime;G/prime/angbracketrightα− →R/angbracketleftC/prime/prime;G/prime/prime/angbracketright, whereα/negationslash=p for all p∈R, and Γ/prime/prime; ∆/prime/prime/subsetsqequalR/angbracketleftC/prime/prime;G/prime/prime/angbracketright. By
deﬁnition of ϕ, the conﬁguration after transition Γ/prime/prime; ∆/prime/primeis inϕ, as desired. J
Deadlock Freedom by Projection
ILemma 67. IfΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, then Γ; ∆isR-deadlock-free.
Proof.Since Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, by Lem. 66, we have that Γ;∆isR-safe. By operational
correspondence of global type /angbracketleftC;G/angbracketrightand conﬁguration Γ;∆(Thms. 11 and 12), there
exists a global type /angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →∗
R/angbracketleftC/prime;G/prime/angbracketright/negationslash− →R, with associated conﬁgurations
Γ;∆→∗
RΓ/prime;∆/prime/negationslash→R. Sincenofurtherreductionsarepossiblefortheglobaltype, theglobaltype
/angbracketleftC/prime;G/prime/angbracketrightmust be of the form /angbracketleftC/prime;end/angbracketright. By applying Def. 10 on Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;end/angbracketright, we have
Γ/prime=Γ/prime
end,Γ/prime
 , where dom(Γ/prime
end)={p|Γ/prime(p) =end}anddom/parenleftBig
Γ/prime
 /parenrightBig
=C/prime={p|Γ/prime(p) =stop},A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 59
asrequired. Byassociationagain, wehavethat, forany p,q, ifq∈C/prime(=dom/parenleftBig
Γ/prime
 /parenrightBig
),∆/prime(·,q)=
/circledivide, and otherwise, ∆/prime(p,q) =/epsilon1, as required. J
Liveness by Projection
ILemma 68. IfΓ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, then Γ; ∆isR-live.
Proof.Since Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, by Lem. 66, we have that Γ; ∆isR-safe.
We are left to show that if Γ;∆→∗
RΓ/prime;∆/prime, then any non-crashing path starting with
Γ/prime;∆/primewhich is fair is also live. By operational correspondence of global type /angbracketleftC;G/angbracketrightand
conﬁguration Γ;∆(Thms. 11 and 12), there exists a global type /angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →∗
R
/angbracketleftC/prime;G/prime/angbracketrightandΓ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright. We construct a non-crashing fair path (Γ/prime
n;∆/prime
n)n∈N, where
N={0,1,2,...},Γ/prime
0=Γ/prime,∆/prime
0=∆/prime, and∀n∈N,Γ/prime
n;∆/prime
n→Γ/prime
n+1;∆/prime
n+1. Then we just need
to show that (Γ/prime
n; ∆/prime
n)n∈Nis live.
(L1)Suppose that ∆/prime
n(p,q)=m(B)·τ/negationslash=/circledivideand m/negationslash=crash. By operational correspondence
of/angbracketleftC/prime;G/prime/angbracketrightand conﬁguration Γ/prime
0;∆/prime
0, and∀n∈N,Γ/prime
n;∆/prime
n→Γ/prime
n+1;∆/prime
n+1, there exists
/angbracketleftC/prime
n;G/prime
n/angbracketrightsuch that Γ/prime
n; ∆/prime
n/subsetsqequalR/angbracketleftC/prime
n;G/prime
n/angbracketright. By Lem. 63 and Def. 10, we only need to consider
the case that G/prime
n=p† q:j{mi(Bi).G/prime/prime
i}i∈Iwith m=mj/negationslash=crashandBj=B. By
applying [GR-&],/angbracketleftC/prime
n;G/prime
n/angbracketrightq&p:mj(Bj)−−−−−−→ R/angbracketleftC/prime
n;G/prime/prime
j/angbracketright. Hence, by the soundness of association,
it holds that Γ/prime
n;∆/prime
nq&p:m(B)−−−−−−→ . Finally, combining the fact that (Γ/prime
n;∆/prime
n)n∈Nis fair
with Γ/prime
n;∆/prime
nq&p:m(B)−−−−−−→ , we can conclude that there exists ksuch thatn≤k∈Nand
Γ/prime
k; ∆/prime
kq&p:m(B)−−−−−−→ Γ/prime
k+1; ∆/prime
k+1, as desired.
(L2)Suppose that Γ/prime
n(p)=q&{mi(Bi).Ti}i∈I. By operational correspondence of /angbracketleftC/prime;G/prime/angbracketrightand
conﬁguration Γ/prime
0;∆/prime
0, and∀n∈N,Γ/prime
n;∆/prime
n→Γ/prime
n+1;∆/prime
n+1, there exists/angbracketleftC/prime
n;G/prime
n/angbracketrightsuch that
Γ/prime
n; ∆/prime
n/subsetsqequalR/angbracketleftC/prime
n;G/prime
n/angbracketright. By Def. 10, Lem. 61, and Lem. 63, we only have to consider that
G/prime
nis of the form q→p†:{mi(B/prime
i).G/prime/prime
i}i∈I/primeorq† p:j{mi(B/prime
i).G/prime/prime
i}i∈I/prime, whereI/prime⊆I, and
for alli∈I/prime:mi=mi,B/prime
i=Bi, and q/∈Rimplies∃k∈I/prime:mk=crash.
G/prime
n=q→p†:{mi(B/prime
i).G/prime/prime
i}i∈I/prime: weﬁrstshowthat p†=p. Since Γ/prime
n(p)/negationslash=stop, byDef.10,
we have that p/∈C/prime
n, and hence, p†/negationslash=p . Given that G/prime
n=q→p:{mi(B/prime
i).G/prime/prime
i}i∈I/prime, by
association, Def. 10, and inversion of subtyping, Γ/prime
n(q)is of the form p⊕{mi(B/prime
i).T/prime
i}i∈I/prime/prime
whereI/prime/prime⊆I/prime. Then applying [Γ-⊕],Γ/prime
n;∆/prime
nq⊕p:mj(B/prime
j)−−−−−−−→ for somej∈I/prime/prime. Then
together with the fairness of (Γ/prime
n;∆/prime
n)n∈N, we have that there exists k,m/prime,B/prime/primesuch
thatn≤k∈NandΓ/prime
k;∆/prime
kq⊕p:m/prime(B/prime/prime)−−−−−−−→ Γ/prime
k+1;∆/prime
k+1, which follows that ∆/prime
k+1(q,p)=
∆/prime
k[q,p/mapsto→∆/prime
k(q,p)·m/prime(B/prime/prime)]. Finally, by the previous case (L1), we can conclude that
there exists k/prime,m/prime/prime,B/prime/prime/primesuch thatk+ 1≤k/prime∈NandΓ/prime
k/prime;∆/prime
k/primep&q:m/prime/prime(B/prime/prime/prime)−−−−−−−−→ Γ/prime
k/prime+1;∆/prime
k/prime+1,
as desired.
G/prime
n=q† p:j{mi(B/prime
i).G/prime/prime
i}i∈I/prime: we consider two subcases:
mj/negationslash=crash: by applying [GR-&],/angbracketleftC/prime
n;G/prime
n/angbracketrightp&q:mj(B/prime
j)−−−−−−→ R/angbracketleftC/prime
n;G/prime/prime
j/angbracketright. Hence, by the sound-
ness association, we have that Γ/prime
n;∆/prime
np&q:mj(B/prime
j)−−−−−−−→ . Finally, combining the fact that
(Γ/prime
n;∆/prime
n)n∈Nis fair with Γ/prime
n;∆/prime
np&q:mj(B/prime
j)−−−−−−−→ , we can conclude that there exists ksuch
thatn≤k∈NandΓ/prime
k; ∆/prime
kp&q:mj(B/prime
j)−−−−−−−→ Γ/prime
k+1; ∆/prime
k+1, as desired.
mj=crash: consider the following two subcases:
∗q†=q :Γ/prime
n(q)=stopbyq∈C/prime
n. By Def. 10, ∆/prime
n(q,p)=/epsilon1. Now applying [Γ-⊙]
onΓ/prime
n(p)=q&{mi(Bi).Ti}i∈I,Γ/prime
n(q)=stop,∆/prime
n(q,p)=/epsilon1and mj=mj=crash60 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
withj∈I/prime⊆I, we have that Γ/prime
n;∆/prime
np⊙q−−→. Then together with the fairness of
(Γ/prime
n;∆/prime
n)n∈N, we can conclude that there exists ksuch thatn≤k∈Nand
Γ/prime
k; ∆/prime
kp⊙q−−→ Γ/prime
k+1; ∆/prime
k+1.
∗q†/negationslash=q : since mj=crash, together with/angbracketleftC;G/angbracketright− →∗
R/angbracketleftC/prime;G/prime/angbracketright, we know that q†/negationslash=q
holds, a desired contradiction. J
ITheorem 20 (Safety, Deadlock-Freedom, and Liveness by Projection) .LetGbe a global
type without runtime constructs, and Rbe a set of reliable roles. If Γis a typing context
associated with the global type G:Γ/subsetsqequalRG, then Γ;∆∅isR-safe,R-deadlock-free, and R-live.
Proof.Note Γ/subsetsqequalRGis an abbreviation of Γ; ∆∅/subsetsqequalR/angbracketleft∅;G/angbracketright, apply Lems. 66–68. J
F Proofs for §5
ILemma 69 (Typing Inversion) .LetΘ/turnstileleftP:T. Then:
1.P=0impliesT=end;
2.P= impliesT=stop;
3.P=q!m/angbracketlefte/angbracketright.P1implies
(a1) q⊕m(B).T16T, and
(a2) Θ/turnstileleftP1:T1, and
(a3) Θ/turnstilelefte:B;
4.P=/summationtext
i∈Iq?mi(xi).Piimplies
(a1) q&{mi(Bi).Ti}i∈I6T, and
(a2)∀i∈IΘ,xi:Bi/turnstileleftPi:Ti;
5.P=ifethenP1elseP2implies
(a1) Θ/turnstilelefte: bool, and
(a2) Θ/turnstileleftP1:T, and
(a3) Θ/turnstileleftP2:T;
6.P=µX.P 1implies Θ,X:T1/turnstileleftP1:T1andT16Tfor someT1;
7.P=Timplies Θ/turnstileleftP:T/primefor someT/prime6T;
Let/turnstilelefth:δ. Then:
8.h=/epsilon1impliesδ=/epsilon1;
9.h=/circledivideimpliesδ=/circledivide;
10.h= (q,m(v))implies/turnstileleftv:Bandδ(q) =m(B);
11.h=h1·h2implies/turnstilelefth1:δ1, and/turnstilelefth2:δ2, andδ=δ1·δ2;
Let/angbracketleftC;G/angbracketright/turnstileleft/producttext
i∈I(pi/triangleleftPi|pi/trianglelefthi). Then:
(a1)∃Γ; ∆such that Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, and
(a2)∀i∈I:/turnstileleftPi: Γ(pi), and
(a3)∀i∈I:/turnstilelefthi: ∆(−,pi).
Proof.By induction on type derivations in Fig. 9. J
ILemma 70 (Typing Congruence) . 1.IfΘ/turnstileleftP:TandP≡Q, then Θ/turnstileleftQ:T.
2.If/turnstilelefth1:δ1andh1≡h2, then there exists δ2such thatδ1≡δ2and/turnstilelefth2:δ2.
3.If/angbracketleftC;G/angbracketright/turnstileleftMandM≡M/prime, then/angbracketleftC;G/angbracketright/turnstileleftM/prime.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 61
Proof.By analysing the cases where P≡Q,h1≡h2,δ1≡δ2, andM≡M/prime, and by typing
inversion Lem. 69. J
ILemma 71 (Substitution) .IfΘ,x:B/turnstileleftP:TandΘ/turnstileleftv:B, then Θ/turnstileleftP{v/x}:T.
Proof.By induction on the structure of P. J
ILemma 72 (Optional Lemma) .If∅/turnstilelefte:B, then there exists vsuch thate↓v.
Proof.By induction on the derivation of ∅/turnstilelefte:B. J
ILemma 73. If/angbracketleftC;G/angbracketright/turnstileleftMandM/negationslash= (p/triangleleft |p/triangleleft/circledivide)|M/prime(for all p,M/prime), then for any Γ;∆
such that Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright, it holds that∀p∈roles(G) : Γ( p)/negationslash=stopand∆(p)/negationslash=/circledivide.
Proof.By induction on the derivation of /angbracketleftC;G/angbracketright/turnstileleftM. J
ITheorem 22 (Subject Reduction) .If/angbracketleftC;G/angbracketright/turnstileleftMandM→ RM/prime, then either/angbracketleftC;G/angbracketright/turnstileleft
M/prime, or there exists /angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketrightand/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Proof.Let us recap the assumptions:
/angbracketleftC;G/angbracketright/turnstileleftM (110)
M→ RM/prime(111)
The proof proceeds by induction on the derivation of M→ RM/prime. Most cases hold by typing
inversion (Lem. 69), and by applying the induction hypothesis.
Case [r-send]: we have
M=p/triangleleftq!m/angbracketlefte/angbracketright.P|p/trianglelefthp|q/triangleleftQ|q/trianglelefthq|M 1 (112)
M/prime=p/triangleleftP|p/trianglelefthp|q/triangleleftQ|q/trianglelefthq·(p,m(v))|M 1 (113)
e↓v (114)
hq/negationslash=/circledivide (115)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (116)
By (110) and Lem. 69, we have that there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (117)
/turnstileleftq!m/angbracketlefte/angbracketright.P: Γ(p) (118)
/turnstilelefthp: ∆(−,p) (119)
/turnstileleftQ: Γ(q) (120)
/turnstilelefthq: ∆(−,q) (121)
∀i∈I:/turnstileleftPi: Γ(pi) (122)
∀i∈I:/turnstilelefthi: ∆(−,pi) (123)
By (118) and 3 of Lem. 69, we have that
Γ(p) =q⊕m(B).T (124)
T16T (125)
/turnstileleftP:T1 (126)
/turnstilelefte:B (127)62 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
We now let
Γ/prime= Γ[p/mapsto→T] (128)
∆/prime= ∆[ p,q/mapsto→∆(p,q)·m(B)] (129)
Then by [Γ-⊕]in Fig. 8, we have
Γ; ∆→RΓ/prime; ∆/prime(130)
Hence, using Thm. 11, we have that there exists /angbracketleftC/prime;G/prime/angbracketrightsuch that
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright (131)
/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright (132)
Combine (131), (132) with
/turnstileleftP: Γ/prime(p) (by (128),(125),(126) and [t-sub] ) (133)
/turnstilelefthp: ∆/prime(−,p) (by (129) and (119) ) (134)
/turnstileleftQ: Γ/prime(q) (by (120) and (128) ) (135)
/turnstilelefthq: ∆/prime(−,q) (by (129),(121) and 10,11of Lem. 69 ) (136)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (122) and (128) ) (137)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (123) and (129) ) (138)
We conclude that /angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Case [r-rcv]: similar to case [r-send]above, except that we proceed by [r-rcv], inversion of
[t-ext](4 of Lem. 69), and Lem. 71.
Case [r-send- ]: we have
M=p/triangleleftq!m/angbracketlefte/angbracketright.P|p/trianglelefthp|q/triangleleft |q/triangleleft/circledivide|M 1 (139)
M/prime=p/triangleleftP|p/trianglelefthp|q/triangleleft |q/triangleleft/circledivide|M 1 (140)
(141)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (142)
By (110) and Lem. 69, we have that there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (143)
/turnstileleftq!m/angbracketlefte/angbracketright.P: Γ(p) (144)
/turnstilelefthp: ∆(−,p) (145)
/turnstileleft : Γ(q) (146)
/turnstileleft/circledivide: ∆(−,q) (147)
∀i∈I:/turnstileleftPi: Γ(pi) (148)
∀i∈I:/turnstilelefthi: ∆(−,pi) (149)
It follows directly that
Γ(q) =stop (150)
∆(−,q) =/circledivide (151)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 63
By (144) and 3 of Lem. 69, we have that
Γ(p) =q⊕m(B).T (152)
T16T (153)
/turnstileleftP:T1 (154)
/turnstilelefte:B (155)
We now let
Γ/prime= Γ[p/mapsto→T] (156)
∆/prime= ∆[ p,q/mapsto→∆(p,q)·m(B)] (157)
Then by [Γ-⊕]in Fig. 8, we have
Γ; ∆→RΓ/prime; ∆/prime(158)
Hence, using Thm. 11, we have that there exists /angbracketleftC/prime;G/prime/angbracketrightsuch that
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright (159)
/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright (160)
Combine (159), (160) with
/turnstileleftP: Γ/prime(p) (by (156),(153),(154) and [t-sub] ) (161)
/turnstilelefthp: ∆/prime(−,p) (by (157) and (145) ) (162)
/turnstileleft : Γ/prime(q) (by (146),(150) and (156) ) (163)
/turnstileleft/circledivide: ∆/prime(−,q) (by (157),(147) and (151) ) (164)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (148) and (156) ) (165)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (149) and (157) ) (166)
We conclude that /angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Case [r-rcv-⊙]: we have
M=p/triangleleft/summationdisplay
i∈Iq?mi(xi).Pi|p/trianglelefthp|q/triangleleft |q/triangleleft/circledivide|M 1 (167)
M/prime=p/triangleleftPk|p/trianglelefthp|q/triangleleft |q/triangleleft/circledivide|M 1 (168)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (169)
k∈I (170)
mk=crash (171)
@m,v: (q,m(v))∈hp (172)64 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
By (110) and Lem. 69, we have that there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (173)
/turnstileleft/summationdisplay
i∈Iq?mi(xi).Pi: Γ(p) (174)
/turnstilelefthp: ∆(−,p) (175)
/turnstileleft : Γ(q) (176)
/turnstileleft/circledivide: ∆(−,q) (177)
∀i∈I:/turnstileleftPi: Γ(pi) (178)
∀i∈I:/turnstilelefthi: ∆(−,pi) (179)
It follows directly that
Γ(q) =stop (180)
∆(−,q) =/circledivide (181)
By (174), 4 of Lem. 69, and [Sub- &], we have that
Γ(p) =q&{mi(Bi).T/prime
i}i∈J(182)
J⊆I (183)
∀i∈J:Ti6T/prime
i (184)
{ml|l∈I}/negationslash={crash} (185)
@j∈I\J:mj=crash (186)
∀i∈I:xi:Bi/turnstileleftPi:Ti (187)
From (186) and (171), we get
k∈J (188)
By (175) and (172), we also know
∆(q,p) =/epsilon1 (189)
We now let
Γ/prime= Γ[p/mapsto→T/prime
k] (190)
∆/prime= ∆ (191)
Then by [Γ-⊙]in Fig. 8, we have
Γ; ∆→RΓ/prime; ∆/prime(192)
Hence, using Thm. 11, we have that there exists /angbracketleftC/prime;G/prime/angbracketrightsuch that
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright (193)
/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright (194)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 65
Combine (193), (194) with
/turnstileleftPk: Γ/prime(p) (by (190),(184),(187) and [t-sub] ) (195)
/turnstilelefthp: ∆/prime(−,p) (by (191) and (175) ) (196)
/turnstileleft : Γ/prime(q) (by (176),(180) and (190) ) (197)
/turnstileleft/circledivide: ∆/prime(−,q) (by (191),(177) and (181) ) (198)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (178) and (190) ) (199)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (179) and (191) ) (200)
We conclude that /angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Case [r- ]: we have
M=p/triangleleftP|p/trianglelefthp|M 1 (201)
M/prime=p/triangleleft |p/triangleleft/circledivide|M (202)
P/negationslash=0 (203)
p/∈R (204)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (205)
By (110) and Lem. 69, we have that there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (206)
/turnstileleftP: Γ(p) (207)
/turnstilelefthp: ∆(−,p) (208)
∀i∈I:/turnstileleftPi: Γ(pi) (209)
∀i∈I:/turnstilelefthi: ∆(−,pi) (210)
By (203), (204), and (207), we have that
Γ(p)/negationslash=stop (211)
Γ(p)/negationslash=end (212)
We now let
Γ/prime= Γ[p/mapsto→stop] (213)
∆/prime= ∆[·,p/mapsto→/circledivide] (214)
Then by [Γ- ]in Fig. 8, we have
Γ; ∆→RΓ/prime; ∆/prime(215)
Hence, using Thm. 11, we have that there exists /angbracketleftC/prime;G/prime/angbracketrightsuch that
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC/prime;G/prime/angbracketright (216)
/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright (217)
Combine (216), (217) with
/turnstileleft : Γ/prime(p) (by (213) ) (218)
/turnstileleft/circledivide: ∆/prime(−,p) (by (214) ) (219)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (209) and (213) ) (220)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (210) and (214) ) (221)
We conclude that /angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.66 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Case [r-cond-T]: we have
M=p/triangleleftifethenPelseQ|p/trianglelefth|M 1 (222)
M/prime=p/triangleleftP|p/trianglelefth|M 1 (223)
e↓true (224)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (225)
By (110) and Lem. 69, we have that there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (226)
/turnstileleftifethenPelseQ: Γ(p) (227)
/turnstilelefth: ∆(−,p) (228)
∀i∈I:/turnstileleftPi: Γ(pi) (229)
∀i∈I:/turnstilelefthi: ∆(−,pi) (230)
By (224), (227) and 5 of Lem. 69, we have that
/turnstilelefte: bool (231)
/turnstileleftP: Γ(p) (232)
/turnstileleftQ: Γ(p) (233)
Combine (232)with(228),(229), and(230), we can conclude that /angbracketleftC;G/angbracketright/turnstileleftM/prime, as desired.
Case [r-cond-F]: similar to the case [r-cond-T].
Case [r-struct]: assume thatM→M/primeis derived from
M≡M 1 (234)
M1→M/prime
1 (235)
M/prime
1≡M/prime(236)
From(234),(110), by 3 of Lem. 70, we have that /angbracketleftC;G/angbracketright/turnstileleftM 1. By induction hypothesis,
either/angbracketleftC;G/angbracketright/turnstileleftM/prime
1or there exists/angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketrightand/angbracketleftC/prime;G/prime/angbracketright/turnstileleft
M/prime
1. Now by (236)and 3 of Lem. 70, we have that either /angbracketleftC;G/angbracketright/turnstileleftM/primeor/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime,
as desired. J
ITheorem 23 (Session Fidelity) .If/angbracketleftC;G/angbracketright/turnstileleftMand/angbracketleftC;G/angbracketright− →R, then there exists M/prime
and/angbracketleftC/prime;G/prime/angbracketrightsuch that/angbracketleftC;G/angbracketright− →R/angbracketleftC/prime;G/prime/angbracketright,M→ R∗M/primeand/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Proof.Let us recap the assumptions:
/angbracketleftC;G/angbracketright/turnstileleftM (237)
/angbracketleftC;G/angbracketright− →R (238)
The proof proceeds by induction on the derivation of /angbracketleftC;G/angbracketright.
Case [GR- ]: by inversion of [GR- ], we have
p/∈R (239)
p∈roles(G) (240)
/angbracketleftC;G/angbracketrightp −→R/angbracketleftC∪{p};G p/angbracketright (241)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 67
We can assume that Mis of the form
p/triangleleftP|p/trianglelefthp|M 1 (242)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (243)
P/negationslash=0 (244)
p/∈R (245)
Then by (237) and Lem. 69, there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (246)
/turnstileleftP: Γ(p) (247)
/turnstilelefthp: ∆(−,p) (248)
∀i∈I:/turnstileleftPi: Γ(pi) (249)
∀i∈I:/turnstilelefthi: ∆(−,pi) (250)
From (241), by Thm. 12, there is Γ/prime; ∆/primesuch that
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC∪{p};G p/angbracketright (251)
Γ; ∆p −→Γ/prime; ∆/prime(252)
Using (244), (245), (247) and [Γ- ]in Fig. 8, we get
Γ/prime= Γ[p/mapsto→stop] (253)
∆/prime= ∆[·,p/mapsto→/circledivide] (254)
It follows that
/turnstileleft : Γ/prime(p) (by (253) ) (255)
/turnstileleft/circledivide: ∆/prime(−,p) (by (254) ) (256)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (249) and (253) ) (257)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (250) and (254) ) (258)
Therefore, by [r- ]and [t-sess], we can conclude that there exists M/prime=p/triangleleft |p/triangleleft/circledivide|M 1and
/angbracketleftC/prime;G/prime/angbracketright=/angbracketleftC∪{p};G p/angbracketrightsuch that/angbracketleftC;G/angbracketrightp −→R/angbracketleftC/prime;G/prime/angbracketright,M → RM/prime, and/angbracketleftC/prime;G/prime/angbracketright/turnstileleft
M/prime.
Case [GR-⊕]: by inversion of [GR-⊕], we have
j∈I (259)
mj/negationslash=crash (260)
/angbracketleftC;p→q:{mi(Bi).G/prime
i}i∈I/angbracketrightp⊕q:mj(Bj)−−−−−−→ R/angbracketleftC;p q:j{mi(Bi).G/prime
i}i∈I/angbracketright (261)
We can assume that Mis of the form
p/triangleleftq!m/angbracketlefte/angbracketright.P|p/trianglelefthp|q/triangleleftQ|q/trianglelefthq|M 1 (262)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (263)
e↓v (264)
hq/negationslash=/circledivide (265)68 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Then by (237) and Lem. 69, there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (266)
/turnstileleftq!m/angbracketlefte/angbracketright.P: Γ(p) (267)
/turnstilelefthp: ∆(−,p) (268)
/turnstileleftQ: Γ(q) (269)
/turnstilelefthq: ∆(−,q) (270)
∀i∈I:/turnstileleftPi: Γ(pi) (271)
∀i∈I:/turnstilelefthi: ∆(−,pi) (272)
By (267) and 3 of Lem. 69, we have that
Γ(p) =q⊕m(B).T (273)
T16T (274)
/turnstileleftP:T1 (275)
/turnstilelefte:B (276)
From (261), by Thm. 12, there are Γ/prime; ∆/primeandα=p⊕q:mk(Bk)such that
k∈I (277)
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;p q:j{mi(Bi).G/prime
i}i∈I/angbracketright (278)
Γ; ∆p⊕q:mk(Bk)−−−−−−−→ Γ/prime; ∆/prime(279)
Using (273), (277), and [Γ-⊕]in Fig. 8, we get
Γ/prime= Γ[p/mapsto→T] (280)
∆/prime= ∆[ p,q/mapsto→∆(p,q)·m(B)] (281)
It follows that
/turnstileleftP: Γ/prime(p) (by (280),(274),(275) and [t-sub] ) (282)
/turnstilelefthp: ∆/prime(−,p) (by (281) and (268) ) (283)
/turnstileleftQ: Γ/prime(q) (by (269) and (280) ) (284)
/turnstilelefthq: ∆/prime(−,q) (by (281),(270) and 10,11of Lem. 69 ) (285)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (271) and (280) ) (286)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (272) and (281) ) (287)
Therefore, by [r-send]and [t-sess], we can conclude that there exists M/prime=p/triangleleftP|p/triangleleft
hp|q/triangleleftQ|q/trianglelefthq·(p,m(v))|M 1and/angbracketleftC/prime;G/prime/angbracketright=/angbracketleftC;p q:j{mi(Bi).G/prime
i}i∈I/angbracketrightsuch that
/angbracketleftC;G/angbracketrightp⊕q:mj(Bj)−−−−−−→ R/angbracketleftC/prime;G/prime/angbracketright,M → M/prime, and/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Case [GR-&]: similar to case [GR-⊕]above, except that we proceed by [GR-&],[r-rcv], inversion
of[t-ext](4 of Lem. 69), and Lem. 71.
Case [GR- m]: by inversion of [GR-⊕], we have
j∈I (288)
mj/negationslash=crash (289)
/angbracketleftC;p→q :{mi(Bi).G/prime
i}i∈I/angbracketrightp⊕q:mj(Bj)−−−−−−→ R/angbracketleftC;G/prime
j/angbracketright (290)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 69
We can assume that Mis of the form
p/triangleleftq!m/angbracketlefte/angbracketright.P|p/trianglelefthp|q/triangleleft |q/triangleleft/circledivide|M 1 (291)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (292)
Then by (237) and Lem. 69, there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (293)
/turnstileleftq!m/angbracketlefte/angbracketright.P: Γ(p) (294)
/turnstilelefthp: ∆(−,p) (295)
/turnstileleft : Γ(q) (296)
/turnstileleft/circledivide: ∆(−,q) (297)
∀i∈I:/turnstileleftPi: Γ(pi) (298)
∀i∈I:/turnstilelefthi: ∆(−,pi) (299)
By (294) and 3 of Lem. 69, we have that
Γ(p) =q⊕m(B).T (300)
T16T (301)
/turnstileleftP:T1 (302)
From (290), by Thm. 12, there are Γ/prime; ∆/primeandα=p⊕q:mk(Bk)such that
k∈I (303)
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;G/prime
j/angbracketright (304)
Γ; ∆p⊕q:mk(Bk)−−−−−−−→ Γ/prime; ∆/prime(305)
Using (300), (303), and [Γ-⊕]in Fig. 8, we get
Γ/prime= Γ[p/mapsto→T] (306)
∆/prime= ∆[ p,q/mapsto→∆(p,q)·m(B)] (307)
It follows that
/turnstileleftP: Γ/prime(p) (by (306),(301),(302) and [t-sub] ) (308)
/turnstilelefthp: ∆/prime(−,p) (by (307) and (295) ) (309)
/turnstileleft : Γ/prime(q) (by (296) and (306) ) (310)
/turnstileleft/circledivide: ∆/prime(−,q) (by (307) and (297) ) (311)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (298) and (306) ) (312)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (299) and (307) ) (313)
Therefore, by [r-send- ]and [t-sess], we can conclude that there exists M/prime=p/triangleleftP|p/trianglelefthp|
q/triangleleft |q/triangleleft/circledivide|M 1and/angbracketleftC/prime;G/prime/angbracketright=/angbracketleftC;G/prime
j/angbracketrightsuch that/angbracketleftC;G/angbracketrightp⊕q:mj(Bj)−−−−−−→ R/angbracketleftC/prime;G/prime/angbracketright,M → M/prime,
and/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
Case [GR-⊙]: by inversion of [GR-⊙], we have
j∈I (314)
mj=crash (315)
/angbracketleftC;q  p:j{mi(Bi).G/prime
i}i∈I/angbracketrightp⊙q−−→R/angbracketleftC;G/prime
j/angbracketright (316)70 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
We can assume that Mis of the form
p/triangleleft/summationdisplay
i∈Iq?mi(xi).Pi|p/trianglelefthp|q/triangleleft |q/triangleleft/circledivide|M 1 (317)
M1=/productdisplay
i∈I(pi/triangleleftPi|pi/trianglelefthi) (318)
k∈I (319)
mk=crash (320)
@m,v: (q,m(v))∈hp (321)
Then by (237) and Lem. 69, there exists Γ; ∆such that
Γ; ∆/subsetsqequalR/angbracketleftC;G/angbracketright (322)
/turnstileleft/summationdisplay
i∈Iq?mi(xi).Pi: Γ(p) (323)
/turnstilelefthp: ∆(−,p) (324)
/turnstileleft : Γ(q) (325)
/turnstileleft/circledivide: ∆(−,q) (326)
∀i∈I:/turnstileleftPi: Γ(pi) (327)
∀i∈I:/turnstilelefthi: ∆(−,pi) (328)
It follows directly that
Γ(q) =stop (329)
∆(−,q) =/circledivide (330)
By (323), 4 of Lem. 69, and [Sub- &], we have that
Γ(p) =q&{mi(Bi).T/prime
i}i∈J(331)
J⊆I (332)
∀i∈J:Ti6T/prime
i (333)
{ml|l∈I}/negationslash={crash} (334)
@j∈I\J:mj=crash (335)
∀i∈I:xi:Bi/turnstileleftPi:Ti (336)
From (335) and (320), we get
k∈J (337)
By (324) and (321), we also know
∆(q,p) =/epsilon1 (338)
From (316), by Thm. 12, there is Γ/prime; ∆/primesuch that
Γ/prime; ∆/prime/subsetsqequalR/angbracketleftC;G/prime
j/angbracketright (339)
Γ; ∆p⊙q−−→ Γ/prime; ∆/prime(340)A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 71
Using (331), (329), (337), (320), (338), and [Γ-⊙]in Fig. 8, we get
Γ/prime= Γ[p/mapsto→T/prime
k] (341)
∆/prime= ∆ (342)
It follows that
/turnstileleftPk: Γ/prime(p) (by (341),(333),(336) and [t-sub] ) (343)
/turnstilelefthp: ∆/prime(−,p) (by (342) and (324) ) (344)
/turnstileleft : Γ/prime(q) (by (325),(329) and (341) ) (345)
/turnstileleft/circledivide: ∆/prime(−,q) (by (342),(326) and (330) ) (346)
∀i∈I:/turnstileleftPi: Γ/prime(pi) (by (327) and (341) ) (347)
∀i∈I:/turnstilelefthi: ∆/prime(−,pi) (by (328) and (342) ) (348)
Therefore, by [r-rcv-⊙]and [t-sess], we can conclude that there exists M/prime=p/triangleleftPk|p/trianglelefthp|
q/triangleleft |q/triangleleft/circledivide|M 1and/angbracketleftC/prime;G/prime/angbracketright=/angbracketleftC;G/prime
j/angbracketrightsuch that/angbracketleftC;G/angbracketrightp⊙q−−→R/angbracketleftC/prime;G/prime/angbracketright,M → M/prime, and
/angbracketleftC/prime;G/prime/angbracketright/turnstileleftM/prime.
The rest of the cases follow directly by inductive hypothesis. J
ITheorem 25 (Session Deadlock-Freedom) .If/angbracketleftC;G/angbracketright/turnstileleftM, thenMis deadlock-free.
Proof.Corollary of Def. 16, Def. 24, Lem. 19, Thm. 22, and Thm. 23. J
ITheorem 27 (Session Liveness) .If/angbracketleftC;G/angbracketright/turnstileleftM, thenMis live.
Proof.Corollary of Def. 18, Def. 26, Lem. 19, Thm. 22, and Thm. 23. J
G Additional Details on Channel Generation
We extend global and local types with annotations on communication statements, and extend
projection with annotation support. Annotations αhave the form of either natural numbers
or sets of natural numbers. We call annotations of the form α∈Natomic-annotations .
G::=pα− →q†:{mi(Bi).Gi}i∈I/vextendsingle/vextendsingle···
S,T ::=p&α{mi(Bi).Ti}i∈I/vextendsingle/vextendsinglep⊕α{mi(Bi).Ti}i∈I/vextendsingle/vextendsingle···
α,β∈N∪P(N)
The projection operator is similarly extended with annotation support. Merging annotations
produces a set-annotation containing all merged atomic-annotations.
p&α{mi(Bi).S/prime
i}i∈I/intersectionsqp&β/braceleftbig
mj(Bj).T/prime
j/bracerightbig
j∈J
=p&α/intersectionsqβ{mk(Bk).(S/prime
k/intersectionsqT/prime
k)}k∈I∩J&p&α/intersectionsqβ{mi(Bi).S/prime
i}i∈I\J&p&α/intersectionsqβ/braceleftbig
mj(Bj).T/prime
j/bracerightbig
j∈J\I
p⊕α{mi(Bi).S/prime
i}i∈I/intersectionsqp⊕β{mi(Bi).T/prime
i}i∈I=p⊕α/intersectionsqβ{mi(Bi).(S/prime
i/intersectionsqT/prime
i)}i∈I
n/intersectionsqm={n,m}N/intersectionsqm=N∪{m}n/intersectionsqM={n}∪M N/intersectionsqM=N∪M
In order to generate channels, we ﬁrst annotate each interaction statement in a given
global type with a unique identiﬁer. To illustrate the process we consider the annotated
global type G.
G=p0− →q:/braceleftBigg
v.p1− →r:x.end
w.p2− →r:y.end/bracerightBigg
(349)72 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
The global type is then projected onto all its participating roles. For G, projecting onto roles
pandqis trivial:
Gp=q⊕0/braceleftbiggv.r⊕1x.end
w.r⊕2y.end/bracerightbigg
Gq=p&0/braceleftbiggv.end
w.end/bracerightbigg
Here, the annotations are propagated verbatim from the global type. Projections that require
merging result in set-annotations. For example, projecting Gonto r:
Gr=p&{1,2}/braceleftbiggx.end
y.end/bracerightbigg
Such set-annotations are used to derive fresh channels to ensure that both sender and recipient
are communicating over the same channel.
For someG, letΓbe the typing context produced by projecting Gon all roles. Let Ωbe
the set of all annotations in Γ,Ωv⊆Ωbe the set of all atomic-annotations (i.e. Ωv= Ω∩N),
andΩs⊆Ωbe the set of all set-annotations (i.e. Ωs= Ω∩P(N)). For each typing context
Γ, we derive an injective function σ: Ω→Nthat maps set-annotations to fresh identiﬁers;
speciﬁcally,∀x∈Ω,∃y∈N,σ(x) =y=⇒x=y∨y∈N\Ωv. The derived σis then applied
to each annotation in Γ. This removes all set-annotations from each local type within Γ.
Applied to our exemplar G(Eq. (349)), we deﬁne the following σand the concomitant local
types.
σ(0) = 0
σ(1) = 1
σ(2) = 2
σ({1,2}) = 3Gp=q⊕0/braceleftbiggv.r⊕1x.end
w.r⊕2y.end/bracerightbigg
Gq=p&0/braceleftbiggv.end
w.end/bracerightbigg
Gr=p&3/braceleftbiggx.end
y.end/bracerightbigg
We generate the type upper bounds that are needed for each local type declaration from the
corresponding annotated local type. In our above example, the local type declarations are
parameterised thus:
1type P[C0 <: OutChan[V | W], C1 <: OutChan[X], C2 <: OutChan[Y]] = ...
2type Q[C0 <: InChan[V | W]] = ...
3type R[C3 <: InChan[X | Y]] = ...
Each channel is declared and passed to role-implementing functions in the body of the
main function. Channel declarations are derived from the set of annotations excluding those
identiﬁers that have been merged during projection, i.e. Ω/prime={σ(x/prime)|x/prime∈Ω∩/uniontextΩs}. Since
role-implementing functions are parameterised by channels, each argument corresponds to
an annotation in the local type projected by the respective role. We derive a surjective
function,ρ: Ω→N, such that∀x∈Ω,∃y∈N,ρ(x) =yiﬀx∈Ωv\/uniontextΩs=⇒x=y,
x∈/uniontextΩs=⇒ ∃X∈Ωs,x∈X∧σ(X) =x, andx∈Ωs=⇒σ(x) =yhold. Intuitively,
we followσ; excepting in cases where an atomic-annotation, x∈Ω, can be found in a
set-annotation,∃X∈Ω,x∈X. In such cases, ρ(x) =σ(X). Each argument is derived
through application of ρon its corresponding annotation. In our example, the resulting main
object therefore includes the following function.
1def main(args : Array[String]) = {
2 var c0 = Channel[V | W]()A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 73
3 var c3 = Channel[X | Y]()
4
5 eval(par(p(c0, c3, c3), q(c0), r(c3)))
6}
Here, Channel constructs a binary channel that inherits from both InChanand OutChan
traits. We leverage Scala’s subtyping system to ensure that, whilst declared channel types
may permit more labels than the corresponding parameter in the local type declaration, the
type system permits only those labels speciﬁed by the latter. An example can be seen here
in passing c3toptwice: although c3speciﬁes a channel whose type is the union of XandY,
the type system will only permit sending XasC1orYasC2.
H Additional Details on Evaluation
We evaluate Teatrino on seven examples derived from the session type literature. Of these,
ﬁve are standard protocols that we extend with crash-handling behaviour. The remaining
examples comprise a distributed logging protocol and the circuit breaker pattern [26].
Our examples demonstrate that Teatrino enables expression of both standard protocols
from session type literature and protocols representing real-world distributed patterns, in
addition to extensions thereof with crash-handling behaviours. Our examples illustrate two
such behavioural patterns: failover and graceful failure. Our Circuit Breaker in particular
illustrates that our approach supports diﬀerent crash-handling behaviour extensions for the
same reliable protocol. Our runtime measurements indicate that generating skeleton code
from a given Scribble protocol is inexpensive, with no example taking longer than 3ms, and
that generation times scale with both input size and the the degree of branching exhibited
by the protocol.
We give a description of our examples in Appendix §H.1, with full metrics given in
Table 1. Each example has at least one (partially) unreliable variant. Variants are primarily
distinguished by their reliability assumptions and, for clarity, will be referred to by their
identiﬁer given in the same ﬁgure (e.g. (a),(l), and (s)). For each variant, we give an
indication of its size and shape via the number of communications and crashlabels in the
protocol, as well as the length of the longest continuation in the global type. We additionally
report the number of channels and functions generated by Teatrino . The former reﬂects
the true number of communications following projection, and the latter reﬂects the degree of
branching exhibited by the given protocol. Fig. 14 gives an exemplar global type for each
example. In Appendix §H.2, we discuss generation times for each example. Full timing
results are given in Fig. 15.
H.1 Example Protocols
PingPongand Adder Both PingPong andAdderexhibit the graceful failure pattern wherein
a protocol is brought safely to an end when a crashed peer is detected. The unreliable variants
of both PingPong and Adder, i.e. (b)and(d), assume that no role is reliable. As binary
protocols, safely ending the protocol is trivial. In both, as seen in Fig. 14, crash-handling
branches feature neither communication nor variables. Consequently, neither PingPong nor
Addersee increases to any metric, excepting the number of crash labels.
Travel Agency TravelAgency represents a basic multiparty protocol with three participants.
It exhibits the graceful failure pattern, but unlike PingPong and Adder, crash-handling74 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
Example Global Type
PingPong Gb=µt0.P→Q:/braceleftbig
ping.Q→P:/braceleftbig
pong.t0,crash/bracerightbig
,crash/bracerightbig
AdderGd=µt0.C→S:

hello.C→S:/braceleftBiggadd(int).G1
2
quit.S→C:/braceleftbig
quit,crash/bracerightbig
crash/bracerightBigg
crash


G1
d=C→S:/braceleftbig
add(int).S→C:/braceleftbig
ok(int).t0,crash/bracerightbig
,crash/bracerightbig
TwoBuyerGf=p→r:/braceleftbigg
title (str).r→p:quote (real).r→q:quote (real).G1
f
crash.R→q:quit/bracerightbigg
G1
f=p→r:

split (real).q→r:/braceleftbigg
split (real).G2
f
crash.r→p:quit/bracerightbigg
crash.q→r:/braceleftBigsplit (real).r→q:quit
crash/bracerightBig


G2
f=r→p:

quit.r→q:quit
ok.r→q:ok.q→r:/braceleftbigg
addr(str).G3
f
crash.r→p:recaddr.G4
f/bracerightbigg


G3
f=r→p:date(str).r→q:date(str)
G4
f=p→r:/braceleftbig
addr(str).r→p:date(str),crash/bracerightbig
OAuthGh=c→s:/braceleftBigstart (int).s→c:redir (int).G1
h
crash.c→a:crash.s→a:quit/bracerightBig
G1
h=c→a:/braceleftBiglogin (int).a→c:auth(int).G2
h
crash.c→s:crash.s→a:quit/bracerightBig
G2
h=c→a:/braceleftbigg
passwd (int).a→c:/braceleftbig
ko(int).G3
h,ok(int).G4
h/bracerightbig
crash.c→s:crash.s→a:quit/bracerightbigg
G3
h=c→s:/braceleftBigko(int).s→c:recvd (int).s→a:quit
crash.s→a:quit/bracerightBig
G4
h=c→s:/braceleftBigok(int).s→a:get(Token).G5
h
crash.s→a:quit/bracerightBig
G5
h=a→s:put(Token).s→c:put(Token)
TravelAgency Gl=µt0.c→a:

query (int).a→c:quote (int).a→s:retry.t0
ok.a→s:ok.c→s:/braceleftbig
payment (int).s→c:ack,crash/bracerightbig
ko.a→s:ko.c→a:/braceleftbig
quit,crash/bracerightbig
crash.a→s:fatal


DistLoggerGo=µt0.l→i:/braceleftbig
pulse.G1
o,crash.G2
o/bracerightbig
G1
o=c→i:

start.i→l:start.i→c:ok.t0
stop.i→l:stop.i→c:ok
put(str).i→l:put(str).t0
get.i→l:get.l→i:/braceleftBigput(str).i→c:put(str).t0
crash.i→c:fatal/bracerightBig


G2
o=c→i:/braceleftbig
start.i→c:ko,stop.i→c:ok,put(str).t0,get.i→c:ko/bracerightbig
CircBreakerGs=µt0.s→r:Ping.r→s:/braceleftbig
ok.G1
s,ko.G2
s,crash.G3
s/bracerightbig
G1
s=µt1.a→s:/braceleftBigenquiry (query).s→a:closed.s→r:enquiry (query).G4
s
quit.s→r:quit/bracerightBig
G2
s=µt1.a→s:/braceleftBigg
enquiry (query).s→a:/braceleftBigopen.s→r:open.s→a:fail.t0
halfOpen.s→r:halfOpen.G5
s/bracerightBig
quit.s→r:quit/bracerightBigg
G3
s=µt1.a→s:/braceleftbig
enquiry (query).s→a:permOpen.s→a:fail.t1,quit/bracerightbig
G4
s=r→s:/braceleftBigput(result).s→a:put(result).t0
crash.s→a:fail.t1/bracerightBig
G5
s=s→r:enquiry (query).r→s:/braceleftBigg
ko.s→a:fail.t0
put(result).s→a:put(result).t0
crash.s→a:fail.t0/bracerightBigg
Figure 14 A selection of global types for our example protocols.A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 75
branches must include at least one communication with the remaining peer. For example,
Glin Fig. 14 states that when the agency detects that the customer has crashed, the seller
is informed via a new fatallabel. We present two unreliable variants for TravelAgency :
(l)whereR={s,a}, and (m)whereR={a}. Both variants introduce a single new
communication statement to the reliable protocol, but do not aﬀect the number of generated
channels, functions, or the length of the longest continuation. Although (m)has fewer reliable
roles, this does not translate into more communication since the communication statement
introduced in (l)need only be extended with an empty crash-handling branch.
OAuth Our OAuthexample is based on the ﬁrst version of the standard and exhibits
graceful failure. We give three variants: (h)whereR={s,a},(i)whereR={s}, and
(j)whereR=∅.OAuthis the largest of our examples with respect to communications,
crash-handling branches, and generated channels for all three of its variants. It features the
second longest continuation. Variant (h)sees a 1.75×increase in communications over the
reliable protocol. Unlike Travel Agency, above, both variants (i)and(j)further increase the
number of communication statements. This is a consequence of the length of the continuations
in the original protocol: comprising a sequence of primarily non-branching communications.
Accordingly, when crash-handling branches are introduced, each must be suﬃciently furnished
to pass projection. In principle, this could be simpliﬁed by lifting such behaviour into a
sub-protocol [44]. In contrast to this growth, and due to merging, all variants only see three
additional channels and an incremental increase in the number role-implementing functions.
Indeed, despite being the largest example in terms of communications, it is notably smaller
than the Circuit Breaker example in terms of branching; this has consequences on generation
times (see Appendix §H.2).
Two Buyer The TwoBuyer example exhibits a form of the failoverpattern in which one
process acts as a substitute for a crashed peer [2]. In the unreliable variant (f), this is
implemented such that one buyer assumes the responsibilities of the other. Speciﬁcally,
following an agreed split, the ﬁrst buyer (i.e. pinGffrom Fig. 14) will conclude the sale
should the second buyer (i.e. q) crash. To simplify our presentation, we assume the seller
(r) is reliable. This failover behaviour results in 2.5×the number of communications in the
reliable protocol. Five new channels and three new role-implementing functions are also
generated as a consequence. The unreliable TwoBuyer features the longest continuation of all
our examples.
Distributed Logger Our DistLogger example represents the full version of the protocols
presented in §2 and §6. Here, the protocol includes a logger, an interface, and a client. The
client is able to issue commands to the logger via the interface to start/stop logging, to record
a given string, and to retrieve the recorded logs. It has two variants: (o)and(p), where
R={i,c}andR={i}, respectively. Variant (o)sees a 1.5×increase in interactions over
the reliable protocol. Variant (p)sees only one additional interaction compared to (o). Since
these increases are a result of reﬂecting the choice made by the client in the crash-handling
branch, the number of generated channels, and maximum continuation lengths are unchanged
with respect to the reliable version. However, for that same reason, we also observe a 1.6×
increase in the number of role-implementing functions.
Circuit Breaker The circuit breaker pattern [26] comprises one or more clients accessing
some fallible resource that is protected by a monitor process. For example, requests made of76 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
a remote database may not be answered in full due to limits on processing capacity. The
monitor tracks failures returned by the resource, where failures may include process crashes.
Should those failures reach some threshold, then no further requests will be forwarded, instead
returning an immediate failure message. In this state, the circuit breaker is said to be open.
After a given period, the monitor may test whether the resource will succeed with requests
again. This ensures that the resource is not tied up with requests that will inevitably fail. In
this state, the circuit breaker is said to be half-open . Should the request succeed, the circuit
breaker enters a closedstate where all requests will be once more forwarded to the resource.
To simplify our presentation, our CircBreaker example features a single client and only
the resource is assumed unreliable. The resource sends a heartbeat message to the monitor
at the start of each iteration. We give two variants with diﬀering crash-handling behaviour.
Variant (r)acts such that it does not discriminate failures transmitted by a liveresource
or those precipitated by a crashedresource. The circuit breaker may remain in an open
state indeﬁnitely, or periodically switch to a half-open state. In cases where the resource
crashes, a half-open state will never transition into a closedstate. This is reﬂected in
Variant (s), where following a crash, the monitor returns a permanently open state. The
outer-most crash-handling branch in Gsin Fig. 14 deﬁnes this behaviour. Both variants
see an approximate 1.3×increase in the number of communications; Variant (s)introduces
onefewercommunication statement compared to Variant (r)due to the permanently open
label, but increases the length of the longest continuation by one due to the nested recursion.
Although not the largest example in terms of communications, it has the greatest number of
meaningful branches, resulting in the most role-implementing functions being generated of
all our examples.
H.2 Generation Times
In order to demonstrate that our code generation approach is practical, we give generation
times using our prototype for all protocol variants and examples. In addition to total genera-
tion times, we report measurements for for three constituent phases of our implementation:
i)parsing,ii)EﬀpiIR generation, and iii)code generation. EﬀpiIR generation projects and
transforms a parsed global type into an intermediate representation, itself used to generate
concrete Scala code. Times are measured using version 1.5.13.0 of the Criterion benchmarking
library, are averages over 100 runs, and are plotted in Fig. 12. Full times are given in Fig. 15.
Results were gathered on a machine with a 4-core Intel i5 CPU at 2.60GHz and 16GB of
RAM, running Ubuntu 22.04.1, and Stack 2.7.5 with GHC 9.0.2. All code compiles and
executes upon generation using Scala 3.0.0-M1.
For all variants, the parsing and code generation phases are the most expensive phases.
For parsing, this is a consequence of its eponymous IO operation. Moreover, parsing ﬁrst
produces an intermediate representation that is then used to generate the global type.
Similarly, the relative expense of code generation is a consequence of traversing the given
EﬀpiIR representation of a protocol at least twice – both local type declarations and role-
implementing functions are derived from the same EﬀpiIR construct. This could be optimised
by generating both in the same traversal.
We note that reported code generation times do notinclude writing to a ﬁle. However,
this is included in the total generation times given in Fig. 15, and serves to explain why these
are greater than the sum of the three phases. EﬀpiIR generation, which includes projection,
is a comparatively lightweight process.
All variants take less than 3ms to generate their respective Scalacode, suggesting
thatTeatrino could be used during development without detrimentally impacting develop-A.D. Barwell, P. Hou, N. Yoshida, F. Zhou 77
Var.Parsing EﬀpiIR Code Gen. Total
M SD M SD M SD M SD
(a)0.0176 0.00044 0.00484 0.00003 0.06295 0.00046 0.17994 0.00153
(b)0.03119 0.00025 0.00647 0.00004 0.0771 0.00099 0.20803 0.00529
(c)0.03298 0.00037 0.02285 0.00026 0.18959 0.00142 0.39031 0.00361
(d)0.06867 0.00062 0.0255 0.0004 0.23475 0.0018 0.49265 0.00495
(e)0.03521 0.00025 0.02887 0.00072 0.22534 0.00262 0.4569 0.01589
(f)0.12475 0.00106 0.08245 0.0028 0.69993 0.00576 1.23656 0.02446
(g)0.05049 0.00076 0.05187 0.00067 0.4106 0.00435 0.73395 0.01065
(h)0.13225 0.0015 0.09848 0.00159 0.55213 0.00695 1.07847 0.02223
(i)0.20489 0.00232 0.12229 0.00238 0.72371 0.0067 1.43904 0.02053
(j)0.4056 0.00451 0.14395 0.00494 0.95247 0.04822 2.05467 0.05883
(k)0.04457 0.00085 0.04084 0.00028 0.30611 0.00263 0.60532 0.03938
(l)0.06989 0.00101 0.04689 0.00043 0.34338 0.00364 0.67495 0.0043
(m)0.0758 0.0011 0.04721 0.00042 0.34992 0.00332 0.68713 0.00751
(n)0.05809 0.00056 0.04882 0.00045 0.3777 0.00446 0.69267 0.00576
(o)0.11514 0.00201 0.07897 0.00083 0.54008 0.00504 1.06704 0.04566
(p)0.12914 0.00168 0.08394 0.00078 0.56313 0.00531 1.13373 0.01655
(q)0.12268 0.00203 0.10927 0.00125 1.08064 0.00894 1.80101 0.03167
(r)0.18658 0.00176 0.14615 0.00187 1.45041 0.06211 2.27098 0.03289
(s)0.20739 0.00265 0.14813 0.00135 1.53911 0.03368 2.42011 0.03774
Figure 15 Teatrino average runtimes (in milliseconds with standard deviations) for all three
generation phases, and total generation times for all variants. Times are a mean average of 100 runs.
ment speed. Although generation times broadly scale with the number of communication
statements, our results demonstrate that other factors also have inﬂuence. For example,
Variant (e)takes less time overall than Variant (d); in particular, Variant (d)takes more
time in the parsing phase. Other examples include the OAuthvariants, (h)and(i), taking
signiﬁcantly less time than all three CircBreaker variants. The diﬀerence here lies in the the
code generation phase. Notably, even within the CircBreaker example, Variant (r)takes less
time than the smaller Variant (s).
In Fig. 16, we see that there is a positive correlation between the number of role-
implementing functions generated by Teatrino and the total generation time. This suggests
that protocols with more meaningful branching (i.e. choice statements with multiple non-
crash-handling branches) are more expensive to generate than those of an equivalent size
but with less meaningful branching. Inspecting our implementation supports this conclusion,
since meaningful branches are translated into separate type and function declarations with
pattern matching. Whilst the degree of meaningful branching does aﬀect generation times, it
does not wholly obviate the eﬀect of protocol size on generation times – e.g. Variants (f)
and(i)both result in seven role-implementing functions, but since (i)is1.4×larger than
(f),Teatrino takes 1.16×longer processing (i).
Inspecting each phase individually, we ﬁnd that parsing scales with the size of the input
ﬁle (e.g. number of characters), EﬀpiIR generation scales with both protocol size and the
degree of merging required during projection, and code generation scales with both protocol78 Designing Asynchronous Multiparty Protocols with Crash-Stop Failures
2 4 6 8 10 12 1400.511.522.5
No. Generated FunctionsTotal Generation Time (ms)
51015202530
No. Communications
Figure 16 Average total generation times against the number of role-implementing functions
generated by Teatrino . Colours indicate the number of communication statements in each variant.
size and the degree of branching, as above. We see evidence for EﬀpiIR generation scaling
in the positive correlation between the number of generated channels and elapsed time.
Inspecting our implementation supports this since protocols that require more merging
require more work to generate the required channels.
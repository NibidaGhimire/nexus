Formalization of p-adicL-functions in Lean 3
Ashvni Narayanan /envelope/orcid
London School of Geometry and Number Theory, Imperial College London
Abstract
The Euler–Riemann zeta function is a largely studied numbertheoretic object, and the birthplace of several conjectures, such as
the Riemann Hypothesis. Different approaches are used to study it, including p-adic analysis : deriving information from p-adic
zeta functions. A generalized version of p-adic zeta functions (Riemann zeta function) are p-adic L-functions (resp. Dirichlet
L-functions). This paper describes formalization of p-adic L-functions in an interactive theorem prover Lean 3. Kubota–Leopoldt
p-adic L-functions are meromorphic functions emerging from the special values they take at negative integers in terms of generalized
Bernoulli numbers. They also take twisted values of the Dirichlet L-function at negative integers. This work has never been done
before in any theorem prover. Our work is done with the support of mathlib 3, one of Lean’s mathematical libraries. It required
formalization of a lot of associated topics, such as Dirichlet characters, Bernoulli polynomials etc. We formalize these first, then the
definition of a p-adic L-function in terms of an integral with respect to the Bernoulli measure, proving that they take the required
values at negative integers.
2012 ACM Subject Classification Mathematics of computing →Mathematical software; Theory of computation →Formal languages
and automata theory
Keywords and phrases formal math, algebraic number theory, Lean, mathlib
Supplementary Material Copies of the source files relevant to this paper are available in a separate repository.
Software : https://github.com/laughinggas/p-adic-L-functions
Funding Ashvni Narayanan : EPSRC Grant EP/S021590/1 (UK)
Acknowledgements The author is supported by EPSRC. The author would like to thank her PhD supervisor Prof Kevin Buzzard
for several helpful insights. She would also like to thank Dr Filippo A. E. Nuccio for helpful conversations that helped give shape to
the project. She is very grateful to the entire Lean community for their timely help and consistent support.
1 Introduction
We are working on formalizing mathematics in an interactive theorem prover called Lean. Formal verification involves the
use of logical and computational methods to establish claims that are expressed in precise mathematical terms [ 1]. Lean
is a powerful tool that facilitates formalization of a system of mathematics supported by a basic set of axioms. There
is a large mathematical library of theorems verified by Lean called mathlib, maintained by a community of computer
scientists and mathematicians. One can then formally verify proofs of new theorems dependent on preexisting theorems in
mathlib.mathlib contained 100579 theorems(as of early October 2022). It would be impossible to construct such a vast
library without a highly collaborative spirit and a communal decentralized effort, one of Lean’s best features.
p-adicL-functions are a well studied numbertheoretic object. They were initially constructed by Kubota and Leopoldt
in [4]. Their motivation was to construct a meromorphic function that helps study the Kummer congruence for Bernoulli
numbers, and gives information regarding p-adic class numbers. As a result, these functions take twisted values of the
DirichletL-function at negative integers, and are also related to the generalized Bernoulli numbers and the p-adic zeta
function. There are several different ways of constructing p-adicL-functions, we refer to the constructions given in Chapter
12 of [6]. As a result, one needs to build a lot of background (in the maximum possible generality) before embarking on
the main goal.
It is difficult to explain all the mathematical terms used here, we attempt to describe as many as possible. To that
effect, a basic knowledge of algebra is assumed. Since mathlib works in utmost generality, one often finds that the
terminology used is less common. Thanks to the community’s endeavour to maintain adequate documentation, we have
added links which serve as explanations wherever possible. When clear, we will explicitly skip writing hypotheses in the
code, since these can get quite long.
We give a mathematical overview in this section, then discuss background in Section 2, define Dirichlet characters inarXiv:2302.14491v1  [math.NT]  28 Feb 20232p-adicL-functions
Section 3, introduce generalized Bernoulli numbers in Section 4, construct the p-adicL-function in Section 5, and evaluate
it at negative integers in Section 6, finishing with a summary in Section 7.
1.1 Mathematical overview
We give a brief overview of the mathematics formalized in this project. L-functions are a fundamental object, appearing
almost everywhere in modern number theory. The Dirichlet L-function associated to a Dirichlet character χis given by
L(s,χ) =∞/summationdisplay
n=1χ(n)
ns=/productdisplay
pprime1
1−χ(p)p−s
wheresis a complex variable with Re(s)>1. This can be analytically extended to the entire complex plane, with a
simple pole at s= 1whenχ= 1. Note also that L(s,1)is the same as the Riemann zeta function. Moreover, it is known
thatL(1−n,χ) =−Bn,χ
n, whereBn,χare the generalized Bernoulli numbers.
In this paper, we construct, for an integer prime p, ap-adic analogue of L(s,χ), called the Kubota–Leopoldt p-
adicL-function, denoted Lp(s,χ). This is generally done by continuously extending the function Lp(1−n,χ) :=
(1−χ(p)pn−1)L(1−n,χ)to the complete p-adic space Cp. In fact,Lp(s,1)is analytic except for a pole at s= 1with
residue 1−1
p(Theorem 5.11, [6]).
Formalization of the p-adicL-functions via analytic continuation was hard, since Cpdid not exist in mathlib at the
time. Following [ 6], we instead define it in terms of an “integral” with respect to the Bernoulli measure. We explain these
terms below.
A profinite space is a compact, Hausdorff and totally disconnected space. The p-adic integers Zp, which are the
completion of the integers Zwith respect to the valuation νp(pα/producttext
pi̸=ppαi
i) =αare a profinite space. One may also think
of them as the inverse limit of the discrete topological spaces Z/pnZ, that is, Zp= proj limnZ/pnZ.
Locally constant functions are those for which the preimage of any set is open. Given a profinite space Xand a
normed ring R, one can show that the locally constant functions from XtoR(denotedLC(X,R )) are dense in the space
of continuous functions from XtoR(denotedC(X,R)).
Given an abelian group A, a distribution is defined to be an A-linear map from LC(X,A)toA. A measure ϕis defined
to be a bounded distribution, that is, ∀f∈LC(X,R),∃K > 0such that||ϕ(f)||≤K||f||, where||f||=supx∈X||f(x)||.
An example of a measure is the Bernoulli measure. Given a natural number dcoprime to pand a clopen set Un,aof
Z/dZ×Zp, the characteristic function χn,a(defined to be 1 on Un,aand 0 otherwise) is a locally constant function. Given
a natural number cthat is coprime to dandp, we then define the Bernoulli measure Ecby :
Ec(χn,a) :=/braceleftbigga
dpn+1/bracerightbigg
−c/braceleftbiggc−1a
dpn+1/bracerightbigg
+c−1
2
Given a measure µ, the integral with respect to µis/integraltext
fdµ:=µ(f)for any locally constant function f, and extending
this definition to C(X,R). In fact, this is an R-linear map.
Finally, the p-adicL-function is defined to be an integral with respect to the Bernoulli measure. The characterizing
property of the p-adicL-function is its evaluation at negative integers :
Lp(1−n,χ) =−(1−χω−n(p)pn−1)Bn,χω−n
n
forn≥1. When defined as an integral, additional work is needed to prove this.
Our contributions to this theory include a formalized definition of the p-adicL-function in generality, taking values
in a normed complete non-Archimedean Qp-algebra, instead of just Cp. Further, it takes as input continuous monoid
homomorphisms, also known as elements of the weight space. We have also developed an extensive theory for Dirichlet
characters, Bernoulli numbers and polynomials, generalized Bernoulli numbers, properties of p-adic integers and modular
arithmetic, making substantial contributions to the number_theory section of mathlib. We use non-traditional methods
to define and prove classical results, often choosing to work with those which are easier to formalize, later proving their
equivalence to the original.A. Narayanan 3
1.2 Lean and mathlib
Lean 3 is a functional programming language and interactive theorem prover based on dependent type theory. This
project is based on Lean’s mathematical library mathlib 3 , which is characterized by its decentralized nature with over
300 contributors. Thus, it is impossible to cite every author who contributed a piece of code that we used.
We assume the reader is familiar with structures such as def,abbreviation ,lemma,theorem, which are used constantly.
An important property of Lean is its typeclass inference system - Lean “remembers” properties given to a structure or
classembedded in an instance structure. This is explained in detail in [ 5]. We shall also use several tactics in proofs,
such as rw,apply,convandrefine1.
2 Preliminaries
2.1 Filters and convergence
None of our mathematical proofs require filters on paper, however, we find that working with them makes formalizing our
proofs significantly less cumbersome. Due to the efforts of Johannes Hölzl, Jeremy Avigad, Patrick Massot and several
others, we have a vast API for filters in Lean. We shall not delve into the details of what a filter is, but instead explain
how they are used to formalize convergence and limits.
For a sequence of functions (fn)n∈N, the expression limn→∞fn(x) =ais represented as :
tendsto (λn :N, f_n) filter.at_top ( Na)
Here, filter.at_top (for the naturals) is a filter on Ngenerated by the collection of sets {b|a≤b}for alla∈N. The
following lemma is particulary useful :
/-- If f 1and f 2are equal almost everywhere, then f 1converges if and only if f 2converges. -/
lemma filter.tendsto_congr’ { α: Type} {β: Type u_1} {f 1f2:α→β}
{l1: filterα} {l 2: filterβ} (h : f 1=f[l1] f 2) :
tendsto f 1l1l2↔tendsto f 2l1l2
This lemma shows that sequences that are the same after finitely many elements have the same limit. Given two sequences
f1andf2(thought of as functions from N),
f1=f[at_top] f 2←→ ∃ (a : N),∀(b : N), b≥a, f 1b = f 2b.
An equivalent condition to convergence on metric spaces is :
lemma metric.tendsto_at_top : ∀{α: Type u_1} { β: Type}
[pseudo_metric_space α] [nonempty β] [semilattice_sup β]
{u :β→α} {a :α} :
tendsto u at_top ( Na)↔ ∀ (ε:R) (h :ε> 0),
(∃(N :β),∀(n :β), n≥N→‖u n - a ‖<ε)
Thus, in order to prove lemmas about convergence, one can either choose to continue doing computations in the tendsto
framework, or prove normed inequalities. Working with the former really simplified calculations. As an example,
suppose we want to prove the convergence of the sequence ggiven byg(0) =g(2) = 1andg(n) = 3f(n), wherefis a
convergent sequence. This is a one-line proof using filter.tendsto_congr’ . Using the above lemma, one must obtain
Ncorresponding to ε/3, and also prove that 0<ε/3. With more complex expressions, this gets computationally difficult
to handle.
Hence, we try to avoid using metric.tendsto_at_top when possible. The only cases where it is used is when direct
inequalities need to be dealt with; this happens precisely when the non-Archimedean condition on Ris used. Thus, this is
a good indicator of where the non-Archimedean condition is needed.
1https://leanprover-community.github.io/mathlib_docs/tactics.html has a full list of tactics in Lean4p-adicL-functions
2.2 Modular arithmetic and units
Some fundamental objects with which we shall work throughout are the finite spaces Z/nZ. Note that proving properties
forzmod nis equivalent to proving them for any finite cyclic group. Given a positive n∈N,Z/nZis the same as fin
n(andZforn= 0), the set of natural numbers upto n. It is also the set of equivalence classes obtained via the relation on
Z:a∼b⇐⇒n|a−b. It has a natural group structure, and is given the discrete topology, making it a topological
group. Some maps used constantly include
val:zmod n →N, which takes any element to its smallest nonnegative reprentative less than n; and cast_hom:zmod n →
R, a coercion to a ring, obtained by composing the canonical coercion with val. IfRhas characteristic dividing n, the
map is a ring homomorphism. Given coprime naturals m,n, an important equivalence is
chinese_remainder:zmod (m * n) ≃+* zmod m ×zmod n. About 45 additional lemmas were required, which have
been put in a separate file, zmod/properties.lean .
Every monoid M has an associated space of invertible elements or units, denoted
units M orM×. We use the map units.coe_hom:M×→Mto identify a unit in its parent space frequently. Given a
monoid_hom (abbreviated as →*)R→* Sfor monoids RandS, one can obtain a homomorphism R×→* S×byunits.map .
3 Dirichlet characters and the Teichmüller character
An important task was to formalize Dirichlet characters, an integral part of the definition of the p-adicL-function.
Dirichlet characters are often not found to be defined in this technical manner. Another addition is the definition of
Dirichlet characters of level and conductor 0. The words character and Dirichlet character are used interchangeably.
Dirichlet characters are usually defined as group homomorphisms from Z/nZ×toC×for some natural number n. A
lot of properties traditionally known for groups hold more generally and are defined in greater generality in mathlib for
monoids. In the same spirit, we define Dirichlet characters to be monoid homomorphisms on any monoid:
abbreviation dirichlet_character (R : Type*) [monoid R] (n : N) :=
(zmod n)×→* R×
/-- The level of a Dirichlet character. -/
abbreviation lev {R : Type*} [monoid R] {n : N}
(χ: dirichlet_character R n) : N:= n
If we gave the definition of Dirichlet characters a defstructure, dirichlet_character would become a Typedistinct
from (zmod n)×→* R×, making compositions with monoid_hom complicated; hence we used abbreviation instead. Note
that the linter returns an extra unused argument warning (for χ) for the latter definition.
Given a Dirichlet character χ,asso_dirichlet_character χreturns a monoid homomorphism from Z/nZtoR,
which isχon the units and 0 otherwise.
noncomputable abbreviation asso_dirichlet_character {R : Type*}
[monoid_with_zero R] {n : N} (χ: dirichlet_character R n) :
zmod n→* R := { to_fun :=
function.extend (units.coe_hom (zmod n)) ((units.coe_hom R) ◦χ) 0, ..}
Lean requires us to tag this definition noncomputable , since we are producing data from an existential statement,
classical.some (appearing in function.extend ), which has no computational content (see Chapter 11 of [ 1]). One
would like to shift between compatible Dirichlet characters of different levels. For this, we construct the following tools :
/-- Extends the Dirichlet character χof level n to level m, for n | m. -/
def change_level {m : N} (hm : n | m) :
dirichlet_character R n →* dirichlet_character R m :=
{ to_fun := λ ψ,ψ.comp (units.map (zmod.cast_hom hm (zmod n))), .. }A. Narayanan 5
/--χ0of level d factors through χof level n if d | n and
χ0=χ◦(zmod n→zmod d). -/
structure factors_through (d : N) : Prop :=
(dvd : d | n)
(ind_char :∃χ0: dirichlet_character R d, χ=χ0.change_level dvd)
The notions of primitivity and conductor of a Dirichlet character follow easily :
/-- The set of numbers for which a Dirichlet character is periodic. -/
def conductor_set : set N:= {x : N|χ.factors_through x}
/-- The minimum natural number n for which a character is periodic. -/
noncomputable def conductor : N:= Inf (conductor_set χ)
/-- A character is primitive if its level is equal to its conductor. -/
def is_primitive : Prop := χ.conductor = n
/-- The primitive character associated to a Dirichlet character. -/
noncomputable def asso_primitive_character : dirichlet_character R χ.conductor := classical.some (
χ.factors_through_conductor).ind_char
Here, classical.some makes an arbitrary choice of an element from a nonempty space, and classical.some_spec lists
down properties of this element coming from the space.
Whena=b, while dirichlet_character R a and dirichlet_character R b are “mathematically” equal, Lean
does not think of them as the same type. This gets complicated when additional layers, such as change_level are added
to the equation. A general method to resolve such problems is by using the tactic subst, which would substitute awithb;
however, that failed. Instead, we used the concept of heterogeneous equality ( heq, or==) to deal with this. The tactic
congr’helped reduce to expressions of heterogeneous equality, which were then solved with the help of lemmas such as :
lemma change_level_heq {a b : N} {S : Type*} [comm_monoid_with_zero S]
(χ: dirichlet_character S a) (h : a = b) :
change_level (show a | b, from by {rw h}) χ==χ
This states that, for a=b, changing the level of a Dirichlet character of level atobis heterogeneously equal to itself.
Traditionally only for primitive characters, our definition of multiplication of characters extends to any two characters.
This takes as input characters χ1andχ2of levels nandmrespectively, and returns the primitive character associated to
χ′
1χ′
2, whereχ′
1andχ′
2are obtained by changing the levels of χ1andχ2tolcm n m.
noncomputable def mul {m n : N} (χ1: dirichlet_character R n)
(χ2: dirichlet_character R m) :=
asso_primitive_character(change_level χ1(dvd_lcm_left n m) *
change_level χ2(dvd_lcm_right n m))
This multiplication is not trivially commutative or associative, with respect to this definition.
We need the notion of odd and even characters. A character χis odd ifχ(−1) =−1, and even if χ(−1) = 1. For a
commutative ring, any character is either odd or even :
lemma is_odd_or_is_even {S : Type*} [comm_ring S] [no_zero_divisors S]
{m :N} (ψ: dirichlet_character S m) : ψ.is_odd∨ψ.is_even
3.1 Teichmüller character
The initial effort was to formalize the definition of the Teichmüller character (denoted ω) directly. However, it was
discovered that Witt vectors, and in particular Teichmüller lifts had previously been added to mathlib by Johan Commelin6p-adicL-functions
and Robert Lewis. This reiterates the importance of the collaborative spirit of Lean, and of making definitions in the
correct generality.
It is beyond the scope of this text to define Witt vectors and do it justice. We refer interested readers to Section 2.4
of [3]. For a commutative ring Rand a prime number p, one can obtain a ring of Witt vectors W(R). When we take
R=Z/pZ, we get
def equiv : W(zmod p)≃+*Z_[p]
One also obtains the Teichmüller lift R→W(R). Givenr∈R, the 0-th coefficient is r, and the other coefficients are 0.
This map is a multiplicative monoid homomorphism and is denoted teichmuller .
Combining this with the previous two definitions, we obtain our definition of the Teichmüller character :
noncomputable abbreviation teichmuller_character_mod_p (p : N)
[fact (nat.prime p)] : dirichlet_character Z_[p] p := units.map
(((witt_vector.equiv p).to_monoid_hom).comp (witt_vector.teichmuller p))
We use [fact p.prime] to make the primality of pan instance. This map takes
x∈Z/pZ×to a root of unity y∈Zpsuch thaty≡x(mod p ). Often we view this as taking values in a Qp-algebraR, by
composing it with algebra_map Q_[p] R, which identifies elements of QpinR. Since we mostly deal with ω−1taking
values onR×, we define this as teichmuller_character_mod_p’ .
WeprovedpropertiesofTeichmüllercharactersin teichmuller_character.lean , suchas, foroddprimes p, theTeichmüller
character is odd, and 1otherwise :
lemma eval_neg_one (hp : 2 < p) : teichmuller_character_mod_p p (-1) = -1
4 Bernoulli polynomials and the generalized Bernoulli number
The Bernoulli numbers B′
nare generating functions given by/summationtextB′
ntn
n!=t
et−1. They appear in the computation of sums of
powers of naturals,/summationtext
nnk. Note that several authors think of Bernoulli numbers Bnto be defined as/summationtextBntn
n!=t
1−e−t.
The difference between these two is : Bn= (−1)nB′
n, withB′
1=−1
2. A reformulation gives :
B′
n= 1−n−1/summationdisplay
k=0/parenleftbiggn
k/parenrightbiggB′
k
n−k+ 1
Inmathlib,B′
nwas already defined (by Johan Commelin) as above. However, we needed Bn, which we then defined as :
def bernoulli (n : N) :Q:= (-1)^n * bernoulli’ n
The Bernoulli polynomials, denoted Bn(X), a generalization of the Bernoulli numbers, are generating functions/summationtext∞
n=0Bn(X)tn
n!=tetX
et−1. This gives :
Bn(X) =n/summationdisplay
i=0/parenleftbiggn
i/parenrightbigg
BiXn−i
We defined the Bernoulli polynomials as :
def polynomial.bernoulli (n : N) : polynomial Q:=
Σi in range (n + 1), monomial (n - i) ((bernoulli i) * (choose n i))
Here, monomial n a translates to aXn, and/summationtexti in s, f i translates to/summationtext
i∈sf(i), for a finset(or finite set) s. A
small aspect of this naming convention is that if the namespaces for Bernoulli numbers and polynomials are both open
(which is often the case), in order to use the Bernoulli numbers, one needs to use _root_.bernoulli . We shall use them
interchangeably here, when the context is clear.
An important fact is, ∀n,(n+ 1)Xn=/summationtextn
k=0/parenleftbign
k/parenrightbig
Bk(X):A. Narayanan 7
theorem sum_bernoulli (n : N) : monomial n (n + 1 : Q) =
Σk in range (n + 1), ((n + 1).choose k : Q)·bernoulli k
These proofs are relatively straightforward. Most of this work is now part of mathlib, and has been used to give a
formalized proof of Faulhaber’s theorem.
4.1 Generalized Bernoulli numbers
Generalized Bernoulli numbers are integral to our work, since these are related to the special values of p-adicL-functions
and Dirichlet L-functions. Given a primitive Dirichlet character χof conductor f, the generalized Bernoulli numbers are
defined as (section 4.1, [6])/summationtext∞
n=0Bn,χtn
n!=/summationtextf
a=1χ(a)teat
eft−1. For any multiple Foff, Proposition 4.1 of [6] gives us :
Bn,χ=Fn−1F/summationdisplay
a=1χ(a)Bn/parenleftbigga
F/parenrightbigg
This is much easier to work with, so we use this as our definition instead, taking F=f:
def general_bernoulli_number {S : Type*} [comm_semiring S] [algebra QS]
{n :N} (ψ: dirichlet_character S n) (m : N) : S :=
(algebra_map QS ((ψ.conductor)^(m - 1 : Z))) *
Σa in finset.range ψ.conductor,
asso_dirichlet_character (asso_primitive_character ψ) a.succ *
algebra_map QS ((bernoulli m).eval (a.succ / ψ.conductor : Q))
Contrary to the traditional definition, this is for all characters, and ψtakes values in any commutative Q-algebra, instead
ofC. One had to also explicitly mention that m - 1must be taken to have type Z, since Lean would otherwise infer it to
have type N, which might have caused errors (subtraction on NandZare different).
4.2 A special property of generalized Bernoulli numbers
An important property of these numbers is :
▶Theorem 1. Letχbe an even Dirichlet character of level dpmfordcoprime to the odd prime p, withmpositive.
SupposeRis a nontrivial commutative non-Archimedean normed Qp-algebra with no zero divisors. For k>1,
lim
n→∞1
dpn/summationdisplay
0<a<dpn;(a,dp )=1χω−k(a)ak= (1−χω−k(p)pk−1)Bk,χω−k
Instead of giving Ra non-Archimedean structure(which did not exist in mathlib when this project began), we give as
input its consequences, conditions naandna’. This is formulated in Lean as :
theorem lim_even_character’ (na’ : ∀(n :N) (f : (zmod n)×→R),
∥Σi : (zmod n)×, f i∥ ≤/unionsqtext(i : (zmod n)×),∥f i∥)
(na :∀(n :N) (f : N→R),
∥Σ(i :N) in finset.range n, f i ∥ ≤/unionsqtext(i : zmod n),∥f i.val∥) :
tendsto (λ(n :N), (1 /↑(d * p ^ n))·
Σ(i :N) in finset.range (d * p ^ n),
asso_dirichlet_character ( χ.mul (teichmuller_character_mod_p’ p R ^ k)) ↑i *↑i ^ k) at_top (
N(general_bernoulli_number
(χ.mul (teichmuller_character_mod_p’ p R ^ k)) k))8p-adicL-functions
The proof of this theorem follows from the proof in Lemma 7.11 of [ 6], a point of difference being that our theorem holds
more generally for Rbeing a non-Archimedean normed commutative Qp-algebra with no zero divisors, instead of Cp.
Majorly, it equates the two sides modulo pnfor a sufficiently large n, and uses the fact that
▶Theorem 2.
lim
n→∞1
dpn/summationdisplay
0<a<dpn;(a,dp )=1χω−m(a)am= 0
The formalization is very calculation intensive, and is a good example of a small proof on paper being magnified in Lean,
because there are multiple coercions and arithmetic calculations to be dealt with. Unfortunately, tactics such as ringand
simpthat usually help with these fail here. It is translated in Lean as :
lemma sum_even_character_tendsto_zero_of_units :
tendsto (λn,Σ(i : (zmod (d * p^n))×), ((asso_dirichlet_character
(χ.mul (teichmuller_character_mod_p’ p R^k))) i * i^(k - 1)))
at_top (N0)
The proof of this theorem is in tendsto_zero_of_sum_even_char.lean .
5 Construction of the p-adic L-function
5.1 Density of locally constant functions
For any compact Hausdorff totally disconnected space X and a commutative normed ring A, we have proved that LC(X,A)
is a dense subset of C(X,A). Formalizing this took about 500 lines of code (now in mathlib), and is based on the fact
that locally compact Hausdorff totally disconnected spaces have a clopen basis :
lemma loc_compact_Haus_tot_disc_of_zero_dim {H : Type*} [t2_space H]
[locally_compact_space H] [totally_disconnected_space H] :
is_topological_basis {s : set H | is_clopen s}
This turned out to be hard to formalize. Given a set sofH, Lean gives a subset Vofsthe type V:set s; however, Lean
does not recognize Vas a subset of H. As a result, to use compact_space s ←→ is_compact (s:set H) , one must
construct V’:set H to be the image of Vunder the closed embedding coe:s→H. This process must be repeated each
time a subset of H, which is also a topological subspace, is considered. Finally, it must be shown that all these coercions
match up in the big topological space H.
5.2 Clopen sets of the p-adic integers
Zpis a profinite space (as shown in section 2.4 of [ 3]). It is the inverse limit of finite discrete topological spaces Z/pnZfor
alln, and has a clopen basis of the form Ua,n:=proj−1
n(a)fora∈Z/pnZ, whereprojnis the canonical projection ring
homomorphism to_zmod_pow n: Z_[p]→+* zmod (p ˆn). We first define the collection of sets (Ua,n)a,n:
def clopen_basis : set (set Z_[p]) :=
{x : set Z_[p] |∃(n :N) (a : zmod (p^n)),
x = set.preimage (padic_int.to_zmod_pow n) {a} }
We show that clopen_basis forms a topological basis and that every element is clopen :
theorem clopen_basis_clopen : (clopen_basis p).is_topological_basis ∧
∀x∈(clopen_basis p), is_clopen xA. Narayanan 9
The mathematical proof is to show that for any ϵ-ball, one can find Ua,ninside it. This is true because, given n∈Nand
x∈Z/pnZ, the preimage of xunder to_zmod_pow n is the same as the ball centered at x(now considered as an element
ofZp) with radius p1−n. The following lemmas prove useful :
lemma appr_spec (n : N) (x : Z_[p]) :
x - appr x n∈(ideal.span {p^n} : ideal Z_[p])
lemma has_coe_t_eq_coe (x : Z_[p]) (n : N) :
(((appr x n) : zmod (p^n)) : Z_[p]) = ((appr x n) : Z_[p])
Forx:Z_[p],appr x n is the smallest natural number in x (mod p^n) . In the latter lemma, the RHS is a coercion of
appr x n , which has type N, toZ_p. The LHS is a coercion of appr x n tozmod (p ˆn)toZ_p. This statement is not
true in general, that is, given any natural number n, it is not true that the lift of ntoZpis the same as the composition of
its lift to Z/pnZandZp. It works here because the coercion from Z/pnZtoZpis not the canonical lift. It is a composition
of a coercion from Z/pnZtoN, which takes a∈Z/pnZto the smallest natural number in its Z/pnZequivalence class.
Onecansimilarlyshowthatthesets Ub,a,n :=proj−1
1(b)×proj−1
2,n(a)formaclopenbasisfor Z/dZ×Zp, whereproj 1isthe
first canonical projection on b∈Z/dZandproj 2,nthe composition of the second projection on a∈Zpwithprojndescribed
above. We call this set clopen_basis’ p d . Its properties are formalized in padic_int.clopen_properties.lean .
5.3 Distributions and measures
In this section, X=lim←−i∈NXidenotes a profinite space with Xifinite and projection maps πi:X− →Xiand surjective
mapsπij:Xi− →Xjfor alli≥j. Henceforth, we use Gto denote an abelian group, Afor a commutative normed ring,
Rfor a commutative complete normed ring which is also a Qp-algebra, and LC(X,Y )for the space of locally constant
functions from XtoY. We fix a prime pand an integer dsuch thatgcd(d,p) = 1.
Thetopologyon C(X,A)comesfromitsnormedgroupstructureinducedbythenormon A:||f−g||=supx∈X||f(x)−g(x)||.
In fact, this topology is the same as the topology defined on bounded functions on X, sinceXis a compact space. Since
the API for bounded continuous functions on compact spaces was developed at around the same time (created by Oliver
Nash), we used the existing lemmas such as equiv_bounded_of_compact .
A distribution (from Section 12.1 of [ 6]) is aG-linear function ϕ:LC(X,G )− →G. This is already a Type, hence we do
not redefine it. Measures (not to be confused with measure theory measures) are bounded distributions :
def measures := { φ: (locally_constant X A) →l[A] A //∃K :R, 0 < K∧
∀f : (locally_constant X A), ∥φf∥ ≤ K *∥inclusion X A f ∥}
The map inclusion identifies the locally constant function fas a continuous function. The boundedness of the distribution
makes the measure continuous.
5.4 The Bernoulli measure
The Bernoulli measure is an essential measure. We make a choice of an integer cwithgcd(c,dp) = 1, andc−1is an integer
such thatcc−1≡1moddp2n+1. For a clopen set Ua,n, we define
Ec(χUa,n) =Ec,n(a) =/braceleftbigga
dpn+1/bracerightbigg
−c/braceleftbiggc−1a
dpn+1/bracerightbigg
+c−1
2
In Lean, this translates to (note that fract x represents the fractional part of x) :
def bernoulli_distribution := λ(n :N) (a : (zmod (d * (p^n)))),
fract ((a : Z) / (d*p^(n + 1)))
- c * fract ((a : Z) / (c * (d*p^(n + 1)))) + (c - 1)/2
The original plan was to define a set of the form :10p-adicL-functions
def bernoulli_measure (hc : c.gcd p = 1) :=
{x : locally_constant (zmod d ×Z_[p]) R→l[R] R |∀(n :N)
(a : zmod (d * (p^n))), x (char_fn R (clopen_from.is_clopen p d n a)) =
(algebra_map QR) (E_c p d hc n a) }
and to show that it is nonempty. char_fn is a locally constant characteristic function on a clopen set ( 1on the set and 0
otherwise), taking as input the range of the function and the fact that the set is clopen. However, information is lost this
way, since one then has to use classical.some to extract the underlying measure. We use an elegant approach :
/-- A sequence has the ‘is_eventually_constant‘ predicate if all the elements of the sequence are
eventually the same. -/
def is_eventually_constant { α: Type*} (a : N→α) : Prop :=
{ n |∀m, n≤m→a (nat.succ m) = a m }.nonempty
structure eventually_constant_seq { α: Type*} :=
(to_seq : N→α)
(is_eventually_const : is_eventually_constant to_seq)
Given a locally constant function ffromZ/dZ×ZptoR, we define the eventually constant sequence from_loc_const :
noncomputable abbreviation from_loc_const : @eventually_constant_seq R :=
{ to_seq := λ(n :N),
Σa in (zmod’ (d * p^n) _),
f(a)·((algebra_map Q_[p] R) (bernoulli_distribution p d c n a)),
is_eventually_constant := _, }
for all natural numbers n.zmod’is the universal finsetofzmod. We shall look into the proof of this sequence being
eventually constant later.
Givenalocallyconstantfunction f:locally_constant ((zmod d)××Z_[p]×) R,anelementoftheset bernoulli_measure
is given by :
sequence_limit (from_loc_const p d R (loc_const_ind_fn _ p d f))
where loc_const_ind_fn is a locally constant function on Z/dZ×Zpthat takes value fon the units of the domain, and
0 otherwise. The linearity properties follow easily. Notice that bernoulli_distribution takes locally constant functions
onZ/dZ×Zp, while bernoulli_measure takes locally constant functions on Z/dZ∗×Z∗
p. This had to be done since our
clopen basis was defined on Z/dZ×Zp, and while it is easy to show the same results for the units on paper, it requires a
bit of work in Lean.
We now prove that bernoulli_measure is indeed a measure, that is, it is bounded. The bound we choose is
K:= 1+∥c∥+∥c−1
2∥. The proof is as follows : let ϕdenote loc_const_ind_fn . We want∥Ec(ϕ(f))∥≤K∥f∥. It
suffices to prove this for χn,a, because one can find an nsuch thatϕ(f) =/summationtext
a∈Z/dZ×Z/pnZϕ(f)(a) ˙χn,a:
lemma loc_const_eq_sum_char_fn (f : locally_constant ((zmod d) ×Z_[p]) R) (hd : d.gcd p = 1) : ∃
n :N, f = Σa in (finset.range (d * p^n)),
f(a)·char_fn R (clopen_from.is_clopen p d n a)
This proof is akin to proving that from_loc_const is eventually constant, using discrete quotients. The discrete quotient
on a topological space is given by an equivalence relation such that all equivalence classes are clopen :
structure (X : Type*) [topological_space X] discrete_quotient :=
(rel : X→X→Prop)
(equiv : equivalence rel)
(clopen :∀x, is_clopen (set_of (rel x)))A. Narayanan 11
The last statement translates to, ∀x∈X,{y|y∼x}is clopen. Given two discrete quotients AandB,A≤Bmeans
∀x,y∈X,x∼Ay=⇒x∼By. Any locally constant function induces a discrete quotient via its clopen fibers :
def locally_constant.discrete_quotient : discrete_quotient X :=
{ rel :=λa b, f b = f a, .. }
We now define a function :
/-- A discrete quotient induced by ‘to_zmod_pow‘. -/
def discrete_quotient_of_to_zmod_pow :
N→discrete_quotient (zmod d ×Z_[p]) :=
λn,⟨λa b, to_zmod_pow n a.2 = to_zmod_pow n b.2 ∧a.1 = b.1, _, _ ⟩
Fora= (a1,a2)andb= (b1,b2)inZ/dZ×Zp, this represents the relation a∼b⇐⇒a2(modpn) =b2(modpn)∧a1=b1.
Then, given a locally constant function fonZ/dZ×Zp, forNlarge enough, the fibers of fmodpNare contained in the
basic clopen sets of pN:
lemma le :∃N :N,
discrete_quotient_of_to_zmod_pow p d N ≤discrete_quotient f
The proofs now follow from this fact : ∃N,∀m≥N,
/summationdisplay
a∈Z/dpm+1Zf(a)Ec,m+1(a) =/summationdisplay
a∈Z/dpmZf(a)Ec,m(a)
The required Nisclassical.some (discrete_quotient_of_to_zmod_pow.le f) + 1 . We also define the following :
/-- Set of all ‘b ∈zmod (d * p^m)‘ such that ‘b = a mod (d * p^n)‘ for
‘a∈zmod (d * p^n)‘. -/
def equi_class (n m : N) (a : zmod (d * p^n)) :=
{b : zmod (d * p^m) | (b : zmod (d * p^n)) = a}
Then, we have the following lemma :
lemma zmod’_succ_eq_bUnion :
zmod’ (d*p^(m + 1)) = (zmod’ (d*p^m)).bUnion
(λa : zmod (d * p ^ m), set.to_finset (equi_class m (m + 1)) a)
This lemma says that any element of Z/dpm+1Zcomes from equi_class m (m + 1) b for someb∈Z/dpmZ. The proof
is now complete with the following lemma :
lemma bernoulli_distribution_sum’ (x : zmod (d * p^m)) :
Σ(y : zmod (d * p ^ m.succ)) in
(λa : zmod (d * p ^ m), ((equi_class m.succ) a).to_finset) x,
bernoulli_distribution p d c m.succ y = bernoulli_distribution p d c m x
which says, for x∈Z/dpmZ,Ec,m(x) =/summationtext′
yEc,m+1(y), for y∈equi_class m (m + 1) x .
5.5 Integrals
The last piece in the puzzle is the integral. We use the same notation as in the previous section. Given a measure µ,
and a function f∈LC(X,R),/integraltext
fdµ:=µ(f). As in Theorem 12.1 of [ 6], this can be extended to a continuous R-linear
map/integraltext
Xfdµ:C(X,R)− →R. This follows from the fact that LC(X,R)is dense in C(X,R); as a result, the map from
LC(X,R)toC(X,R)isdense_inducing , that is, it has dense range and the topology on LC(X,R)is induced from the
topology on C(X,R).
The continuity of the extension of the integral follows from the fact that every measure µis uniformly continuous :12p-adicL-functions
lemma uniform_continuous ( φ: measures X A) : uniform_continuous ⇑φ
5.6 Construction
There are several possible definitions for the p-adicL-function, the most common being a meromorphic function Lp(s,χ)
on
{s∈Cp||s|<p}obtained by analytic continuation, such that
Lp(1−n,χ) =−(1−χω−n(p)pn−1)Bn,χω−n
n
forn≥1(Theorem 5.11, [ 6]). Due to the absence of Cpinmathlib at the time, and the difficulty of showing analytic
continuity(even on paper), our definition is instead motivated by Theorem 12.2, [ 6], which states that, for s∈Zp, and
Dirichlet character χwith conductor dpm, withgcd(d,p) = 1andm≥0, for a choice of c∈Zwithgcd(c,dp) = 1:
(1−χ(c)⟨c⟩s+1)Lp(−s,χ) =/integraltext
(Z/dZ)××Z×
pχω−1(a)⟨a⟩sdEc (1)
where⟨a⟩=ω−1(a)a, andbs=exp(logp(b))(the exponential and logarithm are defined in terms of power series expansions).
Instead of using the variable s(which takes values in a subset of Cp), we choose to use an element of the weight space,
the set of continuous monoid homomorphisms from Z/dZ××Z×
ptoR. We replace⟨a⟩swith w:continuous_monoid_hom
A. The advantage is that our p-adicL-function can now be defined over a more general space : a nontrivial normed
commutative complete non-Archimedean Qp-algebra with no zero divisors.
Given a Dirichlet character χof leveldpmwithgcd(d,p) = 1andm> 0, we now define the p-adicL-function to be :
Lp(w,χ) :=/integraldisplay
(Z/dZ)××Z×
pχω−1(a)wdEc
def p_adic_L_function :=
measure.integral (bernoulli_measure R hc hc’ hd na)
⟨(units.coe_hom R).comp (dirichlet_char_extend p d R m hd
(change_level _ ( χ.mul ((teichmuller_character_mod_p’ p R))))) *
w.to_monoid_hom, cont_paLf m hd _ w ⟩
Here, dirichlet_char_extend extendsχfrom (Z/dpmZ)×to(Z/dZ)××Z×
pvia the restriction map. The last term
cont_paLf proves the continuity of the given function, since Lean takes an element of type C((zmod d)××Z_[p]×, R).
We have absorbed the constant term given in the LHS of (1). This was done because Theorem 12.2 lets Lp(−s,χ)take
values in Cp. In a general ring R, as we have chosen, division need not exist. One would then need the factor to be a unit,
which may not always happen (for example, consider R=Qp). Thus, our p-adicL-function differs from the original by a
constant factor. This factor can be easily removed if one assumes Rhas division.
6 Evaluation at negative integers
We shall now prove that our chosen definition of the p-adicL-function is equivalent to the original one, that is, it takes
the same values at negative integers : for n>1,
Lp(1−n,χ) =−(1−χω−n(p)pn−1)Bn,χω−n
n(2)
For this section, we assume that Ris a non-Archimedean normed commutative Qp-algebra, which is complete, nontrivial,
and has no zero divisors. The scalar multiplication structure obtained from QandQpare compatible, given by
is_scalar_tower Q Q _[p] R(see Section 4.2 of [ 2]). The prime pis odd, and we choose positive natural numbers d
andcwhich are mutually coprime and are also coprime to p. The Dirichlet character χhas leveldpm, wheremis positive.
We also assume χis even and ddivides its conductor. Let us first explain why we need the latter condition.A. Narayanan 13
6.1 Factors of the conductor
We explain here why we need dto divide the conductor of χ. In this section, we do not differentiate between the associated
Dirichlet character and the Dirichlet character.
Recall that χω−1actually denotes the Dirichlet character multiplication of χandω−1, as explained in Section 3.
In order to translate between sums on Z/dpnZ×andZ/dpnZ, one needs that, for all x∈Z/dpnZsuch thatxis not
a unit,χω−k(x) = 0for allk > 0. This is equivalent to saying, ∀y∈N, such that gcd(y,d)̸= 1andgcd(y,p)̸= 1,
gcd(y,(χω−k).conductor )̸= 1.
Given coprime natural numbers k1,k2and a character ψof levelk1k2, one can find primitive characters ψ1andψ2of
levelsk1andk2respectively such that ψ=ψ1ψ2:
lemma eq_mul_of_coprime_of_dvd_conductor {m n : N} [fact (0 < m * n)]
(χ: dirichlet_character R (m * n)) (h χ: m |χ.conductor)
(hcop : m.coprime n) : ∃(χ1: dirichlet_character R m)
(χ2: dirichlet_character R n), χ1.is_primitive∧χ=
χ1.change_level (dvd_mul_right m n) * χ2.change_level (dvd_mul_left n m)
Thus, given k>0, we can find primitive characters χ1andχ2with conductors z1andz2such thatz1|dandz2|pmand
χ1χ2=χω−k. The condition that ddivides the conductor of χensures that z1=d. As a result, if gcd(y,d)̸= 1, then
gcd(y,z1z2)̸= 1, soχω−k(y) = 0as needed.
6.2 Main Result
Note that the same result holds when χis odd or when p= 2, the proofs differ slightly. We shall skip most of the details
of the proof, since these are heavily computational. We shall instead highlight the key concepts that are used. Our
reformulation of (2) is :
theorem p_adic_L_function_eval_neg_int_new :
(p_adic_L_function m χc na (mul_inv_pow (n - 1))) =
(algebra_map QR) (1 / n : Q) *
(1 - (χ(zmod.unit_of_coprime c _) *
(mul_inv_pow n (zmod.unit_of_coprime c hc’, _)))) *
(1 - ((asso_dirichlet_character
(χ.mul ((teichmuller_character_mod_p’ p R)^n))) p * p^(n - 1))) *
(general_bernoulli_number
(χ.mul ((teichmuller_character_mod_p’ p R)^n)) n)
Here, mul_inv_pow is our translation of ⟨a⟩s.
The proof consists of two steps : breaking up the integral in the LHS into three sums, and evaluating each of these sums.
This is very calculation intensive, and was the longest part of the project. The proof is very similar to the proof of
Theorem 12.2 in [6].
SinceLC((Z/dZ)××Z×
p,R)is dense inC((Z/dZ)××Z×
p,R), we observe that the integral Lp(1−n,χ)is the same as :
Lp(1−n,χ) = lim
j→∞/summationdisplay
a∈(Z/dpjZ)×Ec,j(χω−1(a)⟨a⟩n−1)
= limj→∞/parenleftbigg/summationtext
a∈(Z/dpjZ)×χω−nan−1/braceleftbigg
a
dpj/bracerightbigg
(3)
−/summationtext
a∈(Z/dpjZ)×χω−nan−1/parenleftbigg
c/braceleftbigg
c−1a
dpj/bracerightbigg/parenrightbigg
(4)14p-adicL-functions
+/parenleftbigg
c−1
2/parenrightbigg/summationtext
a∈(Z/dpjZ)×χω−nan−1/parenrightbigg
(5)
Going from the first equation to the second took about 600 lines of code, which can be found in neg_int_eval.lean .
While the proof (on paper) is only a page long, this is very calculation heavy in Lean, because one needs to shift between
elements coerced to different types, such as Z/(dpj)Z,Z/dZ×Z/pjZ,Z/dZ×Zp,Rand their units. Moreover, when
each of these types occur as locally constant or continuous functions, one needs to separately prove that each of these
functions is also (respectively) locally constant or continuous. Other difficulties include several different ways to obtain
the same term, such as equiv.inv_fun ,equiv.symm ,ring_equiv.symm andring_equiv.to_equiv.inv_fun . We have
constructed several lemmas to simplify traversing between these terms.
Each of these sums are then evaluated separately. The first sum in (3) follows from Theorem 1, after translations
between zmod (d * p^n)×andfinset.range (d * p^n) . This is done by the following lemma, which says
Z/dpkZ≃{x∈N|gcd(x,d)̸= 1}∪{x∈N|gcd(x,p)̸= 1}∪(Z/dpkZ)×
lemma helper_U_3 (x : N) : range (d * p^x) =
finite.to_finset (finite_of_finite_inter
(range (d * p^x)) ({x | ¬x.coprime d}))
∪((finite.to_finset (finite_of_finite_inter
(range (d * p^x)) ({x | ¬x.coprime p})))
∪finite.to_finset (finite_of_finite_inter
(range (d * p^x)) ({x | x.coprime d} ∩{x | x.coprime p})))
Each of these are made to be a finset, since finset.sum requires the sum to be over a finset.We use this lemma to
break our sum over finset.range (d * p^n) into units and non-units. The condition that ddivides the conductor is
then used to show that the associated Dirichlet character is 0 everywhere on the non-units. These calculations can be
found in lim_even_character_of_units.lean .
Evaluating the middle sum (4) is the most tedious. It is first broken into two sums, so that the previous result can be
used. Then, a change of variable from atoc−1ais applied. The variable cis coerced to Z/dp2kZ, increasing the number
of coercions significantly, thus lengthening the calculations. This can be found in second_sum.lean .
Finally, the last sum (5) is 0. This is where one uses that χis even. This follows from Theorem 2. On paper, it is a
one-line proof, done by substituting ain the summand with −aand doing caluclations mod pn. However, since we work
in a more general setting, we must go through lengthy roundabout ways instead.
Putting these sums together concludes the proof.
7 Conclusion
7.1 Analysis
We list some of the observations that arose while working on this paper.
The tactic rwdoes not always work inside sums. As a result, one must use the convtactic to get to the expression inside
the sum. While using the convtactic, one is said to be working in convmode. Using the convtactic not only lengthens
the proof, but also limits the tactics one can use; Another way around sums is to use simp_rw, however, this increases
compilation time of the proof. Moreover, simp_rw rewrites the lemma as many times as applicable, and is an unsuitable
choice if one wants to apply the lemma just once.
Another recurring problem was the ratio of implicit to explicit variables. The p-adicL-function, for example, has
19 arguments, of which 7 are explicit, and p,dandRare implicit. Excluding Roften means that either Lean guesses
or abstracts the correct term, or it asks for them explicitly. In the latter case, one also gets as additional goals all theA. Narayanan 15
hypotheses that are dependent on Rand implicit, such as normed_comm_ring R . The other alternative is to explicitly
provide terms using @, however this leads to very large expressions.
We also ran into some instance errors. For example, since char_zero is a class, we would like to give the lemma
char_zero R aninstance structure. However, the proof is dependent on Rhaving the [algebra Q_[p] R] structure.
Lean would then claim that this is a dangerous instance (for pbeing an explicit variable) and that pis ametavariable
(forpbeing an implicit variable). Thus, we made it a lemmainstead, and had to explicitly feed it into implicit arguments.
While most properties regarding Bernoulli numbers and polynomials and locally constant functions have been put into
mathlib, the rest of the work is on a private repository. The author hopes to push the work directly to Lean 4, once the
required port is complete.
7.2 Statistics
Given the decentralized nature of mathlib, it is quite difficult to calculate the number of lines of code already existing
inmathlib which were used in this project. When initially completed, this project had about 15000 lines of code. A
major refactor was then conducted, in an effort to reduce length of individual proofs. We tried to uphold the spirit of
mathlib, constructing lemmas in as much generality as possible. The code currently consists of 28 files and about 7500
lines, grouped into appropriate categories where possible, according to the sections of this paper.
7.3 Related work
There are several projects that require Dirichlet characters and properties of the p-adic integers. These include the project
on the formalization of Fermat’s last theorem for regular primes2. There is also an effort by Prof David Loeffler which
involves formalization of the classical Dirichlet L-function, that is somewhat dependent on this work. Our work on
Bernoulli numbers has been used to give a formal proof of Faulhaber’s theorem.
In the future, the author hopes to be able to work on Iwasawa theory, for which the p-adicL-function is a key ingredient.
She also hopes to formalize more properties of Bernoulli numbers, that are a fundamental component of number theory.
References
1Jeremy Avigad, Leonardo de Moura, and Soonho Kong. Theorem proving in lean, Jun 2018. URL: https://kilthub.cmu.edu/
articles/journal_contribution/Theorem_Proving_in_Lean/6492902/1, doi:10.1184/R1/6492902.v1 .
2Anne Baanen, Sander R. Dahmen, Ashvni Narayanan, and Filippo A. E. Nuccio Mortarino Majno di Capriglio. A formalization
of dedekind domains and class groups of global fields. Journal of Automated Reasoning , 66(4):611–637, Nov 2022. doi:
10.1007/s10817-022-09644-0 .
3Johan Commelin and Robert Y. Lewis. Formalizing the ring of witt vectors. In Proceedings of the 10th ACM SIGPLAN
International Conference on Certified Programs and Proofs .ACM,jan2021. URL:https://doi.org/10.1145%2F3437992.3439919,
doi:10.1145/3437992.3439919 .
4Tomio Kubota and Heinrich-Wolfgang Leopoldt. Eine p-adische Theorie der Zetawerte. I. Einführung der p-adischen
Dirichletschen L-Funktionen. J. Reine Angew. Math. , 214(215):328–339, 1964.
5The mathlib Community. The Lean mathematical library. In J. Blanchette and C. Hri t,cu, editors, CPP 2020 , page 367–381.
ACM, 2020. doi:10.1145/3372885.3373824 .
6Lawrence C. Washington. Introduction to cyclotomic fields , volume 83 of Graduate Texts in Mathematics . Springer-Verlag,
New York, second edition, 1997. doi:10.1007/978-1-4612-1934-7 .
2https://github.com/leanprover-community/flt-regular
Fast IDentity Online with Anonymous Credentials (FIDO-AC)
Wei-Zhu Yeoh∗†
CISPA Helmholtz Center for
Information SecurityMichal Kepkowski†
Macquarie UniversityGunnar Heide
CISPA Helmholtz Center for
Information Security
Dali Kaafar
Macquarie UniversityLucjan Hanzlik
CISPA Helmholtz Center for
Information Security
Abstract
Web authentication is a critical component of today’s In-
ternet and the digital world we interact with. The FIDO2
protocol enables users to leverage common devices to eas-
ily authenticate to online services in both mobile and desk-
top environments, following the passwordless authentication
approach based on cryptography and biometric verification.
However, there is little to no connection between the authen-
tication process and users’ attributes. More specifically, the
FIDO protocol does not specify methods that could be used
to combine trusted attributes with the FIDO authentication
process generically and allow users to disclose them to the
relying party arbitrarily. In essence, applications requiring
attributes verification (e.g., age or expiry date of a driver’s
license, etc.) still rely on ad-hoc approaches that do not satisfy
the data minimization principle and do not allow the user to
check the disclosed data. A primary recent example is the data
breach on Singtel Optus, one of the major telecommunications
providers in Australia, where very personal and sensitive data
(e.g., passport numbers) were leaked. This paper introduces
FIDO-AC, a novel framework that combines the FIDO2 au-
thentication process with the user’s digital and non-shareable
identity. We show how to instantiate this framework using
off-the-shelf FIDO tokens and any electronic identity doc-
ument, e.g., the ICAO biometric passport (ePassport). We
demonstrate the practicality of our approach by evaluating a
prototype implementation of the FIDO-AC system.
1 Introduction
Web authentication is a crucial component of the digital world
and the Internet we know today. The predominant web au-
thentication method is via the login and password mechanism.
The password is considered a single factor of authentication.
In most modern applications, users are recommended to use
multiple authentication factors. Such a factor could be an
∗We thank Saarland University for supporting Wei-Zhu Yeoh.
†Equal contribution.SMS code sent to the user’s phone number or a designated
mobile application requesting the user’s acknowledgment.
The state-of-the-art solution is, however, based on crypto-
graphic tokens. Those can store cryptographic keys and per-
form public key cryptography. The tokens, introduced by the
Fast IDentity Online (FIDO) Alliance, are the most prominent
instantiation of this idea, and together with the open-source
FIDO2 protocol are a strong candidate for building advanced
authentication frameworks. However, the main disadvantage
of the current solution is that there is no link between the
user’s attributes and the authentication process, which limits
the potential application space or forces the service to use
ad-hoc solutions that are not bound to FIDO authentication.
The importance of attribute-based authentication is known
in the research community, which has proposed many so-
lutions. The most interesting ones are anonymous creden-
tials, which allow users to disclose the attributes to service
providers arbitrarily. Unfortunately, as time has shown, many
of these approaches are not used in the real world and are
far from what we consider practical. No tools and method-
ologies exist to efficiently combine anonymous credentials
and attributes, in general, with the FIDO authentication pro-
cess. The Meta Research group (formerly Facebook Research)
reached the same conclusion . They issued a call for projects
to develop such solutions1. Potential solutions to this problem
would significantly influence how authentication systems are
used and what we can use them for. One of the use cases is age
verification, which is not a problem in most cases but becomes
one if the service is legally obligated to check age (e.g., for
selling alcohol or serving adult-only content). Even though
those websites are required to verify the user’s age, in practice,
they ask the user to assert without further verification.
Those solutions are not limited to age verification but in-
volve many practical systems where data minimization is
needed but not implemented. This is evident due to many
data breaches leaking the full data of identity documents. An
interesting example is the recent data breach suffered by the
1https://research.facebook.com/research-awards/2022-pri
vacy-enhancing-technologies-request-for-proposals/arXiv:2305.16758v3  [cs.CR]  20 Jun 2023Australian telecommunication company Optus [2], in which
the hackers gained unauthorized access to two unique identity
documents. The scope of this attack was significant because
Optus did not employ techniques to minimize the personal
data stored in the database, such as using attribute-based au-
thentication that would allow the user to disclose only the
minimal data required to receive the phone number.
Contributions. This paper introduces a novel approach for
presenting claims in a privacy-preserving manner through
a commercially recognized authentication protocol. To the
best of our knowledge, our design is the first that presents an
innovative and generic way to combine a privacy-enhancing
technology (e.g., anonymous credentials and eID solutions)
with a strong authentication protocol (i.e., FIDO2). Our ap-
proach to the framework definition is as follows. We introduce
the building blocks of FIDO-AC and define the requirements
for the system. Then, we formally define the notion of pass-
wordless authentication with attributes, which we later extend
with a mediator party to meet our requirements. Our security
models can be of independent interest and used as a founda-
tion for securely integrating attributes into the FIDO standard.
In the next step, we introduce the system design and formal
protocol flow, which we enrich with a security and threat anal-
ysis. Finally, we present our implementation of the FIDO-AC
system and its performance evaluation. Notably, the design
of our system recognizes and addresses the well-known chal-
lenges in integrating the existing deployments. Therefore, we
believe that FIDO-AC can be effortlessly used in any com-
mercial solution to elevate the privacy of Personal Identifiable
Information (PII). To summarize, our contributions are as
follows:
•FIDO-AC framework. We propose a complete and
industry-ready solution for utilizing anonymous creden-
tials with local or remote attestation through a FIDO2
channel.
•FIDO2 Extension. We introduce a new FIDO2 exten-
sion and a mechanism to bind the extension data with the
FIDO2 assertion in the constrained environment of the
WebAuthn API implementations.
•System evaluation. We provide a comprehensive evalua-
tion of the FIDO-AC framework. We discuss the security
and privacy properties, as well as the usability from the
user’s and relying party’s points of view.
•Implementation. We prove the feasibility of our design
by developing and openly publishing a prototype imple-
mentation.
2 Background and Related Work
This section will briefly explain the FIDO2 standard and
how the authentication process works. Later, we will describe
Figure 1: FIDO2 parties and simplified authentication flow
electronic identity documents (focusing on ePassport) and
anonymous credentials. The abbreviations FIDO and FIDO2
are used interchangeably, as they refer to the same protocol.
2.1 FIDO2
FIDO2 is an authentication protocol designed by FIDO Al-
liance in collaboration with vendors and identity and access
management (IAM) experts. The open-source nature and
broad support (i.e., all major web browsers and OSes) make
FIDO2 a serious candidate for becoming the de facto standard
for second-factor and passwordless authentication.
The FIDO standard defines two processes (ceremonies):
registration and assertion. The former allows the creation of
a link between the server and the authenticator. The latter is
used to prove the authenticator’s possession (e.g., a crypto-
graphic token). Both are built on a simple request-response
transaction that generates verifiable proof. Usually, three par-
ties participate in the flow: FIDO Server, FIDO Client, and
the authenticator. As presented in Figure 1, the authentication
flow starts with a trigger sent to the FIDO Server (steps 1. and
2.). The trigger might be an automated action or user interac-
tion (e.g., the user clicks the login button). Then, the FIDO
Server generates a random challenge that travels through the
FIDO Client to the authenticator (steps 3. and 4.). In WebAu-
thn, the user’s action is required to unlock the authenticator
(step 5.). Finally, the authenticator generates a signature (us-
ing the preregistered key) and sends it back to the FIDO
Server (steps 6. and 7.). Interestingly, the transportation layer
of FIDO2 is composed of two related protocols: CTAP [17]
and WebAuthn [37]. The former is responsible for commu-
nication with an authenticator (i.e., binary messages sent via
USB, BLE, or NFC channels), whereas the latter describes
the API for the client side.
The design of FIDO2 follows the "privacy by design" prin-
ciple. Unlike other methods that require Personal Identifi-
able Information (PII) to function (e.g., phone number in
SMS OTP case), FIDO2 does not need any PII. Furthermore,
FIDO2 ensures that the protocol does not compromise privacy
(e.g., by linking accounts using key handles). Both registra-
tion and authentication incorporate privacy-preserving mech-
anisms. A new key pair with randomly-looking key handles
is generated for each registration. The authenticator identi-
fier (AAGUID) and attestation mechanism guarantee that the
authenticator cannot be uniquely identified. In the case of
authentication, each transaction uses a random challenge.2.2 Electronic Identity Documents
Electronic identity documents (eIDs) are standard documents
with an electronic layer capable of storing data and execut-
ing cryptographic protocols. The most widely used eID is
the biometric passport (ePassport) introduced by the Inter-
national Civil Aviation Organization (ICAO) and issued in
more than 150 countries [36]. According to EU regulation,
2019/1157 [30], all European Union members must include
an application supporting the ICAO in their national identity
documents, making this the de facto standard for eIDs. Be-
low we will give a high-level overview of the cryptographic
protocols included in the ICAO standard.
Basic Access Control (BAC) is a password-based mecha-
nism designed to thwart both online skimming and offline
eavesdropping attacks. Attackers without the knowledge of
the password (document number, date of birth, and expiry
date) will be unable to read the passport’s content and deci-
pher the eavesdropped communication. However, the security
of the BAC suffers from offline dictionary attacks due to the
low entropy of the password. Its successor, Password Authen-
tication Connection Establishment (PACE), provides a much
better security guarantee by employing a Diffie-Hellman key.
Passive Authentication (PA) enables the reader to verify
the authenticity of the eID data. During PA, the reader will
retrieve, in addition to the data, the document security object
(DSO), which encompasses a signature on the hash values
of the data. The reader can then verify the authenticity of
the data by comparing the hashed values and verifying the
signature using the issuer’s public key. It is worth noting
that the data is stored in so-called data groups ( DG). This
data contains personal data and random numbers (e.g., eID
number). Moreover, the hash value of the data groups for
the same personal data will be different, i.e., we assume that
H(DG 1)andH(DG 2)are unlinkable, if only knowing the
personal data and not the random numbers.
Chip Authentication (CA) prevents the cloning of eID and
its data. Once read, the data could potentially be uploaded to a
fresh eID, practically cloning the original eID. The problem is
solved via a hardware assumption. We assume that the secret
key loaded to the eID during the personalization phase cannot
be extracted. The corresponding public key is added to the
signed data, creating a link between it and the device. During
verification, the reader checks that the public key used by
the eID during this additional step is part of the data verified
during passive authentication.
2.3 Anonymous Credentials
Anonymous credential systems (ACs) are a cryptographic
building block envisioned and introduced by Chaum [9]. They
allow users to obtain digital credentials encoding their at-
tributes from an issuer. Users can later use those credentialsto prove certain claims (e.g., over 18 years old) without re-
vealing any other meaningful information about themselves.
Anonymous credentials have found applications in various
problems and environments. Those include keyed-verification
ACs [8, 13], AC as delegated parts of the credential to other
parties [4, 6, 14], AC in the decentralized [18, 35] or cloud-
based [26] setting. An interesting system, which can be treated
as a single-use, single-attribute credential, is Privacy Pass [16].
It was introduced as a way to solve the CAPTCHA problem
that anonymous network users are facing. There also exists
a rate-limiting version [23] (introduced in iOS 162), which
uses a trusted mediator to enforce the issuer’s policy. The
privacy guarantees are that the mediator does not learn the
origin where the user will redeem the token. At the same time,
the issuer is oblivious to any data identifying the user, e.g., IP
address or other distinguishing metadata. The exciting part of
this paper is that in this setting, secure hardware components
of the iPhone, together with iCloud, play the role of the trusted
mediator. We will later see that the architecture of our solution
is similar to this.
Recently, Rosenberg et al. [33] introduced the idea of us-
ing the blockchain consensus to make anonymous credential
issuers obsolete. The idea is to use an existing identity infras-
tructure and store the credentials in a secure data structure.
They use a bulletin board based on Ethereum smart contracts
for storage in their implementation. The exciting part related
to our work is that they focus on using the existing infrastruc-
ture for eIDs, particularly the ICAO-based ePassport. They
use the fact that the personal data stored on the ePassport
is authenticated by a governmental authority via passive au-
thentication. Unfortunately, their solutions fail to provide an
active authentication of the ePassport. In particular, knowing
the data stored on the eID and the DSO is enough to create
the credentials in their system. However, this data is fully read
during border control, making their system unusable.
Most notable in the context of our paper is the very recent
work by Schwarz et al. [34] in which the trusted execution
environment (TEE) is used for the AC. The authors propose
FeIDo, a TEE-based roaming FIDO authenticator that com-
putes FIDO credentials based on user attributes. Their main
goal is to solve the token loss problem since the same keys
can be accessed using a different eID because it stores the
same attributes. Interestingly, they notice that since the TEE
gets access to the user’s data, it can enforce access policies.
Our approach is very different. Firstly, we support any FIDO
token and are not bound to a custom instantiation of the to-
ken. Secondly, we are not bound to only electronic identity
documents but also support standalone anonymous credential
systems or any other, e.g., cloud-based identity systems with
the non-shareability property. Lastly and most importantly, in
our approach, the personal data never leaves the user’s device,
which is not true for [34].
2https://developer.apple.com/videos/play/wwdc2022/100773 Requirements and Threat Model
The main objective of FIDO-AC is to provide a practical sys-
tem capable of augmenting the FIDO2 protocol with anony-
mous credentials derived from a verifiable source (i.e., eID).
The system guarantees that the data was gathered from a legit-
imate document at the time of a FIDO transaction, and only
selected information about the user is shared with relying
party. The requirements are crafted with the criteria listed
below:
R.1 Privacy Preserving. At the end of the FIDO-AC pro-
tocol, the relying party should learn only the relevant
authenticated user information without compromising
user privacy. In particular, FIDO2 privacy guarantees
should not be violated.
R.2 Active Authentication (Liveliness). The FIDO-AC sys-
tem should verify the possession of a non-sharable cre-
dential/device for the presented user attributes.
R.3 Compatibility. FIDO-AC should be fully compatible
with the FIDO2 protocol.
R.4 User-Centric Design. The solution should impose mini-
mal user friction to ease the adoption of FIDO-AC.
R.5 Pluggable Integration. The integration of the FIDO-AC
system with an existing FIDO2 deployment should be
effortless in terms of development, operation, and de-
ployment. In particular, FIDO-AC should work without
modification of existing FIDO clients and authenticators.
R.6 Efficient architecture. The FIDO-AC system should
deliver reasonable performance (compared to the pure
FIDO system), and it should be trivial to scale. Moreover,
the architecture should be vendor agnostic.
We design FIDO-AC to be an extension of the existing
FIDO2 standard with the extra capability of providing anony-
mous credentials. The threat model of FIDO2 web authen-
tication [1] is used and extended to include new elements
unique to the proposed system. Following the original FIDO
trust assumptions, we assume authenticated communication
channels between different parties. The integrity of the client
agent, browser, authenticator, and OS is trusted, which is the
same trust assumption needed for FIDO authentication. Addi-
tionally, to accommodate the introduction of new modules, we
trust the mediator party to perform the verification correctly
and not collude with relying parties to link users. Moreover,
we trust the eID infrastructure and the hardware-based pro-
tection of the eID device.
We assume the integrity of the underlying device hardware
is correct and trusted. Side-channel attacks such as fault in-
jection, power analysis, and micro-architecture side-channel
attacks are also out-of-scope in this paper. We also do not
consider denial-of-service (DoS) attacks on the mediator. Last
but not least, we assume the FIDO-AC mobile applications
and services are free of software vulnerability.4Passwordless Authentication with Attributes
In this section, we introduce passwordless authentication with
attributes ( PAwA ). The passwordless authentication protocol
(PLA) captures the syntax of WebAuth and was formally intro-
duced and analyzed in [3] and subsequently in [22]. However,
thePLA protocol does not capture the notion of attributes,
which is needed for FIDO-AC. Therefore, we extend the defi-
nitions from [22] to formally introduce attributes to the pass-
wordless authentication.
In other words, we formally model how to use attributes in
the FIDO framework. Unfortunately, it turns out that achiev-
ing this model with existing FIDO and credential systems
while simultaneously fulfilling the requirements defined in
the previous section is hard. Therefore, we will further extend
this model by introducing an additional trusted party to the
system called a mediator. This new party will act as a sort
of interface between FIDO and the credential system. It will
also introduce new privacy concerns, which will be addressed
by formally introducing the mediator into our definitions of
PAwA .
4.1 Formal Model of PAwA
ThePAwA protocol consists of two processes, namely the
registration phase and the authentication phase. The messages
passed between a server and a token are relayed through
an intermediary client interface, e.g., the web browser. In
both phases, the server sends the first message containing a
challenge and the desired attribute policy. We follow the same
syntax as the one used in [3,22] and encapsulate the policy as
part of the server’s challenge3. After receiving the challenge,
the client, together with the token, computes the response,
similar to standard PLA. Depending on the instantiation of
PAwA , the client can either forward the attribute policy to the
token or compute this part of the assertion locally.
In the registration phase, the token additionally attaches a
public key pkand a credential identifier cid. The server keeps
track of the information received from the token in its storage.
Then, in subsequent authentication, the server includes the
cidin the first message described above. In PAwA , the server
verifies the signed message with respect to the augmented
challenge. The server also verifies the response with respect
to its attribute policy.
4.1.1 Formal Syntax
The model considers parties P=T∪S, where the parties are
partitioned into the set of tokens Tand the set of servers S.
Each token T∈Thas a fixed state that is initialized with a key
msk T. Additionally, we associate an attribute set AttTwith
each token T, where attributes are elements from a set AttU.
3Note that this is in line with how one would implement the attribute
policies as part of the extension fields of a FIDO challenge.Each server S∈Sconstructs a key-value table known as the
registration context rcsS, whereby a new entry will be inserted
whenever a token registers with the server. Each server is also
uniquely identified with its publicly known unique identifier
idS, which in practice, corresponds to a URL. The server is
also assumed to know the user account and its cid. Moreover,
each server specifies an access policy PolicyS⊆AttU.
The syntax of the PAwA protocol is formally defined in
Definition 1. To model the capability of the adversary to
freely communicate with tokens and servers, a server oracle
and a token oracle are additionally defined in Definition 3,
whereby stSis used to model the state transfer between algo-
rithms, Csis used to bind registration to authentication, and
theπi,jhandle is used to model the instances of registration
and authentication. Partnering of two handles πi,j
Sandπi′,j′
Tas
defined in Definition 4, for which they share the same session
identifier, is used as the winning condition of the security
experiments.
Definition 1 (PAwA ).A passwordless authentication scheme
with attributes ( PAwA ) is a tuple PAwA = (Gen,Reg,Auth):
•Gen: on input parameters par, outputs a secret key msk.
•Reg: given as a tuple of the following algorithms:
rchall ac:on input of a server identity idS, outputs challenge
with policy value cpand a state st.
rcomm ac:on input of a server identity idSand a challenge
cp, outputs a message Mr.
rresp ac:on input of a master secret key msk, a server iden-
tityidSand a message Mr, outputs credential identifier
cidand a response Rr.
rcheck ac:on input of a state st, a credential identifier cid
and a response Rac4, outputs a bit band a credential
cred.
•Auth : given as a tuple of the following algorithms:
achall ac:on input of a server identity idS, outputs a chal-
lenge cpand a state st.
acomm ac:on input of a server identity idSand a challenge
cp, outputs a message Ma.
aresp ac:on input of a master secret key msk, a server iden-
tityidS, a credential identifier cid, and a message Ma,
outputs a response Ra.
acheck ac:on input of a state st, a registration context rcs,
a credential identifier cidand a response Rac4, outputs
a bit b∈ {0,1}
Algorithms rchall ac,rcheck ac,achall ac,acheck acare exe-
cuted by servers, rcomm ac,acomm acare executed by clients,
andrresp ac,aresp acare executed by tokens.
Definition 2 (Policy Extraction) .We assume that there ex-
ists a function Pol−Ext(M)that on input of the message
outputs of acomm ac(idS,·), and rcomm ac(idS,·)returns the
policy PolicyS.
4Depending on the flow type, authentication or registration, Raccontains
either RaorRrDefinition 3 (Server and Token Oracles) .LetAbe an ad-
versary algorithm and PAwA = (Gen,Reg,Auth)be a pass-
wordless authentication with attributes scheme. Each party
P∈T∪Sis associated with a set of handles πi,j
Pthat models
two types of instances corresponding to registration and au-
thentication. Each party is represented by a number of these
instances. Concretely, πi,j
Pforj=0is the i-th registration
instance of party Pand for j≥1is the j-th authentication
instance of Pcorresponding to the i-th registration.
It is assumed that for each token T∈T, a secret
key is generated as msk T←Gen(par). For each server
S∈S, key-value tables rcsS,CS,stSare given. By de-
fault, these are empty. Adversary, Ahas access to oracles
Setup ,Start ,Challenge ,Complete defined as follows:
•Setup (PolicyLS,AttLT): Executes (PolicyS1,...,PolicySn)
:=PolicyLS, and (AttT1,...,AttTm):=AttLT.
•Start(πi,j
S): This executes (cp,st)←rchall ac(idS)in case
j=0or(cp,st)←achall ac(idS)in case j>0. The oracle
setsstS[i,j]:=stand returns cptoA.
•Challenge (πi,j
T,idS,cid,M): Executes (cid,Rr)←
rresp ac(msk T,idS,M)ifj=0orRa←aresp ac(msk T,idS,
cid,M)ifj>0.Ais given ( (cid,Rr)orRa) .
•Complete (πi,j
S,cid,R): Aborts if Start(πi,j
S)has not
been queried before. If j=0, it executes (b,cred)←
rcheck ac(stS[i,j],cid,R), sets CS[i]:=cid, and rcsS[cid]:=
cred. Ifj>0, it aborts if cid̸=CS[i]. Otherwise, it exe-
cutes b←acheck ac(stS[i,j],rcsS,cid,R). In both cases, bis
returned to A.
It is assumed that for each (i,j,T,S)∈N×N×T×S,
the oracles Setup (·,·),Start(πi,j
S),Challenge (πi,j
T,·,·,·),and
Complete (πi,j
S,·,·)are executed only once.
Definition 4 (Session Identifiers and Partnering) .Consider
the oracles from Definition 3. Let Vtbe a function that takes as
input the transcript tri,j
T= (idS,cid,M,R)that a token T∈T
observes in an oracle call to Challenge (πi,j
T,·,·,·), and outputs
a bitstring Vt(tri,j
T). Similarly, let Vsbe a function that takes
as input the transcript tri,j
S= (c,cid,R)that a server S∈S
observes in oracle calls to Start(πi,j
S),Complete (πi,j
S,·,·), and
outputs a bitstring Vs(tri,j
S). It is assumed that these functions
are specified by PAwA . The handles πi,j
Tandπi′,j′
Sare part-
nered if: (j=0⇐⇒ j′=0)∧Vt(tri,j
T) =Vs(tri′,j′
S).
4.1.2 Security and Privacy
We will now define what it means for a PAwA protocol to be
secure. We begin with security against impersonation, which
informally ensures that there is precisely one partnered ses-
sion for an accepting server. The security is defined in Defini-
tion 5, for which the adversary can interact with tokens and
servers concurrently by using the oracles defined in Defini-
tion 3.Definition 5 (Impersonation Security (Adapted from [22])) .
For a PAwA = (Gen,Reg,Auth)scheme, the following se-
curity experiment ImpA
PAwA is defined to run between the
challenger and an adversary A.
•Setup. For each token T∈T, a key is generated by running
msk T←Gen(par). The adversary assigns the attribute set
for tokens and policy set for servers by calling the oracle
Setup and passing in the attribute set lists.
•Online Phase. The adversary is allowed to interact with the
oracles Start ,Challenge ,Complete as in Definition 3.
•Output Phase. Finally, Aterminates, and the experiment
outputs 1if and only if there exists a server handle πi,j
Sfor
j>0 such that the following conditions hold:
1.πi,0
Sis partnered with a token handle πk,0
T.
2.πi,j
Saccepted, i.e. in call Complete (πi,j
S,cid,R), algo-
rithm acheck (stS[i,j],rcsS,cid,R)returned 1.
3.πi,j
Sis not partnered with any token handle πi′,j′
T, or it is
partnered with a token handle, which is partnered with a
different server handle πi′′,j′′
S′.
In addition to the standard FIDO security defined above,
we will now define attribute unforgeability. Informally, we
want to ensure that an adversary can only access the server
if it possesses a token that adheres to the server’s policy. We
achieve this by requiring that if Saccepts, then the partnered
token must have the attribute set that satisfies the server policy.
Definition 6 (Attribute Unforgeability) .For a PAwA =
(Gen,Reg,Auth)scheme, the following security experiment
Att-UnfA
PAwA is defined to run between the challenger and an
adversary A.
•Setup. For each token T∈T, a key is generated by running
msk T←Gen(par). The adversary assigns the attribute set
for tokens and policy set for servers by calling the oracle
Setup and passing in the attribute set lists.
•Online Phase. The adversary is allowed to interact with the
oracles Start ,Challenge ,Complete as in Definition 3.
•Output Phase. Finally, Aterminates, and the experiment
outputs 1if and only if there exists a server handle πi,j
Sfor
j>0 such that the following conditions hold:
1.πi,0
Sis partnered with a token handle πk,0
T.
2.πi,j
Saccepted, i.e., in call Complete (πi,j
S,cid,R), algo-
rithm acheck (stS[i,j],rcsS,cid,R)returned 1.
3.πi,j
Sis not partnered with any token handle πi′,j′
T, or it is
partnered with a token handle for which its attribute set
AttTdoes not satisfy the server policy PolicyS.
Similarly to the standard FIDO security model, we intro-
duce an unlinkability definition that ensures that tokens are
not linkable across origins. We extend the unlinkability pro-
posed in [22] to capture attributes. Informally, we ensure that
the server cannot learn more attributes than its policy has
requested. In the unlinkability experiment, the adversary Ais given access to the oracles defined in Definition 7, and
with it, Agains the global view of the system. Ais given two
additional oracles Left andRight , which run TbandT1−bfor
a random bit b.Ais said to win the game if it can determine
which token is used in which oracle with respect to the condi-
tions of instance freshness and credential separation defined
in Definition 3. Credential separation models attack that a
server can launch when the same token is used twice at the
same server, while instance freshness is a consequence of the
oracles definition.
Definition 7 (Unlinkability (Adapted from [22])) .For a
PAwA = (Gen,Reg,Auth), following experiment UnlA
PAwA
is defined to run between the challenger and an adversary A.
•Setup. For each token T∈T, a key is generated by running
msk T←Gen(par). The adversary assigns the attribute set
for tokens and policy set for servers by calling the oracle
Setup and passing in the attribute set lists.
•Phase 1. The adversary is allowed to interact with oracles
Start ,Challenge ,Complete (see Definition 3). Moreover,
we allow the adversary to query the Challenge oracle in
a way that the oracle also executes the client part of the
execution, i.e., the Challenge oracle additionally executes
thercomm acoracomm acalgorithms.
•Phase 2. The adversary outputs two (not necessarily dis-
tinct) token identifiers T0,T1, and two (not necessarily dis-
tinct) server identifiers SL,SR∈Ssuch that:
AttT0⊇PolicyS⇐⇒ AttT1⊇PolicyS,
for all S∈ {SL,SR}. Let i0andi1be the smallest identifiers
for which the token handles πi0,0
T0andπi1,0
T1were not queried
to the Challenge oracle in Phase 1. The experiment chooses
a bit buniformly at random. It sets j0:=0,j1:=0and
initializes two oracles Left,Right as follows:
–Left(cid,M): Abort if Pol−Ext(M)̸=PolicySL, else re-
turnChallenge (πib,jb
Tb,idSL,cid,M)and set jb=jb+1.
–Right (cid,M): Abort if Pol−Ext(M)̸=PolicySR, else
return Challenge (πi1−b,j1−b
T1−b,idSR,cid,M)and set j1−b=
j1−b+1.
Like in Phase 1, we allow the adversary to decide if the Left
andRight oracles should execute the client part algorithms.
•Phase 3. The adversary can interact with all the oracles
defined in Phases 1 and 2.
•Output Phase. Finally, the adversary outputs a bit ˆb. Con-
sider the following lists of cid’s:
–Lr
chcontains all cid’s returned by queries that are
not issued via Left,Right and are of the form
Challenge (πi,0
T,idS,·,·)for any i,T∈ {T0,T1}andS∈
{SL,SR}.
–La
chcontains all cid’s that are part of the input of queries
that are not issued via Left,Right and are of the form
Challenge (πi,j
T,idS,·,·)for any j>0,i,T∈ {T0,T1}and
S∈ {SL,SR}.–Lr
lrcontains all cid’s returned by queries to Left orRight
when jb=0 or j1−b=0, respectively.
–La
lrcontains all cid’s that are part of the queries to Left
orRight when jb>0 or j1−b>0, respectively.
The experiment returns 1 if and only if:
–bitˆbis equal to bit b, and
–(instance freshness) the adversary never made a query to
oracle Challenge using handles πi0,k0
T0andπi1,k1
T1for any
k0,k1, and
–(credential separation) The following set is empty:
wUnl :(Lr
ch∪La
ch)∩(Lr
lr∪La
lr)
mUnl :((Lr
ch∪La
ch)∩La
lr)∪((Lr
lr∪La
lr)∩La
ch)
sUnl :(Lr
ch∩La
lr)∪(Lr
lr∩La
ch).
Depending on credential separation, we distinguish three
levels of unlinkability: weak, medium and strong.
4.2 Formal Model of PAwAM
In the previous section, we introduced a security model for
FIDO with attributes. Unfortunately, introducing attributes
without significant changes to the FIDO specification and
token firmware is impossible, which violates our compatibility
requirement R.3and pluggable integration requirement R.5.
Our goal is to build a system that uses existing building
blocks. In particular, we want to interface existing FIDO
solutions with attribute-based systems (e.g., anonymous cre-
dentials or ICAO eID-based attributes). To this end, we must
introduce a trusted party called a mediator that acts as the
interface between both systems.
4.2.1 Formal Syntax
The mediator is identifiable using a public key pkMwith
a corresponding secret key skM. This new party introduces
additional security problems, which we capture formally
in the definitions below. In our syntax, we will also use
askT←IssCred (AttT)to denote a token-specific secret key
for the attribute-based credential systems. To simplify our
considerations, we abstract the attribute-based system issuing
process using algorithm IssCred . We assume this algorithm
outputs a fresh askfor the given attributes, leading to fresh cre-
dentials for the attribute-based system (e.g., new data groups
in case of eID systems). It is worth noting that in PAwA im-
plementations, the askTcan be part of the token’s master
secret key. We make this key explicit in PAwAM to simplify
the description. The user platform (i.e., token and client) can
use this key to prove possession of attributes to the mediator.
We assume that this key implicitly defines the attributes AttT
corresponding to token T.
Definition 8 (PAwAM ).A passwordless authentication
scheme with attributes and mediators ( PAwAM ) is a tuple
PAwAM = (Gen,Reg,Auth ,Med):•Gen,Reg,Auth : has the same description as in PAwA .
•Med: given as a tuple of the following algorithms:
attestreq ac:on input of a secret key askT, a server chal-
lenge c, outputs an attestation request reqMandnonce .
attestchal ac:on input of a request reqM, a mediator secret
keyskM, a mediator public key pkM, outputs an attes-
tation state stchaland a challenge chal M.
attestresp ac:on input of an attribute secret key askT,
a challenge chal M, outputs an attestation response
respM.
attest ac:on input of a challenge state stchal, a response
respMand a mediator secret key skM, outputs a attes-
tation message attmand a signature σm.
prove ac:on input of an attestation message attm, an attes-
tation signature σm, a nonce nonce , attributes Att, a
policy PolicyS, outputs a proof of attribute possession
ΠAtt.
check ac:on input of a proof ΠAtt, a policy PolicyS, a me-
diator public key pkM, and a challenge c, outputs a bit
bac.
Algorithms check acis executed by servers during the execu-
tion of rcheck acandacheck ac. Algorithms attestchal acand
attest acare executed by mediators, attestreq ac,attestresp ac
andprove acare executed by clients.
Definition 9 (Oracles) .ForPAwAM , we use the same server
and token oracle defined for PAwA . We slightly modify the
Setup oracle, which now additionally sets the keys askTof
tokens according to the attributes the oracle sets. Additionally,
we allow the adversary to communicate with the mediator Mi,
where irepresents the i-th session of the mediator using the
following oracles:
•MedReq (T,c): The oracle executes (nonce ,reqM)←
attestreq ac(askT,c). The result is returned to A.
•MedChal (Mi,reqM): It executes stchal,chal M←
attestchal ac(reqM,skM,pkM)and returns chal MtoA
and sets stM[Mi]:=stchal.
•MedResp (T,chal M): The oracle executes respM←
attestresp ac(chal M,askT)and forwards the output to A.
•MedAttest (Mi,respM): The oracle executes stchal:=
stM[Mi]and(attm,σm)←attest ac(stchal,respM,skM). The
result (attm,σm)is returned to A.
4.2.2 Security and Privacy of PAwAM
We will now define the security experiment for passwordless
authentication with attributes and a mediator. All definitions
follow the same pattern as in the standard PAwA case, except
that we provide the adversary with means to simulate the
interaction between tokens and the mediator. As mentioned,
we must also introduce security notions that will capture a
malicious mediator that tries to break the system’s privacy
(e.g., learning the attributes or the origin of the server).Definition 10 (Impersonation Security) .For the PAwAM , the
impersonation security experiment, ImpA
PAwAM is the same as
defined for PAwA , except that the adversary Ais given access
to the oracles from Definition 9 during the online phase.
Definition 11 (Attribute Unforgeability) .ForPAwAM , the at-
tribute unforgeability experiment, Att-UnfA
PAwAM is the same
as defined for PAwA , except that Ais given access to the ora-
cles from Definition 9 during the online phase. We define as
an additional winning condition that there is no query made
toMedReq using challenge cfor the server handle πi,j
S.
Definition 12 (Unlinkability) .For the PAwAM , the unlinka-
bility experiment, UnlA
PAwAM is the same as defined for PAwA ,
except that the adversary Ais given access to the oracles from
Definition 9 during the phases 1 and 3.
We will now introduce two notions for PAwAM that infor-
mally capture the following two privacy concerns. First, we
ensure that given an attestation request, the mediator cannot
distinguish which origin the user is trying to access. Sec-
ond, the mediator should attest to the user’s attributes without
learning anything about them. We capture the first notion
informally with an experiment where the adversary specifies
one token and two servers. The experiment then proceeds
with picking one of the servers and starting the interaction
with the adversary that plays the role of the mediator. The
adversary wins if it can guess which server the user tried to
access. We call this notion origin privacy and define it more
formally in Definition 13. In addition to origin privacy, we de-
fine attribute privacy that captures the latter informal property.
The adversary now picks two tokens and one server. We want
to model that no information about the attributes of the two
tokens is leaked to the mediator. Therefore, the experiment
randomly picks one of the tokens and asks the adversary to
attest the token to the chosen server. Here we distinguish two
versions of attribute privacy: one-time and many-time. Both
ensure that the attributes used are hidden from the mediator,
but in one-time privacy, attestation requests from the same
token are linkable. Notably, this is similar to one-time-show
and multi-show security of anonymous credentials, where in
the former showing attributes twice is linkable. Still, the at-
tributes (e.g., personal data) are hidden, and there is no link
to the issuing process of the credentials. Although the medi-
ator can see that the same token/user is trying to receive an
attestation, the server cannot do this. Moreover, implementing
a local mediator is a simple solution to make any one-time
scheme many-time secure. In Section 6.1, we provide threat
analysis that depends on how the mediator is implemented in
practice.
We assume that the mediator does not collude with the
servers or the tokens, and further security analysis of the col-
lusion is provided in Section 6.1.
Definition 13 (Origin Privacy) .For the PAwAM , the origin
privacy experiment, Orig -PrivA
PAwAM is defined to run be-
tween the challenger and an adversary A.•Setup. For each token T∈T, a key is generated by running
msk T←Gen(par). The adversary assigns the attribute set
for tokens and policy set for servers by calling the oracle
Setup and passing in the attribute set lists.
•Phase 1. The adversary is allowed to interact with oracles
Start ,Complete ,Challenge (see Definition 3) and oracles
MedReq ,MedResp .
•Challenge Phase. The adversary outputs a token iden-
tifier Tand two (not necessarily distinct) server iden-
tifiers S0,S1∈S. The experiment chooses a bit buni-
formly at random and runs (cb,·)←achall ac(askT,idSb)
and(nonce b,reqM,b)←attestreq ac(askT,cb). The experi-
ment gives reqM,bto the adversary. The adversary outputs
a challenge chal M,bto which the experiment responds with
respM,b, where respM,b←attestresp ac(askT,chal M,b).
•Output Phase Finally, the adversary outputs a bit ˆb. The
experiment returns 1 if and only if bit ˆbis equal to bit b.
Definition 14 (One-time Attribute Privacy) .For the PAwAM ,
the attribute privacy experiment, Att-PrivA
PAwAM is defined to
run between the challenger and an adversary A.
•Setup. For each token T∈T, a key is generated by running
msk T←Gen(par). The adversary assigns the attribute set
for tokens and policy set for servers by calling the oracle
Setup and passing in the attribute set lists.
•Phase 1. The adversary can interact with oracles
Start ,Complete ,Challenge (see Definition 3). Additionally,
it can interact with oracles MedReq ,MedResp .
•Challenge Phase 1. The adversary outputs two (not nec-
essarily distinct) token identifiers T0,T1, and one server
identifier S∈S.
•Challenge Phase 2. The experiment refreshes the attribute-
based secret keys askT0,askT1for tokens T0,T1by running
askT0←IssCred (AttT0)andaskT1←IssCred (AttT1).
•Challenge Phase 3. The experiment chooses a bit buni-
formly at random and runs: (c,·)←achall ac(idS)and
(nonce b,reqM,b)←attestreq ac(askTb,c). The experiment
gives reqM,bto the adversary. The adversary outputs a
challenge chal M,bto which the experiment responds with
respM,b, where respM,b←attestresp ac(chal M,b,askTb).
•Output Phase Finally, the adversary outputs a bit ˆb. The
experiment returns 1 if and only if bit ˆbis equal to bit b.
Definition 15 (Many-times Attribute Privacy) .We define
many-times attribute privacy similar to one-time attribute
privacy, except that it omits Challenge Phase 2 .
5 FIDO-AC: System Design
In this section, we will describe the FIDO-AC system. First,
we give an overview of actors and interactions. We then de-
scribe the requirements that an anonymous credential system
must support to be used in FIDO-AC. We show this in the
example of an electronic identity document (eID) in the ICAOattestreq ac(askT,c)
nonce←${0,1}λ
(H(DG),pkeID,πPA)←BAC/PACE (askT)
reqM:= (H(DG),pkeID,πPA,c,nonce )
retnonce ,reqMattestchal ac(reqM,skM,pkM)
(H(DG),pkeID,πPA,c,nonce ):=reqM
keyses←KE(pkeID,skM)
cmd cha←AE-ENC(keyses,cmd)
chal M:= (pkM,cmd cha)
stchal:= (reqM,keyses)
retstchal,chal Mattestresp ac(chal M,askT)
(pkM,cmd cha):=chal M
respM←CA(pkM,cmd cha,askT)
retrespM
attest ac(stchal,respM,skM)
(reqM,keyses):=stchal
(H(DG),pkeID,πPA,c,nonce ):=reqM
bPA←PAveri f y(H(DG),pkeID,πPA)
bCA←CAVeri f y(respM,keyses)
attm:=H(H(DG)||nonce )||c
σm:=⊥
σm←Sign(skM,attm)i f(bPA∧bCA)
ret att m,σmprove ac(attm,σm,nonce ,Att,PolicyS)
DG←Parse (Att)
(m||cm):=attm
πzkp←ZKProve (crs,(m,PolicyS),
(DG,nonce ))
ΠAtt:= (attm,σm,πzkp)
retΠAttcheck ac(ΠAtt,PolicyS,pkM,c)
(attm,σm,πzkp):=ΠAtt
bM←Verify (pkM,attm,σm)
(m||cm):=attm
bzkp←ZKVer (crs,(m,PolicyS))
bchallenge ←cm=?c
bac←bM∧bzkp∧bchallenge
ret b ac
Table 1: The pseudocode of FIDO-AC for the algorithms defined in Definition 8. Wrapper algorithms: KE- key exchange, AE−ENC
- authenticated encryption, PAveri f y - passive authentication verification, CAveri f y - chip authentication verification.
standard. Finally, we show how those credentials can be inte-
grated into the FIDO2 authentication process.
5.1 Overview
FIDO-AC is a novel system that satisfies the requirements and
threat model stated in Section 3. Figure 3 illustrates the high-
level overview of the new modules introduced by the FIDO-
AC extension to the existing FIDO2. At its core, the FIDO-
AC system comprises three subsystems, namely anonymous
credentials (AC), mediator, and FIDO extension integrated
to provide the needed functionalities. The AC module will
gather and supply all the necessary information required to
fully realize an AC system while utilizing the binding to
FIDO as the medium to deliver the information. Compared
to using the standard FIDO2 protocol, users have to install
an additional FIDO-AC application and scan their eID for
proof of interaction. The application is also used to arbitrarily
disclose the attributes of users, using a non-interactive zero-
knowledge proof system. Note that installation is a one-time
setup, while the result from the scanning of eID can be reused
if the user explicitly permits caching. Additionally, the FIDO-
AC framework relies on a trusted mediator to produce the
proof of interaction with an eID for each FIDO2 transaction.
Below we describe the FIDO-AC protocol (illustrated in
Figure 2) using the notion of passwordless authentication
with attributes and mediator we introduced in the previous
section. The description will use the standard FIDO pass-
wordless authentication as a building block. Thus, we will
use the notion provided by Hanzlik et al. [22]: rchall ,achall ,
rcomm ,acomm ,rresp ,aresp ,rcheck ,acheck , to denote the
standard protocol and use the suffix ac(e.g., rchall ac) to in-
dicate our PAwAM . Please note that only rchall ac,achall ac,
rcomm ac,acomm ac, and rcheck ac,acheck acintroduce addi-
tional steps to the FIDO protocol, which remain the same forregistration and authentication processes. Therefore, we only
provide descriptions of the functions mentioned above and
the pseudocode for the new algorithms (see Table 1).
Thercomm acandacomm acalgorithms are triggered with
server identity idSand challenge cp(the standard FIDO chal-
lenge is extended with a policy). Then, the client extracts
data from the eID (see step †in Figure 2 and Section 5.2),
which is followed by a communication with the mediator to
run the liveliness check (steps ‡) and an attestation genera-
tion (step∗). Then, the client runs the zero-knowledge proof
(ZKP) generation (step∗∗). The attestation is hashed and ap-
pended to the challenge, which is passed to the rcomm or
acomm functions. Regarding the rcheck acandacheck acfunc-
tions, we modify the generated challenge with the hashed
attestation values and ZKP. Then, we use the modified chal-
lenge in the rcheck andacheck algorithms. Finally, we run a
check acalgorithm, which verifies both ZKP and attestation.
The server’s decision depends on both FIDO and FIDO-AC
checks.
5.2 Anonymous Credentials
FIDO-AC can use any anonymous credential system support-
ing an active non-shareability test. In literature, this is usually
ensured via binding the secret key for the credentials to a
hardware token. Due to the construction of the FIDO-AC
framework, it can not only support any attribute system with
a non-shareability property but also improve the privacy guar-
antees of the final solution. Without loss of generality, we will
use ICAO-compliant eIDs as the basis for the credential part
of FIDO-AC. The way we will use the eID can be described
as follows. A FIDO-AC-specific application will extract the
authenticated data for the eID. A mediator can verify the
data using the Passive Authentication protocol described in
Section 2.2, and then run the liveliness check.Mediator Client Server
Mr←rcomm ac(idS,cp): (cp,st)←rchall ac(idS):
Ma←acomm ac(idS,cp): (cp,st)←achall ac(idS):
stchal,chal M←attestchal ac(reqM (id,rs,p):= (c,p):=cp (c,st)←rchall (idS)
reqM,skM,pkM)‡ chal M (nonce ,reqM)←attestreq ac(askT,c)† cp(c,st)←achall (idS)
(attm,σm)←attest ac(stchal,resp M resp M←attestresp ac(chal M,askT)‡st:= (idS,rs,p):= (st,Policy S)
respM,skM)‡∗ attm,σm cp:= (c,p):= (idS,rs,PolicyS)
Token (b,cred)←rcheck ac(st,cid,Rac):
(cid,Rr)←rresp ac(msk,idS,Mr): b←acheck ac(st,rcs,cid,Rac):
Ra←aresp ac(msk,idS,cid,Ma): ΠAtt←prove ac(attm,σm,nonce ,DG,p)∗∗(Rr,Ra,ΠAtt):=Rac
idS,Mr, cac:= (id,(rs||H(ΠAtt))) (c,p):= (idS,rs,p):=st
cid,Ma Mr←rcomm (idS,cac) stac:= (ids,rs||H(ΠAtt))
(cid,Rr)←rresp(msk,idS,Mr) Ma←acomm (idS,cac) (b,cred)←rcheck (stac,cid,Rr)
Ra←aresp (msk,idS,cid,Ma) b←acheck (stac,rcs,cid,Ra)
cid,Rr,RaRac:= (Rr,Ra,ΠAtt) cid,Rac bac←check ac(ΠAtt,p,pkM,c)
b:=b∧bac
Figure 2: The FIDO-AC protocol for registration and authentication. The flow reuses definitions in [22] (Figure 1). - registration,
- authentication, if not marked, applicable to both flows.†- eID read,‡- liveliness check,∗- mediator attestation,∗∗- ZKP generation.
Figure 3: Differences between (a) FIDO-AC and (b) FIDO2.
Additional parts of FIDO-AC are given in the gray box.
The liveliness check , used by mediator, verifies whether the
user owns the provided authenticated data. Such a check is
implemented in the ICAO-based eID infrastructure using Ac-
tive Authentication or its variant that we will use namely Chip
Authentication (CA). The idea behind those authentication
methods is that eID is equipped with a secret key stored in
secure memory. In the eID setting, it is assumed that the key
never leaves this secure memory and cannot be extracted.
During CA, the eID proves knowledge of the secret key with
respect to a public key bound to the authenticated data.
We will now summarize the liveliness test in more detail.
The test starts with the eID sending the hash value of the
data it stores, including the public key and the issuer’s sig-
nature (see Section 2.2 for more information), as well as the
relying party’s challenge and application’s nonce for binding
purposes. Using this data, the mediator performs both the
CA and PA. After the session keys are replaced, the mediatorqueries the eID for a random challenge for the Terminal Au-
thentication (TA) protocol. This command is encrypted using
the session keys that are the result of the CA protocol. Thus,
it implicitly prove knowledge of the secret key corresponding
to the disclosed eID public key, which is bound to authen-
ticated data. The result of the liveliness test is a signature
of the mediator attesting that it performed the liveliness test
for the signed data. The liveliness test is captured in the al-
gorithms ( attestreq ac,attestchal ac,attestresp ac,attest ac), and
the pseudocode for the algorithms can be found in Table 1.
Disclosing Attributes , in the FIDO-AC system, is imple-
mented using zero-knowledge (ZK) proofs. Recall that the
mediator’s signature is under a specific hash value and the
relying party’s challenge. This hash value is a salted hash of
the hashed attributes of the user data and, as such, contains
data that should not be disclosed to the verifier. At the same
time, the verifier must check this double-hashed salted data
to adhere to some policies. Therefore, we will use a proof
system to do exactly this.
To limit communication, we consider using the non-
interactive zero-knowledge proof (NIZK) system, as it do
not require interaction between the prover and the verifier.
There exist many non-interactive ZK-proof systems support-
ing arbitrary computation to be proven, namely Groth’16
ZK-SNARK [20], the setup less bulletproof [7], and ZK-
STARK [5]. The exact choice of the proof system is not
pertinent to the design and is left as the implementation de-
tails. The anonymous credential in FIDO-AC will take theform of a non-interactive zero-knowledge proof about some
properties of the data from the eID, which are represented by
a double-hashed salted value. The credential will also include
the attestation of the mediator in the form of a standard digital
signature on this hash value that will be returned as the result
of the liveliness test. The ZK proof of attributes is captured in
the algorithms ( prove ac,check ac), and the pseudocode for the
algorithms can be found in Table 1.
5.3 FIDO-AC extension
FIDO2 extensions are the recommended way to extend FIDO2
functionality. Therefore our design follows the best practices
and introduces a new extension called fidoac . However, in-
cluding a new extension to the FIDO2 messages is not enough
to fully integrate with the FIDO2 ecosystem. Our objective
is to minimize the effort of adapting the FIDO-AC system
and provide a smooth integration with existing FIDO clients
and authenticators. Therefore, we analyzed the available solu-
tions to select the most suitable approach for the FIDO-AC
system. We identified three approaches: custom client [21],
relying party modification [29], and client extension [31] (de-
tailed evaluation in Appendix D). However, none of the above-
mentioned solutions is sufficient to design an architecture that
fulfills our requirements. Therefore, we followed a hybrid
approach based on the modifications introduced before and
after WebAuthn API is called, and marginal modification in
the FIDO server. First, the FIDO assertion request needs to be
extended to include fidoac extension. Second, an additional
JavaScript ( fidoac.js ) needs to be included in the page, which
handles the navigator.credentials.get execution. Finally, the
FIDO server needs an additional code snippet used to ver-
ify the FIDO assertion with the fidoac extension. FIDO-AC
modified the challenge used, and a detailed discussion of the
modification can be found in Appendix C.
Our approach is fully compatible with FIDO2 ( R.3) and
does not modify user-facing FIDO2 parties ( R.5). Thus, it can
be considered to be as scalable as a pure FIDO2 system ( R.6).
The modifications of the FIDO server are trivial to implement
with the existing FIDO2 libraries (e.g., custom extensions in
SimpleWebAuthn Server5). Similarly, the verification modifi-
cation requires only two widely supported primitives (SHA-
256 and base64 encoding). Regarding fidoac.js , the JavaScript
can be imported directly from an external source (e.g., hosted
by FIDO-AC) to the web page. Therefore, we claim that the
introduced modifications fulfil requirement R.5.
6 Security Analysis
In this section, we analyze the security and privacy of FIDO-
AC and only sketch the idea behind why security holds and
give complete proof in the full paper.
5https://www.npmjs.com/package/@simplewebauthn/serverLemma 1. The FIDO-AC protocol presented in Figure 2 is se-
cure against impersonation as defined in Definition 10 assum-
ing the underlying passwordless authentication PLA protocol
used as a building block is secure against impersonation.
Proof sketch. The idea is that the FIDO protocol remains
unchanged in FIDO-AC, which only adds additional parts
that do not influence impersonation resistance.
Lemma 2. The FIDO-AC protocol presented in Figure 2 is un-
linkable as defined in Definition 12 assuming the underlying
passwordless authentication PLA protocol is secure against
unlinkability, the hash function His a random oracle and the
used proof system is zero-knowledge.
Proof sketch. The only additional data compared to a stan-
dard FIDO response is the mediator’s attestation and zero-
knowledge proof. The former is a standard signature on the
message attm= (H(H(DG)||nonce )||c), which leaks no infor-
mation about the user’s attributes stored in DGdue to the
use of a random nonce . Finally, the proof provided is zero-
knowledge, also leaking no additional information.
Lemma 3. The FIDO-AC protocol presented in Figure 2 is
attribute unforgeable as defined in Definition 11 assuming the
unforgeability of the mediator signature, the security the eID
and the soundness of the used proof system.
Proof sketch. For the server to accept in check ac, the adversary
must be able to provide zero-knowledge proof proving the
message signed by the mediator contains attributes satisfying
the server’s policy. Since the proof system is sound, the only
way to win is for the adversary to forge a signature on the
mediator’s behalf or to break the security of the eID (i.e.,
create a fake eID that passes as valid).
Lemma 4. The FIDO-AC protocol presented in Figure 2 sat-
isfies origin privacy as defined in Definition 13.
Proof sketch. The mediator only gets access to the server’s
challenge and information about the token, which is inde-
pendent of the server in this experiment. The honest server
chooses the challenge uniformly at random, so it does not
reveal any information about it.
Lemma 5. The FIDO-AC protocol presented in Figure 2 sat-
isfies one-time attribute privacy as defined in Definition 14
assuming the random oracle model and the unlinkability of
data groups for the same personal data of the eID.
Proof sketch. The mediator learns the hash value of the data
groups and a static public key for one of the tokens. Since we
only have to prove one-time security, the data groups of both
challenged tokens are reissued, and an adversary can break
attribute privacy only if it can distinguish the refreshed data
groups of the tokens (i.e., break the assumption for eID).
6.1 Mediator Threat Analysis
The Mediator in FIDO-AC can be instantiated in multiple
ways. We first rule out the possibility of delegating the medi-Mediator-Verifier Mediator-Prover
UnlinkabilityNone: ✗∗
TEE: ✗∗
C-TEE: ✓✓
Attribute
Unforgeability✓None: ✗
TEE: ✓
C-TEE: ✓
Table 2: Unlinkability and attribute unforgeability properties
for colluding parties of the FIDO-AC system.
∗- considering ICAO eID, for other eID schemes a stronger unlinka-
bility property can be achieved
ator role to the client’s browser, as it lacks a trusted execution
environment (i.e., the verifier cannot trust such a mediator),
and the configuration of the relying party acting as a mediator,
as it breaks the privacy assumptions (i.e., linking user using
identifiable properties of eID). Therefore, we only consider
the following versions of mediator configuration: a local ap-
plication (backed with hardware attestation), a remote trusted
third party, or any party that uses confidential TEE.
The mediator (local or remote) colluding with either ver-
ifier or prover introduces a threat of breaking the properties
of the FIDO-AC system. In Table 2, we evaluate privacy (i.e.,
unlinkability) and attribute unforgeability properties consid-
ering colluding mediator and various execution environments.
The collaboration of the mediator and verifier breaks the un-
linkability property because data received by the verifier can
be linked to the corresponding eID, unless a confidential TEE
is used (i.e., user identifier not revealed to the mediator). For
the mediator colluding with the prover, the attribute unforge-
ability property can be compromised if the TEE environment
is not used (i.e., any proof can be generated). Therefore, we
claim that a local verifier provides better privacy guarantees
for privacy-oriented systems, whereas a remote mediator is
more suitable for highly secure configurations.
The practical implementation of mediators relies on a
secure trusted environment. Notably, we acknowledge the
threats of jailbreaking TEE or leaking information from con-
fidential TEE (e.g., side-channel attacks for SGX enclave
[10, 32]). However, we argue that for the majority of use
cases, we can safely assume that the TEE properties hold. Re-
garding trusted third party, we argue that, though it guarantees
privacy and soundness of the system, it does not provide in-
centives for the running entity, and thus reduces the practical
value. Therefore, considering the above threats, we decided to
implement the FIDO-AC system (see Section 7) with a local
mediator.
6.2 Web Security
The FIDO-AC system alters the execution of the applica-
tion on the client side (i.e., web browser) by introducing a
fidoac.js library. The security of loading and executing the
fidoac.js script, similarly to any JavaScript library, depends
on the deployment method (e.g., CDN or same origin) andapplied web security mechanisms such as Subresource In-
tegrity (i.e., verifying the script’s hash) and Content Security
Policy (i.e., restricting the script’s origin). Considering the
integration method of fidoac.js (i.e., a decorator pattern), we
argue that our modification of the navigator.credentials object
does not change the security properties of the parent applica-
tion. Additionally, we consider the security of the communi-
cation between fidoac.js and the FIDO-AC client extension
(e.g., FIDO-AC mobile application) depends on the platform-
specific mechanisms, however, unintentional verification is
unlikely because sharing the credentials involves user actions
(e.g., providing an eID to verify liveliness). Nevertheless, if
the channel is insecure, an adversary could send the request
at the right time (i.e., during a valid transaction) to launch
a hijacking attack, hoping that the user does not notice any
difference in the transaction data (similarly to MFA fatigue
attacks). Therefore, we claim that the security of fidoac.js
extension relies only on the web application configuration,
browser security, and OS means to communicate with the
FIDO-AC client extension.
7 Implementation and Evaluation
In this section, we describe our approach to building the
FIDO-AC system and demonstrate its feasibility in practi-
cal deployment in terms of performance evaluation. Notably,
our prototype is one possible instantiation, and we can effort-
lessly adjust to any requirements. Following the system re-
quirements (see Section 3), our implementation is suitable for
most existing FIDO2 deployments. We achieved the claimed
requirements by encapsulating and extracting the FIDO-AC-
specific logic and then introducing the integration points. The
high-level view of our FIDO-AC system implementation is
presented in Figure 4. More details on the interaction be-
tween different components can be found in Appendix A. A
detailed description of the system elements and the discus-
sion about the design decisions can be found in Appendix B.
The source code is published in our open-sourced repository
(https://github.com/FIDO-AC/fidoac ).
7.1 Implementation
The FIDO-AC system implementation is based on three com-
ponents. The first is a user-centered mobile application for
Android OS that introduces a bridge between the eID (in our
prototype, an ICAO-based ePassport) and the FIDO authenti-
cation mechanism. We reuse an NFC interface to execute the
PACE (or alternatively BAC) protocol and implement usabil-
ity enchancements such as extracting data from the machine
readable zone (MRZ) and data caching. We decided to follow
a local mediator approach which is designed as a part of the
FIDO-AC application. It relies on the security assumptions of
Android’s TEE. The zero-knowledge proof generation func-
tionality follows the Groth’16 ZK-SNARK [20] using portedFigure 4: FIDO-AC system implementation high-level view
versions of rust-arkwork [12] and libsnark [28] libraries. The
security as well as ZKP selection considerations can be found
in Appendix B). The second component, FIDO-AC Server, is
introduced to simplify the integration with existing FIDO im-
plementations. It facilitates the anonymous credential trusted
setup and verification. We recognized that the centralized
and externalized party for the server-side process (e.g., ZKP
verification), contributes to the usability and deployability
of the FIDO-AC system. Similarly, the JavaScript integra-
tion (i.e., fidoac.js ) is prepared to seamlessly introduce the
FIDO-AC modifications to the browser execution. The script
is served from CDN and automatically overrides the naviga-
tor.credential functions.
7.2 Performance Evaluation
We tested the FIDO-AC system using a Google Pixel 6 Pro
and a Standard D4s v3 Microsoft Azure cloud instance (4
vcpus, 16 GiB memory). Without loss of generality, we use
an ePassport as the ICAO-compliance eID. The performance
of the running time is across 100 runs of the measured com-
ponent. Reading the eID data takes about ∼1050 msin itself.
Fortunately, this operation can be cached in the application’s
memory. The other part of the interaction with the eID (i.e., se-
cure channel establishment via BAC/PACE and liveliness test
with a local mediator) takes ∼740ms. Verifying the ZKP is
the least taxing operation, which only takes <10msdue to the
usage of ZK-SNARK. The downside of using ZK-SNARKs
is the proving time. The proving time for our example (i.e.,
data and age policy proof) is ∼3.3swhich is relatively slow
compared to the verification time. Fortunately, the FIDO-AC
application can precompute such proofs since they do not
depend on any values chosen by third parties but only on data
and randomness chosen by the application. The application
can do it since the space of practical queries is small, or the
user can predefine a set of accepted predicates. Assuming a
completed offline preprocessed proof and cached eID data, the
added latency of the FIDO-AC system compared to standard
FIDO2 is less than 1 sfor our implementation.
8 Discussion
Achieving high usability was the primary goal of our design.
Therefore, we inspect the usability of FIDO-AC compared toOperation Platform Time (ms) SD (ms)
eID Reading Mobile 1059.4/0.0†37.58
Liveliness Check Mobile 738.92 47.06
ZK Verify Cloud PC 8.19 0.29
ZK Prove Mobile 3375.61∗95.25
†The FIDO-AC application can cache the read data.
∗Running time reduces significantly with preprocessing.
Table 3: Performance overview of the various FIDO-AC oper-
ations. Time is averaged over 100 executions.
other schemes. The user must install a separate FIDO-AC ap-
plication to use the FIDO-AC system. Note that different rely-
ing parties’ services can reuse the same application. Thus, the
initial setup phase is one-time for all future FIDO-AC-enabled
services. To reduce user friction and improve usability, users
can opt into an optional document data caching feature to
prevent inputting the document data in subsequent runs if
they are comfortable with it. The FIDO-AC application can
provide optical character recognition (OCR) functionality to
read the necessary information from the document’s machine-
readable zone (MRZ), eliminating the need for error-prone
and high-friction manual input. It is worth mentioning that the
usability of FIDO-AC (with cached eID data) is comparable
to the FIDO2 authentication via the NFC channel (i.e., eID
must be placed close to the reader).
In the case of the relying parties, we focused our efforts
on the usability of deployment and integration. The relying
party only has to include the provided JavaScript file into
the web application page containing the call to the browser
WebAuthn API without making any other changes to the
existing web application codebase. To simplify and smoothen
the integration of the verification logic needed by FIDO-AC
into the existing FIDO infrastructure, we provide a docker
image containing the verification service and its dependencies
are provided. Alternatively, the relying party can choose to
invoke the verification service hosted by the FIDO-AC server
and parse the result according to the relevant business logic,
which further minimizes the integration effort.
Electronic Identification Schemes. Digital transformation
has been a strategic target for many countries, including issu-
ing digital identity documents and remote identity verification.
In particular, frameworks following the Issuer, Verifier, and
Holder model, such as mobile driving license (mDL) [25]
or eIDAS EUDI Wallet [11], are being introduced as a legal
means to identify people. The FIDO-AC framework (exclud-
ing privacy advancements) resembles the abovementioned
schemes with some key differences. FIDO-AC leverages ex-
isting eID documents, and thus it does not mandate to have
a Holder role. In consequence, FIDO-AC does not introduce
additional provisioning and enrollment procedures. Similarly,
unlike generic eID frameworks, FIDO-AC proposes a spe-
cific set of technologies (e.g., ZKP and FIDO2) that, eventhough might not be suitable for every deployment, reduces
the development and interoperability efforts. Using external
eID, FIDO-AC implements roaming attributes (a concept
similar to the FIDO2 roaming authenticator), enabling device-
independent identity verification (e.g., through thin clients
or kiosks). Regarding privacy, the mediator-based setup of
FIDO-AC allows for a multi-show of credentials, which can-
not be easily achieved with static credentials (e.g., a new set
of credentials has to be issued to remain private, which is a
noticeable inconvenience for both Issuer and Holder). No-
tably, FIDO-AC and wallet-based schemes such as mDL are
not exclusive. On the contrary, FIDO-AC can utilize those
schemes if they provide an active authentication feature.
9 Conclusion
This paper described and demonstrated an end-to-end solu-
tion for enforcing privacy in attribute-based authentication
using the FIDO2 protocol. Our design considers usability
for both users and implementers and is thus ready for pro-
duction deployment. We integrate the eID environment and
enforce a liveliness verification to increase the trustworthi-
ness of the presented attributes, preventing the problem of
attribute sharing. We leverage zero-knowledge proofs to guar-
antee the privacy of the attributes presentation. We introduce
a custom FIDO2 extension for transporting anonymized cre-
dentials and present a mechanism to overcome the WebAuthn
API limitations. We support our design with security and per-
formance evaluations and a prototype implementation of the
system components. The methods presented in this paper will
contribute to sensitive data storage minimization and thus
mitigate private data leaks in the future.
Acknowledgments
We thank the anonymous reviewers for Usenix Security’23
for their helpful comments and feedback. This work is sup-
ported by the Federal Ministry of Education and Research
(BMBF), the German Academic Exchange Service (DAAD),
and Macquarie University under the Australia–Germany Joint
Research Co-operation Scheme with project ID: 57654883.
References
[1]FIDO Alliance. FIDO security reference. https://
fidoalliance.org/specs/common-specs/fid
o-security-ref-v2.1-rd-20210525.html , 2021.
[Online; accessed 11-Oct-2022].
[2]AUSTRAC. Optus Data Breach. https://www.au
strac.gov.au/optus-data-breach-working-o
ur-reporting-entities , 2022. [Online; accessed
11-Oct-2022].[3]Manuel Barbosa, Alexandra Boldyreva, Shan Chen, and
Bogdan Warinschi. Provable security analysis of FIDO2.
In Tal Malkin and Chris Peikert, editors, CRYPTO 2021,
Part III , volume 12827 of LNCS , pages 125–156, Virtual
Event, August 2021. Springer, Heidelberg.
[4]Mira Belenkiy, Jan Camenisch, Melissa Chase, Markulf
Kohlweiss, Anna Lysyanskaya, and Hovav Shacham.
Randomizable proofs and delegatable anonymous cre-
dentials. In Shai Halevi, editor, CRYPTO 2009 , volume
5677 of LNCS , pages 108–125. Springer, Heidelberg,
August 2009.
[5]Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and
Michael Riabzev. Scalable, transparent, and post-
quantum secure computational integrity. Cryptology
ePrint Archive, Report 2018/046, 2018. https://epri
nt.iacr.org/2018/046 .
[6]Johannes Blömer and Jan Bobolz. Delegatable attribute-
based anonymous credentials from dynamically mal-
leable signatures. In Bart Preneel and Frederik Ver-
cauteren, editors, ACNS 18 , volume 10892 of LNCS ,
pages 221–239. Springer, Heidelberg, July 2018.
[7]Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew
Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs:
Short proofs for confidential transactions and more. In
2018 IEEE Symposium on Security and Privacy , pages
315–334. IEEE Computer Society Press, May 2018.
[8]Melissa Chase, Sarah Meiklejohn, and Greg Zaverucha.
Algebraic MACs and keyed-verification anonymous cre-
dentials. In Gail-Joon Ahn, Moti Yung, and Ninghui Li,
editors, ACM CCS 2014 , pages 1205–1216. ACM Press,
November 2014.
[9]David Chaum. Blind signatures for untraceable pay-
ments. In David Chaum, Ronald L. Rivest, and Alan T.
Sherman, editors, CRYPTO’82 , pages 199–203. Plenum
Press, New York, USA, 1982.
[10] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian
Zhang, Zhiqiang Lin, and Ten H. Lai. SgxPectre: Steal-
ing intel secrets from SGX enclaves via speculative exe-
cution. In 2019 IEEE European Symposium on Security
and Privacy (EuroS&P) , pages 142–157, Stockholm,
Sweden, June 2019. IEEE.
[11] European Commission. European digital identity archi-
tecture and reference framework – outline. Standard,
European Commission, 2022.
[12] Arkworks Contributors. Arkworks zkSNARK ecosys-
tem. https://arkworks.rs . [Online; accessed 11-
Oct-2022].[13] Geoffroy Couteau and Michael Reichle. Non-interactive
keyed-verification anonymous credentials. In Dongdai
Lin and Kazue Sako, editors, PKC 2019, Part I , vol-
ume 11442 of LNCS , pages 66–96. Springer, Heidelberg,
April 2019.
[14] Elizabeth C. Crites and Anna Lysyanskaya. Delegatable
anonymous credentials from mercurial signatures. In
Mitsuru Matsui, editor, CT-RSA 2019 , volume 11405
ofLNCS , pages 535–555. Springer, Heidelberg, March
2019.
[15] Özgür Dagdelen and Marc Fischlin. Security analysis
of the extended access control protocol for machine
readable travel documents. In Mike Burmester, Gene
Tsudik, Spyros S. Magliveras, and Ivana Ilic, editors,
ISC 2010 , volume 6531 of LNCS , pages 54–68. Springer,
Heidelberg, October 2011.
[16] Alex Davidson, Ian Goldberg, Nick Sullivan, George
Tankersley, and Filippo Valsorda. Privacy pass: By-
passing internet challenges anonymously. PoPETs ,
2018(3):164–180, July 2018.
[17] FIDO Alliance. Client to authenticator protocol (CTAP).
https://fidoalliance.org/specs/fido-v2.1-p
s-20210615/fido-client-to-authenticator-p
rotocol-v2.1-ps-errata-20220621.pdf , 2021.
[Online; accessed 11-Oct-2022].
[18] Christina Garman, Matthew Green, and Ian Miers. De-
centralized anonymous credentials. In NDSS 2014 . The
Internet Society, February 2014.
[19] Google. Play Integrity API. https://developer.
android.com/google/play/integrity/overview .
[Online; accessed 11-Oct-2022].
[20] Jens Groth. On the size of pairing-based non-interactive
arguments. In Marc Fischlin and Jean-Sébastien Coron,
editors, EUROCRYPT 2016, Part II , volume 9666 of
LNCS , pages 305–326. Springer, Heidelberg, May 2016.
[21] Chengqian Guo, Quanwei Cai, Qiongxiao Wang, and
Jingqiang Lin. Extending registration and authentica-
tion processes of FIDO2 external authenticator with qr
codes. In 2020 IEEE 19th International Conference on
Trust, Security and Privacy in Computing and Commu-
nications (TrustCom) , pages 518–529, 2020.
[22] Lucjan Hanzlik, Julian Loss, and Benedikt Wagner. To-
ken meets wallet: Formalizing privacy and revocation
for FIDO2. In 2023 IEEE Symposium on Security and
Privacy (IEEE SP) , pages 978–995, Los Alamitos, CA,
USA, May 2023. IEEE Computer Society.[23] Scott Hendrickson, Jana Iyengar, Tommy Pauly, Steven
Valdez, and Christopher A. Wood. Rate-limited token
issuance protocol. Internet-Draft draft-privacypass-rate-
limit-tokens-03, IETF Secretariat, July 2022.
[24] Internation Civil Aviation Organization. Doc 9303 Ma-
chine readable travel documents - Part 10: Logical data
structure (LDS) for storage of biometrics and other data
in the contactless integrated circuit (IC). Technical re-
port, ICAO, 2021.
[25] ISO Central Secretary. Personal identification — ISO-
compliant driving licence — Part 5: Mobile driving
licence (mDL) application. Standard ISO/IEC 18013-
5:2021, International Organization for Standardization,
Geneva, CH, 2021.
[26] Stephan Krenn, Thomas Lorünser, Anja Salzer, and
Christoph Striecks. Towards attribute-based creden-
tials in the cloud. In Srdjan Capkun and Sherman S. M.
Chow, editors, CANS 17 , volume 11261 of LNCS , pages
179–202. Springer, Heidelberg, November / December
2017.
[27] Katharina Krombholz, Wilfried Mayer, Martin
Schmiedecker, and Edgar R. Weippl. “I have no
idea what I’m doing” - on the usability of deploying
HTTPS. In Engin Kirda and Thomas Ristenpart, editors,
USENIX Security 2017 , pages 1339–1356. USENIX
Association, August 2017.
[28] SCIPR Lab. C++ library for zkSNARKs. https://gi
thub.com/scipr-lab/libsnark . [Online; accessed
11-Oct-2022].
[29] Yuto Okawa, Shuji Yamaguchi, Hidehito Gomi, and Tet-
sutaro Uehara. Implementation of an extended FIDO2
authenticator using attribute-based signatures. In 2021
IEEE 21st International Conference on Software Qual-
ity, Reliability and Security Companion (QRS-C) , pages
825–832, 2021.
[30] European Parliament. Regulation (EU) 2019/1157 of
the European Parliament and of the Council of 20 june
2019 on strengthening the security of identity cards of
union citizens and of residence documents issued to
union citizens and their family members exercising their
right of free movement (text with EEA relevance.), Jul
2019.
[31] Florentin Putz, Steffen Schön, and Matthias Hollick.
Future-proof web authentication: Bring your own
FIDO2 extensions. In Andrea Saracino and Paolo Mori,
editors, Emerging Technologies for Authorization and
Authentication , pages 17–32, Cham, 2021. Springer In-
ternational Publishing.[32] Hany Ragab, Alyssa Milburn, Kaveh Razavi, Herbert
Bos, and Cristiano Giuffrida. CrossTalk: Speculative
data leaks across cores are real. In 2021 IEEE Sympo-
sium on Security and Privacy , pages 1852–1867. IEEE
Computer Society Press, May 2021.
[33] Michael Rosenberg, Jacob White, Christina Garman,
and Ian Miers. zk-creds : Flexible anonymous creden-
tials from zkSNARKs and existing identity infrastruc-
ture. Cryptology ePrint Archive, Report 2022/878, 2022.
https://eprint.iacr.org/2022/878 .
[34] Fabian Schwarz, Khue Do, Gunnar Heide, Lucjan Han-
zlik, and Christian Rossow. Feido: Recoverable FIDO2
tokens using electronic ids. In 29th ACM Conference
on Computer and Communications Security (CCS) . As-
sociation for Computing Machinery, November 2022.
[35] Alberto Sonnino, Mustafa Al-Bassam, Shehar Bano,
Sarah Meiklejohn, and George Danezis. Coconut:
Threshold issuance selective disclosure credentials with
applications to distributed ledgers. In NDSS 2019 . The
Internet Society, February 2019.
[36] Thales. The electronic passport in 2021 and beyond.
https://www.thalesgroup.com/en/markets/d
igital-identity-and-security/government
/passport/electronic-passport-trends , 2021.
[Online; accessed 11-Oct-2022].
[37] W3C. Web authentication: An API for accessing public
key credentials level 2. https://www.w3.org/TR/we
bauthn-2/ , 2021. [Online; accessed 11-Oct-2022].
A FIDO-AC Implementation Interactions
Figure 5: FIDO-AC interaction flow
Below, we describe the high-level interactions between the
parties of the FIDO-AC system implementation. The illus-
tration of the flow is presented in Figure 5. The interaction
with the FIDO-AC system starts when the user bootstraps the
FIDO-AC application (step 1.). The process involves reading
the data and signature from the eID document and cachingthem in the FIDO-AC application. After the initialization, the
user can trigger the FIDO2 transaction (step 2.). The FIDO2
assertion request is intercepted in the FIDO client and passed
to the FIDO-AC application (step 3.). At this stage, the FIDO-
AC application starts interacting with the mediator (step 4.).
The application shares the eID data: the hashed data values,
eID public key, and signature, as well as the FIDO challenge
and nonce. Notably, the mediator does not learn the identity
of the user. However, because of the eID public key, the in-
teraction of the same eID with the mediator is linkable. The
mediator’s task is to verify the authenticity of the data and
prove the liveliness of the eID. To accomplish that, the medi-
ator starts the interaction with the eID (step 5.). The details
of the interaction are described in Section 5.2. The mediator
returns a signature attesting to the liveliness (step 6.). It is
worth noting that the relying party cannot link the mediator’s
signature to any particular eID because the signed message
depends on its challenge and a hash value that is randomized
using a 128-bit nonce. The FIDO-AC application generates
a proof, which proves the knowledge of the hash preimage
(i.e., DG data) and that this personal data is according to the
policy PolicyS(e.g., above 18 years old). Both (attm,σm)and
πzkpare sent back to the FIDO client (step 7.) and attached
to the FIDO2 transaction (step 8.). Finally, the FIDO client
sends the complete assertion to the relying party, which runs
the signature and ZKP verification.
B FIDO-AC Implementation elements
FIDO-AC Application with Mediator: The application com-
municates with ePassport through an NFC interface with ac-
tive NFC scanning triggered by user interaction. This ap-
proach enables the mobile application to avoid spawning
unnecessary FIDO-AC processes on accidental proximity trig-
gers of NFC events. The ePassport employs a password-based
key-established protocol to protect the communication be-
tween the eID and the terminal. Therefore, our FIDO-AC
application implements the PACE protocol to establish this
secure channel. We also implemented the alternative BAC
protocol that served as the backup for backward compatibility
if the eID does not support PACE. PACE and BAC require a
password as input, composed of user data such as document
number, expiry date, and date of birth. Manual entry of the
data is tedious and error-prone. The mobile application pro-
vides an optional optical character recognition (OCR) to scan,
read and parse the necessary information on the document’s
machine readable zone (MRZ). Furthermore, the read data
can be cached if the user opts in. Caching the personal data
reduces the eID read time, which initially takes ∼1060 ms.
Moreover, the cached data can be encrypted at rest to pro-
vide further protection (defense-in-depth), albeit at a slightly
higher computational cost.
The mobile application also displays information about the
origin of the FIDO-AC requester and its queries. It allowsusers to check whether they are expecting the origin and the
associated queries. Before the eID is scanned, the user retains
the right to cancel the transaction and downgrade to FIDO.
Once the reading of the eID is done, the FIDO-AC mobile
application will communicate with a mediator as described in
Section 5.2. In our prototype implementation, we opted for a
local mediator implemented as part of the mobile application.
This approach relies on the property that (for a secure system)
hardware-backed keys can only be used by the application
that generated it, and the TEE enforces such a boundary. To
attest to an honest computation, the FIDO-AC mediator will
use a package-bound hardware-attested key to sign the result
described in Section 5.1. The relying party verifies the signa-
ture and is assured about the honest behavior of the mediator
component.
The zero-knowledge proof system selected to realize the
privacy-preserving functionality is Groth’16 ZK-SNARK
[20], mainly for its efficiency, short proof size, and the avail-
ability of existing implementation, rust-arkwork [12] and lib-
snark [28]. In this case, we chose to use rust-arkwork [12].
One of the additional deciding factors in choosing this library
was the ease of cross compilation between ARM and x86.
In FIDO-AC, we prove statements that use such examples
as building blocks. Unfortunately, Groth’16 ZK-SNARK re-
quires a trusted setup to generate a common reference string
(CRS) for proving and verifying. The FIDO-AC server will
be trusted to host an honestly generated CRS repository. We
do not introduce new trust assumptions here since we already
trust the FIDO-AC server to provide the certified FIDO-AC
mobile application needed to secure the user-side mediator
implementation.
During verification, the verification service checks the cor-
rect FIDO-AC response and whether the mediator’s public key
has a valid hardware-backed key attestation. A valid hardware-
backed key attestation for this scenario requires the presence
of the mediator package name, the mediator package’s cer-
tificate fingerprint, and an attestation challenge that is the
same as the FIDO challenge. Using this challenge, we bound
the mediator’s hardware-backed key to the particular FIDO
session, which is supported thanks to the functionality pro-
vided by the Android API. It is possible to have a more robust
integrity check utilized by PlayIntegrity API [19]. However,
this particular approach is not considered for implementation
because of the reliance on the GooglePlay service that might
not be available for some Android devices.
FIDO-AC Server: One of our main goals in designing the
FIDO-AC systems is to reduce the complexity of the deploy-
ment process. To meet this goal, we particularly focused on
the design of the FIDO-AC Server. We prepared the Server
as an independent element of architecture (i.e., implemented
as a self-contained and stateless docker container). Notably,
the Server is technology agnostic as it publishes a REST
interface over HTTP. The main tasks of the Server are the
following: distribution of the common reference string forthe zero-knowledge proof system, verification of the media-
tor’s attestation, and the zero-knowledge proof created by the
FIDO-AC application.
The ZKP trusted setup parameters generated by the system
must be propagated to all parties using the proof system (i.e.,
prover and verifier). A naive method would be to include
the parameters in the applications (e.g., in the configuration
files). Even though this could work well with our FIDO-AC
mobile application, integration on the verifier side could raise
usability issues as it requires integration with a relying party
(usually out of the FIDO-AC system control). Considering
the learned lessons from the configuration problems of other
complex security protocols (e.g., the TLS configuration issues
reported by Krombholz et al. [27]), we decided to externalize
and automate the parameter configuration process. Therefore,
we modeled the FIDO-AC Server as a centralized repository
for CRS data, which can be conveniently discovered using a
single HTTP call.
The optional functionalities of the FIDO-AC Server are
introduced to minimize the integration efforts. Notably, the
proof verification functionality can be implemented as a local
module (i.e., in the relying party). However, this approach
does not scale well, as the great diversity of technologies used
for commercial applications makes a single implementation
of the verifier impossible. Therefore, we decided to encap-
sulate and extract this functionality to a separate component
(i.e., FIDO-AC Server) which can be either local for the re-
lying party (e.g., deployed next to the application) or hosted
by an external trusted party. Similarly to the trusted setup
functionality, the verifier can be reached by sending a simple
HTTP request. Following our approach, the relying party can
integrate with only marginal changes to its source code (i.e.,
one HTTP call).
FIDO2 Integration: As discussed in Section 5.3, imple-
menting a fully functional FIDO2 extension is significantly
limited. Therefore, the processing of the fidoac extension is
implemented before and after WebAuthn API calls. We use
the relying parties’ challenge to bind the extension data to the
FIDO assertion. Below, we briefly describe the FIDO2 flow
enhanced with fidoac extension. The steps of the process are
depicted in Figure 6.
The flow starts with generating a FIDO assertion request
with a fidoac extension (step 1.). The processing of the fidoac
extension is encapsulated inside fidoac.js , and thus it does
not require any change of the existing FIDO JavaScript code.
To achieve a frictionless integration, fidoac.js overwrites the
original navigator.credentials.get function with a custom im-
plementation (steps 2. and 3.). In consequence, fidoac.js can
preprocess FIDO assertion and forward it to WebAuthn API
(i.e., the original navigator.credentials.get function). The pro-
cessing of the fidoac extension involves communication with
the FIDO-AC service (steps 4. and 5.) using internal (i.e.,
localhost) HTTP calls. The binding between FIDO-AC data
and FIDO transaction is done via appending the SHA-256Figure 6: FIDO-AC extension processing
hash of data to the FIDO assertion challenge (step 6.). The
modified request is passed to WebAuthn API (steps 7-10)
to generate a signed assertion. Notably, our fidoac extension
is not forwarded to the FIDO authenticator due to the web
browser limitations, and thus the only signed modification is
the appended part of the challenge. The response from We-
bAuthn API is again intercepted by fidoac.js and enriched
with fidoac data (inside the clientExtensionResults element).
The final response is sent back to the server (steps 11. and
12.). Because the challenge was modified, the FIDO server
has to execute the same action (i.e., hashing the extension
data and appending it to the challenge) to verify the FIDO2
transaction successfully.
C FIDO2 challenge
The FIDO2 protocol uses challenges to prevent replay attacks.
In the FIDO-AC system, we use this mechanism as a binding
mechanism (see Section 5.3). Even though theoretically (i.e.,
in the WebAuthn specification), the length of the challenge
is not limited, the software implementations might trigger
errors if the challenge is above a certain threshold. We studied
the documentation of various FIDO2 authenticators, and we
could not find any explicit limitations, which suggests that
vendors do not artificially limit the challenge size and, thus,
are compliant with the vast majority of the FIDO Servers.
We empirically tested various authenticators to ensure their
compatibility with the FIDO-AC system. In our test, we ex-
amined both platform and roaming authenticators using the
Chrome browser on mobile. We tested Android and iOS plat-
form authenticators and Yubico 5 roaming authenticators. The
test procedure repeatedly triggers FIDO2 authentication, in-
creasing the challenge size before each run. The evaluation
stops when the threshold of 100Kb for the HTTP message
is reached. We adopted this threshold from one of the HTTP
servers (i.e., expressjs). The results confirm that authenti-cators allow significantly longer challenges. Therefore, we
claim that the majority of commercial authenticators should
support our approach of appending the hash value (256-bits
of SHA-256).
D FIDO Extension Considerations
The WebAuthn API implementations are known not to sup-
port custom extensions, and thus various solutions have been
proposed. We analyzed academic and industry approaches and
identified three ways to mitigate this problem. The intuitive
one is bypassing client limitations by implementing a custom
FIDO client and authenticator. For example, Gou et al. [21]
follow this approach to introduce a QR-based registration flow.
Unfortunately, in our case, replacing popular FIDO clients
and authenticators is not possible because of requirement R.5
and requirement R.6. Okawa et al. [29] presented a solution
closer to our needs, which used relying party code to imple-
ment WebAuthn API. It is a smart way to evaluate custom
FIDO2 solutions. However, it is not suitable for production
deployment. A solution that could be used in the wild is the
one proposed by Putz et al. [31]. The authors solve the exten-
sion issue by implementing a plugin for web browsers (FIDO
clients) that passes the extension content to the authenticator.
Even though this approach solves the limited FIDO clients, it
does not address requirement R.5. For example, in the mobile
use case, browsers limit or forbid extensions, which makes
integration difficult. Additionally, the arbitrary plugin raises
adaptation and scalability challenges (requirements R.5and
R.6) as it needs to be introduced for each user separately.
E Omitted Proofs for Security Analysis
We will now state the security guarantees of FIDO-AC for-
mally. However, first we will recall standard cryptographic
definitions for signature scheme and zero-knowledge proof
systems.
E.1 Signatures and Proof System
Definition 16. A signature scheme σconsists of PPT algo-
rithms (KeyGen ,Sign,Verify )with the following syntax.
KeyGen (λ):This non-deterministic algorithm takes as input
the security parameter λand outputs a pair of verification
and signing keys (vk,sk).
Sign(sk,m):This algorithm takes as input a signing key sk
and a message mand outputs a signature σ.
Verify (vk,m,σ):This deterministic algorithm takes as input
a verification key vk, a message m, and a signature σ
and outputs either 0 or 1.
We define the following properties of a signature scheme.Correctness: For every security parameter λ∈Nand every
message m∈ {0,1}∗, that given (vk,sk)←KeyGen (λ),
σ←Sign(sk,m), it holds that Verify (vk,m,σ) =1.
Existential Unforgeability under Chosen Message Attacks:
Letλ∈Nbe a security parameter. We define the ad-
vantage EUF-CMAA(λ)of an adversary Aagainst
unforgeability under chosen message attack as the
following probability:
Pr
Verify (vk,m∗,σ∗) =1 :(vk,sk)←Setup (sk);
(σ∗,m∗)←ASign(sk,·)

where m∗was not queried to the Sign(sk,·)oracle, and
the probability is taken over the random coins of Setup
and the random coins of A.
Definition 17 (Non-Interactive Argument System) .LetR
be an NP-relation and LRbe the language defined by R.
A non-interactive argument for LRconsists of algorithms
(Setup ,Prove ,Verify )with the following syntax.
ZKSetup (λ):Takes as input a security parameter λ, and out-
puts a common reference string crs.
ZKProve (crs,stmt,wit):Takes as input a common reference
string crs, a statement stmt and a witness wit, and out-
puts either a proof πzkpor⊥.
ZKVer (crs,stmt,πzkp):Takes as input the common refer-
ence string crs, a statement stmt , and a proof πzkp, and
outputs either 0 or 1.
Completeness: For all security parameters λ∈N,
all statements stmt∈LRand all witnesses wit
with R(stmt,wit) = 1,crs←ZKSetup (λ), and
πzkp←ZKProve (crs,stmt,wit), it holds that
ZKVer (crs,stmt,πzkp) =1.
Computational Soundness: We define the advantage
SoundA(1λ)of an adversary Ain breaking the sound-
ness of the proof system as the probability defined
below, where the probability is taken over the random
coins of ZKVer .
Pr
ZKVer (crs,stmt,πzkp) =1 :
crs←ZKSetup (λ);
(πzkp,stmt)←AVerify (crs,·,·)(crs);
stmt /∈LR

Zero-Knowledge: We define the advantage ZKA(λ)of an
adversary Ain breaking the zero-knowledge property of
the proof system as the probability defined below, where
the probability is taken over random coins of ZKProve .
We say that the proof system is zero-knowledge if thereexist simulator algorithms (SIM 1,SIM 2)such that for
all PPT adversaries Athere exists a negligible function
negl(λ)such that ZKA(λ)≤negl(λ).
Pr
A(πzkp∗) =1 :crs←ZKSetup (λ);
(stmt,wit)←A(crs);
R(stmt,wit) =1;
πzkp∗←ZKProve (crs,
stmt,wit)
−
Pr
A(πzkp∗) =1 :(crs,st)←SIM 1(λ);
(stmt,wit)←A(crs);
R(stmt,wit) =1;
πzkp∗←SIM 2(crs,stmt,st)

E.2 Assumptions
Assumption 1 (Data Groups) .LetDG 0andDG 1be the full
data groups specified in [24], which contain personal data
with attributes stored in the data group 1 file EF.DG1 (see
Section 4.7.1.1 in [24]). As per [24][Section 4.7.1.1], in ad-
dition to the respective personal attributes Att0andAtt1, the
data groups 1 in DG 0andDG 1contain additional high en-
tropy data. Thus, we can define alternative versions of DG 0
andDG 1, denoted by DG′
0andDG′
1, with keys ask′
0,ask′
1.
Except for the personal attributes Att0andAtt1, we assume
that those data groups are different and capture this formally
below.
We will denote the advantage AssuA
DG(λ)of an adversary
Ain breaking this assumption as the following probability:
Pr
¯b=b:(Att0,Att1,st)←A(λ);
ask0←IssCred (Att0);
ask1←IssCred (Att1);
b←${0,1};
D:= (pkeID,πPA,ask′
b,H(DG′
b));
¯b←A(st,{(aski,DG i)}i∈{0,1},D)
−1
2,
where the probability is taken over the random choice of A.
We assume this assumption holds if its advantage is negligible
for any PPT adversary A.
The value Dcontains a public key pkeID, and the corre-
sponding secret key ask′
b, which are not bound to personal
attributes. πPAis a signature under H(DG′
b), also not leaking
anything. The only value in Dthat contains personal infor-
mation is H(DG′
b). According to [24], there are no less than
35 data values independent of personal data and only corre-
sponding to the document (elements 03, 05, 12). Each value
can be one of 37 possibilities ([A-Z], [0-9], ’<’), which gives
around 182 random bits. Thus, in the random oracle model,
this assumption is reasonable. Note that we did not count
additional values like the expiration date and checksum.
Assumption 2 (Passive Authentication) .Let us denote by
DG(Att)the data group encoding of attributes Attand by
(skM,pkM)the Mediator keypair. We will denote the advan-
tageAssuA
PA(λ)of an adversary Ain breaking this assumptionas the following probability:
Pr
bPA=1 :(H(DG),pkeID,πPA)←A(λ);
bPA←PAveri f y(H(DG),pkeID,πPA)
,
where the probability is taken over the random choice of A.
We assume this assumption holds if its advantage is negligible
for any PPT adversary A.
Assumption 3 (Liveliness/Chip Authentication) .Let us de-
note by DG(Att)the data group encoding of attributes
Att, by(skM,pkM)the Mediator keypair, and by cmd the
get random nonce command of Terminal Authentication.
We also introduce the oracle IssCred′(·)that takes as in-
putAtt and outputs DG(Att),pkeID,πPA, such that 1←
PAveri f y(H(DG),pkeID,πPA). It also keeps all the output val-
ues in a set Iss. This allows the adversary to create up to
mtokens/users. Additionally, we give the adversary access
to the oracle Med that takes as input index i∈ {1,..., m}
and challenge cmd chaand outputs the Mediator response
where respM←CA(pkM,cmd cha,askTi). The oracle keeps the
queried inputs cmd chaon a list LM. We will denote the advan-
tageAssuA
CA(λ)of an adversary Ain breaking this assumption
as the following probability:
Pr
bCA=1
:(pkeID,st)←AMed(·,·),IssCred′(·)(λ);
keyses←KE(pkeID,skM);
∧cmd cha←AE-ENC(keyses,cmd);
(H(DG),πPA,respM)←A(st,cmd cha);
cmd cha bPA←PAveri f y(H(DG),pkeID,πPA);
̸∈LM bCA←CAVeri f y(respM,keyses)
,
where the probability is taken over the random choice of A.
We assume this assumption holds if its advantage is negligible
for any PPT adversary A.
Both assumptions hold, as shown in the security analysis
of the extended access control protocol [15]. In more detail,
Assumption 2 holds since the signature scheme used to sign
the data groups is unforgeable. Assumption 3 holds since to
create a valid response for the Mediator challenge without the
secret key corresponding to pkeID, one would have to know
the session key between the Chip and the Terminal after the
Chip Authentication protocol. As shown in [15], this holds.
E.3 Impersonation Security
Theorem 1. Let us define the advantage of an adversary Ain
winning the experiment in Definition 10 as:
AdvA
Imp,PAwAM :=Pr[ImpA
PAwAM =1].
Similarly, we denote AdvA
Imp,PLAthe advantage of an adver-
sary in winning the impersonation experiment for a password-
less authentication schemes as defined in [22].
For the FIDO-AC (Figure 2) we have:
AdvA
Imp,PAwAM =AdvA
Imp,PLA.
Informally, FIDO-AC (Figure 2) is secure against imperson-
ation as long as the underlying FIDO scheme is secure against
impersonation and supports extension fields.Proof. Let us assume that an adversary Aexists against the
FIDO-AC scheme presented in Figure 2. Without loss of
generality, we assume that this adversary always set ups the
system so that all tokens can pass the server’s policies. We
can do this since, in the case of impersonation security, the
attributes do not condition the adversary’s winning conditions.
This assumption only maximizes A’s success probability and
simplifies our considerations.
We will now show this theorem by constructing a reduc-
tion algorithm Rthat will use Aas a sub-procedure to break
the impersonation resistance of the underlying passwordless
authentication scheme PLA used as a building block. The
reduction will play the role of the adversary in the PLA imper-
sonation experiment while simultaneously playing the role of
the challenger in the PAwAM impersonation experiment. We
will now describe how the reduction will answer all queries
for the adversary A. The reduction Rworks as follows:
•Setup. During the setup phase, the reduction runs
the setup phase for the PLA scheme and keeps the
attributes and policies specified by Ain lists (PolicyS1,
...,PolicySn):=PolicyLSand(AttT1,...,AttTm):=AttLT.
For each i∈ {1,..., m}the reduction also executes
askTi←IssCred (AttTi), while retaining all the keys. The
reduction also generates the Mediator’s keypair (skM,pkM)
honestly, allowing it to attest to attributes for all tokens.
•Online Phase. During the online phase the reduction
answers all Mediator related oracle queries (i.e., oracles
MedReq ,MedChal ,MedResp ,respM,MedAttest ) accord-
ing to the FIDO-AC protocol. Note that this is possible,
since it knows the secret key skMand the attributes of to-
kens and server policies. Rbehaves a bit differently in case
of the Start ,Challenge andComplete oracles.
–To answer a Start(πi,j
S)query made by Athe reduction
makes the same call to the PLA challenger, receiving
challenge c. It then output the challenge with policy cp:=
(c,PolicySi).
–To answer a Challenge (πi,j
T,idS,cid,M)query made by
the adversary, the reduction makes the same call to the
PLA challenger.
–To answer a Complete (πi,j
S,cid,Rac)query the reduc-
tion first parses Racas(R,ΠAtt)and then calls the
Complete (πi,j
S,cid,R)oracle provided by the PLA chal-
lenger.
•Output Phase. Finally, adversary Aterminates.
Since we assume that Awins the impersonation experi-
ment, there must exist a server handle πi,j
Sthat fulfills all the
conditions for the impersonation experiments. Note that those
conditions are the same as in the case of PLA. It remains
to show that the change of FIDO-AC did not influence the
acheck result in PLA. The only difference is that the mes-
sage Min all calls of the adversary Ato the Challenge oraclecontains the hash value H(ΠAtt)additionally. However, as
assumed, this does not change the output of the acheck al-
gorithm since we assumed that challenges can be extended.
Thus, if Asuccessfully breaks the security against imper-
sonation, then with the same probability, the reduction R
can break the security against impersonation for the PLA
scheme.
E.4 Unlinkability
Theorem 2. Forx∈ {w,m,s}let us define the advantage of
an adversary Ain winning the experiment in Definition 12
as:
AdvA
xUnl,PAwAM :=|Pr[xUnlA
PAwAM =1]−1/2|.
Similarly, we denote by AdvA
xUnl,PLAthe advantage of an ad-
versary in winning the impersonation experiment for a pass-
wordless authentication scheme as defined in [22]. Addition-
ally, qh,qL,qR, respectively, denote the number of random
oracle queries, queries to the Left oracle, and queries to the
Right oracle.
In the random oracle model, for the FIDO-AC (Figure 2), we
have:
AdvA
xUnl,PAwAM ≤+AdvA
xUnl,PLA+(qL+qR)·(qH
2λ+ZKA).
Informally, FIDO-AC (Figure 2) is unlinkable as long as the
underlying FIDO scheme is unlinkable and the proof system
is zero-knowledge.
Proof. We will show this theorem via a series of small
changes we make to experiment, which follows the well-
known hybrid argument technique.
GAME 0The original xUnl PAwAM experiment.
GAME 1Let(SIM 1,SIM 2)be the simulator for the
zero-knowledge experiment of the underlying proof
system. We will now define (qL+qR)sub-games,
where we keep a counter qLRfor the number
of current queries to either Left orRight . In
thei-th sub-game, instead of computing the proof
πzkpasZKProve (crs,(m,PolicyS),(DG,nonce ))for
the i-th query (i.e., when during the experiment
the query counter qLRisi) we use the simu-
latorSIM 2(crs,(m,PolicyS),st), where (crs,st)←
SIM 1(λ).
We increase the adversary’s advantage by ZKA(λ)with
each sub-game change. Since there are (qL+qR)queries,
we have:
|Pr[GAME 1,(qL+qR)(A) =1]−Pr[GAME 0(A) =1]|
≤(qL+qR)·ZKA(λ)GAME 2Letnonce 1,...,nonce qL+qRbe the nonce used to
compute the attestation messages attmin the (qL+qR)
queries to the Left andRight oracles. We abort the exper-
iment in case the adversary makes a query of the form
(·,nonce i), for any i∈ {1,...,(qL+qR)}, to the random
oracle. Since the nonces are picked by the challenger in
the unlinkability experiment, we can upper bound the
probability of aborting by
|Pr[GAME 2(A) =1]−Pr[GAME 1,(qL+qR)(A) =1]|
≤qH·(qL+qR)
2λ
We now argue that the probability of the adversary Awin-
ning the unlinkability experiment in GAME 2is the same as
winning the unlinkability experiment for the underlying pass-
wordless authentication PLA scheme. To this end, we will
construct a reduction Rthat plays the role of the adversary
against the PLA unlinkability experiment and the role of the
challenger in this experiment for the PAwAM scheme. The
reduction Rworks as follows:
•Setup. During the setup phase, the reduction runs
the setup phase for the PLA scheme and keeps the
attributes and policies specified by Ain lists (PolicyS1,
...,PolicySn):=PolicyLSand(AttT1,...,AttTm):=AttLT.
For each i∈ {1,..., m}the reduction also executes
askTi←IssCred (AttTi), while retaining all the keys. The
reduction also generates the Mediator’s keypair (skM,pkM)
honestly, allowing it to attest to attributes for all tokens. It
is worth noting that due to the changes made in GAME 1,
the reduction uses the SIM 1to generate the common
reference string (crs,st)←SIM 1(λ).
•Phase 1. The reduction translates all calls to the Start ,
Challenge , and Complete oracles to oracle calls for the
PLA scheme and vice versa. This includes adding policies
toPLA challenges and discarding the proof ΠAttfrom the
responses to Complete . For more details, see the proof of
Theorem 1. The reduction also honestly executes all the
Mediator related oracles.
•Phase 2. Rchecks the conditions for the instance
submitted by the adversary and submits them to the PLA
challenger.
•Phase 3. The reduction runs the Phase 1 oracles as already
described. In the case of oracles Left,Right , because of
the changes made in GAME 1, it is using the simulator
SIM 2to create πzkp. Other values in ΠAttare generated
as prescribed, except attm, which is picked uniformly at
random. Note that the reduction knows the Mediator keys
to create the attestation honestly.
•Output Phase. The adversary outputs bit ˆb, which is alsothe output of the reduction R.
It remains to show that Pr[GAME 2(A) =1] =AdvR
xUnl,PLA.
First, we notice that the only additional component in
PAwAM that is the output of the Left andRight oracles, is
the attestation ΠAtt= (attm,σm,πzkp). Because for all proofs,
we used SIM 2, the proof πzkpdoes not contain any informa-
tion about bit ˆb. Moreover, in GAME 2, we assume that A
never queries the random oracle with (·,nonce i). It follows
thatattmalso does not give any information about bit ˆb. The
bit¯boutput by the adversary Awill allow the reduction Rto
win the unlinkability experiment for the PLA scheme since
the same conditions apply.
E.5 Attribute Unforgeability
Theorem 3. Let us define the advantage of an adversary Ain
winning the experiment in Definition 11 as:
AdvA
Att-Unf,PAwAM :=Pr[Att-UnfA
PAwAM =1].
Furthermore, let us denote by qMthe number of supported
queries to the MedChal oracle. For the FIDO-AC (Figure 2)
we have:
AdvA
Att-Unf,PAwAM =EUF-CMAA+SoundA
+AssuA
PA+1
qM·AssuA
CA.
Informally, FIDO-AC (Figure 2) is secure against attribute
unforgeability as long as the Mediator’s signature cannot be
forged, the eID protocols are secure, and the proof system
cannot be used to prove false statements.
Proof. We begin the proof with the following observation.
For the server to accept a response, we need the verification
check ac(ΠAtt,p,pkM,c)to output 1. This can only happen in
case the proof πzkpand signature σmare valid, where ΠAtt=
(attm,σm,πzkp).
We will show this theorem via a series of small changes
we make to the experiment, which follows the well-known
hybrid argument technique.
GAME 0The original Att-Unf PAwAM experiment. Let πi,j
Sbe
the server instance that accepted the partnered session
for which there does not exist a corresponding token
πi′,j′
Torπi′,j′
Tdoes not satisfy the policy of server idS.
GAME 1Same as GAME 0, but we abort in case the signa-
tureσmwas never an output of the MedAttest algorithm.
Since the signature scheme used by the Mediator is exis-
tentially unforgeable, it follows that:
|Pr[GAME 1(A) =1]−Pr[GAME 0(A) =1]|
≤EUF-CMAA.
The claim follows easily via a simple reduction to the
unforgeability experiment. Note that the adversary in
the attribute unforgeability experiment is only given theMediator’s public key pkM. Hence, the reduction can use
the public key given by the signature scheme challenger.
The reduction can use the provided signing oracle to
compute σmand answer Mediator oracle queries. The
winning condition for the attribute unforgeability exper-
iment states that the challenge c, which is also part of
attm, is not queried to a request. It follows that attmis
never queried by the reduction to the signature scheme
signing oracle, which ends the claim.
GAME 2Assume that attm:=H(H(DG)||nonce )||cis the at-
testation message that is part of ΠAttwhich is accepted
incheck acas defined above. Moreover, let Attbe the
attributes encoded in DG. The reduction can access DG
since it sees all the random oracle queries. The reduction
aborts in case PolicyS(Att) =0.
We claim that:
|Pr[GAME 2(A) =1]−Pr[GAME 1(A) =1]|
≤SoundA.
To prove the claim, we construct a reduction Rthat
breaks the soundness property of the proof system. The
reduction simulates the whole system honestly. Since
we abort the experiment in case PolicyS(Att) =0, it fol-
lows that πzkpis a proof for a false statement. Thus, by
returning (πzkp,(m,Policys)), where attm= (m||cm), the
reduction will break the soundness property of the proof
system.
With the above changes, the only way for the server ver-
ification check ac(ΠAtt,p,pkM,c)to accept is for ΠAtt=
(attm,σm,πzkp)to include a sound proof πzkp(i.e., for the
data groups in attm, we have that the attributes satisfy the
policy) and a signature σmgenerated by the Mediator. Thus,
the only way for the adversary is to:
•Create valid data groups DGcontaining public key pkeID
andπPA, such that PAveri f y(H(DG),pkeID,πPA) =0, and
where the adversary knows the corresponding secret key
ask. Informally, this captures the case of creating a new eID
with fake data.
•Use existing data groups DG, public key pkeIDandπPA
without knowing the secret key ask, but create a valid respM
to receive the Mediator’s attestation. Informally, this cap-
tures the case of impersonating a valid user by passing the
liveliness test / Chip Authentication step.
With the next game change, we will exclude the first case and
later show that the probability of success in the last case is
negligible. It is worth noting that in both cases the adversary
must query the Mediator oracles to get a valid attestation.
GAME 3The reduction aborts the experiment if amongst the
queries to the MedChal oracle, there exists a request
reqM= (H(DG),pkeID,πPA,c,nonce )for which the at-
tributes Attcorresponding to DGsatisfy Att̸∈AttLTandDGdo not correspond to any honest token (i.e., DG
contains the key pkeID).
We claim that:
|Pr[GAME 3(A) =1]−Pr[GAME 2(A) =1]|
≤AssuA
PA.
The claim follows directly from Assumption 2. We cre-
ate a reduction Rthat will break this assumption. The
reduction simulates the system honestly. Because of the
previous changes, there must be a call to the MedChal or-
acle with input reqM= (H(DG),pkeID,πPA), where DG
does not correspond to any attributes Att̸∈AttLTor
pkeIDis a public key that does not correspond to data
groups for the token with attributes Att. Thus, the reduc-
tion can return (H(DG),pkeID,πPA)and break Assump-
tion 2. Informally, changing personal data ( Att) or the
full data groups (e.g., the public key pkeID) is synony-
mous with creating a fake eID.
Now the only way for the adversary to win is to create a
valid response to the Mediator’s challenge for an existing
token. Informally, for FIDO-AC (Figure 2) this means that
the adversary passed the eID liveliness test for valid attributes
Att∈AttLTfor which Policy (Att) =1. Thus, we will now
show that |Pr[GAME 3(A) =1]≤1
qM·AssuA
CA. We prove this
claim by constructing a reduction Rthat uses adversary A
inGAME 3to break Assumption 3. The reduction simulates
the system honestly, except that it uses the Med,IssCred′or-
acles provided by a challenger in Assumption 3 to answer
queries to the Mediator oracles. The reduction picks one
query to the MedChal oracle (by randomly picking an index i
from{1,..., qM}), and for that query, it proceeds as follows.
It extracts pkeIDfrom reqM= (H(DG),pkeID,πPA,c,nonce )
and submits it to the challenger of Assumption 3. In re-
turn, it receives cmd chaand it creates the challenge to A
aschal M:= (pkM,cmd cha). The reduction then finds the
corresponding response respMamongst the calls to oracle
MedAttest . Because of the winning conditions, the adver-
saryAnever queries the MedResp oracle with chal M. So the
reduction never queries the Med oracle provided by the As-
sumption 3 challenger (i.e., one of the winning conditions is
cmd cha̸∈LM). Note that this only happens if the reduction
chooses the correct index i, which happens with probabil-
ity1
qM. However, if that happens, the reduction can return
(H(DG),πPA,respM)and break Assumption 3. With this, we
proved the claim and the theorem.
E.6 Origin Privacy
Theorem 4. Let us define the advantage of an adversary Ain
winning the experiment in Definition 13 as:
AdvA
Orig -Priv,PAwAM :=|Pr[Orig -PrivA
PAwAM =1]−1/2|.
For the FIDO-AC (Figure 2) we have:
AdvA
Orig -Priv,PAwAM =0.Informally, FIDO-AC (Figure 2) provides perfect origin pri-
vacy without relying on any assumptions.
Proof. The only information that depends on the bit bthat
is provided to an adversary Aagainst origin privacy is the
request
reqM,b= (H(DG),pkeID,πPA,c,nonce ), and
response
respM,b←CA(pkM,cmd cha,askT).
The response respM,bis independent of any output of the
server, which only generates the challenge c. Thus, only the
request reqMdepends on an output created by server Sb. How-
ever, since cis a unique challenge (i.e., a uniformly random
string of bits), it follows that it does not leak any information
about bit b.
E.7 One-time Attribute Privacy
Theorem 5. Let us define the advantage of an adversary Ain
winning the experiment in Definition 14 as:
AdvA
Att-Priv ,PAwAM :=|Pr[Att-PrivA
PAwAM =1]−1/2|.
Let denote by mthe number of tokens in the system. For the
FIDO-AC (Figure 2) we have:
AdvA
Att-Priv ,PAwAM =m2
2·AssuA
DG.
Informally, FIDO-AC (Figure 2) provides one-time attribute
privacy as long as the hashes of data groups of different docu-
ments but for the same personal data are indistinguishable.
Proof. We will prove the theorem by constructing a reduction
Rusing an adversary Aagainst the one-time attribute privacy
experiment to break Assumption 1.
•Setup. During the setup phase, the reduction runs
the setup phase for the PLA scheme and keeps the
attributes and policies specified by Ain lists (PolicyS1,
...,PolicySn):=PolicyLSand(AttT1,...,AttTm):=AttLT.
It then picks two distinct indexes j0,j1←${1,..., m}
and for each i∈ {1,..., m} \ { j0,j1}the reduction
also executes askTi←IssCred (AttTi), while retaining
all the keys. The reduction now sends (AttT0,AttT1)
to the challenger of Assumption 1, receiving back
(ask j0,DG j0),(ask j1,DG j1),(pkeID,πPA,ask′
b,H(DG′
b))).
•Phase 1. The reduction honestly answers all the queries. It
is worth noting that it possesses all the required information,
including the attribute secret keys ask j0,ask j1and data
groups DG j0,DG j1for the tokens j0andj1.
•Challenge Phase 1. The adversary Aoutputs two token
identifiers T0,T1and server identifier S. The reduction
aborts in case it did not guess the correct tokens. The
reduction proceeds if T0=Tj0,T1=Tj1orT0=Tj1,
T1=Tj0. We will show the reduction for the first case,
while the second only increases the reduction of notaborting by 2. In other words, the probability that the
reduction aborts is smaller than 2 ·1
m2.
•Challenge Phase 2. The reduction does not refresh the
keys but will use (ask′
b,H(DG′
b))in the next phase instead.
•Challenge Phase 3. First, the reduction runs (c,·)←
achall ac(idS)and samples a random nonce nonce←${0,1}λ.
It then sets reqM,b:= (H(DG′
b),pkeID,πPA,c,nonce )and
sends it to the adversary that responds with chal M,b. The
reduction parses the challenge as (pkM,cmd cha)and
executes respM,b←CA(pkM,cmd cha,ask′
b).
•Output Phase. Finally, the adversary outputs ¯b, which is
also the output of the reduction R.
It is easy to see that if adversary Awins the one-time at-
tribute privacy experiment, then the reduction Rwill break
Assumption 1. Thus, this ends the proof.
Optimal Hadamard gate count for Clifford+ Tsynthesis of
Pauli rotations sequences
Vivien Vandaele1,2, Simon Martiel1, Simon Perdrix2, and Christophe Vuillot2
1Atos Quantum Lab, Les Clayes-sous-Bois, France
2Universit´ e de Lorraine, CNRS, Inria, LORIA, F-54000 Nancy, France
Abstract
The Clifford+ Tgate set is commonly used to perform universal quantum computation. In
such setup the Tgate is typically much more expensive to implement in a fault-tolerant way
than Clifford gates. To improve the feasibility of fault-tolerant quantum computing it is then
crucial to minimize the number of Tgates. Many algorithms, yielding effective results, have been
designed to address this problem. It has been demonstrated that performing a pre-processing
step consisting of reducing the number of Hadamard gates in the circuit can help to exploit the
full potential of these algorithms and thereby lead to a substantial T-count reduction. Moreover,
minimizing the number of Hadamard gates also restrains the number of additional qubits and
operations resulting from the gadgetization of Hadamard gates, a procedure used by some
compilers to further reduce the number of Tgates. In this work we tackle the Hadamard gate
reduction problem, and propose an algorithm for synthesizing a sequence of π/4 Pauli rotations
with a minimal number of Hadamard gates. Based on this result, we present an algorithm which
optimally minimizes the number of Hadamard gates lying between the first and the last Tgate
of the circuit.
1 Introduction
Fault-tolerant quantum computing enables reliable and large-scale quantum computation at the
cost of an important resource overhead when compared to an error-free model. Much work has
been put into quantum circuit optimization in order to reduce this additional cost and make fault-
tolerant quantum computing more practical and scalable. In particular, numerous algorithms have
been designed to minimize the number of Tgates in a quantum circuit [1–12]. This focus on T-count
minimization is primarily due to the sizable amount of resources, in terms of time and number of
qubits, generally required by fault-tolerance protocols, such as magic state distillation [13], to im-
plement the Tgate. In contrast, Clifford operations can typically be implemented at little expense
in most common quantum error correcting codes via transversal operations, code deformation [14]
or lattice surgery [15]. In such context, and considering the fact that the Clifford+ Tgate set is
approximatively universal, the T-count stands out as a key metric to minimize in order to make
fault-tolerant quantum computing more efficient. Moreover, minimizing the T-count is also cru-
cial in the field of quantum circuits simulation as many simulators have a runtime that scales
exponentially with respect to the number of Tgates [16–20].
The problem of finding the optimal number of Tgates in a {CNOT , S, T}circuit composed of
nqubits has been well formalized for {CNOT , S, T}circuits by demonstrating its equivalence with
the problem of finding a maximum likelihood decoder for the punctured Reed-Muller code of order
1arXiv:2302.07040v3  [quant-ph]  24 Feb 2024n−4 and length 2n−1 [4], which is tantamount to the third order symmetric tensor rank decompo-
sition problem [21]. In order to make use of this formalism in Clifford+ Tcircuits it is necessary to
circumvent the Hadamard gates in some way; this can be achieved by applying one of the two fol-
lowing strategies. The first method consists of extracting {CNOT , S, T}subcircuits and interposing
them with layers of Hadamard gates [1]. Then an independent and Hadamard-free instance of the
T-count minimization problem can be formulated for each {CNOT , S, T}subcircuit extracted. The
second strategy involves a measurement-based gadget which can substitute a Hadamard gate. This
Hadamard gadgetization procedure requires the following additional resources for each Hadamard
gate gadgetized: an ancilla qubit, a CZ gate and a measurement [22].
The number Tgates in a circuit containing hHadamard gates can be upper bounded by O(n2h)
orO((n+h)2) in the case where all Hadamard gates are gadgetized [4]. Hence, each Hadamard
gate that must be circumvented, regardless of the strategy applied, for a lack of a good Hadamard
gate optimization procedure is potentially the cause of missed opportunities for further Tgate
reduction. Therefore, a preliminary procedure consisting in reducing the number of Hadamard
gates can result in an important T-count reduction, as demonstrated in Reference [3]. It has
been shown that circumventing all Hadamard gates using the Hadamard gadgetization procedure
is the strategy that leads to the best reduction in the number of Tgates [6]. However, the main
drawback of this method is the use of one additional qubit for each Hadamard gate gadgetized.
This is obviously an inconvenience if the number of qubits at disposal is limited, but can also be
detrimental to the optimization process in two ways. Firstly, as suggested in Reference [10], it may
become more difficult to find opportunities to reduce the T-count as the ratio between the number
of qubits and the number of Tgates increases. In addition, the runtime of a T-count optimizer can
drastically increase as the number of qubits grows. For all these reasons it is important to minimize
the number of auxiliary qubits needed, which further motivates investigations into a pre-processing
step optimizing the number Hadamard gates in the initial circuit.
We can mainly distinguish two strategies for the optimization of quantum circuits. The first one
is referred to as pattern matching and involves the detection of patterns of gates within the circuit
to then substitute them by an equivalent, but nonetheless different, sequence of gates. A series of
transformation is therefore applied to the circuit, but its semantic is preserved at each step of the
process. This method has already been applied to the optimization of Hadamard gates by using
rewriting rules that preserve or reduce the number of Hadamard gates within the circuit [3, 10].
The second method is circuit re-synthesis which consists in extracting some parts of the circuit,
representing them by higher level constructs and performing their synthesis to obtain an equivalent
circuit. This method has not yet been considered for the optimization of Hadamard gates, despite
displaying excellent performances for other optimization problems such as Tgate reduction [6,8].
In the case of circuit re-synthesis, a commonly used fact is that the operation performed by
a given Clifford+ Tcircuit can be represented by a sequence of π/4 Pauli rotations followed by
a final Clifford operator [2]. A strategy for optimizing the number of Hadamard gates could
then consist of synthesizing this sequence of π/4 Pauli rotations using as few Hadamard gates
as possible. In Section 3, we present an algorithm that solves this problem optimally. With the
Hadamard gadgetization approach, a Hadamard gate needs to be gadgetized only if it comes after
and precedes a Tgate in the circuit, we say that such Hadamard gates are internal Hadamard
gates. This leads to a more specific Hadamard gate reduction problem consisting in reducing the
number of internal Hadamard gates within the circuit. We tackle this problem in Section 4 by
proposing an algorithm that synthesizes a sequence of Pauli rotations with a minimal number of
internal Hadamard gates. Section 5 presents alternative versions of our algorithms with lower
complexities. Benchmarks are then given in Section 6 to evaluate the performances and scalability
of our algorithms on a library of reversible logic circuits and on large-scale quantum circuits. Our
2algorithms are not working exclusively for the Clifford+ Tgate set but can also be executed on any
circuit composed of {X,CNOT , S, H, R Z}gates.
2 Preliminaries
2.1 Pauli rotations sequences
The four Pauli matrices are defined as follows:
I=1 0
0 1
, X =0 1
1 0
, Y =0−i
i0
, Z =1 0
0−1
.
Two Pauli matrices commute if they are equal or if one of them is the identity matrix I, otherwise
they anticommute. All tensor products of nPauli matrices, together with an overall phase of ±1 or
±i, generate the Pauli group Pn. We define the subset P∗
n⊂ P nas the set of Pauli operators which
have an overall phase of ±1. We will use Pito denote the ith Pauli matrix of a Pauli operator P, for
instance if P=Z⊗Xthen P1=ZandP2=X. We say that a Pauli operator Pis diagonal if and
only if Pi∈ {I, Z}for all i. Two Pauli operators PandP′commute if there is an even number of
indices isuch that Pianticommutes with P′
i, otherwise they anticommute. Given a Pauli operator
P∈ P∗
nand an angle θ∈R, a Pauli rotation RP(θ) is defined as follows:
RP(θ) = exp( −iθP/2) = cos( θ/2)I−isin(θ/2)P.
For example the Tgate is defined as a π/4 Pauli Zrotation:
T=RZ(π/4)
Clifford gates can also be represented in terms of Pauli rotations, we will mostly make use of the
CNOT, SandHgates defined as follows:
CNOT = RZX(π/2)RZI(−π/2)RIX(−π/2),
S=RZ(π/2),
H=RZ(π/2)RX(π/2)RZ(π/2).
The Clifford group Cnis defined as the set of unitaries stabilizing Pn:
Cn={U|U†PU∈ Pn,∀P∈ Pn}.
and is generated by the {CNOT , S, H}gate set. Note that for each pair of Pauli operators P, P′∈
Pn\ {I⊗n}there exists a Clifford operator U∈ C nsuch that P′=U†PU. Unless indicated
otherwise, the term Clifford circuit will refer to a circuit exclusively composed of gates from the
set{X,CNOT , S, H}, the use of other Clifford gate set is discussed at the end of Section 3.2.
A Pauli operator P∈ P∗
ncan be encoded using 2 n+ 1 bits: 2 nbits for the nPauli matrices
and 1 bit for the sign [23]. In the following we will encode a Pauli operator P∈ P∗
nwith 2 nbits
and neglect its sign as it has no impact on the formulation of our problem; we will use the term
Pauli product to designate a Pauli operator deprived of its sign. Let S=Z
X
be a block matrix
of size 2 n×mrepresenting a sequence of mPauli products acting on nqubits such that Zis the
submatrix of Sformed by its first nrows and Xis the submatrix of Sformed by its last nrows.
The value ( Zi,j,Xi,j) represents the ith component of the jth Pauli product encoded by S, such
3Zi
Zj
Xi
Xj⊕
⊕(a) CNOT i,j
Zi
Xi⊕ (b)Si
Zi
Xi (c)Hi
Figure 1: Operations on a sequence of Pauli products S=Z
X
corresponding to the conjugation
of all its Pauli products by a Clifford gate. For the CNOT i,jgate where iis the control qubit and
jis the target qubit (a), the ZjandXirows are added to the ZiandXjrows respectively. For a
Sgate applied on qubit i(b), the Xirow is added to the Zirow. For a Hgate applied on qubit
i(c), the ZiandXirows are swapped.
that the values (0 ,0),(0,1),(1,1) and (1 ,0) are corresponding to the Pauli matrices I, X, Y and
Zrespectively. We use the notation S:,ito refer to the column iof the matrix S, we will denote
P(S:,i) the Pauli product encoded by S:,i, and we will say that S:,iis diagonal if and only if P(S:,i)
is diagonal and that S:,iandS:,jcommute (or anticommute) if their associated Pauli products
P(S:,i) and P(S:,j) commute (or anticommute). Throughout the document we use the zero-based
indexing for vectors and matrices and the initial element is termed the zeroth element, for instance
the zeroth column of SisS:,0. If all Pauli products encoded by Sare conjugated by a Clifford gate
U∈ {CNOT , S, H}, then Scan be updated to encode the Pauli products U†P(S:,i)U, for all i, via
the operations depicted in Figure 1. These operations are analogous to the operations performed in
the tableau representation [23]. We will say that ˜S=U†SUif and only if P(˜S:,i) =±U†P(S:,i)U
for all iand for some Clifford operator U.
Any Clifford+ RZcircuit can be represented up to a global phase by a sequence of Pauli rotations
followed by a final Clifford operator [2]. The synthesis of a Pauli rotation is then a key procedure
for constructing an equivalent Clifford+ RZcircuit from this representation. Let Ube a Clifford
operator such that
U†RP(θ)U=RU†PU(θ) =RZi(θ) (1)
for some qubit iand some Pauli operator P∈ P∗
n. Then the synthesis of the Pauli rotation RP(θ)
can be performed by implementing U,U†and inserting a RZ(θ) gate in between on qubit i. IfPis
diagonal then the Clifford operator Usatisfying Equation 1 can be implemented using only CNOT
andXgates. Otherwise, if Pis not diagonal, at least one Hadamard gate is required to implement
Uover the {X,CNOT , S, H}gate set such that
U†RP(θ)U=RP′(θ) (2)
where P′is diagonal. Note that the gate set considered is not minimal as the Xgate can be
generated from the SandHgates. As our cost model is the number of Hadamard gates we include
theXgate so that no Hgates are required to implement it. The Xgate finds its purpose in the
case where
U†RP(θ)U=RU†PU(θ) =RZi(−θ) (3)
4by allowing the implementation of the RZ(−θ) gate using the RZ(θ) gate via the equality
RZ(−θ) =XRZ(θ)X. (4)
Nonetheless, in the case where θ=π/4, the minimal {CNOT , S, H}gate set can be used since the
negative sign can be compensated by inserting three Sgates as
URZi(7π/4)U†=URZi(−π/4)U†=RUZiU†(−π/4) = RP(π/4). (5)
2.2 Diagonalization network
The synthesis of a sequence of Pauli rotations using the Clifford+ RZgate set implies the con-
struction of a diagonalization network, derived from the notion of parity network established in
Reference [24] and which is defined as follows.
Definition 1 (Diagonalization network) .A Clifford circuit Cis a diagonalization network for a
sequence SofmPauli products if and only if there exists mnon-negative integers α0≤. . .≤αm−1
such that U†
iP(S:,i)Uiis diagonal, where Uiis the Clifford operator implemented by the first αigates
ofC.
A sequence of mPauli rotations can be represented by a triple ( S,b,θ), where Sencodes a
sequence of mPauli products, b∈ {− 1,1}mandθ∈Rmsuch that biandθicorrespond to the
sign and angle associated with the Pauli product P(S:,i). Let Cbe a diagonalization network for
S, then the sequence of Pauli rotations represented by ( S,b,θ) can be easily implemented from C
up to a final Clifford circuit by inserting m{X,CNOT , RZ}subcircuits into C. Indeed, as stated
previously, if a Pauli product Pis diagonal then the Clifford operator Vsatisfying
V†RP(θ)V=RV†PV(θ) =RZj(θ) (6)
for some qubit j, can be implemented using only CNOT and Xgates. And because Cis a diago-
nalization network for Sthen by definition there exists mnon-negative integers α0≤. . .≤αm−1
such that U†
iP(S:,i)Uiis diagonal, where Uiis the Clifford operator implemented by the first αi
gates of C. It follows that inserting, for all iand just after the αith gate of C, a{CNOT , X}
implementation of the Clifford operators ViandV†
iwith the RZj(biθi) gate in between, such that
Visatisfies
V†
iU†
iP(S:,i)UiVi=RZj(biθi) (7)
for some qubit j, will result in an implementation of the sequence of Pauli rotations defined by
(S,b,θ) up to a final Clifford circuit.
The circuit obtained by this procedure obviously contains the same number of Hadamard gates
asCas no additional Hadamard gate was inserted. Thus, synthesizing a sequence of Pauli rotations
represented by ( S,b,θ) with a minimal number of Hadamard gates up to a final Clifford operator is
equivalent to the problem of constructing a diagonalization network for Susing a minimal number
of Hadamard gates. This approach can easily be extended to take into account the final Clifford
operator, as explained in Section 3.3. We define h(C) as being the number of Hadamard gates
in a Clifford circuit C, and we extend the notation for a sequence of Pauli products Ssuch that
h(S) = min {h(C)|Cis a diagonalization network for S}. The problem of synthesizing a sequence
of Pauli rotations ignoring the final Clifford operator with a minimal number of Hadamard gates
can then be defined as follows.
Problem 1 (H-Opt) .Given a sequence Sof Pauli products, find a Clifford circuit Cthat is a
diagonalization network for Sand such that h(C) =h(S).
5In Clifford+ Tcircuits, the Hadamard gadgetization procedure aims to transform the circuit
in order to obtain an Hadamard-free subcircuit containing all the Tgates. Hence, a Hadamard
gate does not need to be gadgetized if there is no Tgate preceding it. To take this particularity
into consideration we define the following problem relating to the synthesis of a sequence of Pauli
rotations up to a final Clifford circuit with a minimal number of internal Hadamard gates.
Problem 2 (Internal-H-Opt) .Given a sequence Sof Pauli products, find a Clifford circuit C=
C1::C2, i.e. Cis the circuit resulting from the concatenation of C1andC2, such that h(C2)is
minimized and C2is a diagonalization network for ˜S=U†SUwhere Uis the Clifford operator
associated with C1.
In Section 3.1 we propose a diagonalization network synthesis algorithm to solve the H-Opt
problem. We prove its optimality in Section 3.2, and it is then employed in Section 4 to design an
algorithm solving the Internal-H-Opt problem.
3 Hadamard gates minimization
3.1 Diagonalization network synthesis algorithm
We first describe a simple procedure, of fundamental importance in our diagonalization network
synthesis algorithm, to construct a Clifford operator Usuch that U†PUis diagonal, where Pis
a non-diagonal Pauli product. Let ibe such that Pi∈ {X, Y}, which necessarily exists as Pis
non-diagonal. If there exists j̸=isuch that Pj∈ {X, Y}, then, based on the operation depicted
in Figure 1(a), we can deduce that the Pauli product P′resulting from the conjugation of P
by the CNOT i,jgate satisfies P′
i∈ {X, Y},P′
j∈ {I, Z}andP′
k=Pkfor all k̸∈ {i, j}. More
generally, if P′=U†PUwhere Uis the Clifford operator associated with the fan-out formed by
the gates {CNOT i,j|Pj∈ {X, Y},∀j̸=i}, then P′
jis diagonal for all j̸=i. To complete the
diagonalization of P′we then just have to make P′
idiagonal while preserving this property. If
P′
i=Ythen conjugating P′by a Sgate on qubit imaps P′
itoX. And in the case where P′
i=X,
then conjugating P′by a Hgate on qubit imaps P′
itoZ, and our diagonalization procedure is
complete as the SiandHioperations do not affect P′
jwhere j̸=i.
Consider the diagonalization network synthesis algorithm whose pseudo-code is given in Algo-
rithm 1 and which takes a sequence SofmPauli products as input. The algorithm constructs
a Clifford circuit Citeratively by processing the Pauli products constituting Sin order. When
a Pauli product P=P(S:,i) is being processed, if U†PU, where U∈ Cnis the Clifford operator
implemented by C, is diagonal then the algorithm moves on to the next Pauli product. Otherwise,
ifU†PUis not diagonal, a sequence of gates, constructed using the procedure described above, are
appended to Cso that the updated Pauli product U†PUis diagonal. Thus, Algorithm 1 outputs
a Clifford circuit that is a diagonalization network for S. A detailed execution example of Algo-
rithm 1 is provided in Appendix A.
Complexity analysis. At each iteration the algorithm carries out at most O(n) row operations
onSwhere nis the number of qubits, miterations are performed and Shasmcolumns, therefore
the complexity of Algorithm 1 is O(nm2).
In the typical case where n < m , a faster version of Algorithm 1 can be implemented using the
tableau representation [23]. Let Tbe a tableau initialized at the begining of the algorithm. Instead
of updating Sfor each Clifford gate appended to the circuit C, we can use Tto keep track of the
Clifford operator Uimplemented by C. For each Clifford gate appended to C,Tcan be updated
6Algorithm 1: Diagonalization network synthesis with a minimal number of Hgates
Input: A sequence S=Z
X
ofmPauli products.
Output: A diagonalization network for Swith a minimal number of Hgates.
1procedure DiagonalizationNetworkSynthesis( S)
2 C←new empty circuit
3 ifSis empty then
4 return C
5 end
6 if∃isuch that Xi,0= 1then
7 foreach j∈ {j| Xj,0= 1} \ {i}do
8 C←C:: CNOT i,j
9 S ← CNOT i,jSCNOT i,j
10 end
11 ifZi,0= 1then
12 C←C::Si
13 S ← SiSSi
14 end
15 C←C::Hi
16 S ← HiSHi
17 end
18 S ← S with its first column removed
19 return C::DiagonalizationNetworkSynthesis (S)
inO(n) [23]. Then, the algorithm proceeds in the same way as Algorithm 1 by sequentially diag-
onalizing the Pauli products represented by S. However, the ith Pauli product to diagonalized is
notP(S:,i) but U†P(S:,i)U, which can be computed in O(n2) using the tableau T. This operation
must be performed O(m) times and Tmust be updated O(nm) times as the number of gates in the
final Clifford circuit is O(nm), therefore the overall time complexity of this algorithm is O(n2m).
More details on this approach are given in Section 5, where this algorithm is adapated to take a
Clifford+ RZcircuit as input instead of a sequence of Pauli products.
Hadamard gate count. In order to evaluate h(C), where Cis the output circuit of Algorithm 1,
we will rely on the following definition.
Definition 2 (Commutativity matrix) .LetSbe a sequence of mPauli products. The commuta-
tivity matrix A(S)associated with Sis a strictly upper triangular Boolean matrix of size m×m
such that for all i < j :
A(S)
i,j=(
0ifS:,icommutes with S:,j,
1ifS:,ianticommutes with S:,j.
For convenience we will drop the superscript ( S) from Awhen it is clear from the context that
Ais associated with S. The commutativity matrix A(S)can also be seen as the adjacency matrix
of a directed acyclic graph, which has already been studied and linked to the T-depth optimization
problem [8]. In this work, we further reinforce the interest in this structure by establishing a relation
between the H-Opt and Internal-H-Opt problems and the rank of A(S). Note that if ˜S=U†SU,
7where Uis some Clifford operator, then A(˜S)=A(S)because if two Pauli products PandP′are
commuting (or anticommuting) then U†PUandU†P′Uare commuting (or anticommuting).
The number of Hadamard gates in the circuit produced by Algorithm 1 can be characterized
via the following theorem.
Theorem 1. LetS=Z
X
be a sequence of mPauli products, Abe its commutativity matrix and
Cbe the Clifford circuit returned by Algorithm 1 when Sis given as input. Then h(C) = rank( M)
where M=X
A
.
Proof. LetS(i)=Z(i)
X(i)
be the sequence of Pauli products given as input to the ith recursive
call of Algorithm 1 with S(0)=S, and let M(i)=X(i)
A(i)
where A(i)is the commutativity matrix
associated with S(i). We first start by analyzing how M(i)evolves to M(i+1)whenS(i)
:,0is diagonal.
In such case, we can obtain M(i+1)from M(i)by removing the first column of M(i)and the first
row of its submatrix A(i). Let P=P(S(i)
:,0), then, because Pis diagonal, the following equation
holds: M
k∈KX(i)
k=M
k∈KM(i)
k=A(i)
0 (8)
where K={k| Z(i)
k,0= 1}. Indeed, as Pis diagonal we necessarily have Pk=Zfor some k, and
in the case where Pj=Ifor all j̸=kwe have X(i)
k,j= 1 if and only if S(i)
:,0anticommutes with
S(i)
:,j, and so X(i)
k=A(i)
0. In a more general case, if there exists j̸=ksatisfying Pj=Zthen we
can apply a CNOT j,kgate for all such jin order to fall back on our previous case, which implies
Equation 8. Consequently, removing the first row of the submatrix A(i)will not change the rank of
M(i). Moreover, due to the fact that S(i)
:,0is diagonal, the first column of M(i)is equal to the null
vector. Therefore we have rank( M(i+1)) = rank( M(i)) when S(i)
:,0is diagonal.
In the case where S(i)
:,0is not diagonal, Algorithm 1 will apply a sequence of CNOT and S
gates followed by a single Hgate. Let ˜S(i)=˜Z(i)
˜X(i)
be the sequence of Pauli products obtained by
conjugating all Pauli products of S(i)by this sequence of CNOT and Sgates, and let ˜M(i)=˜X(i)
A(i)
.
Note that we have rank( ˜M(i)) = rank( M(i)) as applying a Sor CNOT operation on S(i)does not
change the rank of X(i). Let jbe the qubit on which the Hadamard gate is applied, we must have
˜M(i)
j,0= 1 and ˜M(i)
k,0= 0 for all k̸=j, which implies that ˜M(i)
jis independent from all the other
rows of ˜M(i). Let ˆM(i)=ˆX(i)
A(i)
where ˆS(i)=ˆZ(i)
ˆX(i)
is obtained by conjugating all Pauli products
of˜S(i)by a Hadamard gate on qubit j, and notice that ˆM(i)
k=˜M(i)
kfor all k̸=j. Analogously to
Equation 8, since ˆS(i)
:,0is diagonal, the following equation holds:
M
k∈ˆKˆX(i)
k=M
k∈ˆKˆM(i)
k=A(i)
0 (9)
8where ˆK={k|ˆZ(i)
k,0= 1}. Furthermore, as j∈ˆK,ˆM(i)
jcan be expressed as follows:
ˆM(i)
j=M
k∈ˆK\{j}ˆM(i)
k⊕A(i)
0=M
k∈˜K˜M(i)
k⊕A(i)
0 (10)
where ˜K={k|˜Z(i)
k,0= 1}=ˆK\{j}. It follows that ˆM(i)
jis a linear combination of the rows of ˜M(i)
whereas ˜M(i)
jis an independent row, and so rank( ˆM(i)) = rank( ˜M(i))−1. After the Hadamard
gate has been applied we end up in the same case as when S(i)
:,0is diagonal, therefore we have
rank( M(i+1)) = rank( ˆM(i)) = rank( M(i))−1.
We demonstrated that rank( M(i+1)) = rank( M(i)) when no Hadamard gate is applied at the
ith recursive call, and that rank( M(i+1)) = rank( M(i))−1 if one Hadamard gate is applied. Thus,
the number of Hadamard gates in the Clifford circuit Cis equal to rank( M)−rank( M(m)) where
mis the number of Pauli products in S. The sequence of Pauli products S(m)is empty, hence
rank( M(m)) = 0 and h(C) = rank( M).
3.2 Optimality
In this section we demonstrate the optimality of Algorithm 1 by proving the following theorem.
Theorem 2. LetS=Z
X
be a sequence of mPauli products, Abe its commutativity matrix and
Cbe a Clifford circuit that optimally solves the H-Opt problem for S. Then h(C) = rank( M)where
M=X
A
.
Our proof of Theorem 2 rests on the following proposition, which puts an upper bound on the
number of Hadamard gates required to simultaneously diagonalize a set of mutually commuting
Pauli products.
Proposition 1. LetS=Z
X
be a sequence of mmutually commuting Pauli products of size nand
letU∈ Cnbe a Clifford operator such that U†P(S:,i)Uis diagonal for all i. Then h(C)≥rank(X),
where Cis a Clifford circuit implementing U.
Proof. LetS(i)be the state of Sresulting from conjugating all its Pauli products by the Clifford
operator implemented by the first igates of C. If the ( i+1)th gate of Cis a CNOT or Sgate, then
rank(X(i+1)) = rank( X(i)). Else, if the ( i+ 1)th gate of Cis a Hadamard gate, then X(i+1)and
X(i)have at least n−1 rows in common and 1 ≥ |rank(X(i))−rank(X(i+1))| ≥0. Therefore, the
number of Hadamard gates in Cis at least |rank(X)−rank(X(k))|, where kis the number of gates
inC. The circuit Cperforms a simultaneous diagonalization of the Pauli products constituting S,
which implies that rank( X(k)) = 0, hence h(C)≥ |rank(X)−rank(X(k))|= rank( X).
In the following we use S:,:jto denote the submatrix formed by the first jcolumns of S.
Theorem 1 implies an upper bound on the number of Hadamard gates required to solve the H-
Opt problem. There always exists a Clifford circuit Cthat is a diagonalization network for a
sequence of Pauli products S=Z
X
such that rank( M)≥h(C) where M=X
A
andAis the
9commutativity matrix associated with S. In order to prove Theorem 2 it remains to show that if
Cis a diagonalization network for Sthen h(C)≥rank( M). To do so, we will show that we can
derive a Clifford circuit C′from Csuch that C′is satisfying h(C′) =h(C) and is a solution to a
specific instance S′of the simultaneous diagonalization problem, where S′=0
M′
is a sequence
of mutually commuting Pauli products satisfying rank( M′)≥rank( M). By Proposition 1 we then
would have h(C) =h(C′)≥rank( M′)≥rank( M). We first give a construction for M′and prove
that rank( M′)≥rank( M) via the following proposition.
Proposition 2. LetCbe a diagonalization network for a sequence S=Z
X
ofmPauli products
of size n, and let C(i)be the subcircuit of Ctruncated after its ith Hadamard gate. And let the
matrices S(i)=Z(i)
X(i)
be such that S(0)=Sand in the case where i >0:
S(i)
:,j=0 ifC(i−1)is a diagonalization network for S:,:j,
P(S(i)
:,j) =±U†
(i)P(S:,j)U(i) otherwise ,
where U(i)∈ Cnis the Clifford operator associated with C(i). Consider the matrices M=X
A
and
M′=X
A′
where Ais the commutativity matrix associated with S, and A′is a matrix composed
ofh(C)rows such that A′
i−1=X(i)
jwhere jis the qubit on which the ith Hadamard gate of Cis
applied. Then we have rank( M′)≥rank( M).
Proof. We will prove Proposition 2 by showing that the rows of Mare in the span of the set formed
by the rows of the X(i)matrices, which are themselves in the row space of the matrix M′. We first
show that the rows of X(i)are in the span of the set formed by the first n+irows of M′. For i= 0,
this assertion is obviously true as we have Xj=M′
jfor all 0 ≤j < n . Let ˜S(i)=˜Z(i)
˜X(i)
=U†S(i)U,
where Uis the Clifford operator implemented by the {CNOT , S}subcircuit comprised between
theith and ( i+ 1)th Hadamard gate of C. Note that performing a CNOT or Soperation on
S(i)doesn’t change the row space of X(i), therefore the rows of ˜X(i)are in the row space of X(i).
Letαbe a vector of size msuch that αjis the smallest non-negative integer for which C(αj)is a
diagonalization network for S:,:jand let kbe the qubit on which the ( i+ 1)th Hadamard gate of C
is applied. We can then distinguish 3 cases for the value of αj, where 0 ≤j < m :
•αj< i, then S(i+1)
:,j=˜S(i)
:,j=0for all j, because if C(i−1)is a diagonalization network for S:,:j
then C(i)is also a diagonalization network for S:,:j;
•αj=i, then S(i+1)
:,j=0and ˜S(i)
:,jis diagonal, therefore X(i+1)
:,j =˜X(i)
:,j=0;
•αj> ithen ˜S(i)
:,jencodes the same Pauli product as S(i+1)
:,j up to a Hadamard operation on
qubit k, therefore X(i+1)
ℓ,j=˜X(i)
ℓ,jfor all ℓ̸=k.
To sum up we have X(i+1)
j =˜X(i)
jfor all j̸=kand by definition we have X(i+1)
k=M′
n+i+1. It
follows that the rows of X(i+1)are in the span of the set formed by the first n+i+ 1 rows of M′.
10S H H S
H
(a) Circuit Cthat is a diagonalization network for S
where S:,0is diagonalized by the first 3 gates, S:,1by
the first 5 gates and S:,2by the whole circuit.H H
H
(b) Circuit C′derived from C.
S=Z
X
=
1 0 0
1 1 0
1 0 1
0 1 0
, A(S)=
0 1 1
0 0 0
0 0 0

(c) Initial sequence of Pauli products and its
commutativity matrix.S′=0
M′
=
0 0 0
1 0 1
0 1 0
0 1 1
0 0 1
0 0 0

(d) Pauli products that are simultaneously
diagonalized by C′, where M′is as defined in
Proposition 2.
Figure 2: Construction example of C′andS′for the proof of Theorem 2.
We now show that, for all j,Ajis in the row space of X(αj). Since S(αj)
:,jis diagonal, similarly to
Equation 8, the following holds:
M
k∈KX(αj)
k,ℓ=(
0 ifS:,ℓcommutes with S:,jorℓ≤j,
1 ifS:,ℓanticommutes with S:,j,∀ℓ > j,(11)
where K={k| Z(αj)
k,j= 1}. This sum satisfy the same properties as the row jof the commutativity
matrix Aassociated with S, therefore we have:
Aj=M
k∈KX(αj)
k. (12)
Thus, for all j,Ajis in the row space of the matrix X(αj), whose rows are themselves in the row
space of M′. Consequently, Mjis in the row space of M′for all jand rank( M′)≥rank( M).
The proof of Theorem 2 can now be formulated based on Proposition 1 and 2.
Proof of Theorem 2. Consider a Clifford C′containing the same number of Hadamard gates as C,
acting over n+h(C) qubits and constructed by the following process:
1. Start with C′as a copy of Cwith h(C) additional qubits.
2. Remove all Sgates from C′.
3. After the ith Hadamard gate of C′, insert a SWAP gate operating over the qubits n+i−2
andjwhere jis the qubit on which the ith Hadamard gate is applied.
11An example of this process is provided in Figure 2. The SWAP i,jgate can be implemented using
CNOT gates:
SWAP i,j= CNOT i,jCNOT j,iCNOT i,j
This operation can be performed on Sby swapping the rows ZiandZjas well as the rows Xiand
Xj. Let M′be defined as in Proposition 2, let S′=0
M′
be a sequence of mmutually commuting
Pauli products of size n+h(C) and let U′is the Clifford operator implemented by C′, we will show
thatU′†P(S′
:,i)U′is diagonal for all i. We reuse C(i)andS(i)=Z(i)
X(i)
as defined in Proposition 2,
and we define S′(i)=Z′(i)
X′(i)
andC′(i)analogously where C′(i)is the subcircuit resulting from
truncating C′after its ith inserted SWAP gate and C′(0)is the empty circuit.
We now prove by induction that for all 0 ≤i≤h(C), 0≤j < n andn≤k < n +iwe have
X′(i)
j=X(i)
j,Z′(i)
j=0andX′(i)
k=0. For i= 0 and 0 ≤j < n , the equalities X′
j=XjandZ′(i)
j=0
are satisfied by definition. Let 0 ≤i < h (C) and αibe the qubit on which the ( i+ 1)th Hadamard
gate of Cis applied. The matrix S(i+1)can be obtained from S(i)by performing a sequence of
{CNOT , S}operations and a Hadamard operation on qubit αi. Similarly, the matrix S′(i+1)can be
obtained from S′(i)by performing the same sequence of CNOT operations, a Hadamard operation
on qubit αiand a SWAP operation acting on the qubits αiandn+i. In both cases, the rows X(i)
j
andX′(i)
j, where 0 ≤j < n, j ̸=αi, are only affected by the CNOT operations, and so if X′(i)
j=X(i)
j
for all 0 ≤j < n , then X′(i+1)
j =X(i+1)
j for all 0 ≤j < n, j ̸=αi. Notice that the only gate in C′
acting on the qubit n+iis the SWAP gate operating on the qubits αiandn+iand recall that by
definition X′
n+i=X(i+1)
αi; then, because this SWAP gate is the last gate of the circuit C′(i+1), we
haveX′(i+1)
αi=X′
n+i=X(i+1)
αi. Therefore, for all 0 ≤j < n , ifX′(i)
j=X(i)
jthenX′(i+1)
j =X(i+1)
j.
IfZ′(i)
j=0for all 0 ≤j < n , then applying a sequence of CNOT operations on S′(i)acting
on the first nqubits will not alter the matrix Z′(i). Thus, if Z′(i)
j=0for all 0 ≤j < n , then
Z′(i+1)
j =Z′(i)
j=0for all 0 ≤j < n, j ̸=αi. Furthermore, if Z′(i)
αi=0for all 0 ≤j < n , then
applying a Hadamard operation on S′(i)acting on qubit αiafter this sequence of CNOT operations
would yield X′(i)
αi=0. This Hadamard operation is followed by a SWAP operation between the
qubits αiandk=n+iwhich would induce that X′(i+1)
k=0andZ′(i+1)
αi=0because Z′
k=0.
Thus, for all 0 ≤j < n , ifZ′(i)
j=0thenZ′(i+1)
j =0. In addition, for all ksuch that n≤k < n +i,
the circuit C′(i+1)doesn’t contain any gate operating on the qubit kother than those included in
C′(i); therefore if X′(i)
k=0for all n≤k < n +ithenX′(i+1)
k=0for all n≤k < n +i+ 1.
Leti=h(C), by combining the facts that X′(i)
j=X(i)
j=0for all 0 ≤j < n andX′(i)
n+j=0
for all 0 ≤j < i , we can deduce that X′(i)is the null matrix which imply that U′†P(S′
:,j)U′is
diagonal for all jwhere U′is the Clifford operator implemented by C′. By Proposition 1 we have
h(C) =h(C′)≥rank( M′), and by Proposition 2 we have rank( M′)≥rank( M) which entails
h(C)≥rank( M). This lower bound is satisfied by Algorithm 1 as stated by Theorem 1, this
implies that Algorithm 1 is optimal and concludes the proof of Theorem 2.
Pauli rotations ordering. Algorithm 1 solves the H-Opt problem for a fixed sequence of Pauli
rotations. However, if two adjacent Pauli rotations are commuting then their order could be in-
verted, leading to another sequence of Pauli rotations representing the same operator. We show
12that changing the ordering in this way doesn’t affect the minimal number of Hadamard gate re-
quired to implement the diagonalization network associated with the sequence of Pauli rotations.
LetS=Z
X
be a sequence of Pauli products, let ibe such that S:,icommutes with S:,i+1and
letS′=Z′
X′
be a sequence of Pauli products obtained by swapping the columns iandi+ 1 of
S. Let M=X
A
andM′=X′
A′
where AandA′are the commutativity matrices of SandS′
respectively. Since S:,icommutes with S:,i+1we have Ai,i+1=A′
i,i+1= 0, and so M:,i=M′
:,i+1
andM:,i+1=M′
:,i. The matrix M′can be obtained from Mby swapping its columns iandi+ 1,
which entails rank( M) = rank( M′). Thus, inverting the order of two adjacent and commuting
Pauli rotations doesn’t change the minimal number of Hadamard gates required to implement the
diagonalization network associated with the sequence of Pauli rotations.
Other gate sets. One could consider the problem over other Clifford gate sets, which raises
the question of whether these gate sets could perform better than the {X,CNOT , S, H}gate set
considered. In order to achieve a number of Hadamard gate inferior to rank( M), where Mis defined
as in Theorem 2, the gate set considered needs to have at least one gate, other than the Hadamard
gate, such that its decomposition over the {X,CNOT , S, H}gate set necessarily involves at least
one Hadamard gate. Said otherwise, the number of Hadamard gates is at least rank( M) for any
gate set in which the Hadamard gate is the only gate Ufor which there exists a non-diagonal Pauli
operator Psuch that U†PUis diagonal.
3.3 Extension to Clifford +RZcircuit re-synthesis
Any Clifford+ RZcircuit can be characterized by a sequence of Pauli rotations followed by a final
Clifford operator Cf[2]. We demonstrated that Algorithm 1 solves the H-Opt problem optimally,
and so it can be used to synthesize a sequence of Pauli rotations up to a final Clifford operator
Cf′with a minimal number of Hadamard gates. The synthesis of the full Clifford+ RZcircuit can
then be performed by coupling Algorithm 1 with a procedure to synthesize the Clifford operator
Cf·Cf′. We will demonstrate that this procedure can in fact also be performed by Algorithm 1
with a minimal number of Hadamard gates.
A Clifford operator U∈ C ncan be represented by a tableau encoding 2 nPauli operators
such that nof them are mutually commuting Pauli operators called stabilizer generators and the
other half are also mutually commuting Pauli operators referred to as destabilizer generators. If
the stabilizer generators are all diagonalized, then the Clifford operator can be synthesized using
only{X, S, CNOT }gates [23]. Thus, synthesizing a Clifford operator with the minimal number
of Hadamard gates amounts to finding a Clifford circuit Ccontaining the minimal number of
Hadamard gates and such that U†PUis diagonal for all Pin the stabilizer generators, where Uis
the Clifford operator associated with C. We will demonstrate via the following proposition that a
Clifford circuit satisfying these properties is produced by Algorithm 1 when the sequence of Pauli
products Sgiven as input encodes the stabilizer generators on any order.
Proposition 3. LetSbe a sequence of mmutually commuting Pauli products and Cbe the Clifford
circuit returned by Algorithm 1 when Sis given as input. Then U†P(S:,j)Uis diagonal for all j,
where Uis the Clifford operator associated with C.
Proof. LetPandP′be commuting Pauli operators such that Pis diagonal and P′is not diagonal.
If there exists ksuch that P′
k=XandP′
ℓ∈ {I, Z}for all ℓ̸=k, then Pk=Ibecause Pcommutes
13with P′andPis diagonal. Therefore conjugating PandP′with a Hadamard gate on qubit kwill
result in both operators being diagonalized. Let C(i)be the subcircuit of Ctruncated before its
ith Hadamard gate with C(0)defined as the empty circuit, and let U(i)be the Clifford operator
associated with C(i). Due to the construction process of C, for each subcircuit C(i)where i >0
there exists jsuch that P′=U†
(i)S:,jU(i)satisfies P′
k=XandP′
ℓ∈ {I, Z}for all ℓ̸=kwhere
kis the qubit on which the ith Hadamard gate of Cis applied. Hence, for all i < h (C) and for
allj, ifU†
(i)P(S:,j)U(i)is diagonal, then U†
(i+1)P(S:,j)U(i+1)is also diagonal. The circuit Cis a
diagonalization network for S, which imply that for all jthere exists U(i)such that U†
(i)P(S:,j)U(i)
is diagonal, and so U†P(S:,j)Uis a diagonal for all j.
Based on Proposition 3, we can now show that Algorithm 1 can be used to synthesize a sequence
of Pauli rotations followed by a final Clifford operator with a minimal number of Hadamard gates.
LetSbe a sequence of Pauli products associated with the sequence of Pauli rotations we are aiming
to implement, let S′be a sequence of Pauli products encoding the stabilizer generators of the
final Clifford operator, and let ˜S=
S S′
. Any {X,CNOT , S, H, R Z}circuit implementing this
sequence of Pauli rotations followed by the final Clifford operator is necessarily a diagonalization
network for ˜S. The circuit Creturned by Algorithm 1 when ˜Sis given as input satisfies this
condition with a minimal number of Hadamard gates. Moreover, as indicated by Proposition 3, C
simultaneously diagonalize the sequence of Pauli products encoded by S′. Thus, the synthesis of
the sequence of Pauli rotations and the final Clifford operator can be completed with a minimal
number of Hadamard gate by inserting {X,CNOT , S, R Z}subcircuits into C.
LetCbe the circuit obtained once the number of Hadamard gates have been optimized with our
method. The circuit Cmay contain an important number of CNOT gates as our algorithm does
not aim at optimizing the CNOT-count. If necessary, several methods can be used to optimize the
number of CNOT gates in Cwhile preserving the number of Hadamard gates. First, the Clifford
parts of Ccan be re-synthesized by using a Clifford circuit synthesis algorithm that preserve the
optimal number of Hadamard gates. For example, as shown in Reference [25], a Clifford circuit
can be implemented with the optimal number of Hadamard gates via two {CNOT ,CZ, S}circuits
separated by a layer of Hadamard gates. Algorithms designed for the synthesis of {CNOT ,CZ, S}
circuits can then be used to optimize the number of gates or the depth of the circuit [26]. A
complementary way of optimizing the number of CNOT gates in Cis to re-synthesize the Hadamard-
free subcircuits of Cvia a phase polynomial synthesis algorithm [24, 27]. This method would
probably be more effective than the re-synthesis of the Clifford parts approach when Ccontains
large Hadamard-free subcircuits.
4 Internal Hadamard gates minimization
In this section, we tackle the problem of minimizing the number of internal Hadamard gates, which
corresponds to the number of Hadamard gates occurring between the first and the last non-Clifford
RZgate of the circuit. We first give an algorithm in Section 4.1 that performs the synthesis of a
diagonalization network while minimizing the number of internal Hadamard gates. We then prove
its optimality in Section 4.2.
144.1 Algorithm
Solving the Internal-H-Opt problem for a sequence S=Z
X
of Pauli products consists in finding
a Clifford operator Usuch that rank( ˜M) is minimal where ˜M=˜X
A
,˜S=˜Z
˜X
=U†SUandA
is the commutativity matrix associated with S. The inequality rank( A)≤rank( ˜M)≤rank( M)≤
rank( A) +n, where M=X
A
andnis the number of qubits, imply that the circuit produced
by Algorithm 1 contains at most nadditional internal Hadamard gates when compared to an
optimal solution. To go beyond this approximation and obtain an optimal solution, it is necessary
to find a sequence of Clifford operations which, when applied to S, transform Xinto ˜X. As
discussed in Section 3.3, implementing a Clifford operator can be done in two parts: finding a circuit
that simultaneously diagonalize the stabilizer generators of the Clifford operator and finishing the
implementation with a {X, S, CNOT }circuit. The {X, S, CNOT }circuit can be disregarded as
the associated operations have no impact on the rank of ˜M. Hence, solving the Internal-H-Opt
problem for a sequence Sof Pauli products consists in finding a set of mutually commuting Pauli
products, encoded in a matrix S′, that are simultaneously diagonalized by a Clifford operator U
and such that rank( ˜M) is minimal where ˜M=˜X
A
and ˜Sis the sequence of Pauli products
resulting from conjugating all the Pauli products of SbyU. As stated by Proposition 3, a circuit
that simultaneously diagonalize the Pauli products of S′is produced by Algorithm 1 when S′is
given as input. Thus, if
S′S
is given as input to Algorithm 1, then the constructed circuit is
a diagonalization network for Swhich containing a minimal number of internal Hadamard gates.
An example of the execution of Algorithm 2 is given in Figure 3.
We propose an algorithm, whose pseudo-code is given in Algorithm 2, to solve the Internal-
H-Opt problem optimally by finding the Pauli products constituting S′. Let Jmbe an exchange
matrix of size m×mdefined as follows:
Jmi,j=(
1 if i+j=m−1,
0 otherwise .(13)
As such, the Pauli products encoded by the columns of the matrix SJmare then the same as the
ones encoded by Sbut in reverse order. The algorithm starts by performing a call to Algorithm 1
to obtain a Clifford circuit Cthat is a diagonalization network for the sequence of Pauli products
encoded in SJm. Then, a set of stabilizer generators associated with the inverse of Care encoded
in the columns of S′and a second and final call to Algorithm 1 is performed where
S′S
is
given as input. We prove that the resulting circuit gives an optimal solution to the Internal-H-Opt
problem in the next subsection. When one uses Algorithm 2 to perform the re-synthesis of a circuit,
as explained in Section 3.3, the stabilizer generators associated with the final Clifford operator of
the input circuit can be append to the final call to Algorithm 1 to obtain a full re-synthesis of the
circuit containing both a minimal number of Hadamard gates and internal Hadamard gates.
Note that a set of stabilizer generators associated with the inverse of the Clifford circuit Ccan
be computed in O(n2m) using the tableau representation as Cis composed of O(nm) gates and
a tableau can be updated in O(n) operations when a Clifford gate is applied. The complexity of
the algorithm then resides in the two calls made to Algorithm 1. The first call has a complexity
ofO(n2m) asSJmis composed of mPauli products. For the second call, n+mPauli products
are given as input because a Clifford operator acting on nqubits has nstabilizer generators. This
induces a complexity of O(n2(n+m)) =O(n3+n2m), which corresponds to O(n2m) in the
15Algorithm 2: Diagonalization network synthesis with a minimal number of internal H
gates
Input: A sequence SofmPauli products of size n.
Output: A diagonalization network for Swith a minimal number of internal Hgates.
1Jm←exchange matrix of size m×m
2C←DiagonalizationNetworkSynthesis (SJm)
3S′←stabilizer generators of the inverse of the Clifford operator associated with C
4return DiagonalizationNetworkSynthesis (
S′S
)
H S H
S H
(a) Circuit produced by Algorithm 1 when SJmis
given as input.S H H S H
(b) Circuit produced by Algorithm 1 whenS′S
is
given as input. The first 4 gates are a diagonalization
network for S′, the last 3 gates are a diagonalization
for˜S. The whole circuit solves the Internal-H-Opt
problem for Swith rank( A(S)) = 1 internal
Hadamard gates.
S=Z
X
=
1 0 0
1 1 0
1 0 1
0 1 0
, A(S)=
0 1 1
0 0 0
0 0 0

(c) Initial sequence of Pauli products and its
commutativity matrix, which are the same as the
example in Figure 2.S′=
1 0
1 1
1 1
0 1
,˜S=
0 0 1
1 1 0
0 1 1
0 1 1

(d) Sequence of Pauli products S′and ˜Ssuch that S′
is associated with the stabilizer generators of the
Clifford operator U†where Uis implemented by the
circuit depicted in Subfigure 3(a), and ˜S=U†SU.
Figure 3: Example of an execution of Algorithm 2. For a sequence of Pauli products S(c), the first
call to Algorithm 1 will produce a circuit (a) with associated Pauli products S′(d). The algorithm
will then output the circuit produced by Algorithm 1 when
S′S
is given as input (b).
typical case where n≤m. Thus, the overall complexity of Algorithm 2 matches the complexity of
Algorithm 1.
4.2 Optimality
This subsection is dedicated to the proof of the following theorem, which states the optimality of
Algorithm 2.
Theorem 3. LetSbe a sequence of mPauli products, Abe its commutativity matrix and let Cbe
the Clifford circuit returned by Algorithm 2 when Sis given as input. Then Coptimally solves the
Internal-H-Opt problem with rank( A)internal Hadamard gates.
We first show that the optimal number of internal Hadamard gates is equal to rank( A). Our
proof rests on the following proposition.
16Proposition 4. LetSbe a sequence of mPauli products, Abe its commutativity matrix and let
y,y′be such that Ay=0andAy′=0. Then the Pauli products encoded by SyandSy′are
commuting.
Proof. Notice that the Pauli product S:,icommutes with S:,jif and only if ( A⊕AT)i,j= (A⊕AT)j,i=
0. Then Sy′commutes with S:,iif and only if vi= 0, where v= (A⊕AT)y′. And Sy′commutes
withSyif and only if yTv=yT(A⊕AT)y′= 0. As Ay=0andAy′=0, we can show that
yT(A⊕AT)y′=yTAy′⊕yTATy′=yTAy′⊕(Ay)Ty′= 0, which implies that Sycommutes with
Sy′.
Based on Proposition 4 we can show that the optimal number of internal Hadamard gates is
equal to rank( A). Let S′be a sequence of Pauli products such that the columns of S′are forming
a spanning set of {Sy|Ay=0,y∈Fm
2}. It follows that for all ysatisfying Ay=0there exists
a vector y′such that Sy=S′y′. Moreover, Proposition 4 entails that all the Pauli products of S′
are mutually commuting. Therefore if the Pauli products encoded in S′were all to be diagonal,
then, for all ysatisfying Ay=0, the Pauli product Sywould be diagonal, i.e. Xy=0. Let C′be
the circuit resulting from the execution of Algorithm 1 when S′is given as input and let ˜Sbe the
sequence of Pauli products where, for all i, the Pauli product encoded by ˜S:,iis equal to the Pauli
product encoded by S:,iconjugated by the Clifford operator associated with C′. Let ˜M=˜X
A
,
for all ysatisfying Ay=0we have ˜Xy=0because C′performs a simultaneous diagonalization
on the Pauli products of S′, as stated by Proposition 3. Consequently we have ˜My=0for all
y∈nullspace( A) and so rank( ˜M) = rank( A). Then we can use Algorithm 1 to produce a Clifford
circuit ˜Cthat is a diagonalization network for ˜Sand such that h(˜C) = rank( ˜M) = rank( A). It
follows that the Clifford circuit C′::˜Cis a diagonalization network for Scontaining h(˜C) = rank( A)
internal Hadamard gates.
To solve the Internal-H-Opt problem optimally it is then essential to find a spanning set of
{Sy|Ay=0,y∈Fm
2}, which we encode in the columns of S′. Constructing such a spanning
set naively by finding all y∈Fm
2satisfying Ay=0would imply a complexity of O(m3) using
a Gaussian elimination procedure, which is more computationally expensive than minimizing the
number of Hadamard gates via Algorithm 1 in the case where n < m . Fortunately, we can actually
rely on Algorithm 1 to compute S′with a complexity of O(n2m), as it is done in Algorithm 2.
Indeed, if Algorithm 1 is used to constructed a diagonalization network Cfor the sequence of
Pauli products SJm, then the stabilizer generators of the Clifford operator implemented by Care
forming a spanning set of {Sy|Ay=0,y∈Fm
2}. We demonstrate this statement via the following
proposition.
Proposition 5. LetS=Z
X
be a sequence of mPauli products, Jmbe an exchange matrix of
sizem×mand let Ube the Clifford operator associated with the Clifford circuit Cproduced by
Algorithm 1 when SJmis given as input. Let ˜Sbe the sequence of Pauli products obtained by
conjugating all the Pauli products of SbyU, then ˜XJmy=0for all ysatisfying yTA(SJm)=0,
where A(SJm)is the commutativity matrix associated with SJm.
Proof. LetC(i)be the circuit obtained after the ith recursive call to Algorithm 1 when SJmis
given as input, as such C(i)is a diagonalization network for the first i+ 1 columns of SJm. And
letS(i)=Z(i)
X(i)
be the sequence of Pauli products resulting from conjugating Sby the Clifford
17operator associated with the circuit C(i). We defined y(i)∈Fm
2as follows:
y(i)
j=(
yjifj≤i,
0 otherwise ,(14)
where y∈Fm
2satisfies yTA(SJm)=0.
In the case where i= 0, the equality X(0)Jmy(0)=0is satisfied because the Pauli product
encoded by the first column of S(0)Jmis diagonal and y(0)
j= 0 for all j >0. More generally, the
Pauli product encoded by the ith column of S(i)Jmis diagonal, and so the following holds:
M
k∈KX(i)
kJm=A(SJm)
i⊕A(SJm)
:,i (15)
where K={k| Z(i)
k,m−i−1= 1}. Here the ith column of A(SJm)must be added to the ith row of
A(SJm)to form the vector describing how the ith Pauli rotation commutes or anticommutes with
the other Pauli rotations of the sequence. In this sense, it is a generalization of Equation 8 to the
other rows of A(SJm). Equation 15 entails
"M
k∈KX(i)
kJm#T
y(i)=h
A(SJm)
i⊕A(SJm)
:,iiT
y(i)(16)
Moreover, we haveh
A(SJm)
iiT
y(i)= 0 because A(SJm)
i,j = 0 for all j≤iandy(i)
j= 0 for all j > i .
And we also haveh
A(SJm)
:,iiT
y(i)= 0 becauseh
A(SJm)
:,iiT
y(i)=h
A(SJm)
:,iiT
yasA(SJm)
j,i = 0 for all
j > i andh
A(SJm)
:,iiT
y=yTA(SJm)
:,i = 0 by definition. Thus, we proved that the following holds:
"M
k∈KX(i)
kJm#T
y(i)= 0 (17)
where K={k| Z(i)
k,m−i−1= 1}.
Let’s assume that X(i)Jmy(i)=0, we can then distinguish two cases for the ( i+ 1)th iteration
of Algorithm 1. In the case where the ( i+ 1)th Pauli product of S(i)Jmis diagonal, the circuit
C(i+1)can be obtained from C(i)by appending a {CNOT , S}circuit to it. If the Pauli product
encoded by S(i)Jmy(i)is diagonal, as we assumed, then the Pauli product encoded by the vector
S(i+1)Jmy(i)is also diagonal as no Hadamard gate was appended to C(i)to derive C(i+1)from it.
In addition, the ( i+ 1)th Pauli product of S(i+1)Jmis also diagonal which imply that the Pauli
product encoded by the vector X(i+1)Jmy(i+1)is diagonal and so X(i+1)Jmy(i+1)=0. Therefore,
in such case where the ( i+ 1)th Pauli product of S(i)Jmis diagonal, the equality X(i)Jmy(i)=0
implies that X(i+1)Jmy(i+1)=0.
In the case where the ( i+ 1)th Pauli product of S(i)Jmis not diagonal, the circuit C(i+1)
can be constructed from C(i)by appending a {CNOT , S}circuit to it and a final Hadamard gate
on some qubit j. Let ˆC(i+1)be the circuit resulting from appending this {CNOT , S}circuit to
C(i), i.e. ˆC(i+1)corresponds to the circuit C(i+1)whose last gate, which is a Hadamard gate, has
been removed. Let ˆS(i+1)be the sequence of Pauli products obtained by conjugating all the Pauli
products of Sby the Clifford operator associated with ˆC(i+1). Using the same reasoning as before,
if the Pauli product encoded by S(i)Jmy(i)is diagonal then the Pauli product encoded by the vector
18ˆS(i+1)Jmy(i)is also diagonal as no Hadamard gate was appended to C(i)to derive ˆC(i+1)from it,
and so we have ˆX(i+1)Jmy(i)=0.
The circuit C(i+1)can be obtained from ˆC(i+1)by appending a Hadamard gate to it on some
qubit j. Therefore, X(i+1)
k=ˆX(i+1)
kfor all k̸=j, and so
h
X(i+1)
kJmiT
y(i)=h
ˆX(i+1)
kJmiT
y(i)= 0 (18)
for all k̸=j. The ( i+ 1)th Pauli product of S(i+1)Jmis diagonal which means that the ( i+ 1)th
column of X(i+1)Jmis equal to 0, and so the equality holds as well for y(i+1):
h
X(i+1)
kJmiT
y(i+1)=h
X(i+1)
kJmiT
y(i)= 0 (19)
for all k̸=j. Notice that j∈Kwhere K={k| Z(i+1)
k,m−i−1= 1}, then from Equation 17 we can
infer that
h
X(i+1)
jJmiT
y(i+1)⊕
M
k∈ˆKX(i+1)
kJm
T
y(i+1)= 0 (20)
where ˆK=K\{j}. From Equation 19 we can deduce that the second term of Equation 20 is equal
to 0, therefore we haveh
X(i+1)
jJmiT
y(i+1)= 0 (21)
which, when combined with Equation 19, entails X(i+1)Jmy(i+1)=0and concludes the proof of
Proposition 5.
We can now demonstrate Theorem 3 on the basis of Proposition 5.
Proof of Theorem 3. LetS′be as defined in Algorithm 2 and let Cbe the circuit produced by
Algorithm 2 when S=Z
X
is given as input. As Cis a diagonalization network for
S′S
it can
be splitted in two subcircuits such that C=C1::C2, where C1andC2are diagonalization networks
forS′and ˜Srespectively with ˜S=˜Z
˜X
=U†SUwhere Uis the Clifford operator associated with
C1. The number of internal Hadamard gates in Cis therefore equal to the number of Hadamard
gates in C2, proving Theorem 3 can then be done by proving that h(C2) = rank( ˜M) = rank( A(S))
where ˜M=˜X
A(S)
.
The Pauli products encoded in the matrix SJmare the same as in Sbut in reverse order.
Consequently we have A(S)
i,j=A(SJm)
m−j−1,m−i−1, therefore by reversing the order of the rows and
columns of A(SJm)and transposing it to obtain a strictly upper triangular matrix we get the
matrix A(S):h
JmA(SJm)JmiT
=A(S)(22)
From this we can deduce that
A(S)y=0
⇒h
JmA(SJm)JmiT
y=0
⇒ yTJmA(SJm)Jm=0
⇒ yTA(SJm)=0(23)
19where y=Jmy. And based on Proposition 5 we have
˜XJmy=0
⇒ ˜Xy=0(24)
Thus, for all y∈nullspace( A(S)) we have ˜Xy=0and therefore ˜My=0, which implies that
h(C2) = rank( ˜M) = rank( A(S)) and concludes the proof of Theorem 3.
5 Improving the complexity
Algorithm 1 and 2 are taking a sequence of Pauli products Sas input and output a diagonalization
network for S. In order to use these algorithms to minimize the number of Hadamard gates, or
internal Hadamard gates, in a circuit Cit is then required to first extract from Cthe sequence of
Pauli products Sfor which the diagonalization network must be constructed. This procedure can
be done with a complexity O(nM) by using a tableau, where nis the number of qubits and M
is the number of gates in C. In this section, we will see how we can merge the extraction of the
sequence of Pauli products Swith our algorithms to obtain the desired re-synthesis of Cwith a
complexity of O(nM+n2h) instead of O(nM+n2m) where mis the number of Pauli products in
Sandh≤mis the minimal number of Hadamard gates required to construct a diagonalization
network for S. We first explain our notations related to the tableau representation, commonly used
to represent a Clifford operator. In Subsection 5.1 we present an algorithm which performs the
re-synthesis of a sequence of Pauli rotations implemented by a given circuit up to a final Clifford
operator and with a minimal number of Hadamard gates. Finally, in Subsection 5.2, we present an
algorithm which produces a circuit that is a re-synthesis of a given circuit and which implements
the same sequence of Pauli rotations but with a minimal number of Hadamard gates and internal
Hadamard gates.
The tableau representation. A tableau encodes 2 ngenerators which can be represented by 2 n
independent Pauli products along with a phase for each one of these Pauli products. We can thus
reuse our method of encoding for a sequence of Pauli products Sand represent a tableau by a
block matrix T=
sT
Z
X
of size (2 n+ 1)×2nwhere nis the number of qubits. The first row of
Tcorresponds to a vector s∈ {0,1}2nwhich encodes the phases of the generators, the subsequent
nrows of Tare forming the submatrix Zand the last nrows of Tare forming the submatrix X.
Thejth column of Tis then encoding the jth generator: sjencodes its phase which corresponds to
(−1)sjand (Zi,j,Xi,j) encodes its ith Pauli matrix, such that the values (0 ,0),(0,1),(1,1) and (1 ,0)
are corresponding to the Pauli matrices I, X, Y andZrespectively. The first ncolumns of Tare
encoding the stabilizer generators, whereas the last ncolumns of Tare encoding the destabilizer
generators. The identity tableau Tassociated with an empty circuit is such that the matrixZ
X
is forming the identity matrix and s=0, said otherwise the ith stabilizer generator of TisZi
and the ith destabilizer generator of TisXi. The inverse tableau of T, denoted by T−1, is the
tableau associated with the Clifford operator U†where Uis the Clifford operator associated with
T. Analogously, the inverse of a circuit C, denoted C−1, is the circuit obtained from Cby replacing
every gate GbyG†and by reversing the order of its gates. Let Sbe a sequence of Pauli products,
20Algorithm 3: H-Opt
Input: A Clifford+ RZcircuit Cand a tableau T=
sT
Z
X
.
Output: A circuit Coutand a tableau Tout, such that Coutis a re-synthesis of Cand
implements the same sequence of Pauli rotations as Cup to an initial and final
Clifford operator represented by TandT−1
outrespectively.
1procedure HOpt( C,T)
2 Cout←new empty circuit
3 foreach gateG∈Cdo
4 ifGis Clifford then
5 Prepend G†toT
6 end
7 ifGis a non-Clifford RZk(θ) gate then
8 if∃isuch that Xi,k= 1then
9 foreach j∈ {j| Xj,k= 1} \ {i}do
10 Cout←Cout:: CNOT i,j
11 Append CNOT i,jtoT
12 end
13 ifZi,k= 1then
14 Cout←Cout::Si
15 Append SitoT
16 end
17 Cout←Cout::Hi
18 Append HitoT
19 end
20 i←any value satisfying Zi,k= 1
21 ˜C←new empty circuit
22 foreach j∈ {j| Zj,k= 1} \ {i}do
23 ˜C←˜C:: CNOT j,i
24 end
25 ifsk= 1then
26 ˜C←˜C::Xi
27 end
28 Cout←Cout::˜C::RZi(θ) ::˜C−1
29 end
30 end
31 return (Cout,T)
21Algorithm 4: Internal-H-Opt
Input: A Cliffod+ RZcircuit C.
Output: A circuit that is a re-synthesis of Cand which implements the same sequence of
Pauli rotations as Cwith a minimal number of Hadamard gates and internal
Hadamard gates.
1procedure InternalHOpt( C)
2T ← new identity tableau
3 foreach Clifford gate G∈Cdo
4 Prepend G†toT
5 end
6 (˜C,˜T)←HOpt (C−1,T)
7 C˜T←CliffordSynthesis (˜T)
8 (Cout,Tf)←HOpt (C,˜T)
9 return C˜T::Cout::CliffordSynthesis (T−1
f)
if˜S=U†SUthen we will equivalently say that ˜S=T−1STwhere Tis the tableau associated
with the Clifford operator U.
LetCbe a Clifford circuit such that its associated Clifford operator is represented by a tableau
T. If a Clifford gate from the set {CNOT , S, H}is appended to Cthen the generators of Tcan
be updated accordingly with O(n) operations, where nis the number of qubits. The operations
to perform on the Pauli products encoded by Tare the same as the one depicted in Figure 1,
similar operations can be performed to update the phases associated with the Pauli products in
O(n) [23]. Also, if a Clifford gate from the set {CNOT , S, H}is prepended to C, then Tcan also
be updated with O(n) operations [28]. When Tis updated in such manner we will say that we
append, or prepend, a gate to T. As explained in Section 3.3, a Clifford operator, represented by
a tableau Tand acting on nqubits, can be implemented over the {X,CNOT , S, H}gate set with
a complexity of O(n3) and with a minimal number of Hadamard gates by first diagonalizing its
stabilizer generators using Algorithm 1, and then finishing its synthesis using only {X,CNOT , S}
gates. We use the term CliffordSynthesis to denote this procedure in our algorithms.
5.1 H-Opt algorithm
Consider the algorithm whose pseudo-code is given in Algorithm 3 and which takes a circuit Cand
a tableau Tinas input, and let Sbe the sequence of Pauli products associated with the sequence
of Pauli rotations implemented by C. This algorithm outputs a circuit Coutand a tableau Tsuch
that Coutis a re-synthesis of Cand implements the same sequence of Pauli rotations as Cup to
an initial and final Clifford operator represented by TinandT−1
outrespectively.
Algorithm 3 is composed of a loop iterating over the gates of Cand which contains two distinct
cases: either the current gate Gis a Clifford gate or it is not. If Gis Clifford gate then G†is
prepended into T. IfGis a non-Clifford RZi(θ) gate then we must compute the Pauli rotation
that should be appended to Cout. To do so we can first compute which Pauli rotation is actually
being implemented by Cby pulling all the Clifford gates preceding Gthrough the Pauli rotation
RZi(θ). The Pauli rotation obtained is then URZi(θ)U†where Uis the Clifford operator associated
with the Clifford circuit composed of all the Clifford gates preceding G. Then, to be appended into
Cout, the Pauli rotation must also be propagated through the initial tableau Tin, we will denote V
the Clifford operator associated with Tin. Finally, the Pauli rotation must be propagated through
22all the Clifford gates that are in Coutso far, we denote Wthe associated Clifford operator. The
Pauli rotation to append to the circuit Coutis therefore W†V†URZi(θ)U†V W. We can notice that
the Clifford operator U†V W is in fact associated with the tableau T. Indeed, Tis initially equal
toTin, the inverse Clifford gates that are preceding GinChas been prepended to Tand the
Clifford gates that are in Coutso far has been appended to T. The Pauli operator Psatisfying
RP(θ) =W†V†URZi(θ)U†V W is therefore the ith stabilizer generator of T, which is encoded by
theith column of T.
The Pauli rotation RP(θ) can then be implemented by first performing the synthesis of a Clifford
operator Usuch that U†RP(θ)Uis diagonal, and then by performing the synthesis of a Clifford
operator Vsatisfying V†U†RP(θ)UV=RZi(θ), for some qubit i. The Clifford operator Vcan be
synthesized using only {X,CNOT }gates as U†RP(θ)Uis diagonal, this is done in Algorithm 3 by
constructing the circuit ˜C. Once the operators UandVhave been implemented, the gate RZi(θ)
can be appended to the circuit. The operator V†does not necessarily need to be implemented, but
it is actually implemented in Algorithm 3 to avoid additional operations that would be required
to update the tableau T. We should not treat the operator U†the same way as it would increase
the number of Hadamard gates in the circuit, U†is therefore not implemented in Algorithm 3 and
the tableau Tis updated accordingly by appending the gates realizing the implementation of Uto
it. Note that the method utilized to implement Uis the same as the one in Algorithm 1, which
uses exactly one Hadamard gate when Pis not diagonal. It follows from the results in Section 3
that Algorithm 3 can be used to solve the H-Opt problem for ˜S=T−1
inSTin. More concretely,
by removing all the non-Clifford RZgates from the circuit produced by Algorithm 3 we obtain a
diagonalization network which solves the H-Opt problem for ˜S.
LetC′andC′
outbe the Clifford circuits obtained by removing all the non-Clifford RZgates from
CandCoutrespectively, and let CTinbe a Clifford circuit whose Clifford operator is associated with
the tableau Tin. In the end of Algorithm 3, the tableau Tis associated with the Clifford operator
implemented by the circuit CT=C′−1::CTin::C′
out. As Coutimplements the sequence of Pauli
rotations associated with ˜S=T−1
inSTinup to a final Clifford operator implemented by C′−1
out, it
follows that Cf=CTin::Cout::C−1
Tis a re-synthesis of Cand implements the same sequence of
Pauli rotations as C. If the input tableau Tinis the identity tableau, or can be implemented with
no Hadamard gates, and if CTis implemented with a minimal number of Hadamard gates using
the procedure described in Section 3.3, then Cfis a re-synthesis of Cwhich implements the same
sequence of Pauli rotations with a minimal number of Hadamard gates.
Complexity analysis. The main loop of Algorithm 3 is performing Miterations where Mis the
number of gates in the input circuit. At each iteration, if the current gate is a Clifford gate then
it is prepended to Twhich is done in O(n) operations, where nis the number of qubits in the
input circuit. If the current gate is a non-Clifford RZk(θ) gate then the algorithm append O(n)
gates to Cout. In the case where the kth stabilizer generator of Tis not diagonal then a subset of
these gates are appended to Twhich takes O(n) operations for each gates. This happens exactly
htimes where his the number of Hadamard gates in the output circuit Cout, which implies a cost
ofO(n2h) operations. Thus, the overall complexity of Algorithm 3 is O(nM+n2h).
5.2 Internal-H-Opt algorithm
Algorithm 4 is based on the procedure explained in Section 4 and utilized by Algorithm 2 to
synthesize a diagonalization network for a sequence of Pauli products with a minimal number of
internal Hadamard gates. It takes a Clifford+ RZcircuit Cas input and outputs a circuit which is a
re-synthesis of Cand which implements the same sequence of Pauli rotations as Cwith a minimal
23number of Hadamard gates and internal Hadamard gates.
As explained in Section 4, in order to solve the Internal-H-Opt problem for a sequence of
mPauli products Sit is necessary to find a Clifford operator Uthat minimizes rank( ˜M) where
˜M=˜X
A(S)
,A(S)is the commutativity matrix associated with Sand ˜S=˜Z
˜X
=U†SU. We
proved that the Clifford operator associated with the circuit produced by Algorithm 1 when SJm,
where Jmis an exchange matrix of size m×m, is given as input is satisfying this property. Let
Sbe a sequence of mPauli products associated with the sequence of Pauli rotations implemented
by a Clifford+ RZcircuit C, then the Clifford operator Udescribed above can be computed by
theHOpt procedure described in Algorithm 3. To do so, the circuit C−1and the tableau Tmust
be given as input to the HOpt procedure, such that Tis the tableau associated with the Clifford
operator implemented by the circuit C′−1where C′is the Clifford circuit obtained by removing
all the non-Clifford RZgates of C. The circuit C−1is provided so that the Pauli rotations are
processed in reversed order by the HOpt procedure. For the tableau T, it must be provided because
the circuit C−1does not necessarily implements the same sequence of Pauli rotations as C, however
the circuit C′::C−1do implement the same sequence of Pauli rotations as the circuit C. We can
be convinced by this fact by noticing that the Clifford operator formed by all the Clifford gates
preceding a non-Clifford gate in Cis the same as the Clifford operator formed by all the Clifford
gates preceding the corresponding non-Clifford gate in C′::C−1. Then, as shown in Section 5.1,
when the HOpt procedure is executed with C−1andTas parameters, it will produce a circuit ˜C
and a tableau ˜Tassociated with the Clifford operator implemented by the circuit C′::C′−1::˜C′,
which is equivalent to the circuit ˜C′, and where ˜C′is the Clifford circuit obtained by removing all
the non-Clifford RZgates from ˜C. The circuit ˜C′then solves the H-Opt problem for SJm, and
is an implementation of the Clifford operator associated with the tableau ˜T. From the results of
Section 4, it follows that if ˜S=˜Z
˜X
=˜T−1S˜Tthen rank( ˜M) = rank( A(S)) where ˜M=˜X
A(S)
.
Algorithm 4 then performs the synthesis of the Clifford operator associated with ˜Twith a
minimal number of Hadamard gates, the Clifford circuit C˜Tobtained will be the initial Clifford
circuit of the circuit produced by Algorithm 4. The algorithm then calls a second time the HOpt
procedure with Cand˜Tgiven as parameters in order to implement the sequence of Pauli rotations
associated with ˜Swith a minimal number of internal Hadamard gates and up to a final Clifford
circuit. The tableau ˜Tmust be given as input so that the sequence of Pauli rotations implemented
is the one associated with the sequence of Pauli products ˜Sand not S. The procedure HOpt will
then produce a circuit Coutand a tableau Tfsuch that C′
outis solving the H-Opt problem for ˜S
andTfis associated with the Clifford operator implemented by Cf=C′−1::C˜T::C′
out, where
C′andC′
outare the circuits obtained by removing all the non-Clifford RZgates from CandCout
respectively. We can then deduce that C˜T::Cout::C−1
fis implementing the same sequence of
Pauli rotations as Cand the Clifford operator formed by all the Clifford gates of this circuit is the
same as the Clifford operator formed by all the Clifford gates of C. Thus, the circuit produced by
Algorithm 4 is a re-synthesis of Cand it implements the same sequence of Pauli rotations with a
minimal number of Hadamard gates and internal Hadamard gates.
Complexity analysis. Lethbe the number of Hadamard gates within the circuit produced by
Algorithm 4, and let nbe the number of qubits in C. The algorithm performs two calls to the
HOpt procedure for C−1andCrespectively, which both contains Mgates. The first call, with
C−1given as input, will produce a circuit which contains ˜hnumber of Hadamard gates, such that
˜h≤h. The second call, with Cgiven as input, will produce a circuit which contains a number of
24Hadamard gates that is equal to the number of internal Hadamard gates in the circuit produced by
Algorithm 4, and which is therefore less than or equal to h. Hence, these two calls to Algorithm 3
have a cost of O(nM+n2h) operations. The procedure CliffordSynthesis is also called two
times, which induces a cost of O(n3) operations. Thus, the overall complexity of Algorithm 4 is
O(nM+n2h+n3), which corresponds to O(nM+n2h) in the typical case where h > n .
Note that the two calls to the CliffordSynthesis procedure can be avoided if the objective is
to minimize the number of internal Hadamard gates in the circuit and not the number of Hadamard
gates. Indeed, the first call to the HOpt procedure will produce a circuit ˜Cand a tableau Tsuch
thatTis associated with the Clifford operator implemented by ˜C′where ˜C′is obtained by removing
all the non-Clifford RZgates from ˜C. Performing the synthesis of Twill therefore produce a circuit
that is equivalent to ˜C′. Consequently, instead of calling the procedure CliffordSynthesis , an
equivalent circuit could be obtained by constructing ˜C′which can be done with O(nM) operations
as˜Ccontains O(nM) gates. Of course, the drawbacks of this method are that ˜C′may not contain an
optimal number of Hadamard gates and that the worst-case complexity would be greater than O(n3)
in the case where M > n2. The second call to CliffordSynthesis can also be avoided in a similar
manner. Indeed, Tfis associated with the Clifford operator implemented by Cf=C′−1::C˜T::C′
out,
where C′andC′
outare the circuits obtained by removing all the non-Clifford RZgates from Cand
Coutrespectively. The circuit Cfcan then be constructed in O(nM) as the circuits C′−1,C˜Tand
C′
outall contain O(nM) gates. Thus, we can design an algorithm which produces a circuit ˆCwith
a complexity of O(nM+n2h), even in the case where h < n , and such that ˆCis a re-synthesis
of a Clifford+ RZcircuit Cand implements the same sequence of Pauli rotations as Cbut with a
minimal number of internal Hadamard gates.
6 Benchmarks
We compare the performances of Algorithm 4, the InternalHOpt procedure, to the moveH procedure
presented in Reference [10] and which has a complexity of O(M2) where Mis the number of
gates in the input circuit. Note that the moveH procedure does not include the Tgates reduction
method of Reference [10] based on spider nest identities and which is normally performed once
the number of Hadamard gates have been reduced. The moveH procedure applies a sequence of
rewriting rules on the circuit with the aim of reducing the number of internal Hadamard gates.
During this process the number of Tgates may also be reduced, which modifies the sequence
of Pauli rotations implemented by the circuit. This can then lead to a better reduction in the
number of internal Hadamard gates than the one obtained when only the InternalHOpt procedure
is performed. Which is why, in order to better exploit the InternalHOpt procedure, it can be
helpful to first execute an algorithm which can reduce the number of Tgates in the circuit quickly
and efficiently. The T-count reduction algorithms that are closest to these requirements are the
provided in Reference [8] and in Reference [7], these two algorithms have in fact been proven to
be equivalent [29]. The method used in these algorithms consists in merging the Pauli rotations
in the sequence that are equivalent and that are not separated by another Pauli rotation with
which they anticommute. We implemented the algorithm provided in Reference [8] such that it
is not increasing the number of gates in the circuit in order to not increase the execution time of
theInternalHOpt procedure. This procedure, which we refer to as TMerge , has a complexity of
O(nM+nm2) where nis the number of qubits, Mis the number of gates in the input circuit and m
is the number of Pauli rotations. If the Tgates reduction rules used in the moveH subroutine is only
consisting in merging two adjacent RZgates together, then we can infer that the number of Tgates
in the circuit after moveH procedure has been performed is always higher or equal to the number of
25InternalHOpt TMerge [8] + InternalHOpt moveH [10]
Circuit H-count T-count Time (s) H-count T-count Time (s) H-count T-count Time (s)
Tof3 2 21 0.00 2 15 0.00 2 15 0.00
Tof4 4 35 0.00 4 23 0.00 4 23 0.00
Tof5 6 49 0.00 6 31 0.00 6 31 0.00
Tof10 16 119 0.00 16 71 0.00 16 71 0.00
Barenco Tof 3 3 28 0.00 3 16 0.00 3 16 0.00
Barenco Tof 4 7 56 0.00 7 28 0.00 7 28 0.00
Barenco Tof 5 11 84 0.00 11 40 0.00 11 40 0.00
Barenco Tof 10 31 224 0.00 31 100 0.01 31 100 0.00
Mod5 4 0 28 0.00 0 8 0.00 0 8 0.00
VBE Adder 3 4 70 0.00 4 24 0.00 4 24 0.00
CSLA MUX 3 6 70 0.00 6 62 0.00 6 62 0.00
CSUM MUX 9 12 196 0.00 12 84 0.01 12 84 0.00
QCLA Com 7 18 203 0.00 18 95 0.01 18 95 0.00
QCLA Mod 7 58 413 0.00 58 237 0.02 58 237 0.00
QCLA Adder 10 25 238 0.00 25 162 0.01 25 162 0.00
Adder 8 41 399 0.00 37 173 0.02 41 215 0.01
Mod Adder 1024 304 1995 0.00 304 1011 0.12 304 1011 0.06
RC Adder 6 10 77 0.00 10 47 0.00 10 47 0.00
Mod Red 21 17 119 0.00 17 73 0.00 17 73 0.00
Mod Mult 55 3 49 0.00 3 35 0.00 3 35 0.00
GF(24) Mult 0 112 0.00 0 68 0.00 0 68 0.00
GF(25) Mult 0 175 0.00 0 115 0.01 0 115 0.00
GF(26) Mult 0 252 0.00 0 150 0.01 0 150 0.00
GF(27) Mult 0 343 0.00 0 217 0.02 0 217 0.01
GF(28) Mult 0 448 0.00 0 264 0.04 0 264 0.02
GF(29) Mult 0 567 0.00 0 351 0.05 0 351 0.03
GF(210) Mult 0 700 0.00 0 410 0.07 0 410 0.04
GF(216) Mult 0 1792 0.01 0 1040 0.43 0 1040 0.14
GF(232) Mult 0 7168 0.05 0 4128 7.19 0 4128 0.98
GF(264) Mult 0 28672 0.19 0 16448 125.07 0 16448 7.46
GF(2128) Mult 0 114688 1.20 0 65664 2294.64 0 65664 60.47
GF(2256) Mult 0 458752 8.22 0 262400 41474.34 0 262400 2922.20
GF(2512) Mult 0 1835008 53.85 - - - 0 1049088 59186.15
Adder 1024 2044 14322 3.57 2044 8184 31.08 2046 8184 6.12
Adder 2048 4092 28658 18.98 4092 16376 179.07 4094 16376 25.69
Adder 4096 8188 57330 90.46 8188 32760 1182.67 8190 32760 131.11
DEFAULT 11936 62720 13.72 11936 39744 39.33 12030 39744 1602.60
Shor 4 9780 68320 0.21 5010 17052 5.91 9829 22514 77.52
Shor 8 69759 489741 1.74 35585 121341 158.91 69759 163827 6895.79
Shor 16 537630 3755115 15.80 312274 1042881 2821.94 - - -
Shor 32 4173389 29622691 172.98 387103 1303156 24150.54 - - -
Table 1: Comparison of different methods for the optimization of the number of internal Hadamard
gates. The H-count corresponds to the number of internal Hadamard gates. A blank entry indicates
that the execution couldn’t be carried out in less than a day.
26Tgates in the circuit after the TMerge procedure has been performed; this is corroborated by the
results of our benchmarks.
We evaluate the different methods on a set of commonly used circuits which were obtained from
Reference [30] and Reference [31]. We extended the set of circuits over which the benchmarks are
performed by adding larger quantum circuit to better test the scalability of the different approach
on various types of circuits. We added large adders circuits which are performing an addition
over two registers of size 1024, 2048 and 4096 qubits, the implementation of these circuits is based
on Reference [32]. We also added a circuit, given in Reference [33], that is an implementation
of the block cipher DEFAULT. Finally, we added quantum circuits implementing the modular
exponentiation part of Shor’s algorithm for number factoring over 4, 8, 16 and 32 bits.
The TMerge andInternalHOpt procedures were implemented with the Rust programming lan-
guage, while the moveH procedure was extracted from the implementation realized in Haskell by
the authors of the method [34]. Our implementation of the InternalHOpt procedure used for the
benchmarks is publicly available [35], along with the circuits used in the benchmarks and which
have a reasonable size. The operations performed by the InternalHOpt algorithm mostly consist
in bitwise operations between vectors in order to update the tableau. Thus, our algorithm can
greatly benefits from SIMD (Same Instruction Multiple Data) instructions which enable the simul-
taneous execution of some of these bitwise operations. This have for example been used in the
CHP stabilizer circuit simulator [23]. We also exploit this concept in our implementation of the
InternalHOpt procedure by using 256 bit wide Advanced Vector Extensions (AVX).
Benchmarks analysis. The results of our benchmarks are presented in Table 1. We can notice
that the InternalHOpt procedure outperforms the moveH procedure in term of execution time
on some circuits of large size. For instance, the Shor 32circuit was optimized in 173 seconds
by the InternalHOpt procedure while the two other methods did not succeed in optimizing the
circuit in less than a day. However, the InternalHOpt procedure alone does not always achieve
the best results in the number of internal Hadamard gates. For the set of circuits and methods
considered, the method achieving the best results in term of internal Hadamard gates is the TMerge +
InternalHOpt approach. Indeed, the TMerge +InternalHOpt approach always leads to a number
of internal Hadamard gates that is lower or equal to the numbers obtained by the moveH procedure.
This fact also holds for the number of Tgates. However, for some circuits, the performances of the
moveH procedure and the TMerge +InternalHOpt approach are similar with respect to the H-count
andT-count metrics, but the execution time of the moveH procedure is much lower. This is notably
the case for the adder circuits of large size. These adder circuits have a low depth and a high
number of qubits, which is far from the ideal case for TMerge +InternalHOpt approach since the
complexity of both procedures is dependent on the number of qubits. On the contrary, the moveH
procedure is not affected by the number of qubits as it has a complexity of O(M2) where Mis the
number of gates within the circuit. This explains why the moveH procedure is competitive for these
adder circuits and has an execution time that is close to the one of the InternalHOpt procedure.
Another series of circuits for which the moveH procedure is much faster than the TMerge +
InternalHOpt approach are the “GF(2n) Mult” circuits. This behaviour can be explained by
analyzing the structure of the “GF(2n) Mult” circuits and the design of the TMerge algorithm.
The “GF(2n) Mult” circuits are all implementing a sequence of Pauli rotations that are mutually
commuting, which is why no internal Hadamard gate is required for these circuits. In the worst
case, for every pair of Pauli rotations, the TMerge procedure will check whether two Pauli rotations
commute or not. This routine, which seems unnecessary in the case where we know that the Pauli
rotations are all mutually commuting, is particularly expensive for the “GF(2n) Mult” circuits for
which nis high since the number of Pauli rotations increases drastically with respect to n.
27Outlook. Our primary motivation for optimizing the number of internal Hadamard gate is to foster
the minimization of T-gates. Conversely, our benchmarks show that optimizing the number of T-
gate leads to better minimization in the number of internal Hadamard gates. This interdependence
between the T-count and H-count minimization problems could lead us to think that a second
round of T-count optimization followed by a H-count optimization could lead to a lower number
of internal Hadamard gates. Our investigations on that second round of optimization have not be
fruitful as we did not succeed in reducing the number of internal Hadamard gates below the numbers
obtained by the TMerge +InternalHOpt approach. It seems that once the TMerge procedure has
been performed, it becomes difficult to modify the underlying sequence of Pauli rotations in such
a way that it enables further reduction in the number of internal Hadamard gates. Our conclusion
here is only based on some of our tests, more investigations with a wide variety of T-count optimizers
should be performed to know whether or not this second round of optimization could lead to an
improvement in the number of internal Hadamard gates.
Two lines of investigations on how to perform the optimization of internal Hadamard gates
more efficiently can be drawn out from these benchmarks. Firstly, the TMerge procedure is out-
performed, with respect to the execution time, by the moveH procedure on some circuits such as
the “GF(2n) Mult” circuits, can the complexity of the TMerge procedure be improved so that it is
more competitive on these circuits? Secondly, is it possible to design an algorithm similar to the
moveH procedure, so that it has approximatively the same execution time, but which systematically
obtains the same number of Tgates as the TMerge procedure and which optimally minimizes the
number of internal Hadamard gates in the resulting sequence of Pauli rotations as done by the
InternalHOpt procedure?
7 Conclusion
We presented an algorithm to realize the synthesis of a sequence of Pauli rotations over the
{X,CNOT , S, H, R Z}gate set using a minimal number of Hadamard gates and with a time com-
plexity of O(n2m), in the typical case where n≤m, and where nis the number of qubits and m
is the number of Pauli rotations. A closely related problem is to optimize a Clifford+ RZcircuit
so that the sequence of Pauli rotations it is implementing contains a minimal number of internal
Hadamard gates, where a Hadamard gate is called internal if it is comprised between the first and
last non-Clifford RZgates of the circuit. Solving this problem is important to improve the efficiency
and scalability of algorithms minimizing the number of non-Clifford RZgates such as T-count op-
timizers, and to minimize the additional cost that comes with the Hadamard gates gadgetization
procedure. In Reference [10], the authors raised the question of whether this problem is solvable
inO(M2poly log( M)) time where Mis the number of gates in the input circuit. We answer this
question positively, in the case where n≤M/√
hand for a fixed sequence of Pauli rotations by
providing an algorithm solving this problem with a time complexity of O(nM+n2h) where nis the
number of qubits, Mis the number of gates in the input circuit and his the number of Hadamard
gates within the optimized circuit.
Our algorithms are optimal for a given sequence of Pauli rotations, however there may exist other
sequences of Pauli rotations, associated with the same operator, which could be implemented with
fewer Hadamard gates. An open problem is to find a sequence of Pauli rotations Simplementing
a given unitary gate up to a Clifford operator such that rank( A(S)) is minimal, where A(S)is the
commutativity matrix associated with Sas defined in Section 3. Should there exist an algorithm
solving this problem in reasonable time, then it could be used in conjunction with our algorithms
28to implement a unitary gate over the Clifford+ RZgate set with a minimal number of internal
Hadamard gates.
Acknowledgments
We acknowledge funding from the Plan France 2030 through the projects NISQ2LSQ ANR-22-
PETQ-0006 and EPIQ ANR-22-PETQ-007.
References
[1] Matthew Amy, Dmitri Maslov, and Michele Mosca. Polynomial-time T-depth optimization of
Clifford+ T circuits via matroid partitioning. IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems , 33(10):1476–1489, 2014.
[2] David Gosset, Vadym Kliuchnikov, Michele Mosca, and Vincent Russo. An algorithm for the
T-count. Quantum Information & Computation , 14(15-16):1261–1276, 2014.
[3] Nabila Abdessaied, Mathias Soeken, and Rolf Drechsler. Quantum Circuit Optimization by
Hadamard Gate Reduction. In Shigeru Yamashita and Shin-ichi Minato, editors, Reversible
Computation , pages 149–162, Cham, 2014. Springer International Publishing.
[4] Matthew Amy and Michele Mosca. T-count optimization and Reed–Muller codes. IEEE
Transactions on Information Theory , 65(8):4771–4784, 2019.
[5] Yunseong Nam, Neil J Ross, Yuan Su, Andrew M Childs, and Dmitri Maslov. Automated
optimization of large quantum circuits with continuous parameters. npj Quantum Information ,
4(1):1–12, 2018.
[6] Luke E Heyfron and Earl T Campbell. An efficient quantum compiler that reduces T count.
Quantum Science and Technology , 4(1):015004, 2018.
[7] Aleks Kissinger and John van de Wetering. Reducing the number of non-Clifford gates in
quantum circuits. Physical Review A , 102(2):022406, 2020.
[8] Fang Zhang and Jianxin Chen. Optimizing T gates in Clifford+T circuit as π/4 rotations
around Paulis. arXiv preprint arXiv:1903.12456 , 2019.
[9] Niel de Beaudrap, Xiaoning Bian, and Quanlong Wang. Techniques to Reduce π/4-Parity-
Phase Circuits, Motivated by the ZX Calculus. arXiv preprint arXiv:1911.09039 , 2019.
[10] Niel de Beaudrap, Xiaoning Bian, and Quanlong Wang. Fast and Effective Techniques for
T-Count Reduction via Spider Nest Identities. In 15th Conference on the Theory of Quantum
Computation, Communication and Cryptography (TQC 2020) , volume 158, pages 11:1–11:23,
2020.
[11] Anthony Munson, Bob Coecke, and Quanlong Wang. AND-gates in ZX-calculus: spider nest
identities and QBC-completeness. arXiv preprint arXiv:1910.06818 , 2019.
[12] Michele Mosca and Priyanka Mukhopadhyay. A polynomial time and space heuristic algorithm
for T-count. Quantum Science and Technology , 7(1):015003, 2021.
29[13] Sergey Bravyi and Alexei Kitaev. Universal quantum computation with ideal Clifford gates
and noisy ancillas. Physical Review A , 71(2):022316, 2005.
[14] H´ ector Bomb´ ın and Miguel Angel Martin-Delgado. Quantum measurements and gates by code
deformation. Journal of Physics A: Mathematical and Theoretical , 42(9):095302, 2009.
[15] Clare Horsman, Austin G Fowler, Simon Devitt, and Rodney Van Meter. Surface code quantum
computing by lattice surgery. New Journal of Physics , 14(12):123011, 2012.
[16] Sergey Bravyi and David Gosset. Improved classical simulation of quantum circuits dominated
by Clifford gates. Physical review letters , 116(25):250501, 2016.
[17] Sergey Bravyi, Dan Browne, Padraic Calpin, Earl Campbell, David Gosset, and Mark Howard.
Simulation of quantum circuits by low-rank stabilizer decompositions. Quantum , 3:181, 2019.
[18] Hammam Qassim, Hakop Pashayan, and David Gosset. Improved upper bounds on the stabi-
lizer rank of magic states. Quantum , 5:606, 2021.
[19] Aleks Kissinger and John van de Wetering. Simulating quantum circuits with ZX-calculus
reduced stabiliser decompositions. Quantum Science and Technology , 2022.
[20] Aleks Kissinger, John van de Wetering, and Renaud Vilmart. Classical simulation of quantum
circuits with partial and graphical stabiliser decompositions. arXiv preprint arXiv:2202.09202 ,
2022.
[21] Gadiel Seroussi and Abraham Lempel. Maximum likelihood decoding of certain Reed-Muller
codes (corresp.). IEEE Transactions on Information Theory , 29(3):448–450, 1983.
[22] Michael J Bremner, Richard Jozsa, and Dan J Shepherd. Classical simulation of commuting
quantum computations implies collapse of the polynomial hierarchy. Proceedings of the Royal
Society A: Mathematical, Physical and Engineering Sciences , 467(2126):459–472, 2011.
[23] Scott Aaronson and Daniel Gottesman. Improved simulation of stabilizer circuits. Physical
Review A , 70(5):052328, 2004.
[24] Matthew Amy, Parsiad Azimzadeh, and Michele Mosca. On the controlled-NOT complexity
of controlled-NOT–phase circuits. Quantum Science and Technology , 4(1):015002, 2018.
[25] Dmitri Maslov and Martin Roetteler. Shorter stabilizer circuits via Bruhat decomposition and
quantum circuit transformations. IEEE Transactions on Information Theory , 64(7):4729–4738,
2018.
[26] Timoth´ ee Goubault de Brugi` ere, Simon Martiel, and Christophe Vuillot. A graph-state based
synthesis framework for Clifford isometries. arXiv preprint arXiv:2212.06928 , 2022.
[27] Vivien Vandaele, Simon Martiel, and Timoth´ ee Goubault de Brugi` ere. Phase polynomials
synthesis algorithms for NISQ architectures and beyond. Quantum Science and Technology ,
7(4):045027, 2022.
[28] Craig Gidney. Stim: a fast stabilizer circuit simulator. Quantum , 5:497, 2021.
[29] Will Simmons. Relating Measurement Patterns to Circuits via Pauli Flow. arXiv preprint
arXiv:2109.05654 , 2021.
30[30] Matthew Amy. Feynman. https://github.com/meamy/feynman .
[31] Dmitri Maslov. Reversible Logic Synthesis Benchmarks page. http://webhome.cs.uvic.ca/
~dmaslov . Accessed February 2023.
[32] Yasuhiro Takahashi, Seiichiro Tani, and Noboru Kunihiro. Quantum addition circuits and
unbounded fan-out. Quantum Information & Computation , 10(9):872–890, 2010.
[33] Kyungbae Jang, Anubhab Baksi, Jakub Breier, Hwajeong Seo, and Anupam Chattopadhyay.
Quantum Implementation and Analysis of DEFAULT. Cryptology ePrint Archive, Paper
2022/647, 2022. https://eprint.iacr.org/2022/647 .
[34] Xiaoning Bian. STOMP-code. https://github.com/onestruggler/stomp-code/tree/
8df4f46228c2f413e0cf5f8b6d25c20b6460fc0e .
[35] https://github.com/VivienVandaele/quantum_circuit_optimization , 2023.
A Diagonalization network synthesis example
In this section we provide a detailed execution example of Algorithm 1 which performs the synthesis
of a diagonalization network for a given sequence of Pauli products. Let Sbe the sequence of Pauli
products given as input to Algorithm 1 and defined as follows:
S=Z
X
=
1 1 1 0
0 1 0 1
0 1 0 0
1 0 1 1
0 1 1 0
0 0 1 1
.
The algorithm starts by diagonalizing the Pauli product represented by the first column of S.
This is done by inserting a Sgate in the circuit followed by a Hadamard gate on the first qubit.
The matrix Sencoding the sequence of Pauli products is updated by performing the operations
associated with the SandHgates, as depicted in Figure 1. Then, the first column is removed from
the matrix and the algorithm performs a recursive call on the updated matrix.
S H
0 1 1
1 0 1
1 0 0
1 0 1
1 1 0
0 1 1

This time, the first column of the lower matrix has a Hamming weight greater than one. There-
fore, the algorithm inserts a CNOT gate acting on the first and second qubits of the circuit to
reduce the Hamming weight of the first column of the lower matrix to one. The Pauli product
encoded by the first column can then be diagonalized by inserting a Sgate and a Hadamard gate
on the first qubit. Then, the matrix is updated, the first column is removed from the matrix and
the algorithm performs a recursive call.
31S H S H
0 1
0 1
0 0
1 1
1 1
1 1

Again, the first column of the lower matrix has a Hamming weight greater than one. This time
two CNOT gates must be inserted in the circuit to reduce it to one. After that, a Hadamard gate
is inserted to diagonalize the Pauli product encoded by the first column.
S H S H H
1
1
0
0
0
0

Finally, the Pauli product encoded by the remaining column is already diagonal. Therefore, the
algorithm simply removes the column from the matrix. The matrix is then empty so the algorithm
terminates by returning the constructed circuit, which is a diagonalization network for the sequence
of Pauli products encoded by S.
We can then insert {CNOT , RZ}subcircuits in the appropriate places to implement the sequence
of Pauli rotations associated with Sup to a final Clifford circuit. The following figure shows an
example of a possible circuit obtained after this procedure.
S H RZ S H RZ H RZ RZ
The commutativity matrix A(S)associated with Sis
A(S)=
0 1 0 1
0 0 1 1
0 0 0 0
0 0 0 0
.
As stated by Theorem 1, we can notice that the number of Hadamard gates in the circuit
produced by Algorithm 1 is equal to rank( M) where M=X
A(S)
.
32
NASimEmu: Network Attack Simulator & Emulator
for Training Agents Generalizing to Novel Scenarios
Jaromír Janisch , Tomáš Pevný , and Viliam Lisý
Artificial Intelligence Center, Department of Computer Science,
Faculty of Electrical Engineering, Czech Technical University in Prague
{jaromir.janisch, tomas.pevny, viliam.lisy}@fel.cvut.cz
Abstract. Current frameworks for training offensive penetration testing agents
with deep reinforcement learning struggle to produce agents that perform well
in real-world scenarios, due to the reality gap in simulation-based frameworks
and the lack of scalability in emulation-based frameworks. Additionally, existing
frameworks often use an unrealistic metric that measures the agents’ performance
on the training data. NASimEmu, a new framework introduced in this paper,
addresses these issues by providing both a simulator and an emulator with a shared
interface. This approach allows agents to be trained in simulation and deployed in
the emulator, thus verifying the realism of the used abstraction. Our framework
promotes the development of general agents that can transfer to novel scenarios
unseen during their training. For the simulation part, we adopt an existing simulator
NASim and enhance its realism. The emulator is implemented with industry-level
tools, such as Vagrant, VirtualBox, and Metasploit. Experiments demonstrate that
a simulation-trained agent can be deployed in emulation, and we show how to
use the framework to train a general agent that transfers into novel, structurally
different scenarios. NASimEmu is available as open-source.
1 Introduction
Artificial intelligence and machine learning techniques have become increasingly im-
portant in the field of automated penetration testing [ 3]. Deep reinforcement learning
(RL) is an especially promising tool for offensive penetration testing and in recent years,
a number of frameworks were created to train deep RL agents. While surveying the
capabilities of the existing frameworks, we identified important deficiencies.
The first issue is that no existing framework provides means to train deep RL agents
efficiently whilst ensuring that they can be deployed in real systems. In general, the
frameworks can be divided into two groups, simulators [ 12,18] and emulators [ 11,19].
Simulators provide an in-memory abstraction of processes that happen in real computer
networks and are much faster and easier to use than their real counterparts. Deep RL
algorithms are notoriously sample-inefficient, unstable and require large batches to train
properly [ 15,14,17]. Hence, simulators are perfect to generate the data these algorithms
need, possibly training multiple agents in parallel and discarding those that fail. However,
the simulators often suffer from the reality gap , where the level of the used abstraction
makes it impossible to deploy the trained agents in real systems. For example, the authorsarXiv:2305.17246v2  [cs.CR]  18 Aug 20232 Janisch, Pevný, Lisý
of CyberBattleSim [ 12] themselves argue that their framework is too simplistic to be
used in the real world.
Contrarily, emulators are well-grounded in reality, as they use virtual machines with
real operating systems (OSs), services and processes, connected in a virtualized computer
network. While they are realistic and provide a controlled way to test autonomous agents,
they are slow and not scalable for the demands of deep RL training.
Second, the metric used to measure the agents’ performance is often ill-defined,
which manifests in the frameworks’ unrealistic design decisions. It is a common practice
to train and test the agents in the same, static network and measure the number of training
steps it takes to learn the optimal path to penetrate this particular network [ 18,22,5].
Given this goal, the frameworks often do not allow training agents in different scenarios
simultaneously and promote implementing agents that can solve one particular network,
but do not transfer to others. However, in the real world, agents would be deployed into
a network with little information about its segmentation, hosts’ configuration and the
location of sensitive information. Hence, agents’ performance should be measured as
how well they do in these unknown networks not encountered during the training. Using
this objective makes the problem much more difficult and immediately brings multiple
challenges. For example: How to create an agent that is invariant to possible variations
in size, topology and configuration of real networks? When should the agent stop the
penetration testing, given that the location and number of hosts with sensitive data is
unknown?
To study the novel challenges, a new framework that respects the associated require-
ments is needed. It must be designed with a realism-first approach, not succumbing to
the requirements of deep RL and it must provide both simulation to train the agents
and emulation to verify that the level of abstraction is realistic. This paper presents
Network Attack Simulator & Emulator (NASimEmu), a framework that satisfies these
conditions. To this end, we implemented a realistic emulator and adapted an existing
NASim simulator [ 18] to be aligned with the requirements the emulator produced. Both
the simulator and emulator share the same OpenAI Gym [ 2] interface and everything
that is possible in one can be done in the other.
The NASimEmu simulator facilitates training by providing observations that sum-
marize the information gathered so far. It comes with several predefined scenarios to
benchmark agents and encourages the implementation of general agents by allowing
training and testing in multiple distinct scenarios. Many different networks can be gener-
ated from a single scenario description with random variations in the number of hosts in
subnets and their configuration. The framework does not leak unrealistic information
(e.g., the number of hosts in the observation size) and the episode termination is left to
the agent, which incentivizes the researchers to search for new solutions. Also, it comes
with a tool to visualize the agents’ knowledge to ease debugging.
The NASimEmu emulator is based on Vagrant, an industry-level tool for managing
virtual networks, VirtualBox, routing and traffic filtering with a Mikrotik RouterOS host
and an attacker node running MetaSploit. It comes with configurable Linux and Windows
machines, based on Metasploitable3 images, with pre-defined vulnerable services to
choose from. Crucially, the emulator implements an interface common with the simulator,
and it translates agents’ actions into MetaSploit commands and reconstructs observationsNASimEmu: Network Attack Simulator & Emulator 3
from the resulting logs. Any scenario generated for the simulator can be translated to the
emulation with a single command and an agent trained in simulation can be seamlessly
deployed in emulation.
In Experiments, we demonstrate two key points. First, we show that the commonly
used metric of measuring the agents’ performance on their training data is insufficient and
unrealistic and demonstrate how our simulator promotes the development of a general
agent. We leverage the ability to train the agents in multiple distinct random scenarios
and test in others and show how different model architectures influence the agents’
generalization. Specifically, we train two baseline agents with different architectures
using PPO [ 17], a deep RL method. We demonstrate that while a commonly used
architecture based on matrix inputs performs well in the training scenarios, it transfers
poorly to novel scenarios that differ in topology and size. Hence, we implement a second,
invariant architecture, and show initial evidence that it performs well both on the training
andnovel scenarios. In a separate experiment, we demonstrate that a simulation-trained
agent can be successfully deployed in the emulator, therefore verifying that the simulator
abstraction is realistic.
NASimEmu is available at https://github.com/jaromiru/NASimEmu. A separate
repository https://github.com/jaromiru/NASimEmu-agents contains the deep RL agents.
Our contributions are summarized below:
–We introduce a new framework that provides both the simulator and emulator .
Agents trained in simulation can be seamlessly deployed in emulation, which we
experimentally demonstrate. This fact shows that the simulator is realistic.
–Instead of measuring agents’ performance on their training set, we argue that a more
useful metric is their performance in novel scenarios. We design our framework
to encourage training general agents – it can generate random scenario instances
that vary in topology, size and configuration and can measure the performance in
separate, multiple and structurally different training and testing scenarios.
–We demonstrate that, under this new metric, new model architectures are required.
Specifically, we implement a size-invariant model that transfers to novel and
structurally different settings , while the commonly used MLP architecture fails.
2 Related work
The existing penetration testing frameworks targetting RL can be separated into simula-
tors[18,12,20,6,1,7] and emulators [19,11,4]. However, none of the frameworks contains
both the simulator and emulator that would allow training the agent in the former and
seamlessly deploying it in the latter. NASimEmu includes both, and by doing it ensures
that the used abstraction is realistic. Note that although the authors of CybORG [ 20]
claim to have developed both the simulator and emulator, the latter was never published
and the authors confirmed via email that its development was discontinued. Several other
frameworks focus on the attacker vs. defender game [8,20,13,9,16,4].4 Janisch, Pevný, Lisý
3 Network Attack Simulator & Emulator
NASimEmu is separated into two parts – simulation and emulation (see Figure 2). The
simulation, based on NASim [ 18], can be used to train and evaluate agents. It is a memory-
based fast and parallelizable abstraction of real computer networks and can generate
random scenario instances which can vary in network topology, configuration and number
of hosts. The emulation is a controlled environment that runs virtual machines and it
verifies that the simulation abstraction is realistic. Agents trained in simulation can be
transparently deployed in emulation.
3.1 Simulator
The simulator is based on Network Attack Simulator (NASim) [ 18] and it is a memory-
based abstraction of the processes that happen in a real network. It contains hosts
with their configuration and status and simulates the network communication and other
processes, based on the actions received from an agent. After each action, an observation
is returned. Many simulations can be run in parallel (e.g., in our experiments, we use
256 environments). Below, we describe the simulator at a high-level and refer the reader
to [18] for additional details. At the end, we list of changes made to the original NASim.
The network is defined by a scenario , which describes the network topology, host
configuration (OS, services, processes and sensitivity), exploits and privilege escalations.
The topology describes the network division into subnets where a firewall blocks all
communication between disconnected subnets and allows it otherwise.
NASimEmu supports three ways of scenario creation. Static scenarios describe
precisely the whole network and hosts’ configuration. Random scenario are completely
randomly generated, based on the prescribed parameters (e.g., size of the network,
number of exploits, etc.). We add support for dynamic scenarios that enhance the
variability of static scenarios. The motivation is to describe prototypical situations, e.g.,
typical university or corporate networks, while the details in scenario instances vary.
In the real world, some objects (OSs, services, exploits, etc.) can be listed upfront and
stay true in all scenarios. Dynamic scenarios are partially fixed and some properties are
left to chance. In particular, the number of hosts in subnets and hosts’ configuration
can be randomized, while the network topology and lists of possible OSs, services,
processes, exploits and privilege escalations stay fixed. The chance that a host is sensitive
is determined by a scenario-defined subnet sensitivity.
During execution, the simulator maintains the current state of the network, which
contains states of each host as a vector specifying the host’s address, flags whether it has
been compromised, reached and discovered, its value, current access level by the agent,
OS and a list of services and processes running on the host.
The following actions are available: Exploit (exploit_id, target) ,PrivilegeEscala-
tion(privesc_id, target) ,ServiceScan (target) ,OSScan (target) ,SubnetScan (target) ,Pro-
cessScan (target) andTerminalAction . All of the actions target a previously discovered
host. Commonly, the attacker cannot reach its target directly, but must proxy the commu-
nication through other controlled hosts. The simulator abstracts this away and allows
an action if a path to the target exists. We show that the path can be automatically
determined even in emulation.NASimEmu: Network Attack Simulator & Emulator 5
access level 
(id color)sensitivity
(node color)
auxiliary subnet nodelast performed action discovered services
Fig. 1: Example rendered observation for debugging purposes. It graphically shows the
discovered nodes, their known services, access levels, sensitivity and the last action.
The actions are parametrized and the specific implementation into the RL agents is
left to the user. A most simple way is to combine all actions and their parameters to get
a list of grounded actions. Another way is to use a RL framework capable of working
with parametrized actions, e.g., [ 10]. When an action is performed, the internal state
changes accordingly and an observation is returned. The observation is partial (i.e., only
the discovered hosts are included) and it summarizes all the information gathered by the
agent in the current episode.
There is a small negative reward for each step and the positive reward is only given
when the agent gains privileged access to a sensitive host. The simulator never terminates
an episode unless TerminalAction is received. Simply terminating an episode when
all sensitive hosts are exploited does not correspond to the real world, where such
information is unavailable. Still, the agent’s behavior can be hard-coded to terminate
after a specific number of steps, although we encourage the users to implement agents
that can decide to terminate themselves.
To encourage training for generalization, the simulator accepts multiple scenarios
for training or testing, one of which is randomly chosen for each episode. To ease the
subsequent processing of observations by agents’ models, the sizes of host vectors are
united across all scenarios. However, the overall observation size still varies, depending
on the number of visible hosts and total hosts in the scenario instance. To ease debugging,
the environment also provides an observation visualizer that shows discovered hosts and
their services, gained access levels, which hosts are sensitive and the last action (see
Figure 1).6 Janisch, Pevný, Lisý
Table 1: Services, exploits and privilege escalations in the NASimEmu emulator.
service OS port exploit action msf module access exploit IDs
ProFTPD Linux 21 e_proftpd proftpd_modcopy_exec user CVE-2015-3306
Drupal Linux 80 e_drupal drupal_coder_exec user SA-CONTRIB-
2016-039
PhpWiki Linux 80 e_phpwiki phpwiki_ploticus_exec user CVE-2014-5519
WordPress Windows 80 e_wp_ninja wp_ninja_forms_... user CVE-2016-1209
ElasticSearch Windows 9200 e_elasticsearch script_mvel_rce root CVE-2014-3120
MySQL Linux & 3306 - - - -
Windows
Linux kernel Linux local pe_kernel overlayfs_priv_esc root CVE-2015-1328
CVE-2015-8660
Below we summarize the changes made to the original NASim:
–The new dynamic scenarios support random variations while fixing certain objects.
–Agents can be trained or tested in multiple scenarios simultaneously (a random
scenario is chosen from a list in each episode).
–The sizes of host vectors are united across all scenarios.
–The simulator randomly permutes the node and segment IDs at the beginning of the
episode to prevent memorization of fixed addresses.
–Observations keep the revealed information so far to help the agent remember the
results of past actions.
–The environment does not trigger the end of an episode. The agent has to terminate
with TerminalAction .
–The observations are optionally returned as a graph with nodes representing subnets
and individual hosts.
–The observations can be visualized.
3.2 Emulator
The emulator is an important part of NASimEmu that uses virtual machines and network-
ing to let the agent interact with a controlled, but real environment. It can substitute the
simulator and contains necessary wrappers to translate agents’ actions into instructions
for the attacker machine, and it reconstructs the observations from the resulting logs.
Having the emulator where simulation-trained agents can be deployed is important, since
it verifies that the simulation abstraction is realistic .
The emulator uses Vagrant to manage a network of virtual hosts. The individual
hosts run in VirtualBox and are based on configurable Metasploitable images. A single
RouterOS instance acts as a router and firewall and segments the network into subnets.
The attacker host runs Kali Linux with Metasploit that is remotely connected to the
NASimEmu interface (see Figure 2). Every action that an agent issues is translated into
a command for the Metasploit framework, executed and the result is processed back
into the NASimEmu observation. Importantly, Metasploit on the attacker machine isNASimEmu: Network Attack Simulator & Emulator 7
agentsimulation / emulation
environment
rewards
observationsactions
emulation
observations actions
RPC
callsmetasploit
controllerobservation
converter
vagrant
virtual machineslogs
Fig. 2: Left: The RL environment of NASimEmu with a substitutable simulation and
emulation. Right: The emulator translates agents’ actions to commands for the Metas-
ploit framework that runs on the attacker machine and recreates observations from the
resulting logs. Simulation-trained agents can be seamlessly deployed in the emulator.
automatically configured to route the traffic to newly discovered parts of the network
through the controlled hosts that discovered them. Hence, the path from the attacker to a
target node can be determined automatically for any action.
TheExploit andPrivilegeEscalation actions are translated into predefined Metasploit
modules (see Table 1). The ServiceScan performs a port scan and based on the result, it
may perform additional checks (e.g., connect to and determine installed services on the
HTTP server). OSScan tries to fingerprint the OS of the target. SubnetScan performs ping
sweep from the controlled target machine, where we use the fact that ping is installed by
default both on Linux and Windows. Since we currently do not implement any processes
in NASimEmu, ProcessScan does nothing. In future versions, it would return a list of
local processes that can be leveraged through privilege escalation. TerminalAction is a
meta action that is not translated, but instead instructs the framework to end the process.
It is possible to extend NASimEmu with new services, processes or exploits. Services
or processes require installation and start scripts and the detection procedure needs to
be implemented for the ServiceScan orProcessScan actions. For exploits and privilege
escalations, Metasploit must contain the corresponding modules and action and observa-
tion converters that control Metasploit and reconstruct observations from logs must be
implemented. Finally, a unique identifier for the new service, process, exploit or privilege
escalation has to be added to a scenario description.
Currently, NASimEmu supports configurable Linux and Windows machines. We
have implemented six services, five of which are exploitable and Linux machines are
vulnerable to a privilege escalation attack (see Table 1 for the complete list). The sensitive
data is modeled as a specific file at the root of the filesystem ( /loot orc:/loot ).
It contains a unique string and is accessible only by the privileged user, although the
file is visible by any user. Hence, the agent can determine whether the host contains
the sensitive information when it gains any access, but can recover it only through the
privileged user.
Any NASimEmu scenario can be instantiated into a Vagrantfile descriptor. Upon
user command, the network is populated with virtual machines and their services are
disabled or enabled as defined in the descriptor. For example:8 Janisch, Pevný, Lisý
NASimEmu$ ./setup_vagrant.sh scenario.v2.yaml
NASimEmu/vagrant$ vagrant up
Bringing machine ’router’ up with ’virtualbox’ provider...
Bringing machine ’attacker’ up with ’virtualbox’ provider...
Bringing machine ’target10’ up with ’virtualbox’ provider...
Bringing machine ’target40’ up with ’virtualbox’ provider...
[...]
3.3 Known limitations
We strive to be transparent about the capabilities of our framework. Despite the efforts
to make NASimEmu realistic, it still comes with a few shortcomings associated with
the level of abstraction in the simulation. We hypothesize that most of the issues can be
removed by modifying the simulation, but leave it to future work.
Different versions of the same service can be modeled with unique identifiers and in
the emulation, the controller needs to fingerprint these services. However, our implemen-
tation does not currently cover the case where it is not possible to tell service versions
apart.
NASimEmu creates scenario instances where the hosts’ configuration is indepen-
dently randomized. In reality, the configurations are likely to be correlated to other hosts
in subnets. While NASimEmu builds upon NASim [ 18] and can generate correlated host
configurations for totally random scenarios (i.e., when the topology, hosts’ configuration
and even OSs, services, processes, exploits and privilege escalations are randomly gener-
ated), it cannot be yet done for the new dynamic scenarios, where certain objects stay
fixed.
The abstraction of NASimEmu does not include storing and using discovered creden-
tials. We hypothesize that their inclusion should be possible, e.g., by taking inspiration
from [12].
When an agent performs an exploit, it is assumed to work if there is a corresponding
service running on the host. In reality, this is not always the case – the service may be
configured in various ways, patched, etc.
The firewall currently blocks or allows all traffic between subnets, based on the
network topology. With this assumption, the agent can specify only the action target,
while the source is determined automatically (it is the path the host was discovered from).
However, in real networks, firewalls may block only certain ports, while allowing them
from different sources.
In NASimEmu, only the attacker is modeled. Honeypots can be modeled in the
network with a negative reward, but an adversarial defender currently cannot.
4 Experiments
We designed two experiments in which we aim to a)demonstrate how to use our
framework to train an agent that generalizes to novel scenarios and b)verify that a
simulation-trained agent can be deployed in emulation. To this end, we implemented two
baseline agent models and eight simple scenarios, described in the following sections.NASimEmu: Network Attack Simulator & Emulator 9
Note that the environment does not have a terminating condition and we leave this
question to further research. For the sake of our experiments, we limit the number of
steps per episode to 20, hence the goal is to maximize the reward in this time limit (i.e.,
gain access to as many sensitive hosts as possible).
4.1 Agent models
We postulate that for the agent to be successful in novel scenarios, it must be size-and-
permutation invariant wrt. the hosts, be aware of the subnet connections and remember
the results of its actions. Invariance is important to support the ever-changing topologies
of different scenarios. Awareness of segment connections is required to tell the scenarios
apart. Memory is beneficial, because some action results are not reflected in observations.
For example, the SubnetScan action does not change the observation if the scan reveals
nothing new. Yet, the fact that the action was performed is important for future decisions.
However, the main goal of this paper is to demonstrate the capabilities of the new
framework, not to solve all of the aforementioned challenges. For this purpose, we
implement two baseline models. The first is a commonly used fixed MLP, and the other
is a size-invariant model (see Figure 3). Neither of these models is aware of the subnet
connections nor has any memory.
The MLP model is a simple, fixed-architecture feed-forward neural network. The
observed host feature vectors are concatenated and zero-padded to the limit of 30
hosts. The input is processed with a single fully-connected layer with LeakyReLU
activation. The output is processed with two separate heads. The first one is a linear layer
outputting the state value and the second is a linear layer followed by softmax, outputting
probabilities for all possible actions (with size 30×action_dim ). When selecting an
action, the actions corresponding to the padding are masked out, so that the model can
choose only from the available actions.
There are several limitations to the MLP model. It has a limited capacity and its
input is inherently ordered. Each of the input host vectors is treated uniquely and each
position has its own weights in the model. Hence, transformations learned for a host
vector in one position are not applicable to different positions. Because of the padding,
different parts of the network receive different amounts of training. We try to address
these issues with the second model.
The invariant model processes each host feature vector individually with a shared
embedding function, implemented as a linear layer with LeakyReLU activation. The
outputs are aggregated with their concatenated element-wise mean and maximum. This
aggregation is concatenated back to the hosts’ embeddings and each is processed with
a linear layer. These outputs are concatenated and passed through softmax, producing
probabilities for all possible actions. Separately, the aggregation is processed with a
linear layer to output the state value. The host vectors are augmented with a sine-cosine
positional embedding [ 21] of the order the hosts were discovered. It informs the agent
about its attack path, where it entered the network and which hosts it discovered last.
Note that the MLP can implicitly access the same information because its input is ordered
in the same way. Moreover, this positional embedding is not applicable to the MLP, since
it would append the same constant to every input, which can be reduced to a scalar bias.10 Janisch, Pevný, Lisý
padding
host features
(fully connected FFNN)
action matrix
softmax
masked actions
state value
MLP
(fully connected FFNN)
(a) MLP architecture; ϕMLP is a fully connected neural network with one non-linear and one
linear layer
host features
emb
emb
emb
emb
emb
emb
emb
emb
aggregation
concat(max, mean)
concat
action vectors
concat
&
softmax
act
act
act
act
act
act
act
act
V
state value
(b) invariant architecture; ϕembis a non-linear layer, ϕactandϕVare linear layers
model max hosts layer depth # params
MLP 30 2 77 294
invariant ∞ 2 4 684
Fig. 3: Tested model architectures. a)The MLP architecture’s capacity is capped to a
specific number of hosts and learns position-dependent weights. b)The invariant archi-
tecture can process unlimited number of hosts and is better equiped for generalization
due to weight sharing, while using a fraction of the parameters.
This second model is size-invariant and its architecture provides an inductive bias. It
can process an unlimited number of hosts and anything learned about one host can be
directly applied to another. Hence we hypothesize that it should outperform the MLP in
out-of-distribution scenarios.
Both models are trained with a deep RL algorithm PPO [ 17], using 8 consecutive
steps from 256 parallel environments as a training batch. Each epoch consists of 100
training steps, equaling to 204 800 environment steps. The training is performed on CPU
only, using 2 cores of Intel Xeon Scalable Gold 6146 and 4GB of RAM. Each epoch
takes about 6 minutes, so that an experiment with 200 epochs takes about 20 hours. The
exact implementation with all hyperparameters can be found in the published code.NASimEmu: Network Attack Simulator & Emulator 11
Attacker
Subnet A (DMZ)
nodes=[1], sensitivity=0.0
Subnet B (user)
nodes=[2-5], sensitivity=0.0
(a)sm_entry_dmz_one_subnet
Attacker
Subnet A (DMZ)
nodes=[1], sensitivity=0.0Subnet B (user)
nodes=[2-5], sensitivity=0.0
Subnet C (service)
nodes=[2-5], sensitivity=0.7 (b)sm_entry_dmz_two_subnets
Attacker
Subnet A (DMZ)
nodes=[1], sensitivity=0.0
Subnet B (user)
nodes=[2-5], sensitivity=0.0Subnet C (service)
nodes=[2-5], sensitivity=0.7
Subnet D (db)
nodes=[1-3], sensitivity=1.0
(c)sm_entry_dmz_three_subnets
AttackerSubnet A (DMZ)
nodes=[1], sensitivity=0.0
Subnet B (user)
nodes=[2-5], sensitivity=0.0Subnet C (service)
nodes=[2-5], sensitivity=0.7
Subnet D (db)
nodes=[1-3], sensitivity=1.0 (d)sm_entry_user_three_subnets
Fig. 4: The topologies of different scenarios. Node color and radius depict the number
of nodes and the probability of their sensitivity in the corresponding subnets. When a
scenario is instantiated, a network is randomly generated to conform to the scenario
description. Apart from small scenarios ( sm), medium versions ( md, not shown) have
the same topology, but the subnet sizes are changed from 1, 1-3 and 2-5 to 1, 4-6 and
6-10, respectively.
4.2 Scenarios
In the following experiments, we use four prototypical scenarios. Each of them comes in
two variations, small ( sm) and medium ( md), which differ in subnet sizes (see Figure 4).
The scenarios are designed to be simple, yet to provide a challenge.
In the first scenario, entry_dmz_one_subnet , the agent initially sees the DMZ (De-
Militarized Zone) subnet, which contains only a single exploitable node. After gaining
access, the agent can use this node to attack the user segment. As seen in Figure 4a,
this scenario does not contain any sensitive nodes. The optimal behavior would be
to terminate the attack as soon as the agent identifies it is deployed in this scenario.
Although our baseline agents cannot do this, we still include the scenario to make the
learning harder and to provide a challenge to future agents.
Second scenario entry_dmz_two_subnets adds an additional sensitive segment behind
theDMZ . In general, if an agent is randomly deployed in the first two scenarios, the12 Janisch, Pevný, Lisý
challenge is to identify which it is and either terminate the attack or proceed to the
sensitive segment.
Third scenario entry_dmz_three_subnets adds more complexity by including a highly
sensitive dbsegment behind the user segment. To see the dbsegment, the agent must
first successfully attack the user segment. The challenge is to distinguish the user and
service segments.
Fourth scenario entry_user_three_subnets is a variation of the previous scenario,
where the attacker starts with access to the user segment, instead of the DMZ .
When trained in all scenarios at once, our baseline agents do not have the capability to
solve them optimally. The first challenge is when to terminate the episode. As mentioned,
if the agent identifies it is deployed in entry_dmz_one_subnet , the optimal strategy is
to terminate. However, our agents cannot do that. Second, memory is required to make
optimal decisions. If the agent is executed in entry_dmz_two_subnets and performs
SubnetScan to any node in the user subnet, it does not discover any new nodes and the
observation stays the same. This is crucial to distinguish the entry_dmz_two_subnets and
entry_dmz_three_subnets scenarios. However, our agents do not have memory and hence
are incapable of doing that. Therefore, we believe that there is room for improvement
and that the designed scenarios pose a good challenge for future agents.
In our scenarios, we use the MySQL service as an indication that the host can be
sensitive – it runs on all sensitive hosts and it can randomly run on non-sensitive ones.
As in the real world, the generated scenarios are not guaranteed to be solvable , i.e., it is
possible that some sensitive nodes are unreachable to the agent.
4.3 Experiment: Generalization to novel scenarios
We demonstrate our framework’s capabilities to train and test agents in multiple struc-
turally different scenarios with random variations. Specifically, we are interested in
agents’ generalization into substantially different settings that differ both in topology
and size. We design these two experiments:
sm2md: the agent is trained in small scenarios sm_entry_dmz_one_subnet and
sm_entry_dmz_two_subnets and tested in medium scenarios md_entry_dmz_three_subnets
andmd_entry_user_three_subnets . However, in this setting, the MLP model would be
impaired, because the training scenarios do not contain enough hosts to fill the model’s
capacity, and hence to train it properly. Therefore, we design the next experiment.
md2sm: the agent is trained in medium scenarios md_entry_dmz_one_subnet and
md_entry_dmz_two_subnets and tested in small scenarios sm_entry_dmz_three_subnets
andsm_entry_user_three_subnets .
The results in Figure 5-left show that in both experiments, the MLP and invariant
models converge to similar performance when evaluated in their training scenarios
(measured as an average reward per step). However, when tested in novel scenarios
(Fig. 5-right), the invariant model outperforms the MLP model in both experiment
variants. This experiment demonstrates that while our framework allows training for
generalization, it is also necessary to use appropriate architectures to see any benefits.
Machine learning practitioners have long used fixed models with matrix-like inputs
and outputs, and therefore we feel that pointing out this paradigm shift is especially
important. An example run of a trained agent can be seen in Appendix.NASimEmu: Network Attack Simulator & Emulator 13
0 25 50 75 100 125 150 175 200
epoch0.00.10.20.30.40.5reward per steptraining scenarios
MLP
invariant
0 25 50 75 100 125 150 175 200
epoch0.00.20.40.60.8novel scenarios
(a) sm2md experiment
0 25 50 75 100 125 150 175 200
epoch0.150.200.250.300.350.400.450.50reward per steptraining scenarios
MLP
invariant
0 25 50 75 100 125 150 175 200
epoch0.00.10.20.3novel scenarios
(b) md2sm experiment
Fig. 5: MLP and invariant models were trained in small and tested in medium scenarios,
and vice-versa. The y-axis is not comparable between experiments, nor between train vs.
novel settings. The plots show an average of six runs ± one standard deviation.
4.4 Experiment: Transfer to emulation
In this qualitative experiment, we are interested whether the agent trained in simulation
can be deployed in the emulation, which is a controlled version of the real world. If it can,
it suggests that the simulation is a valid abstraction of the real world. We trained the invari-
ant model in the simulator in sm_entry_dmz_one_subnet andsm_entry_dmz_two_subnets
scenarios and then created an emulated scenario instance of the latter. This scenario
contained 10 virtual hosts, including the router and the attacker nodes, and this whole
network was emulated on a single consumer-grade machine.
The experiment found that while there are small discrepancies between the simulation
and emulation, the agent was able to perform credibly in the emulation. Specifically,
it was able to scan and exploit individual hosts and pivot through the network to gain
access to firewalled parts. We tracked it for 17 steps, until it gained access to a sensitive
host and recovered the sensitive information. The complete commented emulation log
can be found in Appendix and in the following text, we reference its steps in parentheses.
Note that in a few cases, the agent performed a non-nonsensical ProcessScan and we
omitted the corresponding steps.14 Janisch, Pevný, Lisý
The agent started with scanning the initial DMZ node (0), where it found that it runs
ElasticSearch and WordPress and chose to exploit the latter. It gained user access (1),
and used it to scan further parts of the network (2), discovering four new hosts in subnets
192.168.3.0/24 and 192.168.4.0/24. The agent chose one host from the second subnet to
scan (3)and exploit its ProFTPD service (6-9) , but found that it does not contain any
sensitive information. Since the agent has been trained on instances of this scenario, it
could determine that the subnet 192.168.4.0/24 probably corresponds to the user subnet,
which does not contain any sensitive hosts. Therefore, it picked a host in the other subnet
to scan and exploit. It discovered that it ran ProFTPD, Drupal, PhpWiki and MySQL
services (14). The MySQL is an indication that the host could contain sensitive data,
hence the agent exploited its Drupal service (15, 16) , and found that the host is running
Linux and indeed contains sensitive information. It escalated its privileges by exploiting
the Linux kernel (17) and upon success, it recovered the sensitive information.
We noticed two differences between the simulation and emulation. First, real network
connectivity is sometimes unreliable and it leads to failed actions. Second, exploits can
sometimes fail without an obvious reason. However, in both of these cases, the agent
was able to recover simply by repeating the failed action. This was done automatically,
because the agent model is deterministic (i.e., it outputs the same action probabilities
given the same input). Since failed actions do not change the observation, the agent
usually repeats the same action.
5 Conclusion and future work
We introduced NASimEmu, a penetration testing framework to train RL agents that
includes both the simulator and emulator with a shared interface. Experimentally, we
verified that a simulation-trained agent can be deployed in the emulation, verifying the
simulation’s realism. Our framework promotes training for generalization by including
a generator that produces random scenario variations, differing in network size and
configuration. It also allows simultaneous training in multiple, structurally different
scenarios and testing in a separate set. We demonstrated that new architectures with
inductive biases are needed to successfully train a general agent that can transfer to novel
scenarios unseen during the training.
Still, many things are left for future work. In terms of the framework itself, the
emulator would benefit from the implementation of more exploits, privilege escalations,
OS fingerprinting, etc. The stability and scalability of the emulation should be more
rigorously explored. There are several known limitations listed in the article, such
as the firewall blocking or allowing all traffic. From the point of RL and machine
learning, different invariant architectures could be explored. The agents could benefit
from including memory and information about subnet connections. The ability to learn
larger and more complex scenarios should be demonstrated. Finally, we have not explored
the stopping problem, i.e., the optimal point to stop penetrating the network.NASimEmu: Network Attack Simulator & Emulator 15
Acknowledgements
This research was supported by The Czech Science Foundation (grants no. 22-32620S
and 22-26655S). The research partly used GPUs donated by the NVIDIA Corporation.
The authors acknowledge the support of the OP VVV funded project CZ.02.1.01/0.0/0.0/
16_019/0000765 “Research Center for Informatics”.
References
1.Andrew, A., Spillard, S., Collyer, J., Dhir, N.: Developing optimal causal cyber-defence
agents via cyber security simulation. In: Workshop on Machine Learning for Cybersecurity
(ML4Cyber) (07 2022)
2.Brockman, G., Cheung, V ., Pettersson, L., Schneider, J., Schulman, J., Tang, J., Zaremba, W.:
OpenAI gym. arXiv preprint arXiv:1606.01540 10(2016)
3.Buchanan, B., Bansemer, J., Cary, D., Lucas, J., Musser, M.: Automating cyber attacks. Center
for Security and Emerging Technology pp. 13–32 (2020)
4.ˇCeleda, P., ˇCegan, J., Vykopal, J., Tovar ˇnák, D., et al.: Kypo–a platform for cyber defence
exercises. M&S Support to Operational Tasks Including War Gaming, Logistics, Cyber
Defence. NATO Science and Technology Organization (2015)
5.Chen, J., Hu, S., Zheng, H., Xing, C., Zhang, G.: GAIL-PT: An intelligent penetration testing
framework with generative adversarial imitation learning. Computers & Security 126, 103055
(2023)
6.Chowdhary, A., Huang, D., Mahendran, J.S., Romo, D., Deng, Y ., Sabur, A.: Autonomous
security analysis and penetration testing. In: 2020 16th International Conference on Mobility,
Sensing and Networking (MSN). pp. 508–515. IEEE (2020)
7.Drašar, M., Moskal, S., Yang, S., Zat’ko, P.: Session-level adversary intent-driven cyberattack
simulator. In: 2020 IEEE/ACM 24th International Symposium on Distributed Simulation and
Real Time Applications (DS-RT). pp. 1–9. IEEE (2020)
8.Hammar, K., Stadler, R.: Finding effective security strategies through reinforcement learning
and self-play. In: 2020 16th International Conference on Network and Service Management
(CNSM). pp. 1–9. IEEE (2020)
9.Hammar, K., Stadler, R.: Learning intrusion prevention policies through optimal stopping.
In: 2021 17th International Conference on Network and Service Management (CNSM). pp.
509–517. IEEE (2021)
10.Janisch, J., Pevný, T., Lisý, V .: Symbolic relational deep reinforcement learning based on
graph neural networks. arXiv preprint arXiv:2009.12462 (2020)
11.Li, L., Fayad, R., Taylor, A.: CyGIL: A cyber gym for training autonomous agents over
emulated network systems. Proceedings of the 1st International Workshop on Adaptive Cyber
Defense (2021)
12.Microsoft: Cyberbattlesim. https://github.com/microsoft/cyberbattlesim (2021), created by
Christian Seifert, Michael Betser, William Blum, James Bono, Kate Farris, Emily Goren,
Justin Grana, Kristian Holsheimer, Brandon Marken, Joshua Neil, Nicole Nichols, Jugal
Parikh, Haoran Wei.
13.Miehling, E., Rasouli, M., Teneketzis, D.: Optimal defense policies for partially observable
spreading processes on bayesian attack graphs. In: Proceedings of the second ACM workshop
on moving target defense. pp. 67–76 (2015)
14.Mnih, V ., Badia, A.P., Mirza, M., Graves, A., Lillicrap, T., Harley, T., Silver, D., Kavukcuoglu,
K.: Asynchronous methods for deep reinforcement learning. In: International Conference on
Machine Learning. pp. 1928–1937 (2016)16 Janisch, Pevný, Lisý
15.Mnih, V ., Kavukcuoglu, K., Silver, D., Rusu, A.A., Veness, J., Bellemare, M.G., Graves,
A., Riedmiller, M., Fidjeland, A.K., Ostrovski, G., et al.: Human-level control through deep
reinforcement learning. Nature 518(7540), 529–533 (2015)
16.Molina-Markham, A., Miniter, C., Powell, B., Ridley, A.: Network environment design for
autonomous cyberdefense. arXiv preprint arXiv:2103.07583 (2021)
17.Schulman, J., Wolski, F., Dhariwal, P., Radford, A., Klimov, O.: Proximal policy optimization
algorithms. arXiv preprint arXiv:1707.06347 (2017)
18.Schwartz, J., Kurniawati, H.: Autonomous penetration testing using reinforcement learning.
arXiv preprint arXiv:1905.05965 (2019)
19. Sick, T., Biondi, F.: Purpledome: Simulation environment for attacks on computer networks.
https://github.com/avast/PurpleDome (2022), (visited on 09.02.2022)
20.Standen, M., Lucas, M., Bowman, D., Richer, T.J., Kim, J., Marriott, D.: CybORG: A gym for
the development of autonomous cyber agents. Proceedings of the 1st International Workshop
on Adaptive Cyber Defense (2021)
21.Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A.N., Kaiser, Ł.,
Polosukhin, I.: Attention is all you need. Advances in neural information processing systems
30(2017)
22.Yang, Y ., Liu, X.: Behaviour-diverse automatic penetration testing: A curiosity-driven multi-
objective deep reinforcement learning approach. arXiv preprint arXiv:2202.10630 (2022)NASimEmu: Network Attack Simulator & Emulator 17
A Appendix
Figure A.6 contains an example run from the simulation. The rest of the section describes
an emulation log from a different run. To produce this log, we trained the invariant model
insm_entry_dmz_one_subnet andsm_entry_dmz_two_subnets and deployed it into a
single emulated scenario instance generated from sm_entry_dmz_three_subnets . The
log below has been slightly modified for readability, commented and shows the first 17
steps, until the agent exploits a sensitive node.
To better understand the process, we provide a brief description of the classes that
appear in the log. EmulatedNASimEnv is the OpenAI Gym wrapper that receives raw
actions from the model and forwards them to EmulatedNetwork , a high-level virtual
network abstraction. Also, it creates observations from the log results. The action is
translated into single or multiple calls to Metasploit, performed by MsfClient .
Note that the scenario description is given to the agent just to inform it about what
OSs, services, processes, exploits and privilege escalation are available. However, no
information about the network itself is used.
1rrl-nasim$ python main.py -load_model trained_model.pt --trace sm_entry_dmz_two_subnets.v2.yaml --emulate
2
3# Initially, the agent automatically performs a scan of the network to determine which hosts are reachable.
4INFO:MsfClient:Connecting to msfrpcd at 127.0.0.1:55553
5INFO:EmulatedNASimEnv:reset()
6INFO:MsfClient:Executing auxiliary:scanner/portscan/tcp with params {’RHOSTS’: ’192.168.1-5.100-110’, ’PORTS’: ’22’, ’THREADS’: 10}
7INFO:MsfClient:Scan result: [’192.168.1.100:22’]
8# Below is the current observation of the agent. Compr. = Compromised; Reach. = Reachable; Disc. = Discovered
9+---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
10 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
11 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
12 | (1, 0) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
13 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
14
15 # Next, the agent scans the discovered node.
16 STEP 0
17 INFO:EmulatedNASimEnv:step() with ServiceScan: name=service_scan, target=(1, 0), cost=1.00, prob=1.00, req_access=USER
18 INFO:MsfClient:Executing auxiliary:scanner/portscan/tcp with params {’RHOSTS’: ’192.168.1.100’, ’PORTS’: ’21,80,3306,9200’, ’
,→THREADS’: 10}
19 INFO:MsfClient:Scan result: [’192.168.1.100:80’, ’192.168.1.100:9200’]
20 INFO:MsfClient:Executing auxiliary:scanner/http/dir_scanner with params {’RHOSTS’: ’192.168.1.100’, ’RPORT’: ’80’, ’THREADS’: 1, ’
,→DICTIONARY’: ’/vagrant/http_dir.txt’}
21 INFO:MsfClient:Folders found on the Http service: [’uploads’, ’wordpress’]
22 INFO:EmulatedNetwork:Found these services: {’21_linux_proftpd’: False, ’80_linux_drupal’: False, ’80_linux_phpwiki’: False, ’9200
,→_windows_elasticsearch’: True, ’80_windows_wp_ninja’: True, ’3306_any_mysql’: False} (192.168.1.100).
23
24 a: ServiceScan: name=service_scan, target=(1, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
25 V(s)=6.26
26 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
27 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
28 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
29 | (1, 0) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | True | True | False |
30 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
31
32 # As the agent sees that the host is running e_search service, it tries to exploit it.
33 STEP 1
34 INFO:EmulatedNASimEnv:step() with Exploit: name=e_wp_ninja, target=(1, 0), cost=1.00, prob=1.00, req_access=USER, os=windows,
,→service=80_windows_wp_ninja, access=1
35 INFO:MsfClient:Executing exploit:multi/http/wp_ninja_forms_unauthenticated_file_upload with params {’RHOSTS’: ’192.168.1.100’, ’
,→TARGETURI’: ’/wordpress/’, ’FORM_PATH’: ’index.php/king-of-hearts/’, ’RPORT’: ’80’, ’AllowNoCleanup’: True}
36 INFO:MsfClient:Executing exploit:multi/handler with params {}
37 INFO:MsfClient:Opened new session #1 for 192.168.1.100
38 INFO:MsfClient:Running ‘DIR C:‘ at #1 (192.168.1.100)
39 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’cmd /c "DIR C:"’, ’SESSION’: 1}
40 INFO:MsfClient:Running ‘whoami /groups‘ at #1 (192.168.1.100)
41 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’cmd /c "whoami /groups"’, ’SESSION’: 1}
42 a: Exploit: name=e_wp_ninja, target=(1, 0), cost=1.00, prob=1.00, req_access=USER, os=windows, service=80_windows_wp_ninja, access
,→=1, r: 0.0, d: False
43 V(s)=6.51
44 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
45 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
46 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
47 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |
48 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
49
50 # The host is compromised. The next step is to perform a network scan from the exploited host to see other parts of the network.
51 STEP 2
52 INFO:EmulatedNASimEnv:step() with SubnetScan: name=subnet_scan, target=(1, 0), cost=1.00, prob=1.00, req_access=USER
53 INFO:MsfClient:Executing post:multi/gather/ping_sweep with params {’RHOSTS’: ’192.168.1-5.100-110’, ’SESSION’: 1}
54 INFO:MsfClient:Scan result: [’192.168.1.100’, ’192.168.3.101’, ’192.168.3.100’, ’192.168.4.101’, ’192.168.4.100’]
55 INFO:EmulatedNetwork:Found new hosts {’192.168.3.100’, ’192.168.3.101’, ’192.168.4.100’, ’192.168.4.101’}, creating a route from
,→192.168.1.100.
56 INFO:MsfClient:Executing msfconsole command: ‘route add 192.168.3.0/24 1‘
57 INFO:MsfClient:Executing msfconsole command: ‘route add 192.168.4.0/24 1‘
58 a: SubnetScan: name=subnet_scan, target=(1, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
59 V(s)=7.10
60 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
61 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
62 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
63 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |18 Janisch, Pevný, Lisý
64 | (3, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
65 | (3, 0) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
66 | (4, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
67 | (4, 0) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
68 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
69
70 # The agent discovered several nodes in two different subnets. Metasploit was automatically configured to use the first host as
71 # a pivot to access these parts of the network. Now the agent chooses one of the hosts and scans it.
72 STEP 3
73 INFO:EmulatedNASimEnv:step() with ServiceScan: name=service_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER
74 INFO:MsfClient:Executing auxiliary:scanner/portscan/tcp with params {’RHOSTS’: ’192.168.4.100’, ’PORTS’: ’21,80,3306,9200’, ’
,→THREADS’: 10}
75 INFO:MsfClient:Scan result: [’192.168.4.100:21’, ’192.168.4.100:80’]
76 INFO:MsfClient:Executing auxiliary:scanner/http/dir_scanner with params {’RHOSTS’: ’192.168.4.100’, ’RPORT’: ’80’, ’THREADS’: 1, ’
,→DICTIONARY’: ’/vagrant/http_dir.txt’}
77 INFO:MsfClient:Folders found on the Http service: [’uploads’, ’phpwiki’]
78 INFO:EmulatedNetwork:Found these services: {’21_linux_proftpd’: True, ’80_linux_drupal’: False, ’80_linux_phpwiki’: True, ’9200
,→_windows_elasticsearch’: False, ’80_windows_wp_ninja’: False, ’3306_any_mysql’: False} (192.168.4.100).
79
80 a: ServiceScan: name=service_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
81 V(s)=11.46
82 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
83 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
84 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
85 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |
86 | (3, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
87 | (3, 0) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
88 | (4, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
89 | (4, 0) | False | True | True | 0.0 | 0.0 | False | False | True | False | True | False | False | False |
90 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
91
92 # ProcessScan actions are non-sensical in our case, because there are not any processes defined. The tested model is not perfect.
93 STEP 4
94 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER
95 a: ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
96 V(s)=6.47
97
98 STEP 5
99 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER
100 a: ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
101 V(s)=6.47
102
103 # The agent tries to exploit the proftpd service on the (4, 0) host. However, the exploit fails for unknown reason. This would
,→never happen in simulation.
104 STEP 6
105 INFO:EmulatedNASimEnv:step() with Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service
,→=21_linux_proftpd, access=1
106 INFO:MsfClient:Executing exploit:unix/ftp/proftpd_modcopy_exec with params {’RHOSTS’: ’192.168.4.100’, ’SITEPATH’: ’/var/www/
,→uploads/’, ’TARGETURI’: ’/uploads/’}
107 INFO:MsfClient:No session created.
108 WARNING:EmulatedNetwork:Failed exploit: Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux,
,→service=21_linux_proftpd, access=1
109
110 a: Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service=21_linux_proftpd, access=1, r:
,→0.0, d: False
111 V(s)=6.47
112
113 # The state did not change, the model is deterministic and outputs the same action probabilities. Hence, it tries the same exploit
,→again. It fails again.
114 STEP 7
115 INFO:EmulatedNASimEnv:step() with Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service
,→=21_linux_proftpd, access=1
116 INFO:MsfClient:Executing exploit:unix/ftp/proftpd_modcopy_exec with params {’RHOSTS’: ’192.168.4.100’, ’SITEPATH’: ’/var/www/
,→uploads/’, ’TARGETURI’: ’/uploads/’}
117 INFO:MsfClient:No session created.
118 WARNING:EmulatedNetwork:Failed exploit: Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux,
,→service=21_linux_proftpd, access=1
119 a: Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service=21_linux_proftpd, access=1, r:
,→0.0, d: False
120 V(s)=6.47
121
122 STEP 8
123 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER
124 a: ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
125
126 # Finally, the exploit succeeds. Automatically, the host is examined whether it contains sensitive data and if it can be accessed.
127 STEP 9
128 INFO:EmulatedNASimEnv:step() with Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service
,→=21_linux_proftpd, access=1
129 INFO:MsfClient:Executing exploit:unix/ftp/proftpd_modcopy_exec with params {’RHOSTS’: ’192.168.4.100’, ’SITEPATH’: ’/var/www/
,→uploads/’, ’TARGETURI’: ’/uploads/’}
130 INFO:MsfClient:Opened new session #2 for 192.168.4.100
131 INFO:MsfClient:Running ‘test -f /home/kylo_ren/loot; echo NO_LOOT=$?‘ at #2 (192.168.4.100)
132 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’test -f /home/kylo_ren/loot; echo NO_LOOT=$?’, ’
,→SESSION’: 2}
133 INFO:MsfClient:Running ‘whoami‘ at #2 (192.168.4.100)
134 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’whoami’, ’SESSION’: 2}
135 a: Exploit: name=e_proftpd, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service=21_linux_proftpd, access=1, r:
,→0.0, d: False
136 V(s)=6.47
137 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
138 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
139 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
140 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |
141 | (3, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
142 | (3, 0) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
143 | (4, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
144 | (4, 0) | True | True | True | 0.0 | 1.0 | False | False | True | False | True | False | False | False |
145 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
146
147 STEP 10
148 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER
149 a: ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
150 V(s)=6.28
151
152 STEP 11
153 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 1), cost=1.00, prob=1.00, req_access=USERNASimEmu: Network Attack Simulator & Emulator 19
154 a: ProcessScan: name=process_scan, target=(4, 1), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
155 V(s)=6.28
156
157 STEP 12
158 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 1), cost=1.00, prob=1.00, req_access=USER
159 a: ProcessScan: name=process_scan, target=(4, 1), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
160 V(s)=6.28
161
162 STEP 13
163 INFO:EmulatedNASimEnv:step() with ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER
164 a: ProcessScan: name=process_scan, target=(4, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
165 V(s)=6.28
166
167 # The agent focuses on a different node and scans it.
168 STEP 14
169 INFO:EmulatedNASimEnv:step() with ServiceScan: name=service_scan, target=(3, 0), cost=1.00, prob=1.00, req_access=USER
170 INFO:MsfClient:Executing auxiliary:scanner/portscan/tcp with params {’RHOSTS’: ’192.168.3.100’, ’PORTS’: ’21,80,3306,9200’, ’
,→THREADS’: 10}
171 INFO:MsfClient:Scan result: [’192.168.3.100:21’, ’192.168.3.100:3306’, ’192.168.3.100:80’]
172 INFO:MsfClient:Executing auxiliary:scanner/http/dir_scanner with params {’RHOSTS’: ’192.168.3.100’, ’RPORT’: ’80’, ’THREADS’: 1, ’
,→DICTIONARY’: ’/vagrant/http_dir.txt’}
173 INFO:MsfClient:Folders found on the Http service: [’uploads’, ’drupal’, ’phpwiki’]
174 INFO:EmulatedNetwork:Found these services: {’21_linux_proftpd’: True, ’80_linux_drupal’: True, ’80_linux_phpwiki’: True, ’9200
,→_windows_elasticsearch’: False, ’80_windows_wp_ninja’: False, ’3306_any_mysql’: True} (192.168.3.100).
175
176 a: ServiceScan: name=service_scan, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, r: 0.0, d: False
177 V(s)=6.28
178 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
179 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
180 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
181 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |
182 | (3, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
183 | (3, 0) | False | True | True | 0.0 | 0.0 | False | False | True | True | True | False | False | True |
184 | (4, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
185 | (4, 0) | True | True | True | 0.0 | 1.0 | False | False | True | False | True | False | False | False |
186 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
187
188 # It discovered that the (3, 0) node runs the mysql service, which is an indication that the node could be sensitive. It tries to
,→exploit the drupal service.
189 STEP 15
190 INFO:EmulatedNASimEnv:step() with Exploit: name=e_drupal, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service
,→=80_linux_drupal, access=1
191 INFO:MsfClient:Executing exploit:unix/webapp/drupal_coder_exec with params {’RHOSTS’: ’192.168.3.100’, ’TARGETURI’: ’/drupal’}
192 INFO:MsfClient:No session created.
193 WARNING:EmulatedNetwork:Failed exploit: Exploit: name=e_drupal, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=linux,
,→service=80_linux_drupal, access=1
194
195 a: Exploit: name=e_drupal, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service=80_linux_drupal, access=1, r:
,→0.0, d: False
196 V(s)=12.98
197
198 # It tries again and this time succeeds. The examination shows that the host contains sensitive information, but it can be accessed
,→ only by a priviledged user.
199 STEP 16
200 INFO:EmulatedNASimEnv:step() with Exploit: name=e_drupal, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service
,→=80_linux_drupal, access=1
201 INFO:MsfClient:Executing exploit:unix/webapp/drupal_coder_exec with params {’RHOSTS’: ’192.168.3.100’, ’TARGETURI’: ’/drupal’}
202 INFO:MsfClient:Opened new session #3 for 192.168.3.100
203 INFO:MsfClient:Running ‘test -f /home/kylo_ren/loot; echo NO_LOOT=$?‘ at #3 (192.168.3.100)
204 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’test -f /home/kylo_ren/loot; echo NO_LOOT=$?’, ’
,→SESSION’: 3}
205 INFO:MsfClient:Running ‘cat /home/kylo_ren/loot‘ at #3 (192.168.3.100)
206 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’cat /home/kylo_ren/loot’, ’SESSION’: 3}
207 INFO:MsfClient:Running ‘whoami‘ at #3 (192.168.3.100)
208 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’whoami’, ’SESSION’: 3}
209
210 a: Exploit: name=e_drupal, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, service=80_linux_drupal, access=1, r:
,→0.0, d: False
211 V(s)=12.98
212 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
213 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
214 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
215 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |
216 | (3, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
217 | (3, 0) | True | True | True | 100.0 | 1.0 | False | False | True | True | True | False | False | True |
218 | (4, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
219 | (4, 0) | True | True | True | 0.0 | 1.0 | False | False | True | False | True | False | False | False |
220 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
221
222 # The agent tries the priviledge escalation and after success it collects the sensitive information (the loot).
223 STEP 17
224 INFO:EmulatedNASimEnv:step() with PrivilegeEscalation: name=pe_kernel, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=
,→linux, process=None, access=2
225 INFO:MsfClient:Executing exploit:linux/local/overlayfs_priv_esc with params {’SESSION’: 3, ’target’: 0}
226 INFO:MsfClient:Opened new session #4 for 192.168.3.100
227 INFO:MsfClient:Running ‘test -f /home/kylo_ren/loot; echo NO_LOOT=$?‘ at #4 (192.168.3.100)
228 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’test -f /home/kylo_ren/loot; echo NO_LOOT=$?’, ’
,→SESSION’: 4}
229 INFO:MsfClient:Running ‘cat /home/kylo_ren/loot‘ at #4 (192.168.3.100)
230 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’cat /home/kylo_ren/loot’, ’SESSION’: 4}
231 INFO:EmulatedNetwork:----------------------
232 INFO:EmulatedNetwork:Loot recovered: LOOT=28a5b8532399467452f55775a05daa10
233 INFO:EmulatedNetwork:----------------------
234 INFO:MsfClient:Running ‘whoami‘ at #4 (192.168.3.100)
235 INFO:MsfClient:Executing post:multi/general/execute with params {’COMMAND’: ’whoami’, ’SESSION’: 4}
236 a: PrivilegeEscalation: name=pe_kernel, target=(3, 0), cost=1.00, prob=1.00, req_access=USER, os=linux, process=None, access=2, r:
,→0.0, d: False
237 V(s)=16.02
238 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
239 | Address | Compr. | Reach. | Disc. | Value | Access | linux | windows | proftpd | drupal | phpwiki | e_search | wp_ninja | mysql |
240 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+
241 | (1, 0) | True | True | True | 0.0 | 1.0 | False | False | False | False | False | True | True | False |
242 | (3, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
243 | (3, 0) | True | True | True | 100.0 | 2.0 | False | False | True | True | True | False | False | True |
244 | (4, 1) | False | True | True | 0.0 | 0.0 | False | False | False | False | False | False | False | False |
245 | (4, 0) | True | True | True | 0.0 | 1.0 | False | False | True | False | True | False | False | False |
246 +---------+--------+--------+-------+-------+--------+-------+---------+---------+--------+---------+----------+----------+-------+20 Janisch, Pevný, Lisý
[4 0]  service_scan Subnet 4
[4 0]  e_wp_ninja
ninja Subnet 4
(1) entry node scanning (2) exploiting WordPress
[4 0]  subnet_scan
ninja Subnet 4
[1 0]  Subnet 1[1 1]  [1 2]  service_scan
[1 3]  
[1 4]  
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
(3) scanning the network from [4, 0] (4) service scan on [1, 2]
[1 0]  Subnet 1[1 1]  [1 2]  e_elasticsearch
elasticsearch, ninja, mysql
[1 3]  
[1 4]  
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
[1 0]  Subnet 1[1 1]  [1 2]  
elasticsearch, ninja, mysql
[1 3]  service_scan
[1 4]  
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
(5) exploiting ElasticSearch (gains root) (6) service scan on [1, 3]
[1 0]  Subnet 1[1 1]  [1 2]  
elasticsearch, ninja, mysql [1 3]  e_phpwiki
phpwiki, mysql
[1 4]  
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
[1 0]  Subnet 1[1 1]  [1 2]  
elasticsearch, ninja, mysql [1 3]  pe_kernel
phpwiki, mysql
[1 4]  
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
(7) exploiting PhpWiki (8) privilege escalation
[1 0]  Subnet 1[1 1]  [1 2]  
elasticsearch, ninja, mysql [1 3]  
phpwiki, mysql
[1 4]  service_scan
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
[1 0]  Subnet 1[1 1]  [1 2]  
elasticsearch, ninja, mysql [1 3]  
phpwiki, mysql
[1 4]  e_drupal
proftpd, drupal, mysql
[2 0]  Subnet 2
[2 1]  [4 0]  
ninjaSubnet 4
(9) service scan on [1, 4] (10) exploiting Drupal
Fig. A.6: Example run of a trained invariant agent, evaluated in the sm_entry_dmz_
three_subnets scenario (simulation). Subnet 1 corresponds to the service subnet and
contains multiple sensitive nodes. The agent sequentially scans them and exploits those
running the MySQL service, as it is an indication that the host contains sensitive infor-
mation. E.g., in step 7, the agent exploits node [1, 3] and discovers that it is sensitive,
but it still needs to escalate its privileges to retrieve the sensitive information.
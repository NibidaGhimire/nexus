Forbidden Patterns in Temporal Graphs Resulting from
Encounters in a Corridor
Mónika Csikós1, Michel Habib1, Minh-Hang Nguyen1, Mikaël Rabie1, and Laurent
Viennot2
1Université Paris Cité, CNRS, IRIF, F-75013, Paris, France
2Inria, DI ENS, Paris, France
September 20, 2024
Abstract
In this paper, we study temporal graphs arising from mobility models, where vertices
correspond to agents moving in space and edges appear each time two agents meet. We
propose a rather natural one-dimensional model.
If each pair of agents meets exactly once, we get a simple temporal clique where the
edges are ordered according to meeting times. In order to characterize which temporal cliques
can be obtained as such ‘mobility graphs’, we introduce the notion of forbidden patterns in
temporal graphs. Furthermore, using a classical result in combinatorics, we count the number
of such mobility cliques for a given number of agents, and show that not every temporal
clique resulting from the 1D model can be realized with agents moving with different constant
speeds. Fortheanalogouscircularproblem, whereagentsaremovingalongacircle, weprovide
a characterization via circular forbidden patterns.
Our characterization in terms of forbidden patterns can be extended to the case where
each edge appears at most once. We also study the problem where pairs of agents are allowed
to cross each other several times, using an approach from automata theory. We observe that
in this case, there is no finite set of forbidden patterns that characterize such temporal graphs
and nevertheless give a linear-time algorithm to recognize temporal graphs arising from this
model.
Keywords: Temporal graphs, mobility models, forbidden patterns, mobile clique.
1 Introduction
1.1 Motivation
Temporal graphs (also known as dynamic, evolving or time-varying networks) can be informally
described as graphs that change with time. Their study is the subject of many theoretical and
practical research works as various real-world systems that can be modelled with temporal graphs
(such as social contacts, co-authorship graphs, or transit networks), see [5, 6, 14, 16, 18]. A very
natural range of models for temporal graphs comes from mobility. When agents move around
in space, we can track the moments when they meet each other and obtain a temporal graph.
The main objective of this work is to characterize temporal graphs resulting from certain mobility
models.
A classical model used for mobile networks is the unit disk graph, where vertices correspond
to unit disks in the plane, and two disk are adjacent if and only if they intersect. When the disks
are allowed to move, we obtain a so-called dynamic unit disk graph [23], and the appearance of
edges then forms a temporal graph. We consider a one-dimensional version where the disks are
1arXiv:2302.07666v2  [cs.DS]  19 Sep 2024movingalongalineorequivalentlyanarrowcorridorofunitwidth. Thiscouldencompasspractical
settings such as communicating cars on a single road. In particular, if each car has constant speed,
each pair of cars encounters each other at most once. We further restrict to the sparse regime
where each disk intersects at most one other disk at a time. In other words, the edges appearing
at any given time always form a matching. This restriction, called local injectivity, has already
been considered in the study of simple temporal cliques [7] which are temporal graphs where an
edge between any pair of nodes appears exactly once.
If two agents can communicate when they meet, one can ask how information can flow in the
network. The appropriate notion of connectivity then arises from temporal paths which are paths
where edges appear one after another along the path. The problem of temporal connectivity has
been considered, by Awerbuch and Even [2], and studied more systematically in [15]. A temporal
spannercanbedefinedasatemporalsubgraphthatpreservesconnectivity. Aninterestingquestion
concerning temporal graphs is to understand which classes of temporal graphs have temporal
spannersoflinearsize. Althoughsometemporalgraphshaveonly Θ(n2)-sizetemporalspanners[3],
simple temporal cliques happen to have O(nlogn)-size temporal spanners [7], and it is conjectured
that temporal cliques could even have linear size spanners. Indeed, a natural question is whether
temporal graphs resulting from a mobility model can have sparse spanners. In particular, do
temporal cliques arising from our 1D model have temporal spanners of linear size?
1.2 Our contribution
Our main contribution is a characterization of the simple temporal cliques that result from this
1D model. A simple temporal clique can only arise when agents start out in a certain order along
the corridor and end up in the opposite order, after each pair of agents crossing exactly once. We
provide a characterization of such “1D-mobility” temporal cliques in terms of forbidden ordered
patterns on three nodes. As far as we know, we introduce the first definition of forbidden patterns
in a temporal graph. Our definition is based on the existence of an order on the nodes (which
actually corresponds to their initial order along the line). A forbidden pattern is a temporal
subgraph with a relative ordering of its nodes, and with a forbidden relative ordering of its edges
according to their time labels.
Our characterization of 1D-mobility temporal cliques leads directly to an O(n3)-time algorithm
for testing whether an ordering of the nnodes of a temporal clique is appropriate and allows to
exclude these patterns. Interestingly, an O(n2)-time algorithm allows to find such an appropriate
initial ordering of the nodes from the list of the edges of the clique ordered by appearance time.
Moreover, we can actually check in O(n2)time that this order excludes the forbidden patterns to
obtain an overall linear-time recognition algorithm, since we have n(n−1)/2edges in our graphs.
Another way of looking at this problem is sorting through adjacent transpositions an array
A, where nelements are initially stored in reverse order. At each step, we choose an index i
such that A[i]> A[i+ 1]and swap the two elements at positions iandi+ 1. The array is
guaranteed to be sorted in increasing order after T=n(n−1)/2steps, since the permutation of
the elements in Ahas initially Tinversions while each step decreases this number by one. Note
that this is reminiscent of bubble sorting, which indeed operates according to a sequence of such
transpositions. This naturally connects our 1D model to the notion of reduced decompositions of
a permutation [21]. Using this observation and a classical combinatorial result, we give a formula
for the number of temporal cliques with nnodes resulting from our 1D model.
In addition, we show that our temporal cliques do contain temporal spanners of linear size
(with exactly 2n−3edges) by highlighting a pertinent temporal subgraph that considers only the
edges incident to one of the two extreme agents in the initial order along the line.
Finally, we consider some generalizations. First, we study those 1D mobility graphs where
each edge appears at mostonce and provide a forbidden pattern characterization of this setup as
well. Second, we consider what might be a forbidden pattern definition if edges can occur multiple
times, that is when some pairs of agents can cross each other multiple times.
In the case of 1D model when agents move with different constant speeds, we observe that the
resulting temporal mobility cliques are not characterized by the same set of forbidden patterns.
2Finally, we consider some generalised models. The first one is the 1D model in which each pair
of agents meet at most once. We provide an extended set of forbidden patterns that characterizes
temporal graphs arising in this situation. Our second extension of the 1D model is when each pair
of agents can meet several times, that is, the arising temporal graphs can have multi-edges. We
give a linear-time algorithm to recognise these multi-crossing 1D mobility temporal graphs. We
also show that there is no finite set of forbidden patterns that characterizes these multi-crossing
1D temporal mobility graphs. On the positive side, we give a characterization using an automaton
wherestatescorrespondtopossibleorderingsbetweenthreenodesandwhereeachpossiblecrossing
induces a transition to a new state.
The final extension is a circular model where agents move along a circle. We give forbidden
patterns to characterize temporal cliques arising from this model when each pair of agents meet
exactly once. Similarly to the linear case, the automata approach is used in the case where each
pair of agents can meet several time.
1.3 Related works
Dynamic unit disk graphs A closely related work concerns the detection of dynamic unit
disk graphs on a line [22, 23]. An algorithm is proposed to decide whether a continuous temporal
graph can be embedded in the line along its evolution, such that the edges present at each time
instant correspond to the unit disk graph within the nodes according to their current position
in the embedding at that time. The sequence of edge events (appearance or disappearance) is
processed online one after another, relying on a PQ-tree to represent all possible embeddings at
the time of the current event according to all events seen so far. It runs within a logarithmic
factor from linear time. Our model is tailored for discrete time and assumes that two nodes cross
each other when an edge appears between them. This is not the case in the dynamic unit disk
graph model: an edge can appear during a certain period of time between two nodes even if they
don’t cross each other. The PQ-tree approach can probably be adapted to our model for a more
general recognition of the temporal graphs it produces. However, our characterization leads to a
faster linear-time algorithm for recognizing simple temporal cliques arising from our model.
Forbidden patterns Since the seminal papers of Damaschke [8] and Skrien [19], many heredi-
tary graph classes have been characterized by the existence of an order of the vertices that avoids
some pattern, i.e. an ordered structure. These include bipartite graphs, interval graphs, chordal
graphs, comparability graphs and many others. In [13], it is proved that any class defined by a set
of forbidden patterns on three nodes can be recognized in O(n3)time. This was later improved
in [9] with a full characterization of the 22 graph classes that can be defined with forbidden pat-
terns on three nodes. An interesting extension to forbidden circular structures is given in [11].
The growing interest in forbidden patterns in the study of hereditary graph classes is partly sup-
ported by the certificate that such an ordering provides as checking if it avoids the patterns can
be checked in polynomial time.
Reduced decompositions The number of reduced decompositions of a permutation of nele-
ments is studied in [20]. An explicit formula is given for the reverse permutation n, n−1, . . . , 1
based on the hook length formula [4, 10].
1.4 Roadmap
In Section 2, we introduce the key notions of the paper. In particular, we provide the precise
definitions of temporal graphs, 1D mobility models, and forbidden temporal patterns. Section 3
contains our main results: a characterization of simple 1D mobility cliques through forbidden
patterns, a formula for the number of such cliques of a given size, a detection algorithm, the
description of a linear size spanner, and a discussion on the case of constant speed agents along
the line. Section 4 handles the case where each pair crosses at most once, by providing the
forbidden pattern characterization. Section 5 considers the case where pairs can cross each other
3several times, for which we present a linear-time recognition algorithm and describe a related
automaton. In Section 6, we study the setup where agents are moving along a circle. We give
a forbidden pattern characterization for the case where pairs cross each other exactly once, and
apply the automata approach for the case where pairs can cross each other several times. Finally,
we state some open questions and perspectives in Section 7.
2 Preliminaries and mobility model
In this section, we introduce the definitions and notations we will use through the paper. In
particular, we first define formally temporal graphs and forbidden patterns. We then introduce
the mobility model and related combinatoric concepts.
2.1 Temporal graphs and forbidden patterns
Informally, a temporal graph is a graph with a fixed vertex set and whose edges change with
time. Atemporal graph can be formally defined as a pair G= (G, λ)where G= (V, E)is a graph
with vertex set Vand edge set E, and λ:E→2Nis a labeling assigning to each edge e∈Ea
non-empty set λ(e)of discrete times when it appears. We note uv∈Ethe edge between the pair
of vertices (or nodes) uandv. Ifλis locally injective in the sense that adjacent edges have disjoint
sets of labels, then the temporal graph is said to be locally injective . Ifλis additionally single
valued(i.e.|λ(e)|= 1for all e∈E), then (G, λ)is said to be simple [7]. The maximum time
label T= max ∪e∈Eλ(e)of an edge is called the lifetimeof(G, λ). In the sequel, we will mostly
restrict ourselves to simple temporal graphs and even require the following restriction of locally
injective. A temporal graph is incremental if at most one edge appears in each time step, that
isλ(e)∩λ(f) =∅for any distinct e, f∈E. The reason for this restriction is mainly to ease the
definition of isomorphism introduced later in this section. A (strict) temporal path is a sequence of
triplets (ui, ui+1, ti)i∈[k]such that (u1, . . . , u k+1)is a path in Gwith strictly increasing time labels:
formally, for all i∈[k], we have uiui+1∈E,ti∈λ(uiui+1)andti< ti+1. Note that our definition
corresponds to the classical strict version of temporal path as we require time labels to strictly
increase along the path1. A temporal graph is temporally connected if every vertex can reach any
other vertex through a temporal path. A temporal subgraph (G′, λ′)of a temporal graph (G, λ)is
a temporal graph such that G′is a subgraph of Gandλ′satisfies λ′(e)⊆λ(e)for all e∈E′. A
temporal spanner ofGis a temporal subgraph Hpreserving temporal connectivity, that is there
exists a temporal path from utovinHwhenever there exists one in G. Given a subset S⊆Vof
nodes, the temporal subgraph inducedbySis defined as the temporal subgraph G|S= ((S, E′), λ′)
ofGsuch that E′=E∩ S
2
andλ′(e) =λ(e)for all e∈E′. A temporal subgraph G′is said to be
inducedif there exists a set Ssuch that G′=G|S.
A representation Rof a temporal graph G= ((V, E), λ)is defined as an ordered list of M=
|λ|=P
e∈E|λ(e)|triplets R= (u1, v1, t1), . . . , (uM, vM, tM)where each triplet (ui, vi, ti)indicates
that edge uiviappears at time ti. We additionally require that the list is sorted by non-decreasing
time. In other words, we have λ(uv) ={t: (u, v, t )∈ R}for all uv∈E. Note that any
incremental temporal graph Ghas a unique representation denoted by R(G). Indeed, its temporal
connectivity only depends on the ordering in which edges appear, we can thus assume without
loss of generality that we have ∪e∈Eλ(e) = [ T]where Tis the lifetime of ((V, E), λ)(we use
the notation [T] ={1, . . . , T }). Given two incremental temporal graphs G= ((V, E), λ)and
G′= ((V′, E′), λ′), anisomorphism fromGtoG′is a one-to-one mapping ϕ:V→V′such that,
for any u, v∈V,uv∈E⇔ϕ(u)ϕ(v)∈E′(ϕis a graph isomorphism), and their representation
R(G) = (u1, v1, t1), . . . , (uM, vM, tM)andR(G′) = (u′
1, v′
1, t′
1), . . . , (u′
M, v′
M, t′
M)have same length
M=|λ|=|λ′|and are temporally equivalent in the sense that edges appear in the same order:
u′
iv′
i=ϕ(ui)ϕ(vi)for all i∈[M]. When such an isomorphism exists, we say that GandG′are
isomorphic . Given an integer L≤M, we define the prefix of length LofGas the temporal graph
1The interested reader can check that the two notions of strict temporal path and non-strict temporal path are
the same in locally injective temporal graphs.
4with representation (u1, v1, t1), . . . , (uL, vL, tL). We also say that ϕis aprefix-isomorphism from
GtoG′when M′≤Mandϕis an isomorphism from the prefix of length M′ofGtoG′. When
such a prefix-isomorphism exists, we say that Gisprefix-isomorphic toG′.
Atemporal clique is a temporal graph (G, λ)where the set of edges is complete, and where
we additionally require the temporal graph to be incremental and λto be single valued. Notice
that it is a slight restriction compared to the definition of [7] which requires (G, λ)to be locally
injectiveratherthanincremental. However, wedonotloseingeneralityasonecaneasilytransform
any locally injective temporal graph into an incremental temporal graph with same temporal
connectivity (we simply stretch time by multiplying all time labels by n2and arbitrarily order
edges with same original time label within the corresponding interval of n2time slots in the
stretched version). With a slight abuse of notation, we then denote the label of an edge uvby
λ(uv)∈N.
Atemporal pattern is defined as an incremental temporal graph H= (H, λ). An incremental
temporal graph G= (G, λ′)excludes Hwhen it does not have any temporal subgraph H′which
is isomorphic to H. A temporal pattern with forbidden edges is a temporal pattern H= (H, λ)
together with a set F⊆V×V\Eof forbidden edges in H= (V, E). An incremental temporal
graph G= ((V′, E′), λ′)excludes Hwhen it does not have any temporal subgraph H′which is
isomorphic to (H, λ′)through an isomorphism ϕrespecting non-edges, that is any pair of nodes
u, v∈V′which is mapped to a forbidden edge ϕ(u)ϕ(v)∈F, we have uv /∈E′. An incremental
temporal graph Gexcludes Has aprefixwhen it does not have any induced temporal subgraph
H′which is prefix-isomorphic to H. In such case, we say that His aforbidden prefix-pattern ofG.
Anordered temporal graph is a pair (G, π), where Gis a temporal graph and πis an ordering
of its nodes. Similarly, an ordered temporal pattern (H, π)is a temporal pattern Htogether with
an ordering πof its nodes. An ordered incremental temporal graph (G, π′)excludes (H, π)when
it does not have any temporal subgraph H′which is isomorphic to Hthrough an isomorphism ϕ
preserving relative orderings, that is π(ϕ(u))< π(ϕ(v))whenever π′(u)< π′(v). We then also say
that the ordering π′excludes (H, π)fromG, or simply excludes (H, π)whenGis clear from the
context. We also define an ordered temporal pattern with forbidden edges similarly as above. We
also say that an ordered incremental temporal graph (G, π′)excludes (H, π)as anordered prefix
when it does not have any induced temporal subgraph H′which is prefix-isomorphic to Hthrough
an isomorphism ϕpreserving relative orderings, that is π(ϕ(u))< π(ϕ(v))whenever π′(u)< π′(v).
In such case, (H, π)is aforbidden ordered prefix-pattern of(G, π′).
2.2 1D-mobility model
We introduce here the notion of a temporal graph associated to mobile agents moving along a line
that is an one-dimensional space. Consider nmobile agents in an oriented horizontal line. At time
t0= 0, they initially appear along the line according to an ordering π0. These agents move in
the line and can cross one another as time goes on. We assume that a crossing is always between
exactly two neighboring agents, and a single pair of agents cross each other at a single time. By
ordering the crossings, we have the k-th crossing happening at time tk=k.
A1D-mobility schedule from an ordering π0=a1, . . . , a nofnagents is a sequence x=
x1, . . . , x Tof crossings within the agents. Each crossing xtis a pair uvindicating that agents
uandvcross each other at time t. Note that their ordering πtat time tis obtained from πt−1
by exchanging uandv, and it is thus required that they appear consecutively in πt−1. To such a
schedule, we can associate a temporal graph Gπ0,x= ((V, E), λ)such that:
•V={a1, . . . , a n},
•E={uv:∃t∈[T], xt=uv},
•for all uv∈E,λ(uv) ={t:xt=uv}.
We are interested in particular by the case where all agents cross each other exactly once as
the resulting temporal graph is then a temporal clique which is called a 1D-mobility temporal
5clique. More generally, we say that an incremental temporal graph Gcorresponds to a 1D-mobility
schedule if there exists some ordering πof its vertices and a 1D-mobility schedule xfrom πsuch
that the identity is an isomorphism from GtoGπ,x. It is then called a 1D-mobility temporal graph .
2.3 Reduced decomposition of a permutation
Our definition of mobility model is tightly related to the notion of reduced decomposition of a
permutation [21]. Let Sndenote the symmetric group on nelements. We represent a permutation
w∈Snas a sequence w=w(1), . . . , w (n)and define its length l(w)as the number of inverse pairs
inw, i.e. l(w) =|{i, j:i < j, w (i)> w(j)}|. Asub-sequence w′ofwis defined by its length
k∈[n]and indices 1≤i1<···< ik≤nsuch that w′=w(i1), . . . , w (ik).
Atransposition τ= (i, j)is the transposition of iandj, that is τ(i) =j,τ(j) =iandτ(k) =k
fork∈[n]\ {i, j}. It is an adjacent transposition when j=i+ 1. Given a permutation wand
an adjacent transposition τ= (i, i+ 1), we define the right product ofwbyτas the composition
wτ=w◦τ. Note that w′=wτ, as a sequence, is obtained from wby exchanging the numbers in
positions iandi+ 1as we have w′(i) =w(τ(i)) = w(i+ 1),w′(i+ 1) = w(τ(i+ 1)) = w(i)and
w′(k) =w(k)fork̸=i, j. Areduced decomposition of a permutation w∈Snwith length l(w) =l,
is a sequence of adjacent transpositions τ1, τ2, . . . , τ lsuch that we have w=τ1. . . τl. Counting the
number of reduced decompositions of a permutation has been well studied (see in particular [20]).
The link with our 1D-mobility model is the following. Consider a 1D-mobility schedule xfrom
an ordering π0. Without loss of generality we assume that agents are numbered from 1ton. Each
ordering πtisthenapermutation. Ifagents uandvcrossattime t, i.e. xt=uv, andtheirpositions
inπt−1areiandi+ 1, we then have πt=πt−1τtwhere τt= (i, i+ 1). If each pair of agents cross
at most once, then one can easily see that the schedule xof crossings corresponds to a reduced
decomposition τ1, . . . , τ Tofπ−1
0πT=τ1···τTas the ending permutation is πT=π0τ1···τT. Note
that this does not hold if two agents can cross each other more than once as the length of the
schedule can then be longer than the length of π−1
0πT.
Interestingly, another decomposition is obtained by interpreting the crossing xt=uvat time
tas the transposition (u, v). We then have πt=xtπt−1for each time t, and finally obtain
πT=xT···x1π0. Note that given an arbitrary sequence of transpositions x1, . . . , x T, it is not
clear how to decide whether there exists an ordering π0and a corresponding sequence of adjacent
transpositions τ1, . . . , τ Tsuch that xt···x1π0=π0τ1···τtfor all t∈[T]. This is basically the
problem we address in the next section.
3 1D-mobility temporal cliques
3.1 Characterization
Consider the ordered temporal patterns from Figure 1 with respect to the initial ordering of the
nodes in a 1D-mobility schedule xproducing a temporal clique Gx. One can easily see that the
upper-left pattern cannot occur in Gxwithin three agents a, b, cappearing in that order initially:
aandccannot cross each other as long as bis still in-between them, while the pattern requires
that edge acappears before abandbc. A similar reasoning prevents the presence of the three
other patterns. It appears that excluding these four patterns suffices to characterize 1D-mobility
temporal cliques, as stated bellow.
Theorem 1. A temporal clique is a 1D-mobility temporal clique if and only if there exists an
ordering of its nodes that excludes the four ordered temporal patterns of Figure 1.
LetCdenote the class of temporal cliques which have an ordering excluding the four ordered
temporal patterns of Figure 1. We first prove that any 1D-mobility temporal clique is in C:
Proposition 1. For any 1D-mobility schedule xfrom an ordering πofnagents such that Gπ,x=
((V, E), λ)is a temporal clique, the initial ordering πexcludes the four patterns of Figure 1.
6a b c2 31
a b c1 23
a b c3 21
a b c2 13
Figure 1: Ordered forbidden patterns in an ordered 1D-mobility temporal clique. Each pattern is
ordered from left to right and has associated ordering a, b, c.
This proposition is a direct consequence of the following lemma.
Lemma 1. Consider three nodes a, b, c∈Vsuch that time λ(ac)happens in-between λ(ab)and
λ(bc), i.e. λ(ac)is the median of {λ(ab), λ(ac), λ(bc)}, then bis in-between aandcin the initial
ordering, i.e. either a, b, corc, b, ais a sub-sequence of π.
Proof.For the sake of contradiction, suppose that bis not in-between aandcinitially. At time
min{λ(ab), λ(bc)}, it first crosses aorc, and it is now in-between aandc. Asaandccannot cross
each other as long as blies in-between them, the other crossing of bwith aorcshould thus occur
before λ(ac), implying max{λ(ab), λ(bc)}< λ(ac), in contradiction with the hypothesis. The only
possible initial orderings of these three nodes are thus a, b, candc, b, a.
One can easily check that the above Lemma 1 forbids the four patterns of Figure 1. Indeed,
in each pattern, the edge of label 2 that appears in-between the two others in time, is adjacent to
the middle node while it should link the leftmost and rightmost nodes. Proposition 1 thus follows.
We now show that forbidding these four patterns fully characterizes 1D-mobility temporal
cliques. For that purpose, we construct a mapping from ordered temporal cliques in Cto the set
R(wn)of all reduced decompositions of wnwhere wn=n, n−1, . . . , 1is the permutation in Sn
with longest length.
Lemma 2. Any temporal clique G ∈ Chaving an ordering πexcluding the four patterns of Figure 1,
can be associated to a reduced decomposition f(G, π)∈R(wn)ofwn. Moreover, the representation
R(G)ofGcorresponds to a 1D-mobility schedule starting from πandGis a 1D-mobility temporal
clique.
Proof.Recall that, up to isomorphism, we can assume that Ghas lifetime T=n(n−1)/2and
that exactly one edge appears at each time t∈[T]. Consider the corresponding representation
R(G) = ( u1, v1,1),(u2, v2,2),. . . ,(uT, vT, T). Starting from the initial ordering π0=π, we
construct a sequence π1, . . . , π Tof orderings corresponding to what we believe to be the positions
of the agents at each time step if we read the edges in R(G)as a 1D-mobility schedule. More
precisely, for each t∈T,πtis defined from πt−1as follows. As the edge utvtshould correspond
to a crossing xt=utvt, it can be seen as the transposition exchanging utandvtso that we define
πt=xtπt−1. Equivalently, we set τt= (i, j)where iandjrespectively denote the indexes of ut
andvtinπt−1, i.e. πt−1(i) =utandπt−1(j) =vt. We then also have πt=πt−1τt.
Our main goal is to prove that f(G, π) :=τ1, . . . , τ Tis the desired reduced decomposition of
wn. For that, we need to prove that utandvtare indeed adjacent in πt−1=π0τ1···τt−1=
xt−1···x1π0. For the sake of contradiction, consider the first time twhen this fails to be. That
isτ1, . . . , τ t−1are indeed adjacent transpositions, edge uvappears at time t, i.e. uv=utvt, and
u, vare not consecutive in πt−1. We assume without loss of generality that uis before vinπ0, i.e.
u, vis a sub-sequence of π0. We will mainly rely on the following observation:
Consider two nodes x, ysuch that xis before yinπ0, then xis before yinπt−1if and only
edge xyappears at tor later, i.e. λ(xy)≥t.
7The reason comes from the assumption that τ1, . . . , τ t−1are all adjacent transpositions: as
long as only xoryis involved in such a transposition, their relative order cannot change. The
above observation thus implies in particular that uis still before vinπt−1. Now, as uandvare
not consecutive in πt−1, there must exist an element wbetween elements uandvinπt−1. We
consider the two following cases:
Case 1. wwas already in-between uandvinπ0, that is u, w, vis a sub-sequence of π0. As the
relative order has not changed between these three nodes, we have λ(uw)> tandλ(wv)> tas
their appearing time is distinct from t=λ(uv). This is in contradiction with the exclusion of the
two patterns on the left of Figure 1.
Case 2. wwas not in-between uandvinπ0. Consider the case where u, v, wis a sub-sequence
ofπ0. From the observation, we we deduce that λ(vw)< tandλ(uw)> t, which contradicts the
exclusion of the bottom-right pattern of Figure 1. The other case where w, u, vis a sub-sequence
ofπ0is symmetrical and similarly leads to a contradiction with the exclusion of the top-right
pattern of Figure 1.
We get a contradiction in all cases and conclude that τ1, . . . , τ Tare all adjacent transpositions.
This implies that xis indeed a valid 1D-mobility schedule from π. As xis defined according to
the ordering of edges in R(G)by appearing time, Gis obviously isomorphic to Gπ,x.
Additionally, as each pair of elements occurs exactly in one transposition, the permutation
τ1···τThas length T=n(n−1)/2and must equal wn. The decomposition f(G, π) =τ1, . . . , τ T
is thus indeed a reduced decomposition of wn.
Theorem 1 is a direct consequence of Proposition 1 and Lemma 2.
3.2 Recognition algorithm
We now propose an Algorithm to decide if a clique belongs to C, and provide an ordering of the
nodes that avoids the patterns if it is the case. The main idea of the algorithm relies on Lemma 1
which allows us to detect within a triangle which node should be in-between the two others in any
ordering avoiding the patterns. This is simply done by comparing the three times at which the
edges of the triangle appear. We assume the input to be given as a representation of the temporal
graph, i.e. the list R(G)of the edges in the form (u, v, t ), sorted according to their time labels.
The algorithm first tries to compute a feasible ordering of the vertices using the function
VertexSorting( R(G)). To do that, the subroutine ExtremeNodes( V)provides the two nodes that
should be at the extremities of some subset Vof nodes. It outputs these two nodes by excluding
repeatedly a node out of some triplets again and again until only two nodes are left, using Lemma 1
to identify which one is in the middle.
We thus finally get the two extremities aandzofVin the initial ordering. Without loss of
generality, we keep aas the first element. We then repeat n−2times the following procedure:
add back zto the remaining nodes, and compute the two extremities among them. If zis one of
the extremities, remove the other one and append it to the partial ordering constructed so far.
Otherwise, return ⊥as a contradiction has been found ( zmust always be an extremity if we have
a 1D-mobility temporal clique).
We then need to check that each temporal edge indeed exchanges two consecutive nodes in
the 1D-mobility model. To do that, we represent the sequence of permutations starting from
πthe initial ordering, and check that each switch, according to the edges sorted by time label,
corresponds to an exchange between two consecutive nodes. If at some point, we try to switch
non consecutive elements, we return False, otherwise at the end we have checked that we had a
1D-mobility temporal clique and return True.
Theorem 2. Algorithm 1 correctly recognizes 1D-mobility temporal cliques in linear time and
outputs an initial vertex ordering from which its representation is a 1D-mobility schedule.
Proof.Letπ′be an ordering that excludes the four forbidden patterns from G.
81Function VertexSorting( R(G))
Input:The representation R(G)of a temporal clique G= ((V, E), λ).
Output: A vertex ordering π.
2Compute a matrix representing λand the set Vof vertices from R(G).
3 X:= ExtremeNodes( V)
4Letaandzbe the two vertices in X.
5Define a partial ordering πwith aas single element.
6 V:=V\ {a}
7While V̸={z}do
8 X:= ExtremeNodes( V)
9 Ifz /∈Xthen
10 return ⊥/* Failure. */
11 else
12 Letbbe the node in X\ {z}.
13 Append btoπ.
14 V:=V\ {b}
15Append ztoπ.
16 Return π
17Function ExtremeNodes( V)
18LetWbe a copy of V.
19Pick any pair u, vof nodes in W.
20 W:=W\ {u, v}
21SetX:={u, v}./* Tentative pair of extremal nodes. */
22 While W̸=∅do
23 Remove a node wfrom W.
24 X:= TriangleExtremities( X∪ {w})
25 Return X
26Function TriangleExtremities( T)
27Letu, v, wbe the three nodes in T.
28Retrieve the three time labels λ(uv), λ(vw), λ(uw).
29 Return the pair consisting of the edge e∈ {uv, vw, uw }with median time label.
Input:A temporal clique G= ((V, E), λ)given by its representation R(G).
Output: True if Gexcludes the four forbidden patterns of Figure 1, False otherwise.
1π:= VertexSorting( R(G))
2Ifπ=⊥then return False
3Compute the index σ(v)of each vertex vinπ.
4Foreach triplet (u, v, t )inR(G)scanned in increasing order do
5If|σ(u)−σ(v)|= 1then
/*uandvare consecutive in π. */
6 Exchange uandvinπand update σ.
7else
8 Return False
9Return True
Algorithm 1: The recognition algorithm.
9Forany W⊆V, theextremeverticesof Wreturnedby ExtremeNodes( W)areuniquelydefined
byW. In other words, these extreme vertices do not depend on the order of nodes wpicked from
Win Line 23, and two nodes, uandv, picked from Win Line 19. The reason is that, in the loop
from Line 22 to Line 24, the node in-between the two others in the restriction of π′to the three
nodes in X∪ {w}will be eliminated by Lemma 1. The function ExtremeNodes( W)thus returns
the two extreme vertices of the restriction of π′toW.
We now prove that the ordering πreturned by function VertexSorting( R(G))is either π′itself
or the reverse of π′. Furthermore, the ordering πis uniquely defined, depending on the choice
of the first element ain Line 5 (among the the two elements in X). At the beginning of the
i-th iteration of the While loop from Line 7 to Line 14, the ordering πincludes ielements,
denoted by x1, x2, . . . , x iwhere x1=a. We prove by induction on ithat function VertexSorting
eventually returns an ordering πthat is either π′or the reverse of π′. For i= 1,x1=ais an
extreme vertex in π′. Assume that xjandxj+1appear consecutively in the ordering π′, i.e.,
|(π′)−1(xj)−(π′)−1(xj+1)|= 1, for all j≤i. In Line 8, set Xincludes two extreme vertices
among all vertices that do not appear in π, according to π′. The two vertices in set Xare thus
uniquely defined, and include zand an other vertex, call it b, which is in-between aandzinπ′.
Additionally, since xjandxj+1appear consecutively in the ordering π′, for all j≤i, it implies
thatbis adjacent to xiinπ′. At the end of this iteration, xi+1=bis appended to the tuple π.
Now we analyse the running time. The subroutine ExtremeNodes( W)clearly runs in O(|W|)
time as TriangleExtremities( T)takes constant time. VertexSorting( R(G))thus uses O(n2)time
which is linear since a temporal clique hasn(n−1)
2edges (this can be checked beforehand). Finally,
checking that R(G)is indeed a 1D-mobility schedule from πin the for loop at Lines 4-8 clearly
takes constant time per triplet.
3.3 Counting
We now estimate the number |C|of 1D-mobility temporal cliques with nnodes through the fol-
lowing result. Recall that R(wn)denotes the set of all reduced decompositions of wnwhere
wn=n, n−1, . . . , 1.
Proposition 2. The number of 1D-mobility temporal cliques with nnodes is
|C|=|R(wn)|
2=1
2 n
2
!
1n−13n−2···(2n−3)1.
Letusdefine C′⊆ C×S nasthesetoforderedtemporalcliques (G, π)suchthat G= ((V, E), λ)∈
Candπis an ordering of Vsuch that R(G)provides a 1D-mobility schedule from π. Proposition 2
derives from two following lemmas and known results [20] counting the number |R(wn)|of reduced
decompositions of wnaccording to the hook length formula [10].
Lemma 3. The mapping f:C′→R(wn)defined in Lemma 2 is a bijection.
Proof.We simply define a mapping g:R(wn)→ C′such that f◦gis the identity. Consider a
reduced decomposition ρ=τ1, . . . , τ Tofwnwhere each τtis an adjacent transposition. As wn
hasn(n−1)/2inversions, its length is indeed T=n(n−1)/2. Let π0= 1, . . . , nbe the identity
permutation and define πt=π0τ1···τt=τ1···τtfor each t∈[T]. Let xt=uvbe the pair of
elements in position iandi+ 1inπt−1where iis the index such that τt= (i, i+ 1). We then
have πt=xtπt−1for all t∈[T], and xis indeed a 1D-mobility schedule from π0that leads to wn.
As each pair of agents u, v∈π0with u < vappears as sub-sequence u, vinπ0and sub-sequence
v, uinπT=wn, they must cross at some time tsuch that xt=uv. As the total number of
crossings is T=n(n−1)/2, this can happen only once, and Gπ0,xis a temporal clique. We can
thus define g(ρ) = (Gπ0,x, π0)which satisfies f(g(ρ)) =ρas we have xt···x1π0=πt=π0τ1···τt
for all t∈[T].
Lemma 4. Any 1D-mobility temporal clique Gadmits exactly two orderings πand its reversal
such that R(G)provides a 1D-mobility schedule from π.
10Proof.Letπbe the ordering provided by Algorithm 1 on a given 1D-mobility clique. By Theo-
rem 2, we know that πis an ordering corresponding to this clique. We can notice that rev(π), the
reversed order of π, is also an ordering corresponding to that clique.
Note that, by Lemma 1, for any three nodes, u,v,w, ofV, with edge label λ(uw)< λ(uv)<
λ(wv),whas to be in-between uandvin all orderings that excludes the forbidden patterns from
G. This implies that no other ordering than πandrev(π)can correspond to this clique.
It implies that any 1D-mobility temporal clique admits exactly two orderings such that R(G)
provides a 1D-mobility schedule from π.
3.4 Temporal spanner
Inthissubsection, weshowthatany1D-mobilitytemporalcliquehasaspannerof Gofsize (2n−3).
Moreover, this spanner has diameter 3, and provides a new structure for (sub)spanners compared
to the ones introduced in [7], see Figure 2 below.
Theorem 3. Given a 1D-mobility temporal clique G, letHbe the temporal subgraph of Gconsisting
in the (2n−3)edges that are adjacent with either v1or vertex vn.His a temporal spanner of G.
Proof.Let us consider the edge (v1, vn, t)that corresponds to the crossing of the initial two ex-
tremities v1andvnon the line. When this happens, we have two sets: VL(resp. VR) corresponding
to the agents being at the left of v1(resp. right of vn) at time t. All edges of Happearing before
t, have the form v1vlwith vl∈VLorvrvnwith vr∈VR. All edges of Happearing after thave
the form v1vrwith vr∈VRorvlvnwith vl∈VL(see Figure 2).
VL VRv1
vnt′< t
t′> t t′< tt′> t
t
Figure 2: Relative order of labels of edges between the sets VL,VRand the two vertices v1and
vn, showing how temporal paths between VLandVRcan be formed.
As we have all edges connected to v1andvn, we only need to prove that we keep connectivity
between VLandVR, but also within those sets:
•To connect a node vl∈VLtovr∈VR, we use the path (vl, v1, vr).
•To connect a node vr∈VRtovl∈VL, we use the path (vr, vn, vl).
•To connect a node vl∈VLtov′
l∈VL, we use the path (vl, v1, vn, v′
l).
•To connect a node vr∈VRtov′
r∈VR, we use the path (vr, vn, v1, v′
r).
3.5 Agents moving with constant speed
Recall that any 1D-mobility schedule corresponds to a set of agents moving continuously on an
oriented horizontal line with (possibly) varying speeds. When studying temporal cliques generated
by 1D-mobility schedules, it is natural to ask whether they can be realised using the following
simpler, constant speed model:
•agent istarts in position pi∈Rwith an initial ordering p1< p2<···< pn
•agent imoves towards infinity with speed sithat satisfies s1> s2>···> sn.
11These assumptions guarantee that each agent can meet at most once, and that after a certain
time, the order of agents reverses thus we obtain a temporal clique. (By slightly perturbing the
starting positions, we can assume that at most one pair of agents meet at any moment.) In this
section, we show that this simplification comes with a loss of generality.
Theorem 4. There exists a 1D-mobility schedule of 7agents that cannot be realized as a temporal
graph associated to mobile agents moving with constant speeds.
Proof.Denote the agents by a, b, c, d, e, f, g , starting in this order, and consider the following
sequence of crossings:
abcdefgx1=ab
− − − → bacdefgx2=cd
− − − → badcefgx3=ad
− − − → bdacefgx4=ef
− − − → bdacfegx5=eg
− − − → bdacfge
x6=ac
− − − → bdcafgex7=af
− − − → bdcfagex8=bd
− − − → dbcfagex9=bc
− − − → dcbfagex10=ag
− − − → dcbfgae.(1)
The corresponding temporal graph is illustrated in Figure 3 with nodes ordered from left to right
according to their initial ordering.
a b c d e f g
1 9 2 410
63
5
78
Figure 3: Any 1D-mobility clique with the above prefix cannot be realized with agents moving at
constant speed.
It is easy to verify that Sequence (1) can be extended to a 1D-mobility temporal clique in the
following way:
dcbfgaex11=ae
− − − → dcbfgeax12=bf, x 13=bg, x 14=be
− − − − − − − − − − − − − − − → dcfgebax15=cf, x 16=cg, x 17=ce
− − − − − − − − − − − − − − − → d fgecba
x18=d f, x 19=dg, x 20=de
− − − − − − − − − − − − − − − → fgedcbax21=fg
− − − → gfedcba.
Now assume that Sequence (1) can be obtained by agents moving with constant speeds sa> sb>
···> sg. The proof of impossibility relies on the following 4observations:
(a) The crossing subsequence x3=ad, x 4=ef, x 5=eg, x 6=acimplies that the agent a
traverses the interval between dandcslowerthan agent etraversing the interval between f
andg.
(b) The crossing subsequence x7=af, x 8=bd, x 9=bc, x 10=agimplies that the agent a
traverses the interval between fandgslowerthan agent btraversing the interval between
dandc.
(c) Agents fandgdo not cross for t∈[0,10], thus in this time interval, their distance is
decreasing as tincreases. This together with the facts that sa> seand that atraverses the
interval between fandglaterthan edoes, imply that emust traverse the interval between
fandgslowerthan adoes.
12a b c1 2a b c2 1a b c21
a b c21
a b c1
Figure 4: Ordered forbidden patterns with forbidden edges in the 1D-mobility model when each
pair of agents cross at most once. The ordering associated to each pattern is a, b, c.
(d) Since sc> sd, the distance between agents canddis increasing after they cross, that is,
after time t= 2.
For agents i, j, k, let Ti(j, k)denote the time agent ispends between j, k, that is, Ti(j, k) =
λ(ik)−λ(ij)(ifiis never located in-between jandk, we set Ti(j, k) =∞). Putting together
Observations (a)-(c), we get
Ta(d, c)(a)
> T e(f, g)(c)
> T a(f, g)(b)
> T b(d, c)
However, btraverses the interval between dandcstrictly after ahad traversed it and thus by
Observation (d), bhas to travel a larger distance between dandcthan adoes. This, together
with sa> sbimplies that Ta(d, c)< Tb(d, c), a contradiction.
We note that any 1D-mobility schedule on up to 4agents can be obtained with constant speed
agents. The remaining cases of 5and6agents are left as open questions. We also conjecture that
there are infinitely many critical patterns for 1D-mobility cliques that cannot be realized with
constant-speed agents. On the other hand a characterization of 1D-mobility schedules that can
be realized with constant speed agents should be interesting.
4 Mobility graph with at most one crossing
In this section, we consider the case where each pair of agents cross each other at most once. We
provide a characterization with the addition of the forbidden patterns of Figure 4 which includes
non-edges corresponding of the non-crossings.
Proposition 3. For any mobility schedule xofnagents where each pair of agents cross at most
once producing an incremental single valued temporal graph Gx= ((V, E), λ), the initial ordering
πof the agents excludes the patterns of Figures 1 and 4.
Proof.Lemma 1 gives us the proof for the patterns of Figure 1. About the patterns of Figure 4,
we have the following observations. Pick three nodes a, b, csuch that a, b, cis a sub-sequence of π
and there exists two agents among them which do not cross each other. If bandcdo not cross
each other, and acrosses bandc, then acrosses bbefore crossing agent c(top left pattern). If b
andcdo not cross each other, and adoes not cross b, then adoes not cross c(bottom pattern). If
aandbdo not cross, similarly, πexcludes the top right pattern and the bottom pattern. If aand
cdo not cross each other, then bcannot cross both aandc(two patterns in the second row).
Lemma 5. Any incremental single valued temporal graph Ghaving an ordering πexcluding the
patterns of Figures 1 and 4 can be associated to a mobility schedule xofnagents where each pair
of agents cross at most once.
13Proof.We proceed similarly as for the proof of Lemma 2. Starting from the initial ordering
π0=π, we define a sequence π1, . . . , π T, of orderings, corresponding to what, we believe, to be
the positions of the agents at each time step if we read the edges of Gby increasing time label as
a mobility schedule. More precisely, for each t∈T,πtis defined from πt−1as follows. Consider
the edge uv=λ−1(t)appearing at time tinG. We define τtas the transposition exchanging u
andvinwt−1. Equivalently, we set τt= (i, j)where iandjrespectively denote the indexes of u
andvinπt−1, i.e. πt−1(i) =uandπt−1(j) =v. We then set πt=πt−1τt.
We need to prove that utandvtare indeed adjacent in πt−1. Consider the first time twhen
this fails to be. That is τ1, . . . , τ t−1are adjacent transpositions, edge uvappears at time t, i.e.
uv=utvt, and u, vare not consecutive in πt−1. It implies that there exists another node wsuch
that, in πt−1, the relative ordering amongs the three vertices is ut, w, v t. We consider the temporal
subgraph, H, induced by the three vertices ut, w, v t. We get to a contradiction by proving that
any order on those nodes in π0will imply that His a forbidden pattern.
Case 1. wwas already in-between utandvtinπ0. It implies that ( utw /∈Eorλ(utw)> t)
and ( vtw /∈Eorλ(vtw)> t). This is forbidden by the two left patterns of Figure 1, the two top
patterns and the bottom pattern of Figure 4.
Case 2. wwas initially before utandvtinπ0. It implies that λ(utw)< t, and vtw /∈Eor
λ(vtw)> t. This is forbidden by the top right pattern of Figure 1 and the third (middle left)
pattern of Figure 4.
Case 3. wwas initially after utandvtinπ0. It implies that λ(vtw)< t, and utw /∈Eor
λ(utw)> t. This is forbidden by the bottom right pattern of Figure 1 and the fourth (middle
right) pattern of Figure 4.
Using Proposition 3 and Lemma 5, we immediately obtain:
Theorem 5. A single valued incremental temporal graph is a 1D-mobility temporal graph if and
only if there exists an ordering of its nodes that excludes the ordered temporal patterns of Figures 1
and 4.
This characterization yields another argument to show that the graph in Figure 3 corresponds
to 1D temporal graph since it does not contain any of the patterns of Figures 1 and 4.
We make the following observation thanks to the characterization of graph classes through
forbidden patterns of size 3 from [9].
Proposition 4. The set of graphs that can be associated to a mobility schedule xofnagents
where each pair of agents cross at most once is contained in the set of permutation graphs.
Proof.First we can note that in the 5 patterns of Figure 4, the last three do not depend on
the time labels, either by symmetry (3, 4) or because there is only one label on the pattern (5).
Using [9], we know that the corresponding class of graph is the permutation graphs, i.e. they are
comparability graph and their complement also. Therefore this class is included in permutation
graphs.
It should be noted that if we consider only patterns of Figure 4 ignoring the labels of the 2
first patterns, this corresponds exactly to the particular case of trivially perfect graphs [9]. These
graphs are also known as comparability graphs of trees or quasi-threshold graphs.
5 Multi-crossing mobility model
5.1 General recognition algorithm
We consider now the case of multicrossing. For each edge, λno longer needs to be single valued.
Weintroduceanalgorithmthatdetectsthetemporalgraphsresultingofmulticrossing. Weprovide
an impossibility result about characterizing this class of graphs. We give a way to check, for any
triplet of nodes, if their temporal subgraph corresponds to a multicrossing sequence or not, by
using an automata approach.
14Input:The representation R(G)of a temporal graph G= ((V, E), λ).
Output: A final vertex ordering π.
1ScanR(G)to obtain the list Vof nodes.
2Initialize for each node u∈Va doubly linked list L(u)containing u.
3We let NL(u)denote the neighbors of each u∈Vin its list (initially, NL(u) =∅).
4We maintain the collection C={L(u) :u∈V}which represents a partition of V.
5For each extremity u∈Vof a list, we also maintain a pointer P(u)to its list (initially,
P(u)points to L(u)for all u∈V, when uis not an extremity P(u)is set to NIL).
6For(u, v, t )∈ R(G)do
7Ifv∈NL(u)then
/*uandvare neighbors in the same list. */
8 Exchange uandvin their list.
9 Update P(u)andP(v)).
10 else
11 If|NL(u)| ≤1and|NL(v)| ≤1andNIL̸=P(u)̸=P(v)̸=NILthen
/*uandvare extremities of two distinct lists. */
12 LetLuandLvbe the lists pointed by P(u)andP(v)respectively.
13 Concatenate LuandLvinto a list Lso that uandvbecome neighbors.
14 C:= (C \ {Lu, Lv})∪L.
15 Exchange uandvinL.
16 Update P(u)andP(v)toNILand for each extremity wofLsetP(w)toL.
17 else
18 Return ⊥/* Failure. */
19Return the concatenation (in any order but including separators) of all remaining lists.
Algorithm 2: Multicrossing recognition algorithm.
15We now propose an algorithm for recognizing if a sequence of edge appearances corresponds
to a1D-mobility schedule. The main idea is to scan the sequence while maintaining all possible
orderings of the nodes at current time through a collection C={L1, . . . , L k}of lists partitioning
the set of nodes. Each list Liin the collection indicates that the nodes it contains are consecutive
in the current ordering π:Lior its reverse must be a sub-sequence of π. In other words, the set
of possible orderings represented by the collection Cis made of concatenations L′
σ(1), . . . , L′
σ(k)
where σis any permutation of [k]and each L′
iis either Lior its reverse. Each time two nodes
uandvcross each other, we know that they must be consecutive in the current ordering and
that their positions get exchanged. If they are in the same list, they must thus be neighbors
and get exchanged in the list. Otherwise, the only possibility is that the two lists containing
uandvare consecutive sub-sequences of the current ordering π. Moreover, uandvmust be
extremities of these sub-sequences, and they are next one to another in π. The two lists must
thus be concatenated before exchanging the positions of uandv. See Algorithm 2 for a formal
description.
Proposition 5. Algorithm 2 is correct and runs in linear time.
Proof.The correctness of Algorithm 2 comes from the fact that Crepresents all possible orderings
of the nodes after each iteration of the scanning loop. This can be proven by a simple induction
based on the discussion above. As each iteration takes constant time, the whole computation takes
linear time. We also use O(1)space per node and the whole computation can be performed in a
streaming fashion using O(n)space.
The collection Ccan be seen as a PQ-tree with only two levels to make the link with [22]. We
use a simple representation as a collection of lists for the sake of simplicity. This algorithm can
be seen as an online algorithm since if new edges appear we can reload the algorithm separating
the lists.
Finally, we can also obtain a possible initial ordering by running the algorithm on the reverse
ofR(G)by a time reversal argument.
5.2 Unordered forbidden patterns
In this section, we consider unordered forbidden patterns for multicrossing graphs. This time, we
no longer have ordering on the nodes for patterns. It means that we directly consider exclusion of
temporal patterns, as defined in the preliminaries section.
We prove that there does not exist any finite set of forbidden (unordered) patterns to charac-
terize the mobility graphs with multicrossing:
Theorem 6. For any k∈N, there exists a graph on knodes that does not correspond to a
multicrossing such that no pattern on a subset of its nodes can be forbidden.
Proof.We consider the set of vertices V={v1, . . . , v k}. The idea is that if we have a se-
quence of edges of the form (x1, x2)2(x2, x3)2. . .(xk−1, xk)2, it means that those nodes are ordered
x1, x2, . . . , x k(or its mirror) both at the beginning and after this sequence of edges. Indeed, when
we have twice in a row the edge (x, y), it implies that xandyare next to each other, and both
are in the same position as before.
Totheabovesequence, byaddingtwicetheedge (x1, xk)attheend, wegetaforbiddenpattern,
as both x1andxkare in the same list in Algorithm 2, but on both ends.
If we take a subset of size k−1, it means that there is some ximissing. From the initial order
xi+1. . . x kx1. . . x i−1, after applying the corresponding sequence of edges, we got no issue with
Algorithm 2 and end up in the same configuration that the one in the beginning.
5.3 Automaton approach
We have noticed in the case of Mobility Cliques that a contradiction is met when 3 agents have an
impossible situation. For this reason, we consider now only 3 nodes, with a new approach. Let a,
16bandcbe three nodes starting with order abc. To see the evolution of the ordering of the 3 nodes,
we consider an automaton where each state represents an ordering. For each possible crossing, we
put an edge with the pair as a label, going from an ordering to its update after the switch. For
example, from abc, with edge ab, we go to state bac. This automaton is represented in Figure 5.
abc start acb cab
bac bca cbabc ac
ac bcab ab
Figure 5: Automaton of possible edge sequences on the nodes a,bandc.
The goal is to capture the possible sequences of edges of V. We can see the ordered sequence
of edges as a word in Σ∗with Σ ={ab, bc, ac }. To consider the impossible words, we need to look
at the complementary of this automaton. We are doing the following shortcuts:
•We can see that only the node in the middle is relevant and the two states corresponding to
an ordering and its left-right mirror. We will now identify these pairs of states, merging abc
andcbainto state b,acbandbcainto state c,bacandcabinto state a.
•To simplify the reading, each edge will be identified with the uppercase version of the node
that is not in it. For example, abbecomes C, and Σ ={A, B, C }.
•We add one more state ⊥, corresponding to the final state that can be reached for leaving
the automaton from Figure 5.
b startc
a⊥A
B
CABC
Σ
Figure 6: Automaton of possible edge sequences.
From this, we get the automaton of Figure 6. In particular, we consider the words ending in
the final state ⊥. This state corresponds to the case where we had an impossible edge happening
before. From there, we accept any edge from Σ.
Using usual automaton reductions, we can deduce a regular expression corresponding to the
set of words on Σ∗/sequences of edges that are possible in our model. One can prove that the
corresponding language LMCis:
LMC=LId(ε+AB∗+CB∗) (2)
17where εdenotes the empty word and LIdis the language of sequences leading back to the initial
ordering with bin the middle:
LId= [A(BB)∗A+C(BB)∗C+AB(BB)∗C+CB(BB)∗A]∗(3)
Equivalently, our model forbids the language recognized by the automaton of Figure 6:
LId[B+ (A+CB)(BB)∗C+ (C+AB)(BB)∗A]Σ∗(4)
Theorem 7. Letnagents on a line initially ordered as {a1, . . . , a n}, and an ordered list of triplets
R= (u1, v1, t1), . . . , (uM, vM, tM)of temporal edges such that ∀i, < j ≤M,ti< tj. We consider
the corresponding temporal graph G= ((V, E), λ)withV={a1, . . . , a n}.
Gcorresponds to multicrossing if and only if, for any i < j < k ≤M, the sequence of edges
A=ajak,B=aiakandC=aiajordered with multiplicity according to Ris in LMC.
Proof.AsLMCcorresponds to the exact set of possible sequences on A,BandC, multicrossing
directly implies the property for any 3 distinct agents. On the other hand, one can notice that G
does not correspond to a multicrossing if there exists ai,aj,akandtsuch that (ai, aj, t)∈ Rand
akis between aiandajat time t−1. Consider the earliest time twhere this happens for a triplet
ai,aj,ak.
As there is no influence from any other node in the sequence in where those three nodes are at
time t−1relatively to each other, we consider the crossings between these three nodes in the prefix
R<t={(u1, v1, t1) :t1< t}. Let us assume i < j < k (the other cases are handled in the same
way, choosing the right names for the edges). Let name A=ajak,B=aiakandC=aiajfor the
(partial) edges, and consider the sequence of apparition of these edges in R<t. As the sequence
of crossing is valid up to that point, the corresponding word on A, B, Cleads the automaton of
Figure 6 to one of the states a, b, c. Asakis in the center, this state must be c, and the transition
Cat time tleads to the ⊥state where the automaton remains until the end of the sequence. This
allows to conclude the second part of the proof.
6 Circular temporal clique
6.1 Preliminary
Circular ordering. A circular ordering of a set Xis a ternary relation C⊆Xsuch that for any
four elements x, y, z, w ∈Xthe following statements hold: [12]
•if(x, y, z )∈Cthen (y, z, x )∈C,
•if(x, y, z )∈Cthen (x, z, y )/∈C,
•either (x, y, z )∈Cor(x, z, y )∈C.
•if(x, y, z )∈Cand(x, z, w )∈C, then (x, y, w )∈C,
The elements in Xcan be uniquely, up to rotations, arranged around a fixed circle such that,
for any tuple (x, y, z )∈C, if we read elements in the circle clockwise from x, then the reading
ordering is x, y, z. We say that xandzareconsecutive inCwhen Cdoes not contain triplets
(x, y, z )nor(z, y, x )for any y∈X.
Circularly ordered graphs. A circularly ordered temporal graph is a pair (G, π), where Gis a
temporal graph and πis a circular ordering of its nodes. Similarly, a circularly ordered temporal
pattern (H, π)is a temporal pattern Htogether with a circularly ordering πof its node. A
circularly ordered incremental temporal graph (G, π′)excludes (H, π)when it does not have any
temporal subgraph H′which is isomorphic to Hthrough an isomorphism ϕpreserving relative
circular orderings, that is (ϕ(u), ϕ(v), ϕ(w))∈πwhenever (u, v, w )∈π′. We then also say that
the ordering π′excludes (H, π)fromG, or simply excludes (H, π)whenGis clear from the context.
186.2 Model
We introduce here the notion of temporal graph associated to mobile agents moving along a circle
that is an one-dimensional sphere. Consider nmobile agents in an oriented circle. At time t0= 0,
they initially appear along the line according to a circular ordering π0. These agents move along
the circle and can cross one another as time goes on. We assume that a crossing is always between
exactly two neighboring agents, and a single pair of agents cross each other at a single time. By
ordering the crossings, we have the kth crossing happening at time tk=k.
Acircular-mobility schedule from an ordering π0=a1, . . . , a nofnagents is a sequence x=
x1, . . . , x Tof crossings within the agents. Each crossing xtis a pair uvindicating that agents u
andvcross each other at time t. Note that the circular ordering πtat time tis obtained from
πt−1by permuting uandv, and it is thus required that they appear consecutively in πt−1. To
such a schedule, we can associate a temporal graph Gπ0,x= ((V, E), λ)such that:
•V={a1, . . . , a n},
•E={uv:∃t∈[T], xt=uv},
•for all uv∈E,λ(uv) ={t:xt=uv}.
We are interested in particular by the case where all agents cross each other exactly once as
the resulting temporal graph is then a temporal clique which is called a circular-mobility temporal
clique. More generally, we say that an incremental temporal graph Gcorresponds to a circular
schedule if there exists some circular ordering πof its vertices and a circular schedule xfrom π
such that the identity is an isomorphism from GtoGπ,x. The graph Gis then called a circular
temporal graph .
6.3 Characterization
Theorem 8. A temporal clique is a circular-mobility temporal clique if and only if there exists a
circular ordering πof its nodes that excludes the circularly ordered temporal patterns of Figure 7
as a prefix.
The theorem derives from the following lemmas.
Lemma 6. The relative circular ordering of four agents, a, b, c, d, does not change after a crossing
of two agents which are both distinct from a, b, c, d.
Lemma 7. LetGbe a circular-mobility temporal clique, and πbe the initial circular ordering of
nodes in the oriented circle, then πexcludes the circular forbidden patterns in Figure 7 from G.
Proof.First observe that the relative circular ordering of four agents, a, b, c, d, does not change
after a crossing of two agents which are both distinct from a, b, c, d. Furthermore, if two agents u
andvare not consecutive at a certain time, they cannot cross each other in the next time step.
One can check that each pattern of Figure 7 contains such a forbidden step.
Informally, for a circular order of four agents, there are 6!incremental temporal cliques. We
considered all of those circular patterns exhaustively, to see if the corresponding four-agent sched-
ules with the corresponding original orderings are feasible or not. All forbidden patterns are
exactly the patterns that have a prefix among the ones displayed in Figure 7.
Lemma 8. Any temporal clique G ∈ Chaving a circular ordering πexcluding the circular forbidden
patterns in Figure 7, can be associated to a circular-mobility schedule from πas initial circular
ordering of agents.
Proof.Recall that, up to isomorphisms, we can assume that Ghas life time T=n(n−1)/2and
that exactly one edge appears at each time t∈[T].
Starting from the initial circular ordering π0=π, we define a sequence π1, . . . , π T, where
T=n(n−1)/2, of circular orderings, corresponding to what, we believe, to be the circular
19au
b
v1au
b
v12
au
b
v21
au
b
v13
24au
b
v14
23
au
b
v1
2
3au
b
v1
2
3au
b
v1
23
4au
b
v3
21
4au
b
v1
43
2au
b
v3
41
2
au
b
v1
23au
b
v1
23au
b
v1
24
3au
b
v4
21
3au
b
v1
34
2au
b
v4
31
2
au
b
v1
23
45au
b
v3
21
54au
b
v1
23
54au
b
v3
21
54au
b
v1
43
25au
b
v3
41
52
au
b
v1
2
354
au
b
v4
2
531
au
b
v1
2
345
au
b
v5
2
431
au
b
v1
45
23au
b
v5
41
32
Figure 7: Circularly ordered forbidden prefix patterns in an ordered circular-mobility temporal
clique. Each pattern is ordered clock-wise and associated circular ordering a, u, b, v.
positions of the agents at each time step if we read the edges of Gby increasing time label as a
mobility schedule. More precisely, for each t∈T,πtis defined from πt−1as follows. Consider the
edge uv=λ−1(t)appearing at time tinG. We define τtas the transposition exchanging uandv
inwt−1. Equivalently, we set τt= (i, j)where iandjrespectively denote the indexes of uandv
inπt−1, i.e. πt−1(i) =uandπt−1(j) =v. We then set πt=πt−1τt.
We need to prove that utandvtare indeed adjacent in πt−1. Consider the first time twhen
this fails to be. That is τ1, . . . , τ t−1are adjacent transpositions, edge uvappears at time t, i.e.
uv=utvt, and u, vare not consecutive in πt−1. It implies that there exists two other nodes a, b
such that in πt−1, the relative circular ordering amongs the four vertices is a, ut, b, vt. We consider
the temporal subgraph, H, induced by the four vertices a, ut, b, vt. Then Hbelongs to the set S
of forbidden circular patterns.
Remark. The set of forbidden prefix patterns in Figure 7 can also be used to characterize
temporal mobility graphs arising in 1D model where pairs cross each other at most once. Each
(partial) completion of a prefix of Figure 7 cannot happen in a circular mobility clique, and
conversely, any impossible pattern must have a prefix from Figure 7.
6.4 Multi-crossing circular mobility model
Each state of the automaton 8 represents two circular orderings of four agents, a, b, c, d, in the
circle. The state x−y, z−tcorresponds to circular orderings such that two agents x,yare
not adjacent; and two agents z,tare not adjacent. Intuitively, from a current circular ordering
20corresponding to the state x−y, z−t, only agents, which are adjacent, can cross. For example,
from an ordering corresponding to the state a−c, b−d, after the agents bandccross, the resulting
circular ordering is an ordering corresponding to the state a−b, c−d. An impossible crossing
arises when two non-adjacent agents, in a current circular ordering, cross. This is captured by
transition rules representing crossing of non-adjacent agents, which leads states to an accepting
state, ⊥. Formally, the automaton, (Q,Σ, δ, q 0, F), of impossible crossing-sequences is defined as
follows.
•Each state, x-y, z-t, inQ, represents two circular orderings ( x, z, y, tandx, t, y, z), in which,
two agents x,yare not adjacent; and two agents z,tare not adjacent;
•Σ ={ab, ac, ad, bc, bd, cd }corresponds to crossings between two agents;
•Function δ, which is a transition function from QtoQ, is given by Figure 8;
•Initial state, q0, is the state a-c, b-d;
•Accepting state, F, is the state ⊥.
Each word of the automaton corresponds to a sequence of crossings which is impossible in a
circular mobility model.
a-c, b-d starta-b, c-d
a-d, b-c⊥bc, ad
ab, cdac, bdac, bdab, cd
bc, adΣ
Figure 8: Automata of possible crossing-sequences.
We can see that the automaton is the same as the one in Figure 6, if we replace Bwith ac, bd,
Cwith ab, dcandAwith bc, ad. Hence, we deduce the set of impossible sequences by doing the
corresponding changes in the regular expression (4).
Theorem 9. LetG= ((V, E), λ)be a temporal graph on nvertices labeled as V={a1, . . . , a n}.
We order the temporal edges of Gas a sequence of triplets R= (u1, v1, t1), . . . , (uM, vM, tM)such
that∀i, < j ≤M,ti< tj. If there exists a circular ordering on vertices of G, such that any
sub-sequence of Rrestricted to crossing among four agents a, b, c, dis recognized by the automaton
in Figure 8, then Gis a multi-crossing mobility graph.
Proof.The proof of Theorem 9 is similar to the proof of Theorem 7.
7 Conclusion and perspectives
In this paper, we have introduced the first notion of forbidden patterns in temporal graphs. In
particular, this notion allowed us to characterize a range of classes of temporal cliques correspond-
ing to 1D mobility models. In case when agents cross each other exactly once, we show that
21Figure 9: Illustration of the appearance of the directed edge 3→5in our 2D-model where agents,
like chickens, have a visibility region orthogonal to their direction of movement.
the corresponding class of temporal cliques has spanners of size 2n−3, following the conjecture
from [7]. We note that in our model when two agents meet, they are forced to switch positions
along the line. As a next step, one could lift this constraint and try to characterize graphs arising
from the more general model, where the adjacency between two agents do not necessarily imply
that they swap places. Another possible generalization is to study mobility models in higher
dimensions. It is known that (static) unit-disk graphs have infinitely many minimal forbidden
induced subgraphs [1]. Nevertheless, it would be interesting to study this class from the point
of view of forbidden patterns. We also propose a more constrained 2D model giving a directed
temporal graph: here vertices are agents in R2, each moving in a fixed direction and at time t,
we have a (directed) edge from agent ito agent jif and only if the line through the positions of
agents iandjis orthogonal to the moving direction of agent i, see Figure 9. We call this the
“chicken model”, imagining that each agent has eyes on each side and sees others when they are
on one side or the other. Note that when all agents have parallel trajectories and move in the
same direction, it is then similar to our 1D-mobility model. More generally, can we find mobility
models in higher dimensions that also provide interesting temporal cliques?
Our work can also be seen as a characterization of square integers matrices in terms of patterns
(if we fill the adjacency matrix of a 1D-mobility clique with the time of appearance of each edge),
perhaps it could be generalized to a study of well-structured matrices as in the seminal work of [17]
on Robinsonian matrices which are closely related to interval graphs.
Acknowledgement
This work was supported by the French ANR project TEMPOGRAL (ANR-22-CE48-0001). The
thirdauthorhasreceivedfundingfromtheEuropeanUnion’sHorizon2020researchandinnovation
program under the Marie Skłodowska-Curie grant agreement No 945332.
References
[1] Atminas, A., Zamaraev, V.: On forbidden induced subgraphs for unit disk graphs. Discrete
& Computational Geometry 60(1), 57–97 (2018)
[2] Awerbuch, B., Even, S.: Efficient and reliable broadcast is achievable in an eventually con-
nected network. In: Proceedings of the third annual ACM Symposium on Principles of Dis-
tributed Computing. pp. 278–281 (1984)
[3] Axiotis, K., Fotakis, D.: On the size and the approximability of minimum temporally con-
nected subgraphs. In: 43rd International Colloquium on Automata, Languages, and Program-
22ming,. LIPIcs, vol. 55, pp. 149:1–149:14 (2016), https://doi.org/10.4230/LIPIcs.ICALP.
2016.149
[4] Bandlow, J.: An elementary proof of the hook formula. Electron. J. Comb. 15(1) (2008),
http://www.combinatorics.org/Volume_15/Abstracts/v15i1r45.html
[5] Bui-Xuan, B., Ferreira, A., Jarry, A.: Computing shortest, fastest, and fore-
most journeys in dynamic networks. Int. J. Found. Comput. Sci. 14(2), 267–285
(2003). https://doi.org/10.1142/S0129054103001728, https://doi.org/10.1142/
S0129054103001728
[6] Casteigts, A., Flocchini, P., Quattrociocchi, W., Santoro, N.: Time-varying graphs and dy-
namic networks. IJPEDS 27(5), 387–408 (2012)
[7] Casteigts, A., Peters, J.G., Schoeters, J.: Temporal cliques admit sparse spanners. Journal of
Computer and System Sciences 121, 1–17 (2021)
[8] Damaschke, P.: Forbidden ordered subgraphs. Topics in Combinatorics and Graph Theory:
Essays in Honour of Gerhard Ringel pp. 219–229 (1990)
[9] Feuilloley, L., Habib, M.: Graph classes and forbidden patterns on three vertices. SIAM
Journal on Discrete Mathematics 35(1), 55–90 (2021)
[10] Frame, J.S., Robinson, G.d.B., Thrall, R.M.: The hook graphs of the symmetric group.
Canadian Journal of Mathematics 6, 316–324 (1954)
[11] Guzmán-Pro, S., Hell, P., Hernández-Cruz, C.: Describing hereditary properties by forbidden
circular orderings. Appl. Math. Comput. 438, 127555 (2023)
[12] Guzmán-Pro, S., Hell, P., Hernández-Cruz, C.: Describing hereditary properties by forbidden
circular orderings. Applied Mathematics and Computation 438, 127555 (2023)
[13] Hell, P., Mohar, B., Rafiey, A.: Ordering without forbidden patterns. In: Algorithms-ESA
2014: 22th Annual European Symposium. Proceedings 21. pp. 554–565. Springer (2014)
[14] Holme, P., Saramäki, J.: Temporal networks. Physics reports 519(3), 97–125 (2012)
[15] Kempe, D., Kleinberg, J., Kumar, A.: Connectivity and inference problems for temporal
networks. In: Proceedings of the thirty-second annual ACM Symposium on Theory of Com-
puting. pp. 504–513 (2000)
[16] Latapy, M., Viard, T., Magnien, C.: Stream graphs and link streams for the modeling of
interactions over time. Social Netw. Analys. Mining 8(1), 61:1–61:29 (2018)
[17] Laurent, M., Seminaroti, M., Tanigawa, S.: AstructuralcharacterizationforcertifyingRobin-
sonian matrices. Electron. J. Comb. 24(2), 2 (2017)
[18] Michail, O.: An introduction to temporal graphs: An algorithmic perspective. Internet Math-
ematics 12(4), 239–280 (2016)
[19] Skrien, D.J.: A relationship between triangulated graphs, comparability graphs, proper inter-
val graphs, proper circular-arc graphs, and nested interval graphs. Journal of graph Theory
6(3), 309–316 (1982)
[20] Stanley, R.P.: On the number of reduced decompositions of elements of Coxeter groups.
European Journal of Combinatorics 5(4), 359–372 (1984)
[21] Tenner, B.E.: Reduced decompositions and permutation patterns. Journal of Algebraic Com-
binatorics 24, 263–284 (2006)
23[22] Villani, N.: Dynamic Unit Disk Graph Recognition. Master’s thesis, Université de Bordeaux
(2021), https://www.labri.fr/perso/acasteig/files/rapport-neven.pdf
[23] Villani, N., Casteigts, A.: Some thoughts on dynamic unit disk graphs. Algorithmic Aspects
of Temporal Graphs IV (2021), https://www.youtube.com/watch?v=yZRNLjbfxxs , satellite
workshop of ICALP
24
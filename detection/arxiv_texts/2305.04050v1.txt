New Algorithms and Applications for Risk-Limiting Auditsâˆ—â€ 
Bar Karovâ€¡Moni NaorÂ§
May 9, 2023
Abstract
Risk-limiting audits (RLAs) are a signicant tool in increasing condence in the accuracy of elec-
tions. They consist of randomized algorithms which check that an election's vote tally, as reported
by a vote tabulation system, corresponds to the correct candidates winning. If an initial vote count
leads to the wrong election winner, an RLA guarantees to identify the error with high probability
over its own randomness. These audits operate by sequentially sampling and examining ballots
until they can either conrm the reported winner or identify the true winner.
The rst part of this work suggests a new generic method, called \Batchcomp", for converting
classical (ballot-level) RLAs into ones that operate on batches. As a concrete application of the
suggested method, we develop the rst ballot-level RLA for the Israeli Knesset elections, and convert
it to one which operates on batches. We ran the suggested \Batchcomp" procedure on the results
of 22nd, 23rd and 24th Knesset elections, both with and without errors.
The second part of this work suggests a new use-case for RLAs: verifying that a population census
leads to the correct allocation of political power to a nation's districts or federal-states. We present
an adaptation of ALPHA, an existing RLA method, to a method which applies to censuses. Our
census-RLA is applicable in nations where parliament seats are allocated to geographical regions
in proportion to their population according to a certain class of functions (highest averages). It
relies on data from both the census and from an additional procedure which is already conducted
in many countries today, called a post-enumeration survey.
âˆ—Research supported in part by grants from the Israel Science Foundation (no.2686/20), by the Simons Foundation
Collaboration on the Theory of Algorithmic Fairness and by the Israeli Council for Higher Education (CHE) via the
Weizmann Data Science Research Center.
â€ A shorter version of this paper appears in the Proceeding of the 4th Annual Symposium on Foundations of
Responsible Computing, FORC 2023.
â€¡Department of Computer Science and Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel.
Email: barkrv@gmail.com
Â§Department of Computer Science and Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel.
Incumbent of the Judith Kleeman Professorial Chair. Email: moni.naor@weizmann.ac.il.
1arXiv:2305.04050v1  [cs.CY]  6 May 2023Contents
1 Introduction 4
1.1 Denition of Risk-Limiting Audits . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.2 Risk Limiting Audits - Limitations and Assumptions . . . . . . . . . . . . . . . . . . 6
1.3 Batch-level Risk-Limiting Audits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.4 Risk Limiting Audits for the Census . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.5 Our Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.6 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.6.1 The SHANGRLA Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.6.2 Finding the Correct Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.6.3 The ALPHA Martingale Test . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.7 Road Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.8 Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2 Batch Risk-Limiting Audits 20
2.1 Preliminaries and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.1.1 The Batch-level RLA Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.2 The Batchcomp RLA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.2.1 Preliminaries and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.2.2 The Batchcomp Algorithm Description . . . . . . . . . . . . . . . . . . . . . . 23
2.2.3 Choosing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3 Israeli Knesset Elections RLA 31
3.1 Knesset Elections Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.2 Designing Assorters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.2.1 Above Threshold Assertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.2.2 Below Threshold Assertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.2.3 Move-Seat Assertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.2.4 Handling Apparentments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.3 Simulations Based on Recent Elections . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.3.1 Technical Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
3.3.2 Results with Accurate Vote Tabulations . . . . . . . . . . . . . . . . . . . . . 37
3.3.3 Results with Small Tabulation Inaccuracies . . . . . . . . . . . . . . . . . . . 43
23.3.4 Simulation Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.4 Existing Recounting Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4 Census Risk Limiting Audits 51
4.1 Preliminaries and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.1.1 Post Enumeration Survey . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.1.2 The Census RLA Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
4.2 The Census RLA Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
4.2.1 Assumption and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
4.2.2 Census Assorters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
4.2.3 Designing Household-Level Assorters . . . . . . . . . . . . . . . . . . . . . . . 55
4.2.4 Designing Household-Comparison Assorters . . . . . . . . . . . . . . . . . . . 59
4.2.5 Census RLA Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4.3 Census RLA Simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.3.1 The House of Representatives of Cyprus . . . . . . . . . . . . . . . . . . . . . 67
4.3.2 Data Generation and Technical Details . . . . . . . . . . . . . . . . . . . . . . 67
4.3.3 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.3.4 Simulation Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
5 Discussion and Further Research 71
6 References 74
31 Introduction
\Those Who Vote Decide Nothing. Those Who Count The Votes Decide Everything"
Attributed to many, including Joseph Stalin1
Running an election is a delicate endeavour, since casting and tallying votes entails seemingly
contradictory requirements: counting the votes should be accurate and it must also be condential.
A risk-limiting audit (RLA) is a process whose goal is to increase the condence that results of an
election were tallied appropriately, or more accurately that the winner/s were chosen correctly. It
is usually described for election systems where there is an electronic vote tabulation, whose tally
is referred to as the reported results , but also backup paper-ballots, whose tally is assumed
to be the true results . The procedure examines what is hopefully a relatively small number of
the backup paper-ballots, and comparing them to the full reported results of the electronic voting
system. These audits are randomized algorithms, where the randomization is manifested in the
choice of ballots to examine, and potentially the order in which they are examined.
A risk-limiting audit ends either when the reported winners of the election are conrmed, or after
a full recount of the backup paper-ballots of all voters. The audit's goal is to conrm that the
reported winners according to the electronic vote tabulation (the reported tally) match the winners
according to the paper-backups (the true tally). Note that RLAs verify that the elections resulted
in the correct winners according to the backup paper-ballots, and not that the reported vote tally
was completely accurate; an RLA will approve election results that contain counting errors which
do not change the winners of the elections. This fact is useful since it would be infeasible to expect
the vote tally to be accurate up to every single ballot, but we should avoid at all cost counting
errors which change the winners of the elections.
The claimed guarantee of RLAs is that if the reported winners of the elections are not correct (with
regards to the full paper count), then the probability that the audit will mistakenly conrm the
results is lower than some predetermined parameter, referred to as the risk-limit of the audit.
The RLA Guarantee:
If the reported winners of the elections are not correct, the probability that an RLA will
approve them is at most , whereis a parameter which is set before the audit begins.
The eciency of an RLA is measured by the number of paper-ballots it requires to read, given that
the reported tally matches the true one. In most cases, an RLA should remain relatively ecient
even if the reported tally isn't completely accurate, as long as it results in the same winners as the
true tally. The eciency of any specic RLA method is limited by the election system it operates
on. If a system has a sensitive social choice function, meaning that small tallying errors can often
change the election winners, then it is more dicult to audit eciently.
Risk limiting audits provide several advantages over other type of post-election audits. First,
they are software independent, meaning that they do not depend on the specic mechanism with
which the voters cast their ballots. Additionally, they are publicly veriable, as the audit can be
easily broadcast to the public and veried by third parties. Lastly, they provide a clear statistical
1See the Snopes website https://www.snopes.com/fact-check/stalin-vote-count-quote
4guarantee regarding the reported winners of the election. Previous post-election audits relied
mostly on manual recounts of randomly selected precincts, without providing any clear statistical
statement regarding the election results.
For these reasons, RLAs are recommended by many bipartisan organizations who deal with election
integrity [3, 9, 26]. They are currently used to audit a number of local and state-wide elections
in the United States [28]. Some states require them by law, while others are in more preliminary
stages of their implementation. Specic RLA methods were also designed for a number of elections
in Europe [41] and Australia [7], but to the best of our knowledge they have yet to be implemented,
with the sole exception of a preliminary pilot conducted in Denmark [33].
The goal of the work is to expand the realm where RLAs can be used. First, in Section 2.2, we
present a new generic method of converting many existing RLAs into batch-level RLAs. Afterwards,
in Section 4, we suggest a new use case of RLAs- assessing whether a census correctly allocates
political power to dierent regions.
1.1 Denition of Risk-Limiting Audits
Explaining RLAs from a mathematical perspective raises the need to formalize the audited election
system. Most election systems can be dened by the set of possible votes a single voter may cast
and a social choice function which outputs the winners of the elections. More formally, it requires
3 denitions:
â€¢LetCbe the set of possible ballots a voter may cast. For example, in standard parliamentary
elections (like the Israeli Knesset Elections), Cwould be the set of all running parties, plus
an invalid ballot. In the US presidential elections, we could dene Cas the set of tuples of
every running candidate and every federal-state1.
â€¢LetObe the set of all possible election outcomes. An election outcome here is a winning
candidate/s, or an allocation of seats to the running parties, and not an exact tally of votes.
â€¢Letf:C!Obe the social choice function of the said elections. ftakes any number of
ballots and outputs the appropriate election outcome.
After an initial (possibly electronic) tallying of the votes, the reported results are determined. These
results are comprised of a reported election outcome, denoted as orep2O, and some information
regarding the ballots that were cast. Usually, this will be the vote tally - a count of how many
ballots of each type were cast in the entire elections. In some instances, the certicate may even
include the interpretation that the initial vote count (the reported results) gave for each specic
paper-backup ballots. We refer to this extended information which is learned about the ballots,
beyond only the reported winners of the elections, as the certicate of the reported results. This
certicate can be used by a risk-limiting audit to increase its eciency on instances where the
reported tally is accurate, though it must full the RLA guarantee even if it is not.
Using this notation, let Rbe a randomized algorithm with query-access to the paper-backup ballots.
The algorithm receives, before it begins querying for ballots, a reported outcome orep2O, a
1Including the 50 States, District of Columbia and the Maine and Nebraska districts.
5certicatetas described above, and a risk-limit 0 1.Rcan sequentially query for paper-
backup ballots until it either outputs "approve", or until all ballots were queried. If all ballots were
queried,Rknows whether the true outcome of the election according to the paper-backup ballots
isorep, and outputs "approve" or "reject" accordingly. Ris an RLA if it fullls the RLA guarantee,
meaning that it approves a wrongful outcome with probability of at most :
Denition 1.Ris an RLA for an election system with possible ballots C, a set of possible election
outcomesOand a social choice function f:C!O, if for any reported results orep2O, certicate
t, number of ballots n2Nandq: [n]!C, we have:
f(q(1);q(2);;q(n))6=orep=)Pr[Rq()(orep;t;) =approve ]:
WhereRq()denotes thatRhas oracle access to q.qhere encodes the paper-backup ballots, such
thatq(i) returns the ith ballot. The expression above essentially means that for any reported
outcome of the elections orep, and for any sequence of paper-backup ballots, if tallying the paper-
backup ballots results in an outcome dierent than orep, thenRapproves w.p. of at most . This
is exactly the RLA guarantee dened previously.
Under this denition, the eciency of an RLA is measured by the query-complexity of Ron
q: [n]!C for whichf(q(1);:::;q (n)) =orep. Ideally, we would like this query complexity to be as
small as possible when the certicate that Rreceives is representative of the paper-backup ballots.
1.2 Risk Limiting Audits - Limitations and Assumptions
While RLAs are considered the golden-standard of post-election audits, they should always be part
of a more exhaustive post election audit. This is due to some critical assumptions that are made
by existing RLA methods, and need to be veried by some other mean. These assumptions are:
â€¢The paper-backup ballots represent the true intention of the voters: An RLA
only veries that the reported winners according to an initial vote tally matches the winners
according to the paper-backup ballots tally. For this reason, it is critical that voters read and
approve their paper-backup ballots, and that no party can alter these ballots after being cast.
â€¢The audit has access to random bits: Most existing audits require sequential access
to randomly selected paper-backup ballots. If the randomness used to choose these ballots
is compromised, an adversary can cause an RLA to approve the wrong election winners. In
practice, random ballots are sampled using a pseudo random number generator with a random
seed, which is generated by throwing dice at a public meeting2.
â€¢The total number of ballots is known: If the number of ballots is not known, some ballots
may not be considered during the audit. Moreover, if the number of paper-backup ballots
does not match the total number of votes according to the electronic tabulation system, the
audit may not fulll its claimed guarantee. Ensuring that these two numbers match is usually
done before an RLA begins, as part of a separate process called a compliance audit [23]. In
most RLAs, if the two numbers do not match but the size of the discrepancy is known, it can
be xed by adding imaginary invalid ballots to the reported or true results.
2See Q5 on https://www.sos.state.co.us/pubs/elections/RLA/faqs.html and https://arstechnica.com/
tech-policy/2016/11/saving-american-elections-with-10-sided-dice-one-stats-profs-quest/ .
6In addition to the points above, note that an RLA only veries the vote tabulation, and not the
voting process itself. If ineligible voters are allowed to vote, or if voters are coerced to vote in a
specic manner, an RLA does not guarantee the integrity of the elections.
1.3 Batch-level Risk-Limiting Audits
Most RLA models assume that the auditing party has the ability to repeatedly sample random
ballots. However, in many real elections, the ballots are partitioned into batches such that it may
be dicult to sample single ballots at random. This inspires the idea of batch risk-limiting audits. In
a batch-level RLA, instead of sampling single ballots, we iteratively sample entire batches and then
manually count the ballots in these batches. Additionally, we assume knowledge of the reported
tally of each batch, according to the reported count. Batch audits are useful when retrieving a
sequence of randomly chosen batches of ballots is easier than retrieving a sequence of randomly
chosen single ballots.
During batch-level RLAs, we may not assume that ballots were partitioned into batches randomly;
in practice, each batch is usually comprised of ballots cast at a dierent location, meaning dierent
batches typically have dierent distributions of votes. Additionally, we cannot assume that dierent
batches have similar probabilities of miscounting votes. If, for example, the initial vote count, which
produces the reported results, is done at dierent locations for dierent batches, a malicious or
faulty vote counter could produce many counting errors within the same batch. For these reasons,
batch-level RLAs are considered more dicult than single-ballot based RLAs, and typically require
a larger number of ballots to audit the same results.
One critical detail which is assumed to be known is the number of ballots contained in each batch.
Without this knowledge, it would always be possible for a single unaudited batch to contain an
extremely large number of ballots which would change the election winners. It is generally sucient,
however, to assume knowledge of an upper bound on number of ballots in each batch, at the cost
of a certain decrease in the audit's eciency. This could be done by imagining that in the reported
tallies, each batch has a certain number of extra invalid ballots, and recalculating the batch totals
accordingly. During the audit, if a batch has less than its reported number of ballots, we treat it
as if the missing ballots are invalid ones.
1.4 Risk Limiting Audits for the Census
Some political systems allocate political power to dierent regions of a country based on their
population, as reported by a country-wide census. For example, in the United States' House of
Representatives, each state is allocated a number of representatives in proportion to their population
after every census, which is held every 10 years. Such systems are also used, for example, in the
Danish Parliament (Folketing) [35] , in the Pakistani National Assembly [27], and in the German
Bundestag [14]. Some nations re-allocate parliament seats to the nation's regions automatically
following every census (e.g. Germany, USA, Denmark), while others require law amendments for
each such update (e.g. Argentina [11], Cyprus [10]). In these systems, an inaccurate population
count for one or more of these regions could lead to inadequate allocation of representation. For
this reason, it is critical for a country's census to be as accurate as possible.
Many countries today assess the accuracy of their census by conducting an independent mini-census
7over a small number of randomly chosen households, in a process called a post-enumeration survey
(PES). This survey is then compared to the census to estimate its accuracy. Statistical analyses of
the census and the PES provide an estimation on the counting errors of the census regarding dier-
ent population groups. In most cases, these comparisons do not provide any statistical assurances
regarding the accuracy of the census, but help estimate the number of people who were under or
overcounted3[43].
The issue of verifying the original census by comparing it to an independently sampled and inde-
pendently conducted mini-census is reminiscent of the problem RLAs were designed to solve. We
have a reported tally of the number of residents in each region (the census), and we wish to verify
that this tally is accurate by taking a small random sample of the households in these regions
and re-running a smaller census over them (the PES). These similarities inspire a new use-case
for RLAs - verifying that the census leads to the correct allocation of political representatives to
federal-states.
Section 4 suggests a new RLA method which applies to population censuses. Just like a classical
RLA sequentially samples ballots and learns their true content, this census RLA sequentially sam-
ples households and learns their "true" number of residents, according to the PES. It eventually
returns a probability 0with which it can approve the results. This returned probability comes
with a statistical guarantee regarding the probability with which the census' resulting allocation of
representatives to states matches the results of the PES.
1.5 Our Contributions
The new contributions suggested in this work are:
1. A new and general method for performing batch-level RLAs , which can be applied for
many election systems, is presented in Section 2.2. This method, which we call "Batch-
comp", is usable for any social choice function that can be audited using the SHANGRLA
framework [40]. To the best of our knowledge, a generic method for converting ballot-polling
RLAs into batch-level RLAs was suggested only once before [37]. Our method is based on
that conversion, and outperforms it signicantly on real data from the election system we
tested (the Israeli Knesset elections).
2. An RLA method for the Israeli Knesset (The Israeli parliament) elections, based on the
SHANGRLA framework, is presented in Section 3. This method can be applied as-is to
conduct ballot-level RLAs, or be combined with Batchcomp to conduct a batch-level RLA.
To test both the Knesset RLA method and Batchcomp, we simulate their combination on the
real results of three recent election cycles.
While our Knesset RLA method can be viewed as a synthesis and adaptation of previous
suggestions in the literature, it is the rst time RLAs are applied to this setting. Current
recounts in Israel elections are done without an evidence-based approach.
3. A new type of RLA that applies to population censuses. This new type of audit is applicable
in nations where political representatives are allocated to the nation's geographical regions
3Such estimations are performed, for example, as part of the US PES: https://www.census.gov/library/
stories/2022/05/2020-census-undercount-overcount-rates-by-state.html
8based on their population, like the United States, Germany, Cyprus and more. It relies on
data that is already collected in many countries, as part of an existing method for assessing
the accuracy of population censuses called a "post enumeration survey" (PES). To the best of
our knowledge, this is the rst and only method which veries the census' resulting allocation
of representatives to federal-states with a clear statistical guarantee. The method is presented
in Section 4.
1.6 Related Work
The need for post-election audits rose as early as 1969, when experts discovered that Los Angeles'
computerized punch-card vote tabulation system could be secretly altered to rig election results [32].
Following this discovery, a number of state appointed committees suggested new methods to pre-
vent fraudulent electronic vote tabulation. The Los Angeles county election security committee
suggested "A statistical recount of a random sample of ballots (should) be conducted after each
election using manual, mechanical or electronic devices not used for the specic election". To
the best of my knowledge, this is the rst proposal for verifying the results of an electronic vote
tabulation system using a partial manual recount of ballots.
Before the advent of RLAs, post-election audits mostly consisted of a manual recount of the ballots
cast in a number of randomly selected polling places. Early legislation in the United State demanded
that a certain xed percentage of polling places would be extensively audited [29]. These audits,
however, did not provide any statistical guarantee , as they did not depend in any way on the margin
of the elections. Other suggested auditing methods focused mainly on the number of ballots or
polling places that would need to be examined to detect a result-altering miscount, as a factor of
the election result's margin [25, 31, 34]. While some of these methods did provide some statistical
guarantee, often under certain assumptions, they only involved manually recounting a set number
of paper ballots. If the reported winners of the elections could not be approved based on this initial
sample, a full manual recount would be required to complete the audit. This is unlike RLAs, which
operate sequentially and can therefore overcome an unlucky initial sample.
One exception to the observations made above is a post-election audit suggested by Johnson [20].
This method claims to be risk-limiting, and includes the option to sample additional ballots if
the initial sample does not provide sucient evidence that the reported winner of the election is
correct. However, as pointed out previously by Lindeman and Stark [24], it does not truly fulll
the RLA guarantee- the analysis of the risk-limit of this audit contains a critical error. In reality,
the risk-limit of the audit can exceed the pre-set parameter as the audit samples additional ballots.
These issues raised the need for a new type of post-election audit, which provides a clear statistical
guarantee, while having the ability to avoid a full manual recount even if the rst ballots to be
audited do not represent the true distribution of all votes. RLAs, which were rst introduced by
Philip B. Stark in 2008 [38] and received their name shortly after [39], fulll both of these conditions.
Early works in the eld, headed by Lindeman and Stark, focused mainly on plurality elections [23,
24], where the candidate who receives the most votes wins the elections. Later works expanded
the domain of RLAs to additional social choice functions [7, 41, 40]. While often mentioned in
literature as a tool for conrming the results of an electronic vote tabulations system, RLAs can be
used to conrm any type of initial vote count. This can be the tally according to a computerized
voting system, the result of an optical scan of paper-backup ballots, or a manual vote count.
9Most RLA methods belong to one of three categories, as dened by Lindeman and Stark [23]:
1.Ballot-comparison audits: In ballot-comparison audits, the auditor knows which paper-
ballot matches which electronic-ballot. This category of audits is the most ecient, since it
contains the most information about the election results. However, since they require nding a
matching paper-ballot for any randomly selected electronic-ballot, they place a heavier burden
on the body running the election. For this reason, they are seldomly used in practice [23, 22].
2.Ballot-polling audits: In ballot-polling audits, a single paper-ballot can be sampled and
examined, but it does not need to be matched to its corresponding electronic-ballot. This
category of audits appears to be the most popular in practice [1].
3.Batch-level audit: In batch-level audits, ballots are partitioned into batches. The reported
tally of each batch is available, but there's no guarantee that a paper-ballot in the batch
can be connected to its electronic counterpart. As mentioned in previous sections, ballots
are usually not randomly partitioned, and dierent batches are of dierent sizes. Batch-level
audits are generally the least ecient of the three categories, as they require reading more
ballots to get a representative sample of the overall vote distribution.
As mentioned, one of the main goals in recent RLA literature is to develop RLAs for additional elec-
tion systems. Towards this purpose, Stark suggested a general framework called SHANGRLA [40]
which aids in adapting existing RLA algorithms to new social choice functions. This method is
based on an abstraction called \sets of half-average nulls" (SHAN), where given a collection of
lists containing unknown non-negative numbers, we wish to test whether the average of all of
those lists is greater than1
2by querying for the values at dierent indexes. In the paper in-
troducing SHANGRLA, it is shown that testing whether the reported winners of an election are
correct, for many social choice functions, is reducible to the problem of \sets of half-average nulls".
SHANGRLA has opened the way for auditing new social choice functions, and therefore adapt-
ing RLAs to new election systems. A more detailed description of this framework is presented
in Section 1.6.1.
Following SHANGRLA, a number of papers attempted to utilize and improve this framework: Blom,
Stuckey and Teague [5] suggested an even more general way of reducing the problem of approving
election results into the problem of SHAN, including such a reduction for election systems which
use the D'Hondt method. Waudoby-Smith, Stark and Ramdas [44] and Stark [37] provide new and
generally more ecient ways for solving the SHAN problem, thereby improving the eciency of
any SHANGRLA based RLA. Spertus and Stark [36] expanded the SHANGRLA framework to one
that supports stratied RLAs, a type of \split audit" which allows a certain part of the audit to
use ballot-comparisons while only relying on ballot-polling for the rest.
One particularly useful algorithm that is based on the SHANGRLA framework is the ALPHA
martingale test [37]. This test provides one of the most ecient solutions for the SHAN problem,
meaning that every risk-limit auditing problem which can be reduced to SHAN can be solved with
this test. One unique benet of ALPHA is its relatively simple expansions to the elds of both
stratied RLAs and batch-level RLAs. To the best of my knowledge, it provides the rst and only
batch-level RLA for the SHANGRLA framework, though its eciency was not previously analyzed,
either analytically or by using simulations. The batch RLA algorithm provided in Section 2 of this
work relies on their suggested method.
10The batch RLA method provided by ALPHA can convert any existing SHANGRLA based ballot-
polling RLA into a batch-level RLA. That method, however, does not utilize the reported tallies
of each batch; it only uses the reported winners of the elections, the sizes of the batches and the
overall reported tally of the elections. This could be useful if the reported tallies of specic batches
are not available, but is likely to be sub-optimal otherwise. One could naively convert their batch-
level RLA method into one that uses these reported batch tallies, but any such simple conversion
I could think of turned out to be less ecient than their original ALPHA's batch method, at least
when simulated on the Israeli Knesset elections. This observation inspired our work towards new
batch-level RLAs.
Since the new batch-level RLA method suggested in this work is based on SHANGRLA and ALPHA,
it requires some understanding of these two works. The goal of the following two subsections is
to provide all necessary information regarding them. We begin by presenting the SHANGRLA
framework, and follow by showing how the ALPHA martingale test can be used to audit any
election system which has a SHANGRLA-style reduction.
1.6.1 The SHANGRLA Framework
As mentioned previously, one popular way of designing an RLA is the SHANGRLA framework [40].
This framework is based on a reduction of the problem of verifying the election result to another
problem, called \sets of half average nulls". The exact reduction is dependant on the social choice
function used in the elections. Once a reduction for some specic election system is found, a number
of existing algorithms [37, 40, 44] for the \sets of half average nulls" problem can be used to perform
an RLA on that system.
Sets of Half-Average Nulls
In this setting we have `lists, each containing nunknown entries of non-negative numbers. We
denote the values in these lists as:
[x1
1;x1
2;:::;x1
n]
...
[x`
1;x`
2;:::;x`
n];
where we are guaranteed that for all 1 i`and 1jnwe havexj
i0. The goal of an
algorithm for this problem to determine w.h.p. (up to a pre-set parameter) whether the average of
allof these lists is above1
2. Meaning, to determine whether for every j2[`] we have:
1
nnX
i=1xj
i>1
2:
The algorithm has query access to the values in the lists, where each query returns the values at
some specied index in all lists. Meaning, if the algorithm queries for index i, it learns the values
ofx1
i;x2
i;:::;x`
i.
11The eciency of such an algorithm for a specic input and a parameter 0 1 is measured
by the expected number of queries it performs to determine whether an input is a yes-instance
(e.g. all lists have an average greater than1
2), w.p. of at least 1  . Typically, we wish that an
algorithm would be as ecient as possible on yes-instances, but we do not care about its eciency
on no-instances.
For the purposes of RLAs, we are interested in randomized and adaptive algorithms for this setting.
Such an algorithm can query for indexes sequentially, and decide after each query whether to query
again, or to stop and declare that all of the list-averages are at greater than1
2.
A typical algorithm for this problem keeps `p-values, each corresponding to a dierent list. Each
of these values represents the probability of obtaining the query results we previously received if
the average of its corresponding list is at most1
2. The algorithm then queries for random indexes
iteratively, where after each query it updates the p-values based on the values it learns. If all
p-values are below simultaneously, it decides the average of all lists is greater than1
2. Otherwise,
it queries for another random index.
Reduction From the Problem of Approving Election Results
LetCbe the set of all possible ballots a single voter may cast, including the option to cast an invalid
ballot. For example, in standard parliamentary elections (such as the elections for the Knesset),
Cincludes all running parties, plus an invalid ballot. In ranked choice voting, Cis the set of all
permutations over all subsets of candidates, plus an invalid ballot. Let B2Cnbe the list of all
ballots in an election with nvoters. For simplicity, we assume that the entries of Bare given in
random order, and denote these ballots as b1;b2;:::;bn.
Given the reported winners of the elections, we wish to reduce the problem of nding whether these
reported winners are the true winners, to the aforementioned problem of sets of half-average nulls.
In the SHANGRLA framework, this reduction is done by nding `functions called assorters :
Denition 2. LetCbe the set of ballots a single voter may cast in some election system. A set
of functions: a1;a2;:::;a`:C![0;1)areassorters for the election system if they fulll the
condition: The reported winners are the true winners i for every k2[`]we have:
1
nnX
i=1ak(bi)>1
2:
These`inequalities are referred to as the assertions of the audit.
If we nd such functions a1;:::;a`, then an RLA could be performed by solving the SHAN problem
on the following `lists:
[a1(b1);a1(b2);:::;a 1(bn)]
...
[a`(b1);a`(b2);:::;a`(bn)];
where we query for an index by sampling the corresponding ballot and calculating a1;a2;:::;a`over
that ballot. Recall that when approving the reported election winners, we wish to minimize the
12query complexity on inputs where the reported winners are correct. If the reported winners are
not correct, a full recount would be in order anyway, so we would not mind it if the audit counts
many (or potentially all) ballots to discover so.
Example - Plurality Elections
Say we wish to audit a plurality election between two candidates, Alice and Bob, where the can-
didate who receives more votes wins. When we only have two running candidates and no invalid
ballots, this reduces to a simple majority election. If Alice reportedly won the elections, we could
audit them using the SHANGRLA framework using a single assorter:
a(b) =8
><
>:1 ifbis for Alice
0 ifbis for Bob
1
2ifbis invalid
and1
nP
b2Ba(b)>1
2i Alice got more votes than Bob.
If we have more than 2 candidates, we could add one more similar assorter for every reportedly
losing candidate c. This assorter has a mean of1
2or more i the reportedly losing candidate c
receives less votes than Alice (the reported winner):
ac(b) =8
><
>:1 ifbis for Alice
0 ifbis forc
1
2ifbis invalid
Verifying that all such assorters have a mean greater than1
2using an algorithm for the SHAN prob-
lem is equivalent to verifying that Alice received more votes than all reportedly losing candidates,
making Alice the true winner of the elections.
1.6.2 Finding the Correct Assertions
In the example above, nding the correct set of assertions and assorters is relatively simple. For
other election systems, which use more complicated social choice functions, verifying the correctness
of the election winners can sometimes be reduced to verifying a set of linear inequalities, but it is
not immediately clear how to reduce them to assertions of the form1
jBjP
b2Ba(b)>1
2. For such
cases, Blom et al. [5] suggests a generic solution, by reducing the problem of verifying that a set of
linear inequalities that depend on the various vote tallies are all true to the problem of verifying
that a set of assorters all have a mean greater than1
2. This section explains this reduction.
Say we have `inequalities that we wish to conrm, each of the form:
X
c2Ccvtrue(c)>d; (1)
wherevtrue(c) is the number of cast ballots of of type caccording to the true results, and dandc
(for eachc2C) are constants. We wish to convert each inequality in the form of (1) to an assertion
13in SHANGRLA form:
1
jBjX
b2Ba(b)>1
2; (2)
whereBis the list of all paper-backup ballots in the election and ais a non-negative function.
Meaning, given (1), we wish to nd a function a:C![0;1) such that (2) is equivalent to (1). As
Blom et al. suggest, this is achieved by dening:
a(b) := b z
2
z d
jBj; (3)
wherez:=minc2Cfcg. The value bhere is the coecient of the type of ballot bis in (1). Using
this denition for a, we have it that inequality (1) is true i (2) is true, and ais a non-negative
function, as required.
Note that this assorter is valid as long as z d=jBj<0. Otherwise, it may return negative
values. As explained by Blom et al., having z d=jBj0 would indicate that (1) is either always
false or always true, for any distribution of votes. Thus, the assorters this method generates are
non-negative in all non-trivial cases.
Given a set of inequalities as in (1), we can use this denition to create one SHANGRLA assertion
(as in (2)) per inequality. The set of these SHANGRLA assertions are all true i the set of the
original inequalities are all true.
1.6.3 The ALPHA Martingale Test
This section explains the ALPHA martingale test [37] solution for the set of half-average nulls
problem. Using the reduction described in Section 1.6.1, this algorithm can be used to perform
RLAs. For brevity, This description details how this algorithm operates on the problem of approving
election results directly. This means that instead of writing xi
k, as dened in the SHAN problem,
we useak(bi), which is the the ith value in list number kin the reduction described in Section 1.6.1.
The version described here relies on sampling ballots without replacement.
Before presenting the full algorithm, we provide a high level description of its operation- the ALPHA
martingale test operates by keeping `variablesT1;:::;T`, each representing the multiplicative inverse
of a p-value for the hypothesis that a certain list has an average greater than1
2. The test then
queries sequentially for random paper-backup ballots, without replacement, where after each ballot
it updates these kvariables. If at any point a statistic Tksurpasses the threshold1
, it means that
we have sucient evidence that the mean of its corresponding assorter akover all ballots is greater
than1
2. If after a certain query, all of T1;:::;T`have surpassed1
at some point during the audit,
then the reported winners of the elections are approved.
After each queried paper-backup ballots bi, the algorithm updates the statistic Tkfor everyk2[`].
This update is performed by comparing ak(bi) to the following values, which are set before biis
revealed:
1.k: The mean value of akover all ballots that have yet to be audited, given that the mean
ofakover all ballots is1
2. Recall that if the mean of akover all ballots is at most1
2, then the
14reported winners of the elections are wrong, which is the case the algorithm wishes to detect.
This means that if at some point during the audit, we sample a ballot bwithak(b)k, it
provides evidence that the reported winners of the elections are less likely to be correct, and
vice-versa.
2.k: A guess for what we would expect ak(bi) to be based on the reported results and the ballots
previously queried. This guess can be made in several ways while maintaining the algorithm's
correctness. One reasonable way to do so is to set kto be the mean of akover ballots that
have yet to be audited, assuming that the reported tally is completely accurate. The audit
becomes more ecient, meaning less ballots need to be examined, the more accurate this
guess is.
3.uk: In the paper presenting ALPHA, ukwas dened as the maximal value akmay return.
In reality, the ALPHA martingale test is risk-limiting even for other choices of uk, as long as
the inequality k<k<ukis always maintained. For our purposes, ukcan be thought of as
a guess for whether the next sampled ballot would indicate that assertion kis more or less
likely to be true. If the next ballot to be sampled increases our condence that the assertion
is true, the audit is more ecient when ukis large, and vice-versa.
After each query, the test updates Tkaccording to ak(bi);k;kanduk. IfTk>1
, it concludes
that1
nP
b2Bak(b)>1
2. Otherwise, it updates k;kandukin preparation for the next query.
If after querying for some ballot biwe haveak(bi)k, thenTkwould shrink - indicating that
it's now less likely that1
nP
b2Bak(b)>1
2. Otherwise, if ak(bi)> k, thenTkwill increase. The
magnitude with which Tkincreases depends on ak(bi) andk.Tkgrows more signicantly when
ak(bi) is large and when ak(bi) is close to k. For this reason, we set kto be the best guess we can
make for the value akwould return on the next ballot we sample.
The variable uk, controls how stable Tkis. Meaning, how substantially Tkchanges per ballot.
Choosing a larger ukcausesTkto be more stable, meaning that the magnitude of its change based
on a single ballot is smaller. Choosing a smaller ukincreases that magnitude and therefore raises the
variance of the audit - it could cause it to nish earlier, since it allows Tkto grow more substantially
per ballot, but might slow it down or potentially cause it to read all ballots, if the order in which
we sample ballots is \unlucky".
The algorithm presented here is a slightly altered version of the one presented in the original paper.
The exact dierences are discussed at the end of this section.
ALPHA Martingale Test Algorithm
Let the inputs to the algorithm be ballots B= (b1;b2;:::;bn), which are given to us in random
order, and assorters a1;:::;al:C![0;1) whereCis the set of all possible ballots a voter can cast.
Recall that we assume that the reported winners of the elections are correct i for all k2[`]:
1
nnX
i=1ak(bi)>1
2:
The description below initializes kto be the mean of akover all ballots according to the reported
results, and initializes ukto be the maximal value akcan return. Other initialization and update
15rules forkandukare also valid (the algorithm would still fulll the RLA guarantee), as long as
we always have uk>k>k. The algorithm operates as follows:
1.Initialization
1.1. InitializeK= [`]. During the test, an index is removed from Kwhenever we have
sucient evidence that its corresponding assertion is correct.
1.2. For each k2Kinitialize:
â€¢Tk:= 1.
â€¢k:=1
2.
â€¢uk:= maxb2Cfak(b)g.
â€¢k:=arep
k(B), wherearep
k(B) is1
nPn
i=1ak(bi) given that the reported results are
completely accurate.
2.Auditing Stage: For eachi2[n]:
2.1. Sample the next paper backup-ballot biand read it.
2.2. For each k2K, updateTk:
Tk Tkak(bi)
kk k
uk k+uk k
uk k
2.3. For each k2K, ifTk>1
, removekfromK. This means we have sucient evidence
that the assertion1
jBjP
b2Bak(b)>1
2is true.
2.4. For each k2Kupdatek;kanduk:
â€¢k 1
2n Pi
j=1ak(bj)
n i
â€¢k max
k+;arep
k(B) Pi
j=1ak(bj)
n i
â€¢uk maxfuk;k+g
Wherearep
k(B) is1
nPn
i=1ak(bi) given that the reported results are completely accurate,
and>0 is some very small positive meant to ensure that k<k<uk.
2.5. ifk<0, thekth assertion is necessarily true, so remove kfromK.
2.6. IfK=;, approve the reported winners and nish the audit.
3.Output: If the audit hasn't approved the reported winners yet, we recounted all ballots and
the true winners are known.
Note that after each iteration, we dene kto be the mean of akover the remaining ballots, if the
mean ofakover all ballots was1
2. Conversely, kis the mean of akover the remaining ballots, if
the reported tally is correct.
Theorem 1. For any election system that can be audited using the SHANGRLA framework and
for any 01, if the reported winners of the elections are wrong, then the ALPHA martingale
test will approves the results with probability of at most .
16Proof. Fix0, a list of backup paper-ballots Bwhose tally is the true results of the election
and some wrongful reported tally regarding them which leads to the wrong winners. Let the set of
assorters used to audit the ballots be a1;:::;a`. Since we assume that the set of reported winners
of the elections is wrong, there must be some akwith1
nPn
i=1ak(bi)<1
2. Assume w.l.o.g. that it is
a1.
Assumption.1
nPn
i=1a1(bi)<1
2
To prove that the algorithm fullls the RLA guarantee, we need to show that the test approves the
reported winners w.p. of at most . It suces to show that the algorithm approves that the mean
ofa1over all ballots is greater than1
2w.p. of at most . Meaning, that the probability of 1 getting
removed from the set Kis at most.
The index 1 cannot be removed from Kin step 2.5., since that would mean that at some point
during the audit we had:
k<0 =)1
2n iX
j=1a1(bj)<0 =)1
2<1
niX
j=1a1(bj)1
nnX
i=1a1(bj);
contradicting our assumption. This means that the algorithm approves the results only if at some
point,T1>1
.
Letb1;:::;bnbe random variables which represent the ballots that are sampled by the audit, in the
order in which they are sampled. Each of these values is a random variable which depends on B
and on the randomness of the audit. Denote by T0
1;T1
1;:::;Tn
1the values of T1after each sampled
ballot, where T0
1is its initial value. Similarly, let 1
1;2
1;:::;n
1, and1
1;2
1;:::;n
1andu1
1;u1
1;:::;un
1
be the values that 1,1andu1have, respectively, when sampling each ballot. By their denition,
eachTi
1is a random variable whose value is determined by b1;:::;bi, and each of ui
1;i
1andi
1are
determined only by b1;:::;bi 1, and not by bi.
With these denitions in mind, we use Ville's inequality [12] (also referred to as Doob's inequality),
to show that:
Pr(9i2[n]; Ti
1>1
);
thereby proving that the algorithm fullls the RLA guarantee.
Ville's Inequality [12]
IfX1;X2;:::;Xnis a non-negative supermartingale, meaning that for any i2[n] we have
Pr[Xi0] = 1 and E[XijX1;X2;:::;Xi 1]Xi 1, then for any >0:
Pr
max
i2[n]fXig>1

E[X1]:
To use this inequality, we need to show that T1
1;:::;Tn
1is a non-negative supermartingale, which we
do in the following two claims:
Claim 1.1. Ti
1is non-negative for every i2[n].
17Proof. Fixi2[n] and observe the update rule of T1in step 2.2.. Since we have 0 i
1<i
1<ui
1,
and sincea1is a non-negative function, we have:
Ti
1=Ti 1
10
BBB@a1(bi)
i
1|{z}
0i
1 i
1
ui
1 i
1|{z}
>0+ui
1 i
1
ui
1 i
1|{z}
>01
CCCA:
And sinceT0
1= 1, by induction, Ti
1is non-negative, concluding the proof of this claim.
Claim 1.2. For anyi2[n], we have E[Ti
1jT1
1;:::;Ti 1
1]Ti 1
1.
Proof. First, note that since we are under the assumption that1
nPn
j=1a1(bj)<1
2, we have:
E[a1(bi)]i
1;
where the expectation is over the choice of the ith ballot that is audited, bi.
Now, observe that xing the rst i 1 ballots that were audited b1;:::;bi 1xesT1
1;:::;Ti
1, and
vice-versa, since T1
1;:::;Ti
1is deterministically determined by the ballots that are audited. Thus,
we have it that:
E[Ti
1jT1
1;:::;Ti 1
1] =E[Ti
1jb1;:::;bi 1]: (4)
Onceb1;:::;bi 1are xed, the values i
1;i
1andui
1are also xed, and can be calculated by simulating
the audit on the rst i 1 ballots. Continuing from (4), by this the update rule of T1in step 2.2.,
we have:
=Ti 1
1E[a1(bi)]
i
1i
1 i
1
ui
1 i
1+ui
1 i
1
ui
1 i
1
;
and since E[a1(bi)]i
1:
Ti 1
1i
1 i
1
ui
1 i
1+ui
1 i
1
ui
1 i
1
=Ti 1
1ui
1 i
1
ui
1 i
1
=Ti 1
1;
proving the claim.
By these two claims, T1
1;:::;Tn
1is a non-negative supermartingale. This concludes the proof, since
Ville's inequality states that for any 2[0;1] we have:
Pr
max
i2[n]fTi
1g>1

E[T0
1] =
and therefore the probability that the algorithm wrongfully approves the reported election winners
is at most.
18Changes from Original Algorithm and Proof
In the original ALPHA martingale test, ukis dened as the maximal value that akmay return. In
the denition above, ukis seen as a variable which controls the magnitude with which Tkchanges.
The proof presented by Stark [37] doesn't actually require that uk=maxb2Cak(b), but only requires
to haveuk>k>kin every iteration.
Additionally, in the original statement of the SHAN problem, we assume to know an upper bound
on the values in each list. In the statement in Section 1.6.1 of this work, this assumption is omitted.
For most audits, this distinction does not matter, since the assorters frequently return the maximal
value in their image. However, for batch-level RLAs, this distinction allows for more ecient
audits, as will be explained in later sections. If it was not for this alternate denition of uk, then
the eciency of the Batchcomp algorithm presented in Section 2 would be signicantly reduced.
1.7 Road Map
Section 2 formally denes the batch-level RLA model, and presents a new, general method for
performing batch-level RLAs. This method is usable for every social choice function which could
be reduced to SHANGRLA assertions as described in Section 1.6.1.
While this method is generic and could be used to convert many existing RLAs to batch-level
RLAs, Section 3 focuses on its application for the Israeli Knesset elections. In the Israeli Knesset
elections, 120 seats are allocated to dierent parties using party-list proportional representation,
according D'Hondt method (also known as the Jeerson method) with a few added caveats. The
seats of each party are then allocated to specic party-members according to a ranked list which
is submitted by the parties ahead of the elections. Simulated results of the Batchcomp method
compared to the ALPHA-batch method are shown in Section 3.3.
Finally, Section 4 presents a new type of RLA which veries that a country's population census
results in correct allocation of political power to dierent regions within that country, as is done
e.g. in the US. Section 4.3 shows simulated results for the application of this method on the census
and house of representatives of Cyprus.
1.8 Acknowledgments
I would like to express my deepest gratitude to my supervisor, Moni Naor, for introducing me to
the eld and providing guidance, feedback and support throughout this process.
I would additionally like to thank my parents and friends, primarily Daniel Shwartz and Nicole
Kezlik, for listening to my rumblings and providing some essential feedback, professional or not.
192 Batch Risk-Limiting Audits
2.1 Preliminaries and Notation
2.1.1 The Batch-level RLA Model
In the batch-level RLA model, ballots are partitioned into batches, denoted as B1;B2;:::;Bd. The
set of all ballots in the elections, which is the union of these batches, is denoted as B. As mentioned
previously, we make no assumption on how the ballots were partitioned into batches, but we do
assume that their size is known. Our goal, just as before, is to perform an RLA for the reported
election winners. However, instead of sampling single ballots, we can now only sample a complete
batch, and tally all ballots in it. We assume that we know the reported tally of each batch. Meaning,
instead of only knowing the reported tally of all of the votes, we also know the individual reported
tally of each batch and can use it during the audit.
Such a model could be useful for election systems where each polling place tallies its own votes,
and the reported winners of the elections (pre-audit) are determined according to the sum of the
tallies. If a governing body wishes to audit these results and verify that the reported winners, as
calculated by the tally each polling place performed, are accurate, it can use a batch-level RLA to
do so. Note that this audit doesn't ensure that all batches were counted accurately. It only veries
that it is unlikely that there is a counting mistake which changes the winners of the elections .
2.2 The Batchcomp RLA
This section describes a generic and ecient way of performing batch-level RLAs, when the results
of the elections can be veried using SHANGRLA assertions, as described in Section 1.6.1. This
algorithm is original to this work. If an election system has a ballot-level RLA which uses the
SHANGRLA framework, this method can be used to audit in the batch-level RLA model. The
inspiration for the Batchcomp method comes from another SHANGRLA-based batch RLA sug-
gested in Section 4 of the paper introducing the ALPHA martingale test [37], which we refer to as
ALPHA-batch .
The ALPHA-batch method is performed by examining the mean of every assorter over each sampled
batch according to its paper-backup ballots. It does not use the reported vote tally of the batches
beyond the total number of ballots they contain. The Batchcomp method attempts to improve on
ALPHA's eciency by auditing something slightly dierent - instead of auditing the mean value
of an assorter aover the paper-backup ballots (true results) in a sampled batch, it audits the
discrepancy between the mean value ahas over a batch according to its reported tally, and the
mean value it has over the same batch according to its paper-backup ballots. The values returned
by the ALPHA-batch assorters can change drastically from batch to batch, depending on their
vote distribution according to the true results. The values the Batchcomp assorters return depend
primarily on the accuracy of the reported tally; if two batches with dierent vote distributions were
both counted accurately in the reported results, a Batchcomp assorter will return the same value
when applied on each of them. This fact is shown in Section 2.2.1, when discussing the advantages
of the Batchcomp assorters.
Recall that before sampling and reading a paper-backup ballots, the ALPHA martingale test guesses
20the value that each assorter would return on this ballot (this guess is k, for each assorter ak). As
explained by Stark [37], the audit is more ecient when these guesses are accurate. If each assorter
returns a similar value for all batches, as is the case with Batchcomp, then the audit can make
guesses which are more accurate. This is the root cause for Batchcomp outperforming ALPHA-
batch in the simulations shown in Section 3.3.
2.2.1 Preliminaries and Notation
As mentioned previously, the Batchcomp method is applicable for any election system that can
be reduced to assertions according to the SHANGRLA framework, as described in Section 1.6.1.
Through the rest of Section 2, we describe how the Batchcomp method applies to some generic
elections where the problem of verifying that the reported winners are correct can be done using
SHANGRLA. Fix some elections system, a set of ballots Band a partition of these ballots into
batchesB1;:::;Bd. By assuming that we can verify that the reported winners of the elections are
correct using the SHANGRLA framework, we are making the following assumption:
Assumption. Assume we have `assortersa1;::;a`such that the reported winners are true i for
allk2[`]:
1
nX
b2Bak(b)>1
2:
Throughout the following sections, we sometimes abuse notation and apply assorters over entire
batches. When doing so, ak(Bi) is dened as the mean of akover all ballots in batch Bi:
ak(Bi) =1
jBijX
b2Biak(b): (5)
Before proceeding, note that for each batch has a reported tally, which we know before the audit
begins, and a true tally, which we may only learn during the audit. Therefore, each assorter has a
reported and true mean value over each batch, which can be calculated from the reported and true
tally, respectively. We denote the reported mean of an assorter akover a batch Biasarep
k(Bi), and
its true mean over that batch as atrue
k(Bi).
Using this notation, we now dene a new assorter Akfor each original assorter ak. Unlike the
original assorter ak, this new assorter can only be applied on batches, and not over single ballots.
To dierentiate it from regular assorters, we refer to these new assorters as batch-assorters . During
a Batchcomp RLA, the audit uses these new batch-assorters instead of the original ones.
Denition 3. Let there be some election system with assorters a1;:::;a`. For each assorter ak, we
dene the Batchcomp-assorter Ak:C![0;1)as:
Ak(Bi) :=1
2+Mk+atrue
k(Bi) arep
k(Bi)
2(wk Mk):
WhereMkis the reported margin of assorter akacross all batches:
Mk:=arep
k(B) 1
2;
21andwkis the maximal reported value of akacross all batches:
wk:= max
jfarep
k(Bj)g:
The denominator in the denition of Akwas chosen such that the minimal value Akmay return is
0, as proven in the following claim.
Claim 2.1. For anyk2[`],Akis non-negative.
Proof. Fix an assorter akand its Batchcomp counterpart Ak. To check minimal value Akmay
return, we examine the minimum of atrueand the maximum of arep. Since assorters are non-
negative, for any batch Biwe haveatrue(Bi)0, and since we know the reported tallies of the
batches before the audit begins, we can calculate the maximum of arep
1across all batches, wk. Thus,
for any batch Bi:
Ak(Bi) =1
2+Mk+0z}|{
atrue
k(Bi) wkz}|{
arep
k(Bi)
2(wk Mk)1
2+Mk wk
2(wk Mk)= 0:
Concluding this proof
Advantages of the Batchcomp Assorters
These batch-assorters have a couple of useful properties for batch-level RLAs. First, they can be
used in-place of the original assorters during a batch-level audit. This is because each of them has
a normalized mean greater than1
2on all batches (normalized according to the size of the batches)
i the mean of its corresponding regular assorter over all ballots is at least1
2. A proof of this fact
is shown in Claim 2.2.
Additionally, these batch-assorters are useful since the values they return only depend on the
accuracy of the reported tallies of the batches, and not on the vote distribution within each batch.
If the reported tallies were calculated properly, we expect only small discrepancies between the
reported and true tallies of all batches. Therefore, auditing these discrepancies would reduce the
audit's dependence on the order in which batches are sampled. To understand why these batch-
assorters only depend on the tally's discrepancy, we can examine the case in which the reported tally
of each batch is equal to its true tally. In this case, any batch Binecessarily has atrue
k(Bi) =arep
k(Bi),
meaning that for every i2[d]:
Ak(Bi) =1
2+Mk
2(wk Mk):
Therefore, if the reported tallies of all batches are accurate, then this batch-assorter returns the
same value over all batches. As mentioned in Section 2.2, this makes the audit agnostic to the
order in which we sample the batches and also improves its eciency.
Conclusion. For any assorter akand its Batchcomp conversion to a batch-assorter Ak,Akoperates
over the batch-level discrepancy between the reported and true results, and has Ak(B)>1
2i
ak(B)>1
2.
22Auditing The Batch-Assertions
To run a batch-level RLA, we use a very similar method to the ALPHA martingale test described
in Section 1.6.3, except we sample batches instead of single ballots. In our method, we use our
dened batch-assorters A1;:::;A`instead of the original assorters a1;:::;a`. Additionally, we need
to consider the fact that dierent batches have dierent sizes. For this reason, whenever the audit
samples a new batch, each batch is chosen with probability that is proportional to its size.
Running the ALPHA martingale test also requires setting uk- a variable which \guesses" whether
the next sampled batch Biwill haveak(Bi)<korak(Bi)>k. We must always have uk>k,
and any such choice for ukyields a valid RLA. Here, since the algorithm uses the batch-assorters
A1;:::;A`, we denote these variables as U1;:::;U`. If we expect to have ak(Bi)> kw.h.p. then
the algorithm is more ecient when Ukis as small. Here, since accurate reported tallies lead to
always having Ak(Bi)>k, we are encouraged to set ukto be as small as possible. This leads us
to set these variables to be, for every k2[`]:
Uk=1
2+Mk+
2(wk Mk);
whereis a very small positive. We must have >0, but other than that any choice of is valid.
A smaller value for leads to a more ecient audit when all batches have accurate reported tallies,
but decreases eciency when there are large / malicious errors in the reported tally. Section 2.2.3
further examines how should be chosen.
The algorithm operates by sequentially sampling batches of paper-backup ballots, reading them
to get their true tally, and calculating the value of each batch-assorter A1;:::;A`over the sampled
batches. For each sampled batch Biand for each batch-assorters Ak,Ak(Bi) is compared to
3 variables which are set before the backup ballots in Biare read - k;kandUk.kis the
algorithm's guess for Ak(Bi) given that the reported winners of the elections are wrong. kis its
guess given that the reported winners are correct. Ukessentially guesses whether Ak(Bi)mukor
not. By comparing Ak(Bi) to these values, the algorithm updates a p-value which represents the
risk-limit with which the kth assertion can be approved. The algorithm either approves the kth
assertion if this p-value is below the risk-limit , or decides to sample another batch. For a more
extensive explanation regarding the variable's in this algorithm, see Section 1:6:3.
The full Batchcomp algorithm operates as follows:
2.2.2 The Batchcomp Algorithm Description
1.Initialization:
1.1. InitializeK= [`], which holds the indexes of assertions we have yet to approve.
1.2. InitializeB1= (B1;B2;:::;Bd) andB0=;. As the algorithm progresses, B0holds the
batches which were already audited and B1the batches that have yet to be audited.
1.3. For each k2Kinitialize:
â€¢Tk:= 1.
â€¢k:=1
2.
23â€¢k:=1
2+Mk
2(wk Mk).
â€¢Uk:=1
2+Mk+
2(wk Mk). Section 2.2.3 examines how to choose , but technically any
>0 works.
2.Auditing Stage: As long asB16=;, perform:
2.1. Sample a batch from B1and denote it as Bi. Each batch BjinB1is sampled with
probability proportional to its size:jBjjP
Bt2B1jBtj.
2.2. Remove BifromB1and add it toB0.
2.3. For each k2K, updateTk:
Tk TkAk(Bi)
kk k
Uk k+Uk k
Uk k
2.4. For each k2K, ifTk>1
, we have sucient evidence that the kth assertion is true, so
setK=Knfkg.
2.5. For each k2Kupdatek;;kanduk:
â€¢k 1
2n P
Bj2B0jBjjAk(Bj)
n P
Bj2B0jBjj
â€¢k maxn
1
2+Mk
2(wk Mk);k+o
â€¢Uk maxfUk;k+g
Whereis some very small positive meant to ensure that k< k< Uk. We assume
these variables are updated according to the order of their listing above.
2.6. Ifk<0, then the kth assertion is true, so remove kfromK.
2.7. IfK=;, approve the reported winners.
3.Output: If the audit hasn't approved yet, it recounted all batches, and the true winners of
the elections are known.
Note that we changed the update rule of k, the variable that represents our guess for what Akwould
return over the next batch we sample, compared to the one presented in the ALPHA martingale
set. In ALPHA, kwas set to be the mean value of akover all ballots that were not audited yet,
given that its mean over all ballots is arep(B). Here, we set it to be the value that Ak(Bi) would
return over a batch with an accurate reported vote tally. Using the old update rule here would still
be valid, but could lead to an undesired situation where a counting error in one batch leads us to
guess that there are counting errors in the opposite direction in other batches. Our new update
rule is based on the principle that we do not expect the next audited batch to have counting errors
that are skewed in a specic direction.
Theorem 2. For any election system that can be audited using the SHANGRLA framework, for
any0and for any partition of the ballots into batches, if the reported winners of the elections
are wrong, then the Batchcomp RLA approves them with probability of at most .
Proof. By assuming that we can we can audit an elections system using the SHANGRLA framework,
we are essentially making the following assumption:
24Assumption. We have`assortersa1;::;a`such that the reported winners of the elections are true
i for allk2[`]:
1
nX
b2Bak(b)>1
2:
The proof of this theorem relies on two claims. First we show that if there exists k2[`] s.t.
ak(B)<1
2, then we also have Ak(B)<1
2(Claim 2.2). Afterwards, we show that if there exists
somek2[`] s.t.Ak(B)<1
2, then the algorithm approves the reported winners w.p. of at most 
(Claim 2.4). The combination of these claims means that if the reported winners of the elections
are not correct, the algorithm approves them w.p. of at most , which is the RLA guarantee.
Claim 2.2. If there exists k2[`]s.t.ak(B)<1
2, then we also have Ak(B)<1
2.
Proof. Assume such a kexists. By the denition of AkandMk(Denition 3), we therefore have:
Ak(B) =1
2+Mk+atrue
k(B) arep
k(B)
2(wk Mk)
=1
2+arep
k(B) 1
2+atrue
k(B) arep
k(B)
2(wk Mk)
=1
2+atrue
k(B) 1
2
2(wk Mk)
and sinceatrue
k(B)<1
2:
<1
2+1
2 1
2
2(wk Mk)
=1
2;
proving the claim.
The next claim formally proves the following statement: at any stage during the audit, the following
two values are equal, for any Batchcomp assorter Ak:
â€¢The result, in expectation, of sampling a new batch Biand calculating Ak(Bi).
â€¢The result of applying Akover a batch which includes all previously unaudited ballots.
Calculating the second value here might at rst appear problematic, as Akcannot be applied on
any arbitrary collection of ballots; the domain of Akcomprises of batches of ballots which have
reported tallies. However, note that all unaudited ballots are exactly the union of all previously
unaudited batches. Meaning, we can calculate the reported tally of all of the unaudited ballots by
summing the reported tallies of all of the unaudited batches. More generally, this means we can
apply aAkover any union of batches, by summing the reported tallies of these batches to get the
25reported tally of the union. Given a set of batches ZfB1;B2;:::;Bdgwherenz:=P
Bj2ZjBjj
denotes the total number of ballots in Z, the value of Ak([Bi2ZBi) can be calculated as follows:
A([Bi2ZBi) =1
2+Mk+atrue
k([Bi2ZBi) arep
k([Bi2ZBi)
2(wk Mk)(6)
where:
atrue
k([Bi2ZBi) =1
nzX
Bi2ZX
b2Biatrue(b); (7)
arep
k([Bi2ZBi) =1
nzX
Bi2ZX
b2Biarep(b): (8)
Note thatarep(b) over a single ballot bis not well dened, as we do not have reported results over
single ballots; we only have them over entire batches. However, here we only use sums of arep(b)
over all ballots in a batch, and we do know the values of these sums.
We can now proceed to the formally stating and proving this claim:
Claim 2.3. For any assorter aand its conversion to a batch-comp assorter A, and for any Z
fB1;:::;Bdg, we have EBiZ[A(Bi)] =A([Bi2ZBi), whereBiZmeans that Biis sampled from
Zw.p. proportional to jBij.
Proof. As before, denote the total number of ballots in Zasnz. The equality now follows from the
denition of the batch-assorter A:
EBiZ[A(Bi)] =X
Bi2ZjBij
nzA(Bi);
inserting the denition of A:
=1
nzX
Bi2ZjBij1
2+M+atrue(Bi) arep(Bi)
2(w M)
=1
2+M
2(w M)+1
2(w M)nzX
Bi2ZjBij 
atrue(Bi) arep(Bi)
;
using the denition of awhen applied on batches (see (5)):
=1
2+M
2(w M)+1
2(w M)nzX
Bi2ZjBij0
@1
jBijX
b2Biatrue(b) 1
jBijX
b2Biarep(b)1
A;
slightly re-arranging the sums yields:
=1
2+M
2(w M)+1
2(w M)1
nzX
Bi2ZX
b2Bi(atrue(b) arep(b));
26and using (7) and (8):
=1
2+M
2(w M)+1
2(w M)(atrue([Bi2ZBi) arep([Bi2ZBi))
=1
2+M+atrue([Bi2ZBi) arep([Bi2ZBi)
2(w M);
nally, by (6):
=A([Bi2ZBi);
concluding the proof of this claim.
Claim 2.4. If there exists k2[`]s.t.Ak(B)<1
2, then the algorithm will approve the reported
winners w.p. of at most .
Proof. Assume such a kexists and w.l.o.g. let it be k= 1. The index 1 cannot be removed from K
in step 2.6., because then:
k<0 =)1
2n X
Bj2B0Ak(Bj)jBjj<0 =)1
2<X
Bj2B0Ak(Bj)jBjjA1(B);
contradicting our assumption. This means assertion 1 ( A1(B)>1
2) can only be approved in
step 2.4.. We now show that this happens w.p. of at most .
As we do in the proof of Theorem 1, denote by T0
1;T1
1;:::;Td
1the values of T1after each sampled
batch. Similarly, let 1
1;2
1;:::;d
1,1
1;2
1;:::;d
1andU1
1;U2
1;:::;Ud
1be the values that 1,1andU1
have when sampling each batch. To prove this claim, it suces to prove T0
1;T1
1;:::;Td
1is a non-
negative supermartingale. If we can do so, then the algorithm approves the results w.p. of at most
by Ville's inequality, as explained while proving Theorem 1.
First, we show A1(Bi) is non-negative for any i2[t]. Towards this goal, recall the update rule of
Ti
1in step 2.3.:
Ti
1=Ti 1
1A1(bi)
i
1i
1 i
1
ui
1 i
1+Ui
1 i
1
Ui
1 i
1
:
To show that Ti
1is non-negative for any i, it suces to prove that A1(Bi)0, since we always
have 0i
1i
1Ui
1. We now do so:
A1(Bi) =1
2+M1+0z}|{
atrue
1(Bi) w1z}|{
arep
1(Bi)
2(w1 M1)1
2+M1+ 0 w1
2(w1 M1)=1
2 1
2= 0:
Conclusion. Ti
1is non-negative.
What remains is to show that for any i2[d] we have E[Ti
1jT0
1;:::;Ti 1
1]Ti 1
1. Towards this
purpose, x some i2[d]. For simplicity, we use B0andB1to denote the sets of batches B0andB1
were when sampling the ith batch to audit.
27In every iteration of the algorithm, in step 2.5., 1is dened to be the value that A1([Bj2B1Bj)
would have, given that A1(B) =1
2. This means that since A1(B)1
2, we haveA1([Bj2B1Bj)i
k.
By Claim 2.3, we therefore have EBjB1[A1(Bj)]i
1, whereBjB1means that we sample a
batch fromB1w.p. that is proportional to that batch's size. By the same reasoning as (4) in the
proof of Theorem 1:
E[Ti
1jTi 1
1;:::;T0
1] =E[Ti
1jB1;:::;Bi 1];
now, by the update rule of T1from step 2.3.:
=Ti 1
1EBjB1[A1(Bj)]
i
1i
1 i
1
Ui
1 i
1+Ui
1 i
1
Ui
1 i
1
;
and since EBjB1[A1(Bj)]i
1:
Ti 1
1i
1
i
1i
1 i
1
Ui
1 i
1+Ui
1 i
1
Ui
1 i
1
=Ti 1
1i
1 i
1
Ui
1 i
1+Ui
1 i
1
Ui
1 i
1
=Ti 1
1Ui
1 i
1
Ui
1 i
1
=Ti 1
1:
This concludes the proof of this claim, since we have shown that T1
1;:::;Td
1is a non-negative
supermartingale, meaning that the audit approves the assertion (P
b2Ba1(b)>1
2) w.p. of at most
.
As explained previously, the combination of these 3 claims concludes the proof of this theorem.
2.2.3 Choosing 
As explained in Section 2.2.1, for every assorter akand its Batchcomp counterpart Akwe initialize:
Uk=1
2+Mk+
2(wk Mk);
whereMk=arep(B) 1
2is the reported margin of akand>0. Dierent choices for all produce
valid RLAs (any choice maintains the RLA guarantee), but under certain conditions, certain values
ofyield more ecient audits. This section attempts to give intuition regarding the ideal choice of
. Generally, the more we expect the reported vote tallies of the dierent batches to be accurate,
the smaller should be. We show this by comparing kto the expected value of a Batchcomp
assorter on the next batch to be sampled.
Claim 2.5. During a Batchcomp RLA, if the next sampled batch BjsatisesAk(Bj)kfor
some batch-assorter Ak, then choosing a smaller Ukincreases the audit's eciency, and vice-versa;
ifAk(Bj)<k, then setting a larger Ukincreases the audit's eciency.
28Proof. Examine some Batchcomp assorter Ak. First, note that auditing the assorter is more ef-
cient, meaning it requires examining fewer ballots, the more signicantly Tkgrows per batch.
This is because the audit approves assertion kwhenTk>1
. Therefore, it suces to show that if
Ak(Bj)k, thenTkgrows more signicantly when Ukis small, and vice-versa.
Towards this purpose, denote the next audited batch as Bi. To prove this claim, we take the
derivative by Ukof the update rule of Tkin step 2.3. of the Batchcomp algorithm:
Tk TkAk(Bi)
kk k
Uk k+Uk k
Uk k
:
Taking its derivative by Ukresults in:
Tk
 Ak(Bi)
kk k
(Uk k)2+1
Uk k Uk k
(Uk k)2
=Tk
(Uk k)2
 Ak(Bi)
k(k k) +Uk k Uk+k
=Tk
(Uk k)2
 Ak(Bi)
k(k k) k+k
=Tkk k
(Uk k)2
|{z}
>0
1 Ak(Bi)
k
:
Where the term on the left (above the underbrace) is positive since Tkis positive, and since
we always have Uk> k> k>0. We can observe that if Ak(Bj)> k, this derivative is
negative, meaning that choosing a smaller value for UkcausesTkto increase more signicantly. If
Ak(Bj)<k, then the opposite is true. This concludes the proof of this claim.
By this claim, if we expect to have Ak(Bj)> kfor all batch-assorters and batches, we should
choose a smaller , and vice versa. When using the Batchcomp assorter, we have:
Ak(Bi) =1
2+Mk+atrue
k(Bi) arep
k(Bi)
2(wk Mk)
Andwk> Mk>0 by the denition of Mk. Therefore, as long as the discrepancies between the
reported and true vote counts are small, we expect to consistently have Ak(Bi)k, meaning we
should choose a smaller . To getAk(Bi)< k, we would need to have atrue
k(Bi) arep
k(Bi)>
Mk, meaning that the discrepancy in vote counts, as it relates to the assorter a, is greater than
its reported margin. If the margin isn't extremely small, and the errors in the vote count are
uncorrelated and rare, this is very unlikely to happen. This suggests that if the counting mistakes
aren't malicious, we should choose a very small .
If we choose a very small and the counting mistakes are malicious, the audit might become
inecient, but it will still fulll the RLA guarantee. This could encourage choosing a very small
value for, since it would only make the audit inecient if it's likely that the vote counting was
malicious. If there were correlated mistakes in the vote counting (such as errors that are skewed
29against a certain party), we would not mind a more exhaustive audit. Meanwhile, if the counting
mistakes are \honest", meaning the chance of any ballot to be misinterpreted is equal, we would
like the audit to examine as few batches as possible.
Conclusion. A Batchcomp RLA is more ecient when  >0is very small, as long as the vote
tallying is not done maliciously.
On the extreme case, we could technically choose !0+. This essentially means that kUkfor
everyk2[`] and the update rule of Tkbecomes:
Tk TkAk(Bi)
kk k
Uk k+Uk k
Uk k
TkAk(Bi)
k:
This inspires a simplied batch-level RLA, which is very ecient as long as the counting-errors
are random: we could ditch kandUkentirely, and just update each TkbyTk TkA(Bi)
k. If the
counting mistakes are random, this method appears to perform just as well as the full batch-comp
RLA, according to simulations (for brevity, the full plots are not included here). This is true even
when auditing election results with assertions which have very tight margins, meaning that even
small random mistakes might lead to some cases where Ak(Bi)< kfor somek. However, note
that this method could completely fail if we ever get Ak(Bi) = 0. Having a batch-assorter and
batch with Ak(Bi) = 0 would mean that:
A(Bi) = 0 =)1
2+Mk+atrue
k(Bi) arep
k(Bi)
2(wk Mk)= 0
=)1
2=arep
k(Bi) atrue
k(Bi) Mk
2(wk Mk)
=)wk Mk=arep
k(Bi) atrue
k(Bi) Mk
=)wk=arep
k(Bi) atrue
k(Bi);
which indicates that arep
k(Bi) =wk= maxjfarep
k(Bj)gandatrue
k(Bi) = 0. This means that re-
portedly, this batch is the \the best one" for assorter a, while in reality its as bad as it can get.
Such a scenario is very unlikely to occur unless the vote counting is malicious, and in that case, we
wouldn't mind a full manual recount anyway.
Conclusion. As long as the counting errors are not malicious, the update rule of Tkin the Batch-
comp RLA could be changed to simply Tk TkAk(Bj)
k. This simplies the audit but adds a small
probability of an unnecessary full manual recount of the paper-backup ballots.
303 Israeli Knesset Elections RLA
This section describes how to perform an RLA to verify results of the Israeli Knesset elections.
This method can be used in Israel currently to verify the initial hand-count of the votes, which is
not performed centrally - each polling place independently tallies its own ballots. This method can
also become useful if, in the future, the vote tallying will be done by some electronic means, such
as an optical reader. In such cases, this method could conrm that the winners outputted by the
electronic vote tabulation system are highly likely to be correct.
In the context of the Knesset elections, we wish to verify that the correct Knesset members were
elected. Since the Knesset elections use a closed party-list, meaning that each party submits a
ranked list of its candidates ahead of the elections, we only need to verify that each party receives
the correct number of seats. Again, we do not mind if the vote tallies are not completely accurate,
as long as the correct number of seats was given to each party.
Before moving to explain the how the Knesset elections work, we dene some notation. Let Pbe
the set of all parties running in the elections, and let Sbe the number of available seats. For every
partyp2P, letvtrue(p) denote the true number of votes preceived, according to the paper-backups
ballots. Similarly, denote the true number of invalid votes as vtrue(invalid ) and the true number
of valid votes as vtrue(valid ).
3.1 Knesset Elections Method
The Knesset is the Israeli parliament and its sole legislative authority. It consists of S:= 120
members who are elected according to closed party-list proportional representation. Before each
election cycle, each party submits a ranked list of its candidate. On polling day, each voter votes
for a single party, and parties receive seats in proportion to the share of the votes they received.
The seats each party wins are given to the top-ranked candidates in the party's list.
Allocating Knesset seats to the various parties is done as follows [42]:
Electoral Threshold
In the Knesset elections, only parties which receive at least 3.25% of the valid votes are eligible to
win seats. We denote this threshold as t:= 0:0325.
Seat allocation
The allocation of seats is done according to the D'Hondt method, a highest average method, and
can be formulated in multiple ways. The description here, which was suggested previously by
Gallagher [13], lends itself more naturally to the SHANGRLA framework. Meaning, it simplies
the process of developing SHANGRLA assertions which are all true i the reported winners of the
elections are correct.
To nd how many seats each party deserves, we do the following:
1. Imagine a table with a row for each party which is above the threshold (meaning vtrue(p)
31tvtrue(valid )), andScolumns. In the cell of party pand column s, we writevtrue(p)=s. All
cells are initially uncolored.
2. Color (or mark) the Scells with the largest values in the table.
3. The number of colored cells a party has in its row is the number of seats it should receive.
Note that the values in each row are monotonically decreasing, so each row would be fully colored
up to a certain column, and not colored for the rest of it.
For example, in an election with 3 parties and 10 seats, the results would be as follows:
Apparentment (Also Known as Electoral Alliances or Heskemei Odam)
Two parties may sign prior to the the electoral day an apparentment agreement, which may allow
one of them to gain an extra seat. If two parties sign an apparentment agreement, and only if both
are above the threshold, they essentially unite to a single allied party during the seat allocation
stage. Then, the number of seats their alliance received is split between them according to the same
seat allocation method. Meaning, for each apparentment between two parties, we write another
table with only these two parties, and allocate the number of seats they won together between
them, using the same method described above.
If one of the parties in the apparentment is below the electoral threshold while using only its own
votes, the apparentment is ignored. Each party may only sign a single apparentment agreement.
3.2 Designing Assorters
This section presents assorters that can be used to perform an RLA for the Knesset elections, using
the SHANGRLA framework. We begin by presenting 3 conditions which all hold true if and only
if the reported winners of the election are correct. We then proceed to develop assorters for each
of these conditions, such that the assorters all have a mean greater than1
2if and only if these
conditions all hold true.
Theorem 3. Letsrep(p)andstrue(p)be the reported and true number of seats that a party pwon
in a Knesset elections, respectively. We have it that srep(p) =strue(p)for every party p2P, if and
only if these 3 conditions all hold true:
1. Every party who is reportedly above the electoral threshold, is truly above the electoral thresh-
old.
2. Every party who is reportedly below the electoral threshold, is truly below the electoral thresh-
old.
323. For every two parties p1;p2who are reportedly above the electoral threshold, the condition 
srep(p1)strue(p1)
_ 
srep(p2)strue(p2)
is true.
Proof. Fix some reported and true tallies for the elections, and calculate the number of seats each
party reportedly and truly won according to these tallies. If the reported and true number of seats
each party won are equal, then the 3 conditions above hold true trivially.
Otherwise, assume there is a discrepancy between the reported and true seat allocation. Under
this assumption, there is at least one party who won more seats according to the reported result
compared to the true results, which we denote as pr, and at least one party who won less seats
according to the reported results compared to the true results, which we denote as pt. We now
show that at least one of the three conditions above are violated.
Ifpris not truly above the electoral threshold, then Condition 1 is violated, as it receives seats
according to the reported tally, which indicates that it is reportedly above the threshold. Similarly,
ifptis below the threshold according to the reported tally, then Condition 2 is violated. Otherwise,
both parties are reportedly and truly above the threshold.
If both parties are reportedly above the electoral threshold, then ptreportedly won less seats than
it truly deserves, meaning that srep(pt)< strue(pt). Similarly, we have srep(pr)> strue(pr). This
violates Condition 3 and concludes our proof.
Next, we present SHANGRLA assertions which conrm that each of these 3 conditions are true.
These assertions and their corresponding assorters can be used to perform an RLA for Knesset
elections using the Alpha martingale test, or to perform a batch-level RLA using the Batchcomp
method.
Throughout this section, denote by vtrue(p) andvrep(p) the true and reported number of votes a
partypreceived, respectively. Similarly, denote the reported and true number of seats a party p
won bysrep(p) andstrue(p).
3.2.1 Above Threshold Assertion
The role of this assertion is to check that Condition 1 holds, i.e. that a party who reportedly
received more votes than the electoral threshold, is indeed above the threshold. Verifying this is
equivalent to ensuring that every party who is reportedly above the threshold has in fact received
at least at-share of the valid votes. Stark [40] has previously suggested a SHANGRLA assertion
for this condition exactly - verifying whether a candidate or party won a certain share of the valid
votes (super-majority). For the Knesset elections, this assertion is used once per each party who is
reportedly above the threshold.
For every party pwho reportedly is above the electoral threshold, we add a single assertion to the
set of assertions we audit:1
nP
b2Baabove(b)>1
2, using the following assorter:
Denition 4. An above threshold assorter, which veries that a party pis truly above the electoral
threshold, is dened as:
aabove
p(b) :=8
><
>:1
2tifbis for party p
1
2ifbis invalid
0otherwise
33The mean of this assorter over all ballots is:
1
nX
b2Baabove(b) =1
n1
2vtrue(invalid) +1
2tvtrue(p)
=1
2n
vtrue(invalid) +1
tvtrue(p)
:
And this is equal or greater than1
2i:
vtrue(invalid) +1
tvtrue(p)n()vtrue(p)t(n vtrue(invalid ))
as needed.
3.2.2 Below Threshold Assertion
In order to check Condition 2, that every party who is reportedly below the threshold is truly
below it, we need to conrm that every such party received less than tof the valid votes. This is
equivalent to verifying that all other parties received at least 1  tof the valid votes. Therefore, we
can use a similar assorter to the one from Denition 3. For every party pwho is reportedly below
the electoral threshold, we add the assertion1
nP
b2Babelow(b)>1
2to the set of assorters we audit,
where the assorter abelowis dened as:
Denition 5. A below threshold assorter, which veries that a party pis truly below the electoral
threshold, is dened:
abelow
p(b) :=8
><
>:0 ifbis for party p
1
2ifbis invalid
1
2(1 t)otherwise
3.2.3 Move-Seat Assertion
The role of this assertion is to verify that Condition 3 holds, i.e. that for every two parties p1;p2who
are reportedly above the electoral threshold, 
srep(p1)strue(p1)
_ 
srep(p2)strue(p2)
is true.
An assertion for this condition was previously suggested by Blom et al., section 5.2 [5], but is devel-
oped here independently. We begin by reducing the problem of verifying Condition 3 to the problem
of conrming that some linear inequality is true (Claim 3.1). From this inequality, we develop an
assorter which veries that Condition 3 is true using the method described in Section 1.6.2.
Claim 3.1. For any two dierent parties p1;p2who are reportedly above the threshold, we have:
vtrue(p1)
srep(p1) + 1<vtrue(p2)
srep(p2)
=)  
srep(p1)strue(p1)
_ 
srep(p2)strue(p2)
:
Meaning that conrming that the inequality on the left is true also conrms that Condition 3 is
true.
Proof. Fix some reported and true election results, and two dierent parties who are reportedly
above the threshold p1;p2. Say that we allocate seats according to the true tally, using the colored
34table method described in Section 3.1. Note that in this described seat-allocation table, each party
phas exactly its rst strue(p) cells colored.
Examine the case where the condition on the right side of the claim is false, meaning that the
condition 
srep(p1)<strue(p1)
^ 
srep(p2)>strue(p2)
is true. If this condition is true, then the
cell at index [ p1;srep(p1) + 1] of the table is colored, as p1wins more than srep(p1) according to the
true results, while the cell at [ p2;srep(p2)] is not, as p2wins less than srep(p2) according to the true
results. Therefore, to show that 
srep(p1)<strue(p1)
^ 
srep(p2)>strue(p2)
is false, it suces to
show that if the cell at index [ p2;srep(p2)] is not colored, then the cell at [ p1;srep(p1) + 1] is not
colored either.
Recall that the colored cells in the table are the ones which hold the Slargest values. Thus, to show
that if the cell at index [ p2;srep(p2)] is not colored, then the cell at [ p1;srep(p1) + 1] is not colored,
it suces to show that the value at [ p1;srep(p1) + 1] is smaller than the value at [ p2;srep(p2)].
Meaning, to show that Condition 3 is true regarding p1;p2, it suces conrm that:
vtrue(p1)
srep(p1) + 1<vtrue(p2)
srep(p2): (9)
The smaller term here is the value at index [ p1;srep(p1) + 1], while the larger term is the value at
index [p2;srep(p2)]. This completes the proof of this claim.
By this claim, to verify that Condition 3 holds for two parties p1;p2, it is sucient to verify
that (9) holds. At rst glance, it may appear that Condition 3 can be true while (9) is not. This
can be problematic, as there may be elections where Condition 3 is true regarding some two parties,
without (9) being true. Meaning, if we develop an assertion for verifying (9), we may encounter
election results where Condition 3 is true but this assertion is false. An audit which uses this
assertion might unnecessarily require a full manual recount, despite the reported winners being
correct.
A more careful examination, however, shows that such a scenario is not possible. If the reported
winners of the elections are correct, then for any two parties who are above the electoral threshold
p1;p2, partyp2truly winssrep(p2) seats while party p1truly wins less than srep(p2)+1 seats. Thus,
the value at cell [ p2;srep(p2)] in the imaginary table from Claim 3.1 is colored, while the cell at
[p1;srep(p1) + 1] is not, meaning that (9) is true.
Conclusion. If the reported winners of the election match the true results, then (9)is true for any
two parties p1;p2who are reportedly above the electoral threshold.
Thus, to verify Condition 3, we can develop assertions that verify (9). Using such assorters, we
are guaranteed that if the reported winners of the elections are correct, these assertions will all be
true. Meaning, the assertions we audit are both sucient and necessary conditions for the winners
of the elections to be correct.
We now move to developing the assorters of these assertions. Fix two parties p1;p22Pwho are
reportedly above the threshold. We wish to nd a non-negative function ap1;p2such that (9) is
equivalent to a SHANGRLA assertion of the form:
1
jBjX
b2Bap1;p2(b)>1
2: (10)
35This is achieved by using the method described in Section 1.6.2, which converts linear inequalities
to SHANGRLA assertions. To use this method, we re-arrange (9) as a linear inequality over the
tallies of the various parties:
1
srep(p2)vtrue(p2) 1
srep(p1) + 1vtrue(p1)>0: (11)
We can now apply the method from Section 1.6.2 to nd a non-negative function ap1;p2such that (10)
and (11) are equivalent. This results in the following denition for ap1;p2:
Denition 6. An assertion which veries that Condition 3 is true for two parties p1;p2who are
reportedly above the threshold, is1
jBjP
b2Bamove
p1;p2(b)>1
2where:
amove
p1;p2(b) :=8
><
>:1
2+srep(p1)+1
2srep(p2)ifbis forp2
0 ifbis forp1
1
2otherwise
And we need add two instances of this assertion to the audit for every two parties who are reportedly
above the threshold, one using amove
p1;p2and one using amove
p2;p1.
3.2.4 Handling Apparentments
The assertions above ignore the existence of apparentments. To handle them, we can simply treat
each two allied parties who are reportedly above the electoral threshold as a united party when
adding move-seat assertions. Afterwards, we also need to verify that the seat allocation between
every two allied parties is correct. To do so, we can add two move-seat assertions (one in each
direction) for every two allied parties who are reportedly above the electoral threshold.
3.3 Simulations Based on Recent Elections
We describe the results of simulating the execution of a batch-comparison RLA over three dierent
elections for the Knesset, all conducted between 2019 and 2021. The election results used in this
section are the true election results, as reported by the Israeli Central Elections Committee4. The
partition of ballots to batches is also done according to the real election results, and each batch
contains ballots from a single polling place. A typical batch contains between 250 and 550 ballots,
with the average across the three election cycles being 386. The audit uses assertions as described
in Section 3.2, and converts their assorters to Batchcomp assorters as described in Section 2.2.1
Finally, the Batchcomp method described in Section 2.2.2 is used to perform the RLA over these
Batchcomp assorters.
We begin by showing the simulated performance of the Batchcomp algorithm on each of the 3
election cycles, assuming all vote tallies are accurate . For each cycle, we compare Batchcomp with
the ALPHA-batch algorithm described in section 4.2 of [37] using the same SHANGRLA assertions
from Section 3.2. Afterwards, we move to examine the Batchcomp algorithm's eciency when there
is a small, independent probability (0.01) that each ballot is misread during the reported count.
4See https://votes22.bechirot.gov.il/ ,https://votes23.bechirot.gov.il/ ,https://votes24.bechirot.
gov.il/ .
363.3.1 Technical Details
The following results detail the execution of the this suggested batch-level RLA with a risk-limit
of= 0:05 and with set to 10 10. The latter was determined after some experimentation - lower
choices for do not improve eciency when the reported results are accurate, while higher values
reduce the audit's eciency.
For all plots and tables, the number of audited ballots by each method is averaged across 10
simulations. An examination of these simulations shows that the number of ballots required to
approve each assertion has very low standard deviation. The mean standard deviation, across all
assertions in all elections, is 1,898, while the maximal standard deviation across all assertions is
6,041.
The code used for these simulations was written in Python, and is available in https://github.
com/TGKar/Batch-and-Census-RLA .
3.3.2 Results with Accurate Vote Tabulations
The upcoming plots present the number of ballots required to approve each assertion during the
audit, both by the ALPHA-batch method and by our Batchcomp method. Each point in these
plots represents a single assertion, where its value on the x axis is its margin in log-scale (minimal
number of ballots that would need to be altered for the assertion to become false), and its value
on the y axis is the number of ballots that the audit examined before approving the assertion.
Each point in the plot is colored by the type of assertion it represents - either an above threshold
assertion, a below threshold assertion, or a move-seat assertion.
For each election cycle, the top plot shows these results when using the ALPHA-batch RLA, the
middle plot when using Batchcomp, and the bottom plot shows the dierence in ballots required
per assertion between ALPHA-batch and Batchcomp.
37Using the 22nd Knesset Election Results (2019)
38Approving the reported winners for this election cycle required auditing virtually all ballots by both
methods, due to a single assertion which had a very small margin (47). Without this assertion, the
Batchcomp audit would be done after auditing 34% of the ballots, while ALPHA-batch would still
require 98%.
The three assertions which required the most ballots to be approved by the Batchcomp algorithm
are:
Margin Batchcomp ALPHA
Assertion (% of votes) (% of votes) (% of votes)
Don't move a seat from 47 4,465,090 4,465,139
Likud & Yamina to UTJ & Shas (0:001%) (100%) (100%)
Don't move a seat from 2,996 1,513,454 4,367,793
Blue and White to Yisrael Beiteinu (0:07%) (34%) (98%)
Don't move a seat from 4,919 1,036,336 4,409,273
Blue and White & Yisrael Beiteinu (0:11%) (23%) (99%)
to UTJ & Shas
39Using the 23rd Knesset Election Results (2020)
40Approving the reported winners for this election cycle required auditing 35% of ballots by Batch-
comp, while requiring 99% by ALPHA-batch.
The three assertions which required the most ballots to be approved by the Batchcomp algorithm
are:
Margin Batchcomp ALPHA
Assertion (% of votes) (% of votes) (% of votes)
Don't move seat from 3,042 1,593,006 4,556,963
Emet & Blue and White to Likud & Yamina (0:07%) (35%) (99%)
Don't move a seat from 3,545 1,421,340 4,583,377
Emet & Blue and White to UTJ & Shas (0:08%) (31%) (99%)
Don't move a seat from 3,591 1,126,277 4,580,758
Yisrael Beiteinu to UTJ & Shas (0:08%) (24%) (99%)
41Using the 24th Knesset Election Results (2021)
42Approving the reported winners for this election cycle required auditing 85% of ballots by Batch-
comp, while requiring virtually all ballots by ALPHA-batch. If it wasn't for a single assertion which
had a very small margin (367 ballots), the Batchcomp audit would be done after auditing ~32% of
the ballots, while ALPHA-batch would still require reading nearly all ballots.
The three assertions which required the most ballots to be approved by the Batchcomp algorithm
are:
Margin Batchcomp ALPHA
Assertion (% of total votes) (% of votes) (% of votes)
Don't move a seat from 367 3,782,124 4,435,111
Meretz to Labor (0:008%) (85%) (100%)
Don't move a seat from 2,567 1,410,184 4,424,102
The Joint List to Likud & Religious Zionist (0:06%) (32%) (100%)
Don't move a seat from 2,162 1,392,993 4,412,059
New Hope to Yamina (0:05%) (31%) (99%)
3.3.3 Results with Small Tabulation Inaccuracies
In addition to checking the Batchcomp method's eciency under \perfect" conditions, we examine
its tolerance to small counting errors. For this purpose, we compare the number of ballots it requires
to approve each assertion under two conditions:
1. When each ballot has a probability of 0 :01 to be misread in the reported tally. If a ballot is
misread, it either becomes invalid (w.p. 0.1) or is counted towards a party drawn uniformly
at random.
2. When the reported vote tallies of all batches are completely accurate, as examined previously
in Section 3.3.2.
43We present the plot described in Section 3.3.2 for each condition, as well as one additional plot
which shows the dierence in ballots required between the two conditions. Note that the assertion
margins presented in these plots (the x axis) are calculated according to the reported results and
not the true ones, since the true margin changes in each repetition of the simulation.
The choice of 0 :01 probability for miscounting each ballot is inspired by historical data. Unless
critical errors occur, both manual and electronic vote tabulations miscount less than 1% of ballots [6,
2].
The 22nd Knesset elections require very small counting errors to change their results. For this
reason, it's extremely unlikely for the seat-allocation to remain identical if approximately 1% of the
votes are miscounted. Since we are only interested in Batchcomp's performance when the reported
and true winners match, this section only examines the 23rd and 24th Knesset elections.
Using the 23rd Knesset Results (2020)
4445Using the 24th Knesset Results (2021)
46Examining both election cycles shows that most assertions are not signicantly eected by the
existence of small counting errors. Meaning, the number of ballots that are required to approve
them remains similar. However, we can observe that random counting errors do eect some small
margined assertions. Typically, assertions of the same type and of similar margins behave similarly.
Here, somewhat surprisingly, some of these tight move-seat assertions become much easier to audit,
while others become much more dicult.
Why Similar Assertions Exhibit Dierent Error Tolerance
A full exploration of this phenomenon is beyond the scope of this work, but we attempt to provide
a brief and mostly intuitive explanation for it. First, note that randomly miscounted votes are
distributed evenly to all parties, while being disproportionately taken from parties who are above
the electoral threshold, as they receive the vast majority of votes. Therefore, a party who is above
the threshold will typically lose more votes than it gains due to random miscounts.
Next, examine a move-seat assertion which conrms that compared to the reported seat-allocation,
some party A doesn't deserve extra seats at the expense of party B. The counting errors which
could cause this assertion to be false are either overcounting the votes for party A, or undercounting
the votes for party B. Let mredbe the minimal number of votes we would need to reduce from
party A (compared to its reported tally) to make the assertion false. Similarly, let maddbe the
number of votes we would need to add to party B to make the assertion false.
We could now partition all move-seat assertions into two categories: (I) assertion for which mred<
maddand (II) assertions for which mredmadd. An examination of move-seat assertions from
these simulations shows that assertions from category (II) are helped by random counting errors,
meaning the errors reduce the number of ballots required to conrm these assertions. Meanwhile,
assertions from category (I) are harder to conrm when random counting errors exist.
Since we've established that random errors typically reduce the tallies of parties who passed the
47threshold, assertions for which mred<maddare harder to conrm when the parties of the assertion
both lose votes, and vice-versa. This is because the margins of assertions from category (I), accord-
ing to the true results, decreases by the existence of random errors, while the margin of assertions
from category (II) increases.
3.3.4 Simulation Conclusions
Knesset Elections are Dicult to Audit
Most Knesset elections have very tight margins, which make them dicult to audit in a risk-limiting
manner. If the Election winners win with a margin of below 0.001% of the total ballots, it's unlikely
that any RLA method could approve them without close to a full manual recount.
To remedy this, if RLAs are implemented for such elections, the auditing body could decide in
advance that some tight-margined assertions are not worthy of auditing. In the 24th Knesset
elections, for example, the tightest assertion (don't move a seat from Meretz to Avoda) relates to
two parties who are in an electoral alliance, indicating that they are ideologically aligned. Auditing
this assertion nearly triples the length of the audit, despite it being one of the least critical assertions
for this election.
In addition to this, it is possible to adjust any move-seat assertion such that it veries that no
more than a single seat should be moved between two parties, compared to the reported results.
For any two parties, p1;p2and their move-seat assertion amove
p1;p2, this is achieved by dening amove
p1;p2
(see Denition 6) as if p1won one extra seat at the expense of p2. Meaning, we dene:
amove
p1;p2(b) :=8
><
>:1
2+srep(p1)+2
2(srep(p2) 1)ifbis forp2
0 if bis forp1
1
2otherwise
If a move-seat assertion has a very small margin, we can switch its assorter to this one, thereby
shortening the audit at the expense of a weaker guarantee.
Batchcomp consistently beats ALPHA-batch in These Settings
While auditing the entire Knesset elections proves to be rather dicult, examining the number of
ballots required to approve the various assertions shows that Batchcomp signicantly outperforms
ALPHA-batch. Generally, assertions that had very small or fairly large margins required a similar
number of ballots by both algorithms, while assertions with margins of between 0.01% and 2%
were signicantly easier to audit using Batchcomp. Some assertions which ALPHA-batch could
not approve without a nearly full manual recount were approved by Batchcomp while examining
less than 20% of the paper-backup ballots.
Resilience to Random Errors
The Batchcomp RLA appears to be resilient to small random errors in the reported tallies of
the various batches. While not shown within this work, this observation is also true regarding
48ALPHA-batch, as it makes no use of the reported tallies of specic batches.
What Actually Eects The Audit's Eciency
The eciency of the audit (number of ballots that are required to approve correct winners) seems to
be eected only by the assertion which has the tightest margin. The last assertion to be approved
remains consistent when repeating the audit's simulation multiple times. The number of assertions
and the margin of any other assertion, other than the one with the minimal margin, appear to have
no eect on the eciency of the RLA.
This is due to the fact that when the reported tallies of the batches are accurate, every Batchcomp
assorter has the same value across all batches. Therefore, the progression of the p-value of each
assertion (1
Tk, as dened in Section 2.2.2) during the audit remains similar regardless of the order
in which we audit the batches.
This observation persists when there are small random counting errors, but may change the specic
assertion which is the most dicult to audit. This is since, as explained in Section 3.3.3, two
assertions with similar margins may be eected dierently by random counting errors.
In some cases, the problem of approving a reported election result can be reduced to SHANGRLA
assertions in multiple ways, and the auditing body has to choose the specic set of assertions to
use during the audit. If the audit is conducted using the Batchcomp method, this observation
teaches that we should choose the set of assertions where the tightest margined assertion has the
maximal margin. Ideally, if our reduction yields assertions that are both sucient and necessary
for the reported winners of the elections to be correct, then the margin of the tightest assertion is
exactly the margin of the entire elections. If this is the case, then any sucient and necessary set
of assertions would perform similarly. Trying to minimize the number of assertions does not, by
itself, eect the eciency of the audit, though it might reduce the computation time required per
ballot or batch.
Conclusion. Any reduction into SHANGRLA assertions which are both sucient and necessary
yields a similarly ecient audit, regardless of the number of assertions.
3.4 Existing Recounting Methods
To the best of my knowledge, recounts in the Israeli Knesset elections are currently performed
without an evidence based approach or a clear statistical guarantee. Currently, votes are tabulated
manually in each polling place, and the vote tally of each location is reported to the Central Election
Committee. This committee reviews the tallies of each polling place, and may re-count the paper-
backup ballots if necessary. There appears to be no systematic method for recounting ballots. From
published cases where recounts were conducted, it appears that recounts are performed either after
complaints of election fraud at a specic polling place, if inconsistent election records are discovered,
or sometimes at randomly selected locations [19].
One particularly interesting partial-recount of ballots happened in 2019, following the elections
for the 21st Knesset. In these elections, the New Right party received 3.22% of the valid votes,
falling 1,454 ballots (0.03% of the valid votes) short of the electoral threshold and thus receiving
no seats in parliament. Following these results, the New Right party asked for a vote recount,
49which eventually resulted in recounting the ballots at 66 polling places where the party claimed for
irregularities, amounting to approximately 26,000 votes. The recount resulted in the New Right
party losing 3 votes, after which their leaders accepted the original election results [21].
RLAs oer an evidence based solution for this problem- running the audit with a single asser-
tion, which attempts to conrm that the New Right party is truly below the electoral threshold
(see Section 3.2.2). It comes with the statistical guarantee that if the examined party did pass
the threshold, the probability of the audit approving the election results is bounded by a pre-set
parameter.
However, note that in this instance, the number of ballots that would need to be examined in such
an audit is expected to be rather large. Using Batchcomp with a risk limit of 0.05 would require
reading approximately 2,500,000 ballots to approve the results according to simulations, given that
the initial vote tabulation was accurate.
504 Census Risk Limiting Audits
This section presents a risk-limiting audit method for a population census. It applies to nations
which allocate political power to their constituencies or federal-states in proportion to their popula-
tion according to a certain class of methods (highest averages), and who conduct a post-enumeration
survey as recommended by UN guidelines [43]. According to these guidelines, a PES is performed
by randomly sampling a small number of households, re-running the census over this chosen sample,
and then comparing the results to the original census. For consistency, throughout this section, we
assume that this allocated political power is manifested as the number of representatives a region
receives in parliament, and refer to these regions as the nation's federal-states. The goal of our
audit is to provide a clear statistical guarantee regarding the correctness of this census' resulting
allocation of representatives.
To achieve such a guarantee, we rst need to dene what allocation is considered correct. When
auditing parliamentary elections, we dene the true number of seats a party should win as the
number it deserves according to the tally of the paper-backup ballots. When auditing a census, one
might wish to similarly dene the results of the PES as the true results. Such a denition could be
problematic, however, as the PES only runs over a small sample of households.
For this reason, we view the true results of the census as the results the PES would have if it was to
run over all households. This means that technically, a census RLA assumes that the PES surveyed
all households. During the actual census audit, however, it only asks for the information the PES
collected on a small, randomly chosen sample of households, which is exactly the data that the
PES actually has.
The census RLA is performed by sequentially sampling households and processing the census and
PES information regarding them. Since the PES only runs over a small sample of households,
the audit is limited in its length. For this reason, it could be unreasonable to set a risk-limit
(probability of approving wrong results) before the audit begins, as we do in election RLAs. If we
were to do so, then the audit may fail to approve a correct representative allocation even when
using the entire PES sample, resulting in an inconclusive outcome. This issue does not exist when
auditing elections, as the audit can keep sampling and reading ballots until it either approves the
reported winners, or until reading all ballots and learning the true results.
The observation above leads us to slightly change the statistical guarantee that a census RLA
provides: instead of setting the risk-limit and then running the audit, the census RLA runs over
the entire PES and then returns the risk-limit with which it can approve the census representative
allocation. This results in the following statistical guarantee:
The Census RLA guarantee:
For any 0<1, if running the PES over all households would lead to a dierent
allocation of representatives than the census, then the probability that a census RLA
returns a value 0such that0is at most.
Using this guarantee, a governing body could examine the risk-limit returned by a census RLA in
order to decide whether the allocation of representatives to states is reliable enough. If it is not,
they may decide to conduct a second round of re-surveying, and to continue the audit on these
newly re-surveyed households. Alternatively, if the audit's outputted risk-limit is too high, it may
51also decide to re-run the census altogether. Our suggested census RLA method can also examine
which state specically is more or less likely to have a correct number of representatives. This will
be discussed further at the end of Section 4.3.4.
As a summary of this section, a census-RLA is an altered version of an election-RLA, where we wish
to verify that the census results in a correct allocation of representatives to the federal states. The
critical dierences between an election-RLA and a census-RLA are summarized in the following
table:
Category Election RLA Census RLA
GoalApprove
election winner'sApprove census' allocation
of representatives
Applicable Ballots have Allocation is proportional
When physical backups to population and a PES exists
Audited Unit Ballot Household
Reported Result Electronic vote count Census resident count
True Result Paper-backup ballots manual count PES resident count
Risk-Limit Pre-set Outputted by audit
Audit's Length Factor of risk-limit Factor of PES size
4.1 Preliminaries and Notation
4.1.1 Post Enumeration Survey
A post enumeration survey is a process which measures the accuracy of a population census by
conducting an independent population survey over a small portion of randomly chosen households.
Our census-RLA method assumes that the PES is done according to the guidelines published by
the Department of Economic and Social Aairs of the United Nations [43]. According to these
guidelines, the PES begins by choosing a partial sample of the households in a nation, such that
each household has an equal probability of being included in this sample. In some instances, the
pool of households from which this sample is taken includes all households that were surveyed in
the original census. In other cases, such as in the US census, this pool of potential households is
constructed independently of the original census. Our suggested census RLA method applies for
both options.
After sampling the households to be included in the PES, a new and independent survey contacts
each household and asks them the exact same questions as the original census. Since the PES is
conducted a few months or years after the census, the household members report their answers as
they were on the date of the original census. For our purposes, the only information of interest is
the number of residents living at each household5. If a sampled household did not respond during
the PES, it reports that it holds no residents.
We denote the information given by the census as follows:
5Some countries may allocate representatives to federal-states according to the number of a specic sector of the
population that they hold (e.g. eligible voters or citizens). In this work, we assume it's simply the number of residents,
but our methods apply in the same manner otherwise.
52â€¢Hcen: A list of households that were surveyed.
â€¢gcen(h): The number of residents a household h2Hcenhas according to the census.
And denote the information given by the PES as:
â€¢HPES: A list of households from which the sample used by the PES was chosen. This may
or may not be identical to Hcen.
â€¢~HPES: The households which were surveyed by the PES. Must be a subset of HPES.
â€¢gPES(h): The number of residents a household h2~HPESholds according to the PES.
4.1.2 The Census RLA Model
In our model a nation allocates Rrepresentatives to its federal-states, whose set we denote as S,
in proportion to their population as measured by a country-wide census. We assume that after the
census is nished, a PES is conducted as described in Section 4.1.1. Following the census and the
PES, we learn Hcenandgcenfrom the census, and HPES;~HPESandgPESfrom the PES.
We assume that the nation allocates its Rrepresentatives to its federal-states using the census
results, according to a highest averages method. Highest averages methods, such as the D'Hondt
method described in Section 3.1, are a class of methods which allocate representatives to federal-
states using an imaginary table. Each row in this table represents a state, and each column
represents a potential number of representatives it may win. Each cell of this table holds a value
which depends on its federal-state (its row), the number of representatives it represents (its column)
and the number of residents in its federal-state according to the census. The Rcells with the highest
values in the table are colored, and each federal-state receives a number of representatives equal to
the number of colored cells it has in its row. The value at cell [ s;r], wheres2Sandr2[R], is:
gcen(s) +cs
d(r); (12)
wherecsis a constant which depends on the state s, andd:N!Nis a monotonically increasing
function. Since dis monotonically increasing, the values in each row of the table are monotonically
decreasing.
The choice of csandddetermines the exact allocation method within the class of highest averages
methods. For example, setting d(j) =jandcs= 0 for any s2Sresults in the D'Hondt method
described in Section 3.1.
The additive factor in (12), cs, allows our model some added exibility, meaning it can include
more political systems. If, for example, representatives are allocated to federal-states according
to a weighted sum of their population and their land-area, as done in Denmark [35], this model
supports this type of seat allocation by dening csto be the land-area of sin appropriate units.
This additive factor can also be used in cases where part of a state's population is not included in
the PES. In the US, for example, we would want to exclude people living in group residence (e.g.
53homeless people, nursing home residents, people living in remote Alaska, etc') from the audit, since
they are not covered by the PES. If we wish to exclude them from the RLA, we can assume their
number according to the census is accurate and run the audit over the rest of the population. To
do so within this model, we can dene csto be the number of persons without permanent residence
in statesaccording to the census.
More formally, a census-RLA is dened as follows:
Denition 7. Letfbe a social choice function which allocates representatives to federal-states
based on census data. Let Cbe a randomized algorithm which outputs a non-negative value, and
takes the following inputs:
â€¢A list of households according to the census Hcenand according to the PES HPES, where the
state of each household is known.
â€¢A subset of households which were surveyed during the PES: ~HPESHPES.
â€¢Census results gcen:Hcen!N0.
â€¢PES results gPES:~HPES!N0.
Cis a census risk-limiting audit for the social choice function fif for anyHcen;HPES,gcenand
PES results over all households gPES:HPES!N0, given a random subset of PES households
~HPESHPESof a certain pre-determined size, we have:
f(gcen())6=f 
gPES()
+
82[0;1];Prh
C
Hcen;HPES;~HPES;gcen();gPES
~HPES
i
<:
WheregPES
~HPES
denotes thatConly receives access to the PES results over the surveyed
households ~HPES.
Note that in this denition, gPESencodes the results of the PES if it was to run over all households.
However,Conly receives access to gPESover households that were actually surveyed during the
PES. Thus, if f(gcen())6=f 
gPES()
is true, it means if the PES had surveyed all of HPES,
it would result in a dierent allocation of representatives than that of the census. If this is true,
the census RLA guarantee demands that for any 2[0;1] a census RLA will output a value smaller
thanw.p. of at most , which is exactly the demand stated in the denition above.
4.2 The Census RLA Algorithm
This section suggests a new method to performs census RLAs, which relies on the SHANGRLA
framework. In Section 4.2.3, we design SHANGRLA assertions for auditing the census' resulting
allocation of representatives to the federal-states. While these assertions can be used as-is to
perform a census RLA, they are only an intermediate step in the development of more ecient
assertions that are eventually presented in Section 4.2.4. These assertions are used by an adapted
version of the ALPHA martingale test to perform a census RLA, as described in Section 4.2.5.
544.2.1 Assumption and Notation
Our census RLA method relies on one simplifying assumption:
Assumption. In both the census and in the PES, the number of residents in a single household is
upper-bounded by a known value, denoted as gmax.
The valuegmaxmust be set before the PES is conducted. Both the census and the PES must report
that all households have gmaxresidents at most.
This assumption is necessary due to a critical dierence between elections and censuses; In elections,
a single ballot has very limited power. In a census, if it was not for this assumption, a single
household could hold an arbitrarily large number of residents and completely swing the allocation
of representatives to the states.
Under this assumption, the number of residents at a household according to the census is given by
the function gcen:Hcen![gmax][f0g, and the number of residents according to the PES is given
bygPES:~HPES![gmax][f0g. Throughout the next sections, we sometimes abuse notation by
applyinggcenon households that are not from Hcen, or applying gPESon households that were not
surveyed during the PES. In any such case, we assume that these functions return 0. Finally, for a
states2Sand a household h2H, we denote the number of residents from state sat household
hbygcen
s(h) (according to the census) and gPES
s(h) (according to the PES). If his not in state s,
we simply have gPES
s(h) =gcen
s(h) = 0.
4.2.2 Census Assorters
We begin by adapting the denition of assertions and assorters to the language of census RLAs.
When auditing elections, an assorter is dened as a non-negative function over the set of possible
ballots a voter may cast. When auditing a census, we dene an assorter as a non-negative function
over the set of all households, meaning a:H![0;1). An assorter asatises the assertion
1
jHjP
h2Ha(h)>1
2if and only if some condition regarding the allocation of representatives to the
federal states is true.
Denition 8. A set of functions: a1;:::;a`:H![0;1)arecensus assorters if the allocation
of representatives according to the census and the PES match i for all k2[`]:
1
jHjX
h2Hak(h)>1
2:
These`inequalities are referred to as the census assertions .
4.2.3 Designing Household-Level Assorters
In this section, we present assorters that can be used for a census RLA in our described model.
In Section 4.2.2, we use these assorters to develop new, more ecient assorters which are used
during the census RLA method described in Section 4.2.5.
These assorters are developed by reducing the problem of conrming the census' allocation of
representatives to the problem of verifying that a set of linear inequalities are all true (Theorem 4).
55Once we have such inequalities, we use the method described in Section 1.6.2 to convert them to
equivalent SHANGRLA assertions, giving us our census assorters.
Theorem 4. Assume the PES surveyed all households. The allocation of representatives according
to the census and according to the PES match, if and only if for any two states s1;s22S:
P
h2HgPES
s1(h) +cs1
d(rcen(s1))>P
h2HgPES
s2(h) +cs2
d(rcen(s2) + 1): (13)
Wherercen(s)is the number of representatives that state sis allocated according to the census. The
rest of the notation is dened in Section 4.1.2.
Proof. First, assume that the two allocations of representatives match. Examine the imaginary
table with which representatives are allocated to states according to the PES, as described in Sec-
tion 4.1.2. Recall that each state has exactly its rst rPES(s) cells colored. Since we assume that
for anys2S,rPES(s) =rcen(s), we have it that for any s1;s22S, the cell at index [ s1;rcen(s1)] is
colored, while the cell at [ s2;rcen(s2) + 1] is not. Since the colored cells are the ones which hold the
largest values in the table, the cell at [ s1;rcen(s1)] has a larger value than the cell at [ s2;rcen(s2)+1].
Writing these values out results exactly in (13)- the larger term is the value at [ s2;rcen(s2) + 1],
and the smaller is the value at [ s1;rcen(s1)].
Towards proving the other direction of the equivalence, we show that if (13) is true for any s1;s22S,
then a certain condition (14) holds for any s1;s2. We then show that if this condition is true, then
the allocation of representatives according to the census and according to the PES match.
Claim 4.1. LetrPES(s)be the number of representatives a state sis allocated according to the full
PES results. For any s1;s22S, if(13) is true then:
 
rPES(s1)rcen(s1)
_ 
rPES(s2)rcen(s2)
(14)
Proof. Assume towards contradiction that for some s1;s22S, the condition (14) is false, meaning
that its negation, 
rPES(s1)<rcen(s1)
^ 
rPES(s2)>rcen(s2)
, is true.
Examine the table used to allocate representatives to states according to the PES results. According
to this table, s2is awarded rPES(s2) representatives. Since rPES(s2)>rcen(s2), and since the row
s2has exactly its rst rPES(s2) cells colored, the cell at [ s2;rcen(s2) + 1] is colored. Additionally,
sinces1was awarded exactly rPES(s1) representatives and since rPES(s1)< rcen(s1), the cell at
[s1;rcen(s1)] is not colored.
By the paragraph above, if 
rPES(s1)rcen(s1)
_ 
rPES(s2)rcen(s2)
is false, then the cell at
[s2;rcen(s2) + 1] is colored while the cell at [ s1;rcen(s1)] is not. Since the colored cells are the ones
which hold the largest values, it follows that the cell at [ s2;rcen(s2) + 1] has a larger value than the
cell at [s1;rcen(s1)], meaning that:
P
h2HgPES
s1(h) +cs1
d(rcen(s1))P
h2HgPES
s2(h) +cs2
d(rcen(s2) + 1):
The larger term in this inequality is the value at index [ s2;rcen(s2) + 1] and the smaller one is the
value at index [ s1;rcen(s1)]. This contradicts (13), and thereby proves this claim.
56Claim 4.2. If(14) is true for any s1;s22S, then the allocation of representatives according to
the census and according to the full PES are identical.
Proof. Assume towards contradiction that the two allocations are not identical. Therefore, there
must be at least one state swithrPES(s)6=rcen(s). IfrPES(s)>rcen(s), since the number of total
representatives is constant, there must be another state s0withrPES(s0)< rcen(s0). Similarly, if
rPES(s)<rcen(s), there must be another state s0withrPES(s0)>rcen(s0). Either way, either
 
rPES(s)rcen(s)
_ 
rPES(s0)rcen(s0)
or 
rPES(s0)rcen(s0)
_ 
rPES(s)rcen(s)
are false, meaning that (14) is not true regarding all pairs of states. Thus, if (14) is true for every
pair of states, then the two allocations must be identical, completing the proof.
Using these two claims, we can now complete the proof of this theorem. Assume (13) is true for
any pair of states. By Claim 4.1, (14) is also true for any pair of states, and by Claim 4.2, this
makes the allocation of representatives according to the census and according to the PES identical.
This proves the other direction of the equivalence and concludes the proof of this theorem.
Finding the Assorters - Goal
By Theorem 4, to prove that the census and PES lead to the same allocation of representatives, it
suces to verify that (13) is true for any pair of states. Next, for every pair of states s1;s22S, we
develop a SHANGRLA assertion which is equivalent to (13), giving us our census RLA assorters.
Towards this goal, we slightly re-arrange (13) into an equivalent form that is simpler to work with:
P
h2HgPES
s1(h)
d(rcen(s1)) P
h2HgPES
s2(h)
d(rcen(s2) + 1)>cs2
d(rcen(s2) + 1) cs1
d(rcen(s1)): (15)
For everys1;s22S, we wish to nd a non-negative function aPES
s1;s2such that (15) is equivalent to:
1
jHjX
h2HaPES
s1;s2(h)>1
2:
This is done using the method described in Section 1.6.2, which converts linear inequalities regarding
ballot tallies to SHANGRLA assertions. This method originally applies on elections, and not on
censuses. To use it here, we need to view the census as a an election.
From Census to Elections
To view the census as an election, we dene an election system where each ballot corresponds to a
household in the census, and the elections result in an allocation of representatives to states, just as
is done in the census. In this election system, each ballot holds the state and number of residents
of its corresponding household according to the PES.
57More formally, the set possible ballots a voter may cast in these elections is C:=Sf [gmaxj[f0gg,
and the ballots that were truly cast are B=f(sh;gPES(h))gh2H, whereshdenotes the state of
householdh. Additionally, we use v(s;k) to denote the number of ballots cast for ( s;k). Using this
notation, we can rewrite (15) as:
gmaxX
k=01
d(rcen(s1))kv(s1;k) 1
d(rcen(s2) + 1)kv(s2;k)
>cs2
d(rcen(s2) + 1) cs1
d(rcen(s1)):(16)
This is equivalent to (15) since bothPgmax
k=0kv(s;k) andP
h2HgPES
s(h) count the number of resi-
dents at state s.
(16) is a linear inequality regarding the vote tallies in some elections, which allows us to apply
the method from Section 1.6.2 to convert it to an equivalent SHANGRLA assertion. The resulting
assertions are1
jBjP
b2Bas1;s2(b)>1
2for eachs1;s22S, with:
as1;s2(s;k) =k 1s=s1
cd(rcen(s1))+gmax k 1s=s2
cd(rcen(s2) + 1); (17)
where we denote:
c:= 2gmax
d(rcen(s2) + 1)+cs2
jHjd(rcen(s2) + 1) cs1
jHjd(rcen(s1))
(18)
Back From Elections to the Census
The assorter above is intended for our imagined elections. We now wish to convert it to an assorter
which operates on households instead of ballots. Towards this purpose, observe that for a household
hand its conversion to a ballot ( sh;k), we have for any s2S:k 1sh=s=gPES
s(h). Meaning that
deningapes
s1;s2to operate directly on the households results in the following:
Denition 9. The census assorter aPES
s1;s2is dened as:
aPES
s1;s2(h) :=gPES
s1(h)
cd(rcen(s1))+gmax gPES
s2(h)
cd(rcen(s2) + 1);
wherercen(s)is the number of representatives state sis awarded according to the census, cis dened
as in (18).
Since we used the method from Section 1.6.2, we have, for any two states s1;s2:
 
1
jHjX
h2HaPES
s1;s2(h)>1
2!
() P
h2HgPES
s1(h) +cs1
d(rcen(s1))>P
h2HgPES
s2(h) +cs2
d(rcen(s2) + 1)!
:
And by Theorem 4, the allocation of representatives according to the census and PES match i for
alls1;s22S:
1
jHjX
h2Has1;s2(h)>1
2: (19)
584.2.4 Designing Household-Comparison Assorters
For each assorter aPES
s1;s2from Denition 9, we now dene a new assorter As1;s2which can also be used
to audit the same census. As1;s2has a signicant advantage over aPES
s1;s2, which motivates us to use it
instead. Each assorter aPES
s1;s2essentially audits the number of residents per household according to
the PES, without using the per-household census data. Meanwhile, As1;s2audits the discrepancy
in the number of household members between the census and the PES. Since we typically expect
this discrepancy to be small, this yields a more stable and ecient audit.
Some Intuition
This next part is only meant to explain how these nal assorters are deduced, and not to prove
that auditing them results in a valid census-RLA. A formal proof that these assorters satisfy the
condition described above is shown in Theorem 5.
First, note that each assorter aPES
s1;s2can also be dened over the census population counts instead
of the PES counts. We denote this as acen
s1;s2:
Denition 10.
acen
s1;s2(h) :=gcen
s1(h)
cd(rcen(s1))+gmax gcen
s2(h)
cd(rcen(s2) + 1):
As mentioned previously, we would like As1;s2to operate over the per-household discrepancy be-
tween the census and the PES as it relates to aPES
s1;s2. Meaning, it should operate over:
aPES
s1;s2(h) acen
s1;s2(h);
A simple way of doing so is to dene our new assorter As1;s2to have a similar form to the Batchcomp
assorter from Denition 3:
As1;s2(h) =1
2+ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
; (20)
with some choice of denominator in place of ( ).ms1;s2here is the margin of acen
s1;s2:
ms1;s2:=1
jHjX
h02Hacen
s1;s2(h0) 1
2: (21)
Observe that for any s1;s22S,ms1;s2>0. This is true since otherwise,1
jHjP
h02Hacen
s1;s2(h0)
1
2, meaning that if the PES and census results completely match on all households, we have
1
jHjP
h02HaPES
s1;s2(h0)1
2, contradicting (19).
With this denition of As1;s2, for any positive denominator we use in place of the dots ( ), we
would have:  
1
jHjX
h2Has1;s2(h)>1
2!
() 
1
jHjX
h2HAs1;s2(h)>1
2!
;
as we show while proving Claim 4.4. What remains is to choose the denominator.
59Choosing the Denominator
Ideally, we would like As1;s2to return large values when the census and the PES agree on the
number of residents of a certain household, since this would cause the audit to approve a correct
census (one that matches the PES) sooner. When the census and the PES agree on some household
h, we have:
As1;s2(h) =1
2+ms1;s2+=0z}|{
aPES
s1;s2(h) acen
s1;s2(h)
=1
2+ms1;s2
:
And since, as explained right after after (21), ms1;s2>0, this value will be larger the smaller
our chosen denominator is. However, if we choose a denominator which is too small, As1;s2could
potentially return negative values. By these two observations, we should choose the denominator
to be the smallest positive such that As1;s2is non-negative. To nd which value satises this, we
nd the minimal value that the nominator may have. By the denition of aPES
s1;s2andacen
s1;s2, the
value of the nominator is:
ms1;s2+aPES
s1;s2(h) acen
s1;s2(h) =ms1;s2+gPES
s1(h) gcen
s1(h)
cd(rcen(s1))+gcen
s2(h) gPES
s2(h)
cd(rcen(s2) + 1):
his either from s1, froms2or from neither of them. If it's from neither, than this expression is
equalms1;s2. If it's from s1, then:
ms1;s2+0z}|{
gPES
s1(h) gmax
z}|{
gcen
s1(h)
cd(rcen(s1))+=0z}|{
gcen
s2(h) gPES
s2(h)
cd(rcen(s2) + 1)ms1;s2 gmax
cd(rcen(s1));
wheregmaxis the maximal number of residents a single household may have. If his froms2, then:
ms1;s2+=0z}|{
gPES
s1(h) gcen
s1(h)
cd(rcen(s1))+0z}|{
gcen
s2(h) gmax
z}|{
gPES
s2(h)
cd(rcen(s2) + 1)ms1;s2 gmax
cd(rcen(s2) + 1):
So for anyh2H:
ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
min
ms1;s2;ms1;s2 gmax
cd(rcen(s2) + 1);ms1;s2 gmax
cd(rcen(s1))
(22)
We can now set the denominator to be the smallest value for which As1;s2is non-negative:
As1;s2(h) :=1
2+ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
 2 minn
ms1;s2 gmax
cd(rcen(s2)+1);ms1;s2 gmax
cd(rcen(s1));ms1;s2o:
For brevity, we denote:
zs1;s2:= maxgmax
cd(rcen(s2) + 1);gmax
cd(rcen(s1));0
: (23)
And writeAs1;s2as follows:
60Denition 11. The census comparison assorter for states s1;s22S is dened as:
As1;s2(h) :=1
2+ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
2(zs1;s2 ms1;s2):
We now prove that the assorters fAs1;s2js1;s22SS;s16=s2gare valid for auditing the census'
allocation of representatives to the federal states.
Theorem 5. Assume that the PES surveyed all households. The assorters fAs1;s2js1;s22Sg , as
dened above, are all non-negative and satisfy the following condition: The allocation of represen-
tatives according to the census and the PES match i for all s1;s22S:
1
jHjX
h2HAs1;s2(h)>1
2:
Proof. We rst prove that As1;s2is non-negative for any s1;s22S, and then show that the equiv-
alence above holds.
Claim 4.3. For anys1;s22S,As1;s2is non-negative.
Proof. Fix two states s1;s22S. By (22) and by the denition of zs1;s2:
ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)ms1;s2 zs1;s2: (24)
Meaning that for any h2H:
As1;s2=1
2+ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
2(zs1;s2 ms1;s2)
1
2+ms1;s2 zs1;s2
2(zs1;s2 ms1;s2)
= 0;
proving the claim.
Claim 4.4. The allocation of representatives according to the census and the PES match i for all
s1;s22S:
1
jHjX
h2HAs1;s2(h)>1
2:
Proof. In Section 4.2.3, we developed assorters aPES
s1;s2such that the allocation of representatives
according to the census and the PES match i for all s1;s22S:
1
jHjX
h2HaPES
s1;s2(h)>1
2
Therefore, to prove this claim, it suces to prove that for every s1;s22S:
 
1
jHjX
h2HAs1;s2(h)>1
2!
() 
1
jHjX
h2Has1;s2(h)>1
2!
:
61Fix any two federal-states s1;s22S. We show that the two inequalities above are equivalent:
1
jHjX
h2HAs1;s2(h)>1
2
()1
jHjX
h2H 
1
2+ms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
2(zs1;s2 ms1;s2)!
>1
2
()1
jHjX
h2Hms1;s2+aPES
s1;s2(h) acen
s1;s2(h)
2(zs1;s2 ms1;s2)>0:
Now, using the denition of ms1;s2and re-arranging the summation yields the desired equivalence:
()1
jHjX
h2H1
jHjP
h02Hacen
s1;s2(h0) 1
2+aPES
s1;s2(h) acen
s1;s2(h)
2(zs1;s2 ms1;s2)>0
()1
jHjP
h02Hacen
s1;s2(h0) +1
jHjP
h2HaPES
s1;s2(h) 1
jHjP
h2Hacen
s1;s2(h) 1
2
2(zs1;s2 ms1;s2)>0
()1
jHjP
h2HaPES
s1;s2(h) 1
2
2(zs1;s2 ms1;s2)>0
()1
jHjX
h2HaPES
s1;s2(h)>1
2;
The last transition relies on the fact that zs1;s2>ms1;s2, which is true since:
zs1;s2max
h2Hacen(h)ms1;s2:
This concludes the proof of this claim.
The combination of these two claims completes this theorem's proof.
4.2.5 Census RLA Description
The algorithm presented next is a slightly altered version of the ALPHA martingale test from Sec-
tion 1.6.3, when thinking of each household as a ballot whose content is the household's state and
its number of residents.
Adapting the ALPHA Martingale Test to Censuses
Unlike an election RLA, where the paper-backup ballots are read as the audit is ran, a census RLA
is performed after the PES, meaning that the households were re-surveyed before the audit begins.
We handle this by sampling households such that from the auditor's perspective, if it doesn't know
which households were surveyed by the PES, it receives a previously unsampled household uniformly
at random. This is performed according to a subroutine that takes as its input 4 arguments:
62â€¢H1: the set of households that have yet to be audited.
â€¢Hcen: the list of households according to the census.
â€¢HPES: the list from which the PES randomly chose the households it surveyed ( ~HPES).
â€¢~HPES: a list of households that were surveyed during the PES.
Sample Household( H1;Hcen;HPES;~HPES):
With probabilityjHPES\H1j
jH1j, sample a household uniformly at random from ~HPES\H1.
Otherwise, sample a household uniformly at random from 
HnHPES
\H1.
Additionally, recall that instead of pre-setting the risk-limit , the algorithm outputs the smallest
valuewith which it can approve the representative allocation of the census, as described in
the Census RLA guarantee. This is done by keeping, at all times, the risk-limit of each assertion,
1
Tmax. When the audit runs out of households to sample, the procedure outputs the maximal
risk-limit across all the assertions (step 3).
Before presenting the algorithm, recall that the variables ;andUrepresent guesses regarding
the value that their corresponding assorter will return in the next iteration. is that guess given
that the assorter has a mean of exactly1
2,is the guess assuming that the census and PES agree
on all households, and Uis a parameter which controls how signicantly Tchanges per iteration.
Tis the inverse of the risk-limit with which we can approve that its corresponding assertion is true,
andTmaxholds the maximal value of Tthroughout the audit.
The Census RLA Algorithm
1.Initialization
1.1. Initialize H1=HandH0=;.H1holds the households that have yet to be audited,
andH0holds the households which were already audited.
1.2. For each ( s1;s2)2SS s.t.s16=s2initialize:
â€¢Ts1;s2:= 1.
â€¢Tmax
s1;s2:= 1.
â€¢s1;s2:=1
2.
â€¢s1;s2:=1
2+ms1;s2
2(zs1;s2 ms1;s2).
â€¢Us1;s2:=1
2+ms1;s2+
2(zs1;s2 ms1;s2), where>0.
For denitions of ms1;s2andzs1;s2see (21) and (23).
2.Auditing Stage: WhileH1\~HPES6=;, perform:
2.1. Sample a household husing the subroutine Sample Household( H1;Hcen;HPES;~HPES).
2.2. Remove hfromH1and add it to H0.
2.3. For each s1;s2, updateTs1;s2andTmax
s1;s2:
63â€¢Ts1;s2 Ts1;s21
Us1;s2
As1;s2(h)s1;s2
s1;s2+ (Us1;s2 As1;s2(h))Us1;s2 s1;s2
Us1;s2 s1;s2
.
â€¢Tmax
s1;s2 max
Tmax
s1;s2;Ts1;s2	
.
2.4. For each s1;s2updates1;s2;s1;s2andUs1;s2to be:
â€¢s1;s2 1
2jHj P
h02H0As1;s2(h0)
jH1j.
â€¢s1;s2 maxn
1
2+ms1;s2
2(zs1;s2 ms1;s2);s1;s2+o
.
â€¢Us1;s2 maxfUs1;s2;s1;s2+g.
Whereis some very small positive meant to ensure that s1;s2< s1;s2< Us1;s2. We
assume these variables are updated according to the order of their listing above.
2.5. For any s1;s2, ifs1;s2<0, we must have1
jHjP
h2HAs1;s2(h)>1
2, so setTmax
s1;s2=
1. This means that we can approve this assertion with risk-limit 0 - this assertion is
necessarily true.
3.Output: The result of the audit is the maximal risk-limit across all assertions:
max
s1;s22S1
Tmaxs1;s2
:
Before proving that this algorithm satises the census RLA guarantee, we make one preliminary
claim.
Claim 4.5. If the PES is conducted over a random subset of households from HPES, the sam-
plehousehold subroutine returns a household which is selected uniformly at random from H1.
Proof. Fix any call to sample household during the audit. During this proof, we denote H1as
the setH1is while executing this call. Denote by jthe number of households from H1that were
surveyed during the PES.
Examine any unsampled household from the PES household list h2HPES\H1.hwill be returned
by sample household if and only if these 3 events all occur:
â€¢hwas surveyed during the PES - there arejhouseholds in H1that were surveyed in the
PES, andjH1\HPESjhouseholds in H1that were considered for surveying by the PES. This
puts the probability of hbeing surveyed during the PES atj
jH1\HPESj.
â€¢sample household sampled a household that was surveyed during the PES - this
happens w.p.jH1\HPESj
jH1j.
â€¢sample household chose h, given that the two previous events happened - there are
jhouseholds in H1that were surveyed during the PES, so the probability of this occurring
is1
j.
The probability of hgetting sampled by sample household is therefore:
j
jH1\HPESjjH1\HPESj
jH1j1
j=1
jH1j:
64This establishes that the probability of any single household from H1\HPESbeing returned is
1
jH1j. Now, since sample household may only return households from H1, and since any household
fromH1nHPESis returned with equal probability, the probability of any household from H1
getting returned must be1
jH1j. This shows that sample household returns a household uniformly
at random from H1, proving the claim.
We can now prove that this audit is a census RLA.
Theorem 6. For any nation with federal-states S, that allocates representatives to its federal-
states in proportion to their population using a highest averages method, this suggested census RLA
satises the census RLA guarantee: For any 0< 1, if running the PES over all households
would lead to a dierent allocation of representatives than the census, then the probability that a
census RLA returns a value 0such that0is at most.
Proof. This proof is similar to the proof of correctness for the ALPHA martingale test in Theorem 1.
The key point here is that from the perspective of the auditor, the households it receives are
sampled uniformly at random and without replacement from the set of all households. Given this
observation, the census RLA algorithm can be viewed as a regular election RLA, where each ballot
corresponds to a household and contains the household's state and number of residents.
Fix a highest-averages allocation method (meaning a monotonically increasing function d:N!N
andcs2Rfor eachs2S), lists of households Hcen;HPESand census results gcenas specied
in Section 4.1.2. Assume that extending the PES such that it surveys all households leads to
a dierent allocation of representatives than the census, and denote the function which returns
these full PES results as gPES:HPES![gmax][f0g. Let ~HPESbe a set of randomly selected
households of a pre-determined size from HPESwhich were actually surveyed during the PES, and
x2[0;1]. We wish to show that when running the census RLA over these inputs, the probability
of the census RLA outputting a value 0s.t.0<is at most.
By Claim 4.4, since the representative allocations according to the census and according to the PES
are dierent, there must be some census-assorter whose mean is at most1
2. Denote this assorter as
As0
1;s0
2:
Assumption.
1
jHjX
h2HAs0
1;s0
2(h)1
2:
Tmax
s0
1;s0
2cannot become1in step 2.5., since that would mean, for any H0H:
s1;s2<0 =)1
2jHj X
h02H0As1;s2(h0)<0 =)1
2<1
jHjX
h02H0As1;s2(h0)1
jHjX
h02HAs1;s2(h0)
contradicting our assumption. Therefore, Tmax
s0
1;s0
2receives its nal update in step 2.3..
Denote the values Ts0
1;s0
2has after every sampled household during the audit as T0
s0
1;s0
2;T1
s0
1;s0
2;:::;Tq
s0
1;s0
2,
whereT0
s0
1;s0
2is its initial value and qis any natural number. Since the algorithm outputs:
max
s1;s22S1
Tmaxs1;s2
;
65it outputs a value that is smaller than only if at the end of the audit we have Tmax
s0
1;s0
2<1
. By this
and by the fact Tmax
s0
1;s0
2receives its nal value at step 2.3., to prove this theorem, it suces to prove
that:
Pr
max
jfTj
s0
1;s0
2g>1

: (25)
To achieve this, we show that T0
s0
1;s0
2;:::;Tq
s0
1;s0
2is a non-negative supermartingale, and then use Ville's
inequality, similarly to Theorem 1. Note that the update rules of Ts1;s2and ofTkare identical in
the census RLA and in the ALPHA martingale test respectively, and that the update rules for
Us1;s2;s1;s2;s1;s2always maintain Us1;s2> s1;s2> s1;s2. Moreover, just like the ALPHA mar-
tingale test samples ballots randomly and without replacement, the census RLA samples households
randomly and without replacement, by Claim 4.5. For these reasons, Claim 1.1 applies here too -
given a non-negative assorter, our update rule for Ts1;s2makes it non-negative itself, meaning that
T0
s0
1;s0
2;:::;Tq
s0
1;s0
2are all non-negative.
Additionally, for the same arguments as in Claim 1.2, we have it that for any i2[q]:
E[Ti
s0
1;s0
2jT1
s0
1;s0
2;:::;Ti 1
s0
1;s0
2]Ti 1
s0
1;s0
2:
This is true because both Ts0
1;s0
2here andT1in Claim 1.2 belong to assertions which are false
(their assorters have a mean of1
2or less), and are updated in the exact same manner. This makes
T0
s0
1;s0
2;:::;Tq
s0
1;s0
2a non-negative supermartingale, meaning that by Ville's inequality [12]:
Pr
max
jfTj
s0
1;s0
2g>1

T0
s0
1;s0
2=:
Which proves (25) and thereby completes the proof of this theorem.
4.3 Census RLA Simulations
This section simulates the suggested census RLA on the Cypriot census and its resulting allocation
of representatives to districts in the House of Representatives of Cyprus. Our original intention
was to simulate the suggested census RLA method on the US census and its resulting allocation of
representatives in the US House of Representatives to the states. This turned out to be infeasible,
however, due to the relatively large number of states (50) and representatives (435). Allocating
many representatives to many states increases the probability of there being a single representative
whose allocation is determined by a very small number of state residents. Therefore, such systems
require a very small enumeration error to change the census' allocation, and are therefore more
dicult to audit. Using our suggested method on the American setting, a PES which surveys 10%
of households results in a risk-limit of only 0.75. In reality, the US PES surveys around 1% of
households [4].
To show that the census RLA is useful in other cases, we chose to simulate the audit on the House
of representatives of Cyprus, where 56 representatives are allocated to 5 districts. Due to the
somewhat limited available resources in English regarding the Cypriot census, we view this as a
pet-setting for testing our census RLA method, and not as a ready-as-is implementation.
664.3.1 The House of Representatives of Cyprus
The House of representatives of Cyprus is its sole legislating body. Ocially, The house holds 80
seats, where 56 are to be elected by the Greek Cypriot community and 24 by the Turkish Cypriot
community. In 1964, the Turkish-Cypriots withdrew from the political decision-making process,
leaving their house seats vacant [10].
Since then, the remaining 56 seats of the house are allocated to 5 districts. Currently, the allocation
of seats to the districts is amended by law when found necessary, and does not change automatically
following a census according to a set method. Our census RLA could be useful when performing
these amendments, to ensure that the resulting allocation of seats to districts is suciently reliable.
4.3.2 Data Generation and Technical Details
The data used to perform this simulation is based on the population census conducted in 2021 [30].
The Statistical Service of Cyprus publicly reports the total number of residents in every district,
but not the individual household data, which the census RLA requires. To generate this data, we
assumed that the number of residents per household distributes as it does in the United States,
as reported by its census [8]. We additionally assumed that 1% of households do not respond to
the census and are counted as if they have no residents. The per-household data used in these
simulations was generated as follows:
Generating the Census Data
1. The number of households per district was calculated by dividing the district's population by
the expected number of residents per household.
2. The number of residents in each household was drawn from the distribution specied in the
US census [8].
3. Due to the randomness involved in the previous step, the real census and our generated
one might disagree on the population of the districts. To balance this, the constant of each
district (csin (12) at Section 4.1.2) was set as the dierence between the population of the
district according to the real census and according to our generated one. With this denition,
the allocation of representatives to districts by the real census and by our generated one is
necessarily identical.
Audit Parameters and Other Details
We allocated representatives to districts using the D'Hondt method. D'Hondt was chosen since
it's currently used in the Cypriot elections to allocate seats to political parties. The audit was
run assuming that each household holds 15 residents at most, and with = 10 10. We assumed
that the list of households according to the census and the PES match, meaning HPES=Hcen.
The simulation's code was written in Python and is available in https://github.com/TGKar/
Batch-and-Census-RLA .
674.3.3 Results
We present the outputted risk-limit of the census RLA as a factor of the size of the PES. The x-axis
shows the share of households that were surveyed of the PES, and each point in the plot represents
the audit's outputted risk-limit when using a PES of that specied size. The results are averaged
across 10 simulations.
Results When Census and PES Completely Match
The audit's output when the census and PES fully agree on the number of residents in each
household. Under these conditions, a PES which samples 0.66% of households is sucient for a
risk limit of 0.1, and a sample of 0.87% is sucient for a risk-limit of 0.05. A PES often surveys
around 1% of households [18], meaning that our census RLA can condently approve its resulting
allocation of representatives to districts under these specied conditions.
Results with Small Enumeration Errors
The next plot shows the same results when the census and PES potentially disagree on 5% of
households. For these 5% of households, which are selected uniformly at random, the number
of residents according to the PES is re-drawn from the distribution of residents per household
described in Section 4.3.1. The following simulations were run over census and full PES results
that lead to the same allocation of representatives to states. During the simulated census RLA,
the audit only receives the PES results over a subset of randomly selected households.
68These results appear very similar to the previous plot, where the census and PES agreed on the
number of residents at all households. With the described rate of disagreement between the PES
and the census, a PES which surveys 0.72% of households is required for the audit to approve the
allocation with a risk limit of 0.1, compared to 0.66% if there were no enumeration disagreements.
To get a risk-limit of 0.05, the PES would need to survey 1% of households, compared to 0.87%
with no enumeration errors.
4.3.4 Simulation Conclusions
Settings Where Our Method is Applicable
As mentioned previously, our original goal was to run the census RLA over the US census and
House of Representatives, but our method could not conrm such representative allocations with
sucient condence unless the PES was very large. In nations with less representatives and federal-
states, such as Cyprus, our method can approve the census with a relatively low risk-limit with a
PES which covers 1% of households. More generally, our method is applicable when the minimal
census enumeration error which leads to a change in the resulting allocation of representatives is
relatively large (0.25% appears to be sucient for Cyprus based on simulations). When there are
many representatives and federal-states, even a small mistake in the census can lead to a wrongful
allocation of representatives and auditing the census results requires a larger PES sample.
Tolerance to Census and PES Disagreements
Our method appears to be tolerant to small disagreements between the census and the PES results
under these specied settings. A disagreement over 5% of households leads to a small decrease in
the audit's resulting risk-limit for any given PES sample size. A PES usually surveys around 1%
69of households, which is sucient for a risk-limit of 0.05 when the census and PES disagree on 5%
of households, compared to a risk-limit of 0.03 when there are no such disagreements.
Recovering From Assertions with a High Risk-Limit
Even when there are relatively few representatives and states, it's possible that a small enumeration
error could lead to a dierent allocation of representatives. In such cases, a full census RLA would
struggle to approve the census results with a suciently low risk-limit. If this occurs, the auditing
body can examine the risk-limit of the individual assertions (1
Tmaxs1;s2for eachs1;s22S) to see which
assertions have a higher risk-limit. As seen while simulating an election RLA in Section 3.3, in
many cases, one specic assertion is signicantly more dicult to approve than others, meaning
that its risk-limit is signicantly higher. If the risk-limit of all other assertions is suciently low,
we might still decide that the census' allocation of representatives is reliable, with the exception of
a single representative whose state-allocation could not be determined with condence.
If the audit results in an insucient risk-limit, we can also examine the risk-limit of each state, i.e.
the risk-limit that would be outputted if we only wanted to approve that the number of representa-
tives a specic state receives according to the census and according to the PES match. For a state
s, this risk-limit is the maximal risk-limit of all assertions which involve s, meaning:
max
s02Snfsg(
1
Tmax
s;s0;1
Tmax
s0;s)
:
705 Discussion and Further Research
Throughout this work, we can observe that an election's social choice function and setting can
severely limit the eciency of their RLAs. Systems like the Israeli Knesset elections and the US
House of Representatives' allocation of representatives to states are very sensitive to enumeration
errors, making it dicult to audit them eciently.
When designing new election systems, the ability to audit their social choice function in a risk-
limiting manner should be examined in advance. If a system has a sensitive social-choice function,
it should be compensated by other means. E.g., it can use a vote tabulation system which returns
the specic interpretation it gave each paper-backup ballots and ensure individual ballots can be
accessed eciently, allowing for ballot-comparison audits. If a system cannot be audited eciently
at all, implementing electronic vote tabulations for it should be done with extra care or avoided
altogether.
The Batchcomp RLA
In current literature, dierent RLA methods are usually compared by showing their simulated
performance over some reported election results. Most RLA methods, including the ones presented
in this work, are not analyzed in terms of query-complexity. This issue is especially prominent in
the eld of batch RLAs, where the performance of methods which can audit social choice functions
beyond a simple plurality is often not analyzed at all, neither analytically or by using simulations.
The simulations presented in this work (Section 3.3) indicate that Batchcomp provides a noticeable
improvement over ALPHA-batch in the limited settings that were tested. Despite this relative
success, we cannot denitively say it outperforms existing methods without a clear, rigorous way
of analyzing their eciency.
Auditing the Knesset Elections
Section 3.3 shows the diculties in auditing the Knesset election. Due to the small margins these
election results some times have, implementing RLAs for them seems could be problematic, since
they will require a full recount when any constraint is close to be unsatised.
Currently, a more practical use for RLAs in Israel could be to approve specic conditions regarding
the election results. E.g., conrm that a certain party is above or below the electoral threshold. In
such cases, the audit should be simulated in advance to ensure that the number of ballots it would
require to read is manageable.
Census RLAs
The census RLA method appears to be useful in some limited settings, and can be implemented
using existing post-enumeration surveys. In systems where our method is currently not sucient,
a census RLA could perhaps aim for a weaker guarantee - that the number of representatives each
state should receive according to the PES is close to the number it has according to the census.
The work raises many open questions and potential research directions:
71Applying RLAs in Additional Settings: Generally speaking, RLAs are relevant and can be
applied whenever one wishes to verify the computation of some function over a large number of
inputs obtained through potentially error-prone processes. While political elections provide
a natural environment for their application, we advocate for their use in a wider range of
settings to ensure reliable results.
As an example of such settings, RLAs could potentially be used to verify that decisions taken
based on datasets which were altered in order to satisfy dierential privacy are correct accord-
ing to the real data. This could be achieved by running an RLA in a protected environment
(enclave) which holds a subsample of the original, noiseless data. In this setting, the noisy,
(dierential private) dataset is seen as the reported result, while the noiseless dataset is the
true results. An RLA can verify that the results of some computation over the dierential
private dataset and over the original noiseless dataset are likely to be identical, based on a
(hopefully) small random sample from the original dataset. One challenge is to make sure
that the very fact that the data passed the test does not hurt the desired dierential privacy
property.
Analytical Analysis of the Eciency of RLAs: Most recent literature in the eld, including
this work, focuses on suggesting new RLA algorithms and tting them to additional electoral
systems and settings. There is little to no analytical analysis of the eciency and capabilities
of many RLA methods. Without a more rigorous analysis, it is not possible to denitively
determine which RLA methods are better for which settings. Such analysis could help, for
instance, to argue analytically whether Batchcomp is indeed preferable over ALPHA-Batch.
Analyzing the Ability to Audit Dierent Systems: Future research should analyze how
eciently dierent social choice functions can be audited. The "audatibility" of a social choice
function might be connected to the its noise stability, i.e., the probability of its outputted
winners changing if every vote is changed with some equal, independent probability. If a
social choice function has low noise-stability, it's more likely to lead to election results which
have small margins, meaning they would be dicult to audit eciently. The noise-stability
of dierent voting rules has been examined previously in literature [16, 17]. Connecting these
works to the eld of RLAs may aid in determining the potential capabilities of RLAs for
dierent election systems.
Connection Between RLAs and Computational Models: Thus far, advancements in the
eld of RLAs were done mostly independently and without connection to computational
models. Finding such connections may inspire new RLA algorithms, or suggest new methods
for analyzing the capabilities and eciency of existing methods. As an example of these
connections, RLAs can essentially be viewed as randomized decision trees, where each branch
represents a dierent sequence of paper-backup ballots that can be uncovered during the
audit. Viewing RLAs in this manner allows us to analyze their query complexity (number
of ballots examined) or instance complexity (best possible performance over specic election
results) and to apply existing results from other elds onto RLAs.
Unlabeled Instance Complexity and RLAs: Future research may nd lower bounds for the
query-complexity of RLAs by analyzing the randomized unlabeled certicate complexity of the
social choice function they operate on, as dened by Grossman, Komargodski and Naor [15].
The randomized unlabeled certicate complexity is a complexity measure of a function over
72some specic input. It's dened roughly as the minimal number of queries, in expectation, that
any randomized decision tree which computes this function has to perform over the specied
input, given a permuted version of it as a certicate. This notion is relevant for RLAs since
they are essentially randomized decision trees which calculate a social choice function's output
(the true winners) while using the reported election results. In the ballot-level RLA setting,
these reported results are given as a reported tally of the votes, which is equivalent to an
unlabeled certicate - a randomly permuted version of the paper-backup ballots. Therefore,
it appears that an RLA's expected query-complexity over accurate reported results is lower
bounded by the election's social choice function's randomized unlabeled certicate complexity
over these same results.
Making such an observation, however, requires some adjustments in the denition of the
randomized unlabeled instance complexity. RLAs are expected to be ecient even if their
certicate is nearly accurate. Meaning, if the reported tally they receive only contains small
errors which do not change the election winners, they are still expected to be relatively
ecient. Decision trees which are optimal for a specic input may be very inecient when
the certicate is even slightly inaccurate. Thus, the unlabeled instance complexity of a
function may be determined by randomized decision trees which would make for bad RLAs,
as they may lead to a full recount if the reported results contain negligible mistakes. Without
adjusting its denition, lower bounds which rely on this complexity measure may therefore
be too loose.
The Expressibility of SHANGRLA: Future research should attempt to assess the capabilities
and limitations of dierent RLA frameworks, such as SHANGRLA. Such research could, for
example, nd bounds on the eciency (number of examined ballots) of a SHANGRLA based
RLA given some reported election results, or discover classes of social choice functions which
can and cannot be audited using SHANGRLA. Some social choice functions, such as instant
runo voting, do not currently have reductions to SHANGRLA assertions which are both
sucient and necessary for the reported winners of the elections to be correct [40]. Finding
clear limitations for SHANGRLA can prevent researchers from trying to develop SHANGRLA
based RLAs for systems where it cannot apply.
Batch-Level RLAs Beyond SHANGRLA: Currently, There are few batch-level RLA algo-
rithms for social choice functions beyond a simple plurality. This work suggests a generic
method for converting any SHANGRLA based RLA to a batch-level RLA. Some election
systems, such as instant runo voting, do not currently have a reduction to SHANGRLA
assertions that are both sucient and necessary for the reported winners of the elections to
be correct. This raises the need for an even more general batch-level RLA method, which can
be used in systems that cannot currently be audited using SHANGRLA.
Census RLAs: This work presents the rst RLA for population censuses. It is possible and even
likely that other RLA algorithms could be adapted to audit censuses, perhaps with dierent
goals or guarantees than our suggested method.
Additionally, our census RLA method could potentially be optimized further. This method
operates iteratively, by sequentially sampling households and reading their census results,
and maintains a probability with which it can approve the census at all times. It is possible
73that other algorithms, which use the entirety of the census and PES data in one shot, could
outperform our method.
6 References
[1] A full list of U.S.A. states that conduct risk-limiting audits is available on the National Con-
ference of State Legislature's website .https://www.ncsl.org/research/elections-and-
campaigns/risk-limiting-audits.aspx .
[2] Stephen Ansolabehere, Barry C. Burden, Kenneth R. Mayer, and Charles Stewart III. \Learn-
ing from recounts". In: Election Law Journal: Rules, Politics, and Policy 17.2 (2018), pp. 100{
116.
[3] American Statistical Association. American Statistical Association statement on risk-limiting
post-election audits . 2010.
[4] National Governor's Association. Brieng On Post Enumeration Census Results .https :
/ / www . nga . org / updates / briefing - on - post - enumeration - census - results / # : ~:
text=The%20Post%2DEnumeration%20Survey%20is,independent%20of%20the%20census%
20operations . 2022.
[5] Michelle Blom, Jurlind Budurushi, Ronald L. Rivest, Philip B. Stark, Peter J. Stuckey,
Vanessa Teague, and Damjan Vukcevic. \Assertion-based approaches to auditing complex
elections, with application to party-list proportional elections". In: International Joint Con-
ference on Electronic Voting . Springer. 2021, pp. 47{62.
[6] Michelle Blom, Andrew Conway, Peter J. Stuckey, Vanessa J. Teague, and Damjan Vukcevic.
\Random errors are not necessarily politically neutral". In: International Joint Conference
on Electronic Voting . Springer. 2020, pp. 19{35.
[7] Michelle Blom, Peter J. Stuckey, and Vanessa Teague. \RAIRE: Risk-limiting audits for IRV
elections". In: arXiv preprint arXiv:1903.08804 (2019).
[8] United States Census Bureau. Historical Households Tables .https://www.census.gov/
data/tables/time-series/demo/families/households.html . Table HH-4. 2022.
[9] Bipartisan Policy Center. Presidential Commission on Election Administration . 2013.
[10] Giorgos Charalambous. \The House of Representatives". In: The Politics and Government
of Cyprus. Oxford: Peter Lange (2008), pp. 143{168.
[11] Constitution of the Argentine Nation .http://www.biblioteca.jus.gov.ar/argentina-
constitution.pdf . Sections 45-46.
[12] Rick Durrett. \Probability: theory and examples". In: vol. 49. Cambridge university press,
2019, p. 235.
[13] Michael Gallagher. \Proportionality, disproportionality and electoral systems". In: Electoral
studies 10.1 (1991), pp. 33{51.
74[14] Federal Returning Ocer of Germany (Bundeswahlleiter). Musterberechnung: Sitzverteilung
nach dem F unfundzwanzigsten Gesetz zur Anderung des Bundeswahlgesetzes .https://www.
bundeswahlleiter.de/dam/jcr/05c1185a- 173f- 4bab- 80d6- 51027c94b1bc/bwg2021_
mustersitzberechnung_ergebnis2017.pdf . In German. An unocial explanation in En-
glish based on this document is available at https://mikebeneschan.medium.com/the-
algorithm-that-fills-germanys-parliament-fa1e10c85917 . 2020.
[15] Tomer Grossman, Ilan Komargodski, and Moni Naor. \Instance Complexity and Unlabeled
Certicates in the Decision Tree Model". In: 11th Innovations in Theoretical Computer Sci-
ence Conference (ITCS 2020) . Schloss Dagstuhl-Leibniz-Zentrum f ur Informatik. 2020.
[16] Steven Heilman. \Noise Stability of Ranked Choice Voting". In: arXiv preprint arXiv:2209.11183
(2022).
[17] Steven Heilman and Alex Tarter. \Three candidate plurality is stablest for small correlations".
In:Forum of Mathematics, Sigma . Vol. 9. Cambridge University Press. 2021.
[18] Guihua Hu, Ting Wen, and Yuhuan Liu. \Determining the sample size of a post-enumeration
survey: The case of China, 2020". In: Mathematical Population Studies (2022), pp. 1{31.
[19] The Central Election Committee of Israel. Decisions and guidelines from the elections of the
19th Knesset . 2013, pp. 359{360.
[20] Kenneth C. Johnson. \Election certication by statistical audit of voter-veried paper bal-
lots". In: Available at SSRN 640943 (2004).
[21] Zeev Kam. \Vaadat habchriot layamin hadash: "Hateanot hasrot shachar, novot memetzuka"
[The Central Election Committee to the new right party: "The claims are baseless, born of
distress"]". In: Kan (Israeli Public Broadcasting Corporation) (Apr. 16, 2019).
[22] Mark Lindeman, Neal McBurnett, Kellie Ottoboni, and Philip B. Stark. \Next steps for the
Colorado risk-limiting audit (corla) program". In: arXiv preprint arXiv:1803.00698 (2018).
[23] Mark Lindeman and Philip B. Stark. \A gentle introduction to risk-limiting audits". In: IEEE
Security & Privacy 10.5 (2012), pp. 42{49.
[24] Mark Lindeman, Philip B. Stark, and Vincent S. Yates. \BRAVO: Ballot-polling Risk-limiting
Audits to Verify Outcomes". In: EVT/WOTE . 2012.
[25] John McCarthy, Howard Stanislevic, Mark Lindeman, Arlene S. Ash, Vittorio Addona, and
Mary Batcher. \Percentage-based versus statistical-power-based vote tabulation audits". In:
The American Statistician 62.1 (2008), pp. 11{16.
[26] Medicine National Academies of Sciences Engineering. Securing the Vote: Protecting Ameri-
can Democracy . National Academies Press, 2018, pp. 29{30.
[27] National Assembly of Pakistan - Composition .https://na.gov.pk/en/composition.php .
[28] NCSL Risk-Limiting Audits .https : / / www . ncsl . org / research / elections - and -
campaigns/risk-limiting-audits.aspx .
[29] Lawrence D. Norden, Aaron Burstein, Joseph Lorenzo Hall, and Margaret Chen. Post-election
audits: Restoring trust in elections . Brennan Center for Justice, 2007. Chap. II.
[30] Statistical Service of the Republic of Cyprus. Census of Population and Housing 2021: Prelim-
inary Results .https://www.pio.gov.cy/en/press-releases-article.html?id=27965 .
2022.
75[31] Ronald L. Rivest. \On estimating the size of a statistical audit". In: (2006).
[32] Roy G. Saltman. Eective use of computing technology in vote-tallying . Vol. 13. US Depart-
ment of Commerce, National Bureau of Standards, 1978. Chap. V.
[33] Carsten Sch urmann. \A risk-limiting audit in Denmark: A pilot". In: International Joint
Conference on Electronic Voting . Springer. 2016, pp. 192{202.
[34] J. D. Simon and B. O'Dell. An end to `faith-based' voting: universal precinct-based handcount
sampling to check computerized vote counts in federal and statewide elections . 2006.
[35] The Danish Ministry of Social Aairs. The Electoral System in Denmark - Parliamentary
elections .https : / / elections . sim . dk / media / 10507 / the - electoral - system - in -
denmark.pdf .
[36] Jacob V. Spertus and Philip B. Stark. \Sweeter than SUITE: Supermartingale Stratied
Union-Intersection Tests of Elections". In: International Joint Conference on Electronic Vot-
ing. Springer. 2022, pp. 106{121.
[37] Philip B. Stark. \ALPHA: Audit that Learns from Previously Hand-Audited Ballots". In:
arXiv preprint arXiv:2201.02707 (2022).
[38] Philip B. Stark. \Conservative statistical post-election audits". In: The Annals of Applied
Statistics 2.2 (2008), pp. 550{581.
[39] Philip B. Stark. \Risk-limiting postelection audits: Conservative P-values from common prob-
ability inequalities". In: IEEE Transactions on Information Forensics and Security 4.4 (2009),
pp. 1005{1014.
[40] Philip B. Stark. \Sets of half-average nulls generate risk-limiting audits: SHANGRLA". In: In-
ternational Conference on Financial Cryptography and Data Security . Springer. 2020, pp. 319{
336.
[41] Philip B. Stark, Vanessa Teague, and Aleksander Essex. \Veriable European elections: Risk-
limiting audits for D'Hondt and its relatives". In: fUSENIXgJournal of Election Technology
and Systems (fJETSg)1 (2014), pp. 18{39.
[42] The Distribution of Knesset Seats (Bader-Ofer Method) .https://m.knesset.gov.il/en/
about/lexicon/pages/seats.aspx . This page wrongly states that the electoral threshold is
2.0%. It was since changed to 3.25%.
[43] Department of Economics United Nations Secretariat and Statistics Division Social Af-
fairs. Post Enumeration Surveys Operational guidelines .https://unstats.un.org/unsd/
demographic/standmeth/handbooks/Manual_PESen.pdf . 2010.
[44] Ian Waudby-Smith, Philip B. Stark, and Aaditya Ramdas. \RiLACS: Risk limiting audits
via condence sequences". In: International Joint Conference on Electronic Voting . Springer.
2021, pp. 124{139.
76
Set Semantics for Asynchronous TeamLTL:
Expressivity and Complexity
Juha Kontinen /envelope/orcid
University of Helsinki, Finland
Max Sandström1/envelope/orcid
University of Sheﬃeld, UK
University of Helsinki, Finland
Jonni Virtema /envelope/orcid
University of Sheﬃeld, UK
University of Helsinki, Finland
Abstract
We introduce and develop a set-based semantics for asynchronous TeamLTL . We consider two
canonical logics in this setting: the extensions of TeamLTL by the Boolean disjunction and by
the Boolean negation. We establish fascinating connections between the original semantics based
on multisets and the new set-based semantics as well as show one of the ﬁrst positive complexity
theoretic results in the temporal team semantics setting. In particular we show that both logics
enjoy normal forms that can be utilised to obtain results related to expressivity and complexity
(decidability) of the new logics. We also relate and apply our results to recently deﬁned logics whose
asynchronicity is formalized via time evaluation functions.
2012 ACM Subject Classiﬁcation Theory of computation →Logic and veriﬁcation
Keywords and phrases Hyperproperties, Linear Temporal Logic, Team Semantics
Digital Object Identiﬁer 10.4230/LIPIcs.CVIT.2016.23
Funding Juha Kontinen : Partially supported by the Academy of Finland grant 345634.
Max Sandström : Partially supported by the Academy of Finland grant 322795.
Jonni Virtema : Partially supported by the Academy of Finland grant 345634 and by the DFG grant
VI 1045/1-1.
1 Introduction
Linear temporal logic ( LTL) is one of the most prominent logics for the speciﬁcation and
veriﬁcation of reactive and concurrent systems. The core idea in model checking, as introduced
in 1977 by Amir Pnueli [ 20], is to specify the correctness of a program as a set of inﬁnite
sequences, called traces, which deﬁne the acceptable executions of the system. In LTL-model
checking one is concerned with trace sets that are deﬁnable by an LTL-formula. Ordinary
LTLand its progeny are well suited for speciﬁcation and veriﬁcation of trace properties .
These are properties of systems that can be checked by going through all executions of the
system in isolation. A canonical example here is termination ; a system terminates if and
only if each run of the system terminates. However not all properties of interest are trace
properties. Many properties that are of prime interest, e.g., in information ﬂow security
require a richer framework. The term hyperproperty was coined by Clarkson and Schneider
[3] to refer to properties of systems which relate multiple execution traces. A canonical
example here would be bounded termination ; one cannot check whether a system terminates
in bounded time by only checking traces in isolation. Checking hyperproperties is vital in
1Corresponding author
©Juha Kontinen, Max Sandström and Jonni Virtema;
licensed under Creative Commons License CC-BY 4.0
42nd Conference on Very Important Topics (CVIT 2016).
Editors: John Q. Open and Joan R. Access; Article No.23; pp.23:1–23:20
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, GermanyarXiv:2304.10915v1  [cs.LO]  21 Apr 202323:2 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
information ﬂow security where dependencies between secret inputs and publicly observable
outputs of a system are considered potential security violations. Commonly known properties
of that type are noninterference [ 22,19] and observational determinism [ 28]. Hyperproperties
are not limited to the area of information ﬂow control. E.g., distributivity and other system
properties like fault tolerance can be expressed as hyperproperties [5].
During the past decade, the need for being able to formally specify hyperproperties
has led to the creation of families of new logics for this purpose, since LTLand other
established temporal logics can only specify trace properties. The two main families of the
new logics are the so-called hyperlogics and logics that adopt team semantics . In the former
approach standard temporal logics such as LTL,CTL, and QPTLare extended with explicit
trace and path quantiﬁcation, resulting in logics like HyperLTL [2],HyperCTL∗[2], and
HyperQPTL [21,4]. The latter approach (which we also adopt here) is to lift the semantics
of temporal logics to sets of traces directly by adopting team semantics yielding logics such
asTeamLTL [14, 7] and TeamCTL [13, 7].
Krebs et al. [ 14] introduced two versions of LTLwith team semantics: a synchronous
semantics and an asynchronous variant that diﬀer on how the evolution of time is linked
between computation traces when temporal operators are evaluated. In the synchronous
semantics time proceeds in lock-step, while in the asynchronous variant time proceeds
independently on each trace. For example the formula “ Fterminate " (here Fdenotes the
future-operator and “ terminate " is a proposition depicting that a trace has terminated)
deﬁnes the hyperproperty “bounded termination” under synchronous semantics, while it
expresses the trace property “termination” under asynchronous semantics.
The elegant deﬁnition of bounded termination exempliﬁes one of the main distinguishing
factors of team logics from hyperlogics; namely the ability to refer directly to unbounded
number of traces. Each hyperlogic-formula has a ﬁxed number of trace quantiﬁers that
delineate the traces involved in the evaluation of the formula. Another distinguishing feature
of team-based logics lies in their ability to enrich the logical language with novel atomic
formulae for stating properties of teams. The most prominent of these atoms are the
dependence atom dep(¯x,¯y)(stating that the values of the variables ¯xfunctionally determine
the values of ¯y) andinclusion atom ¯x⊆¯y(expressing the inclusion dependency that all the
values occurring for ¯xmust also occur as a value for ¯y).
As an example, let o1,...,onbe some public observables and assume that creveals
some conﬁdential information. The atom (o1,...on,c)⊆(o1,...on,¬c)expresses a form of
non-inference by stating that an observer cannot infer the value of the conﬁdential bit from
the outputs.
While HyperLTL and other hyperlogics have been studied extensively, many of the
basic properties of TeamLTL are still not well understood. Krebs et al. [ 14] showed
that synchronous TeamLTL andHyperLTL are incomparable in expressivity and that the
asynchronous variant collapses to LTL2. In this article we consider extensions of the
asynchronous TeamLTL , which have a greater expressive power. Not much was know about
the complexity aspects of TeamLTL until Lück [ 17] showed that the complexity of satisﬁability
and model checking of synchronous TeamLTL with Boolean negation ∼is equivalent to the
decision problem of third-order arithmetic. Subsequently, Virtema et al. [ 27] embarked for
a more ﬁne-grained analysis of the complexity of synchronous TeamLTL and discovered a
decidable syntactic fragment (the so-called left-ﬂat fragment ) and established that already
a very weak access to the Boolean negation suﬃces for undecidability. They also showed
2There was a slight error in the deﬁnition of asynchronous semantics in [14] which we ﬁx here.J. Kontinen, M. Sandström and J. Virtema 23:3
that synchronous TeamLTL and its extensions can be translated to HyperQPTL+, which is
an extension of HyperLTL by (non-uniform) quantiﬁcation of propositions. Kontinen and
Sandström [ 12] deﬁned translations between extensions of TeamLTL and the three-variable
fragment of ﬁrst-order team logic to utilize the better understanding of the properties of
logics in ﬁrst-order team semantics in the study of TeamLTL . They also showed that any
logic eﬀectively residing between synchronous TeamLTL extended with the Boolean negation
and second-order logic inherits the complexity properties of the extension of TeamLTL with
the Boolean negation. Finally, Gutsfeld et al. [ 7] reimagined the setting of temporal team
semantics to be able to model richer forms of (a)synchronicity by developing the notion
of time-evaluation functions. In addition to reimagining the framework, they discovered
decidable logics which however relied on restraining time-evaluation functions to be either k-
context-bounded ork-synchronous . It is worth noting that recently asynchronous hyperlogics
have been considered also in several other articles (see, e.g., [8, 1]).
Itcanbesaidthatalmostallcomplexitytheoreticresultspreviouslyobtainedfor TeamLTL
are negative, and the few positive results have required drastic restrictions in syntax or
semantics. In this article we take a take a fresh look at the asynchronous variant of TeamLTL .
Recent works on synchronous TeamLTL have revealed that quite modest extensions of
synchronous TeamLTL are undecidable. Thus, our study of asynchronous TeamLTL partly
stems from our desire to discover decidable but expressive logics for hyperproperties. Until
now, all the papers on temporal team semantics have explicitly or implicitly adopted a
semantics based on multisets of traces. In the team semantics literature, this often carries
the name strict semantics , in contrast to lax semantics which is de-facto set-based semantics.
In database theory, it is ubiquitous that tasks that are computationally easy under set based
semantics become untractable in the multiset case. In the team semantics setting this can be
already seen in the model checking problem of propositional inclusion logic PL(⊆)which is
P-complete under lax semantics, but NP-complete under strict semantics [10].
Our new set-based framework oﬀers a setting that drops the accuracy that accompanies
adoption of multiset semantics, in favour of better computational properties. Consider
the following formula expressing a form of strong non-inference in parallel computation:
G((o1,...,on,c)⊆(o1,...,on,¬c)),whereo1,...,onare observable outputs and cis conﬁdential.
In the synchronous setting, the formula expresses that during a synchronous computation,
at any given time, an observer cannot infer the value of the secret cfrom the outputs. In
the asynchronous setting, the formula states a stronger property that the above property
holds for all computations (not only synchronous). In the multiset setting the number of
parallel computation nodes is ﬁxed, while in the new lax semantics, we drop that restriction,
and consider an undeﬁned number of computation nodes. The condition is stronger in lax
semantics; and intuitively easier to falsify, which makes model checking in practice easier.
Our contribution. We introduce and develop a set-based semantics for asynchronous
TeamLTL, which we name lax semantics and write TeamLTLl. We consider two canonical
logics in this setting: the extensions of TeamLTLlby the Boolean disjunction TeamLTLl(>)
and by the Boolean negation TeamLTLl(∼). By developing the basic theory of lax asyn-
chronous TeamLTL, we discover some fascinating connections between the strict and lax
semantics. We discover that both of the logics enjoy normal forms that can be utilised
to obtain expressivity and complexity results. Tables 1 and 2 summarise our results. For
comparison, Table 3 summarises the known results on complexity of synchronous TeamLTL .
CVIT 201623:4 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
TeamLTLs/lleft-ﬂat– TeamLTLs(6)Cor. 12< TeamLTLs(>)
<
Ex. 6≡
Thm. 8
TeamLTLl(>)Thm. 10≡left-ﬂat– TeamLTLl(6)†
<quasi-ﬂat– TeamLTLs/l(∼)
≡
Thm. 14
left-dc– TeamLTLl(∼)
Table 1Expressivity hierarchy of the asynchronous logics considered in the paper. Logics with
lax or strict semantics are here referred with the superscripts lands, respectively. For the deﬁnitions
of left ﬂatness, quasi ﬂatness, and left downward closure, we refer to Deﬁnitions 7 and 13. †: This
follows since only TeamLTLl(6)is downward closed (cf. Theorem 8 and Deﬁnition 13). Theorem 8
implies that for TeamLTL(∼)-formulae in quasi-ﬂat form the strict and lax semantics coincide.
Logic Complexity of References
(asynchronous semantics) model checking satisﬁability
LTL PSPACE PSPACE [23]
PL(∼) ATIME -ALT(exp ,poly) ATIME -ALT(exp ,poly) [9]
TeamLTLl/sPSPACE PSPACE [14], Theorem 5
left-ﬂat- TeamLTLs/l(6) PSPACE PSPACE Theorem 17
TeamLTLl(6) PSPACE PSPACE Theorem 17
TeamLTLs(6) ??? PSPACE †
TeamLTLs(dep) NEXPTIME -hard PSPACE [14]
left-dc- TeamLTLl(∼) inTOWER(poly) inTOWER(poly) Theorem 17
Table 2Complexity results of this paper. All results are completeness results if not otherwise
speciﬁed. PL(∼)refers to the propositional fragment of TeamLTL (∼)which embeds also to
left-dc- TeamLTLl(∼).†: All PSPACE -completeness results for satisﬁability in strict semantics
andTeamLTLlfollow directly from classical LTLby downward closure and singleton equivalence
similar to [ 14, Proposition 5.4]. ATIME-ALT(exp ,poly)refers to alternating exponential time with
polynomially many alternations while TOWER(poly) refers to problems that can be decided by a
deterministic TM in time bounded by an exponential tower of 2’s of polynomial height.
Logic Complexity of References
(sync. strict semantics) model checking satisﬁability
TeamLTL PSPACE PSPACE [14]
left-ﬂat- TeamLTL( 6)inEXPSPACE PSPACE [27]
TeamLTL(dep) NEXPTIME -hard PSPACE [14]
TeamLTL( 6) ??? PSPACE †
TeamLTL( 6,⊆) Σ0
1-hard Σ0
1-hard [27]
TeamLTL(∼) third-order arithmetic third-order arithmetic [17]
Table 3Complexity results for synchronous strict semantics. All results are completeness results
if not otherwise speciﬁed. †: All PSPACE -completeness results for satisﬁability follow directly from
classical LTLby downward closure and singleton equivalence similar to [14, Proposition 5.4].J. Kontinen, M. Sandström and J. Virtema 23:5
2 Preliminaries
Fix a set APofatomic propositions . The set of formulae of LTL(over AP) is generated by
the following grammar:
ϕ::=p|¬p|ϕ∨ϕ|ϕ∧ϕ|ϕ|Gϕ|ϕUϕ,wherep∈AP.
We adopt the convention that formulae are given in negation normal form, i.e., ¬is allowed
to appear only in front of atomic propositions. Note that this is an expressively complete set
ofLTL-formulae.
Atracetover APis an inﬁnite sequence from (2AP)ω. For a natural number i∈N, we
denote byt[i]theith element of tand byt[i,∞]the postﬁx (t[j])j≥ioft. Semantics of LTL
is deﬁned in the usual manner:
t|=p ⇔ p∈t[0]
t|=¬p ⇔ p/negationslash∈t[0]
t|=ϕ1∨ϕ2⇔ t|=ϕ1ort|=ϕ2
t|=ϕ ⇔ t[1,∞]|=ϕ
t|=Gϕ ⇔ ∀ i≥0. t[i,∞]|=ϕ
t|=ϕ1Uϕ2⇔ ∃ i≥0. t[i,∞]|=ϕ2
and∀j: 0≤j <i⇒t[j,∞]|=ϕ1
Thetruth value of a formula ϕon a tracetis denoted by JϕKt∈{0,1}.
The logical constants /latticetop,⊥and the operators FandWcan be deﬁned in the usual way:
⊥:=p∧¬p,/latticetop:=p∨¬p,Fϕ:=/latticetopUϕ, andϕWψ:= (ϕUψ)∨Gϕ.
Next we give the so-called asynchronous team semantics for LTLintroduced in [ 14]. In
[14], the release operator was deﬁned slightly erroneously; we ﬁx the issue here by taking Gas
primitive. Informally, a multiset of traces Tis a collection of traces with possible repetitions.
Formally, we represent Tas a set of pairs (i,t), whereiis anindex(from some suitable large
set) andtis a trace. We stipulate that the elements of a multiset have distinct indices. From
now on, we will always omit the index and write tinstead of (i,t). For multisets TandS,
T/unionmultiSdenotes the disjoint union of TandS(obtained by stipulating that traces in SandT
have disjoint sets of indices). Note that all the functions fwith domain Tare actually of
the formf((i,t))and may map diﬀerent copies of the trace tdiﬀerently. A team(multiteam ,
resp.) is a set (multiset, resp.) of traces. If f:T→Nis a function, we deﬁne the update of
the team through T[f,∞]:={t[f(t),∞]|t∈T}, where the function fdetermines for each
trace the point in time it updates to. For functions fandf/primeas above, we write f/prime<fif for
allt∈Tit holds that f/prime(t)<f(t). The underlying team support (T):={t|(i,t)∈T}of a
multiteamTis called the supportofT.
IDeﬁnition 1 (Team Semantics for LTL).LetTbe a multiteam, l∈{p,¬p|p∈AP}
a literal, and ϕandψLTL-formulae. The asynchronous team semantics of TeamLTL is
deﬁned as follows.
T|=l⇔t|=lfor all (i,t)∈T
T|=ϕ∧ψ⇔T|=ϕandT|=ψ
T|=ϕ∨ψ⇔ ∃T1,T2s.t.T1/unionmultiT2=TandT1|=ϕandT2|=ψ
T|=ϕ⇔T[1,∞]|=ϕ,where 1is the constant function t/mapsto→1
CVIT 201623:6 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
T|=Gϕ⇔ ∀f:T→NT[f,∞]|=ϕ
T|=ϕUψ⇔ ∃f:T→NT[f,∞]|=ψand∀f/prime<f:T/prime[f/prime,∞]|=ϕ,
whereT/prime:={t∈T|f(t)/negationslash= 0}
The synchronous variant of the semantics is obtained by allowing fto range only over
constant functions.
We also consider the following Boolean connectives: Boolean disjunction 6andBoolean
negation∼interpreted in the usual way.
T|=ϕ6ψiﬀT|=ϕorT|=ψ T |=∼ϕiﬀT/negationslash|=ϕ
In this paper, we take the asynchronous semantics as the standard semantics and write
TeamLTL for asynchronous TeamLTL .
Next we deﬁne some importation semantic properties of formulae studied in the literature:
(Downward closure) IfT|=ϕandS⊆T, thenS|=ϕ.
(Empty team property) ∅|=ϕ.
(Flatness) T|=ϕiﬀ{t}|=ϕfor allt∈T.
(Singleton equivalence) {t}|=ϕiﬀt|=ϕ.
A logic has one of the above properties if every formula of the logic has the property. It is
easy to check that TeamLTL has all the above properties [14].
We will now justify our choice of semantics. The semantic rules for literals, conjunction,
and disjunction are the standard ones in team semantics, and which have been motivated
numerous times in the literature [ 24]. The two main desirable properties for the logic to
have are ﬂatness and singleton equivalence, which also motivated the original deﬁnition of
asynchronous TeamLTL [14]. The given semantics for is the only possible one that satisﬁes
ﬂatness. The same is true for F(i.e.,/latticetopUϕ) and G; moreover the semantics clearly capture the
intuitive meanings of asynchronously in the future and asynchronously globally, respectively.
The given semantics for Upreserves ﬂatness and singleton equivalence, and adequately
captures the intuitive meaning of asynchronous until. The framework of asynchronous
TeamLTL then allows us to deﬁne diﬀerent variants of the familiar temporal operators. E.g.,
ϕW1ψ:=Gϕ∨ϕUψandϕW2ψ:=Gϕ6ϕUψdeﬁne diﬀerent variants of weak until ; the
ﬁrst of which is ﬂat, while the second is not.
T|=ϕW1ψ⇔ ∃T1,T2s.t.T1/unionmultiT2=T, T 1|=GϕandT2|=ϕUψ
T|=ϕW2ψ⇔T|=GϕorT|=ϕUψ
SimilarlyϕR1ψ:=ψU((ψ∧ϕ)∨Gψ)andϕR2ψ:=ψU((ψ∧ϕ)6Gψ)give rise to diﬀerent
variants of release. Moreover, with ∼one can deﬁne additional dual operators.
A deﬁning feature of team semantics is the ability to enrich logics with novel atomic state-
ments describing properties of teams in a modular fashion. For example, dependence atoms
dep(ϕ1,...,ϕn,ψ)andinclusion atoms ϕ1,...,ϕn⊆ψ1,...,ψn,withϕ1,...,ϕn,ψ,ψ 1,...,ψn
being LTL-formulae, have been studied extensively in ﬁrst-order and modal team semantics.
The dependence atom states that the truth value of ψis functionally determined by that
ofϕ1,...,ϕnwhereas the inclusion atom states that each value combination of ϕ1,...,ϕn
must also occur as a value combination for ψ1,...,ψn. The semantics of these atoms can be
given as follows:
T|= dep(ϕ1,...,ϕn,ψ)iﬀ∀t,t/prime∈T:/parenleftBig/logicalanddisplay
1≤j≤nJϕjKt=JϕjKt/prime/parenrightBig
⇒JψKt=JψKt/primeJ. Kontinen, M. Sandström and J. Virtema 23:7
T|=ϕ1,...,ϕn⊆ψ1,...,ψniﬀ∀t∈T∃t/prime∈T:/logicalanddisplay
1≤j≤nJϕjKt=JψjKt/prime
Consider the following example formula with dependence atoms:
Gdep(i1,i2,o)∨Gdep(i2,i3,o)
This formula states that the executions of the system can be decomposed into two parts; in
the ﬁrst part, the output ois determined by the inputs i1andi2, and in the second part, o
is determined by the inputs i2andi3.
IfAis a collection of atoms and connectives, TeamLTL (A)denotes the extension of
TeamLTL with the atoms and connectives in A. It is straightforward to see (in analogy
to the modal team semantics setting [ 11]) that any dependency such as the ones above
is determined by a ﬁnite set of n-ary Boolean relations. Let Bbe a set of n-ary Boolean
relations. We deﬁne the property [ϕ1,...,ϕn]Bfor ann-tuple (ϕ1,...,ϕn)ofLTL-formulae:
T|= [ϕ1,...,ϕn]Biﬀ{(Jϕ1Kt,...,JϕnKt)|t∈T}∈B.
Expressions of the form [ϕ1,...,ϕn]Baregeneralised atoms . It was shown in [ 27] that, in the
synchronous setting, TeamLTL (∼)is expressively complete with respect to all generalised
atoms, whereas the extension of TeamLTL (>)with the so-called ﬂattening operator can
express any downwards closed generalised atoms. These results readily extend to the
asynchronous setting. Moreover the ﬂattening operator renders itself unnecessary due to
ﬂatness of asynchronous TeamLTL . The results imply, e.g, that the (downwards closed)
dependence atoms can be expressed in both of the logics TeamLTL (∼)andTeamLTL (>),
and inclusion atoms in turn are expressible in TeamLTL (∼). The proof of the following
theorem is essentially the same as the proof of [26, Proposition 17].
ITheorem 2. LetA,Dbe the sets of all generalised atoms, and all downward closed gener-
alised atoms. Then TeamLTL(A,>)≡TeamLTL( >)andTeamLTL(D,∼)≡TeamLTL(∼).
In the above L≡L/primedenotes the equivalence of the logics LandL/prime.
3 Set-based semantics for TeamLTL
Next we deﬁne a relaxed version of the asynchronous semantics. It is called laxsemantics
as it corresponds to the so-called lax semantics of ﬁrst-order team semantics (see e.g., [ 6]).
From now on we refer to the semantics of Deﬁnition 1 as strict semantics. The possibility
of considering lax semantics for TeamLTL was suggested by Lück already in [ 18] but the
full deﬁnition was not given. Intuitively, lax semantics can always be obtained from a strict
one by checking what strict semantics would yield if multiteams would be enriched with
unbounded many copies of each of its traces. One of the deﬁning features of lax semantics is
that it unable to distinguish multiplicities, which is formalised by Proposition 4 below.
We need some notation for the new deﬁnition. We write P(N)+to denoteP(N)\{∅}.
For a team Tand function f:T→P(N)+, we writeT[f,∞]to denote the team {t[s,∞]|
t∈T,s∈f(t)}. ForT/prime⊆T,f:T→P(N)+, andf/prime:T/prime→P(N)+, we deﬁne that f/prime<fif
and only if
∀t∈T/prime:min(f/prime(t))≤min(f(t))andmax(f/prime(t))<max(f(t))(assuming max(f(t))exists).
Nowforf/negationslash=f/prime, itholdsthat f/prime<fifandonlyifthereexistsafunction g:T/prime[f/prime,∞]→P(N)+
such that/parenleftbig
T/prime[f/prime,∞]/parenrightbig
[g,∞] =T/prime[f,∞].
CVIT 201623:8 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
IDeﬁnition 3 (TeamLTLl).SupposeTis a team, and ϕandψareTeamLTL formulae.
The lax semantics is deﬁned as follows. We only list the cases that that diﬀer from the
standard semantics.
T|=lϕ∨ψ⇔ ∃T1,T2s.t.T1∪T2=TandT1|=ϕandT2|=ψ
T|=lGϕ⇔ ∀f:T→P(N)+it holds that T[f,∞]|=lϕ
T|=lϕUψ⇔ ∃f:T→P(N)+such thatT[f,∞]|=lψand
∀f/prime:T/prime→P(N)+s.t.f/prime<f, it holds that T/prime[f/prime,∞]|=lϕorT/prime=∅,
whereT/prime:={t∈T|max(f(t))/negationslash= 0}
In the context we will be considering in this article, the subformulae ϕin the deﬁnition of the
until operator Ualways has the empty team property and thus we disregard the possibility
that the team T/primeis empty in our proofs, as that case follows from the empty team property.
The above set-based semantics can also be viewed in terms of multisets. In that case
functionsfare quantiﬁed uniformly, i.e. we restrict our consideration to functions where
f(i,t) =f(j,t). Furthermore semantics for disjunctions is deﬁned in a way that omit
references to multiplicities. We extend the lax semantics to multiteams Tby stipulating that
T|=lϕiﬀsupport (T)|=lϕ. This stipulation makes it easier to relate our new logic to the
old multiteam based ones.
The following theorem shows that TeamLTLl(∼)satisﬁes the so-called localityproperty,
see Appendix A for the proof. For a trace toverAP/primeandAP⊆AP/prime, thereduction of ttoAP,
tAP, is a sequence from (2AP)ωsuch thatp∈t[i]if and only if p∈tAP[i], for allp∈APand
i∈N. For a team ToverAP/primewe deﬁne the reduction of TtoAPbyTAP={tAP|t∈T}.
IProposition 4. LetTbe a team and ϕaTeamLTLl(∼)-formula with variables in AP.
NowT|=lϕiﬀTAP|=lϕ.
The next theorem displays that lax semantics enjoys the same fundamental properties as
its strict counterpart. The proof via a straightforward induction, see Appendix A for details.
ITheorem 5. TeamLTLlsatisﬁes downward closure, empty team property, singleton equi-
valence, and ﬂatness.
The following example establishes that the new lax semantics diﬀers from the strict
semantics, and that in the old semantics multiplicities matter. Moreover, we obtain
TeamLTLl<TeamLTLl(6)by showing that the latter is not ﬂat.
IExample 6. Letϕbe the formula G(p>q),T1:={t}andT2:={(1,t),(2,t)}, where
t:={p}{q}ω. It is easy to check that T1|=ϕbutT1/negationslash|=lϕ(which is witnessed by
T[f,∞]/negationslash|=lp>qforf(t):={0,1}). Likewise T2/negationslash|=ϕ. Moreover{si}|=lϕ, fori∈{1,2},
but{s1,s2}/negationslash|=lϕ, wheres1:={p}ωands2:={q}ω.
We will also consider the following fragments of TeamLTL( 6)andTeamLTL(∼).
IDeﬁnition 7. A formulaϕofTeamLTL (6)is called left-ﬂat, if in all of its subformulae of
the form GψandψUθ, the subformula ψis an LTL-formula. A formula ϕofTeamLTL (∼,>)
is called left-downward closed , if in all of its subformulae of the form GψandψUθ, the
subformula ψis an TeamLTL( 6)-formula.
We will later show that the above syntactic restriction for ﬂatness could be replaced by a
semantic restriction as well (see Corollary 11). The proof of the following Theorem can be
found in Appendix A.J. Kontinen, M. Sandström and J. Virtema 23:9
ITheorem 8. For allϕ∈TeamLTLl(6)the following two claims hold:
1.ϕis downward closed, and
2.ifϕis left-ﬂat, then T|=ϕiﬀsupport(T)|=lϕfor all multiteams T.
The restriction to left-ﬂat formulae in case (2) above is necessary by Example 6.
4 Normal Form Theorems
In this section we develop normal forms for our logics, which we then utilise to obtain strong
expressivity and complexity results.
4.1 TeamLTL with the Boolean disjunction
IDeﬁnition 9. A formulaϕis in>-disjunctive normal form if it is of the form >i∈Iαi,
whereαiareLTL-formulae.
We will next show that every formula of TeamLTLl(>)can be transformed into equivalent
>-disjunctive normal form. This result is similar to the one proved in [ 25] for team-based
modal logic ML(>).
ITheorem 10. Every formula ϕ∈TeamLTLl(>)is logically equivalent to a formula
ϕ∗=>i∈Iαiin>-disjunctive normal form, where |αi|≤|ϕ|and|I|= 2k, wherekis the
number of 6inϕ.
Proof.The proof proceeds by induction on the structure of formulae. Note that atomic
formulae are already in the normal form and that the case for >is trivial. The remaining
cases are deﬁned as follows:
(ψ∧θ)∗:=>
i∈I,j∈J(αψ
i∧αθ
j) ( ψ∨θ)∗:=>
i∈I,j∈J(αψ
i∨αθ
j)
(ψ)∗:=>
i∈Iαψ
i (Gψ)∗:=>
i∈IGαψ
i
(ψUθ)∗:=>
i∈I,j∈J(αψ
iUαθ
j).
whereαψ
iandαθ
jare the ﬂat formulae in the disjunctive normal forms of ψandθrespectively,
andIandJare the respective index sets.
Supposeϕ=ψ∧θand thatψ≡>i∈Iαψ
iandθ≡>i∈Jαθ
j(induction hypothesis). Now
T|=lϕif and only if T|=lψandT|=lθ. The latter holds, if and only if T|=lαψ
kand
T|=lαθ
l, for somekandl. This can be equivalently expressed as T|=l>i,j(αψ
i∧αθ
j), i.e.
T|=lϕ∗.
Supposeϕ=ψ∨θand thatψ≡>i∈Iαψ
iandθ≡>i∈Jαθ
j. By deﬁnition T|=lϕif and
only if there exists T/prime∪T/prime/prime=Tsuch thatT/prime|=lψandT/prime/prime|=lθ. By the induction hypothesis
the latter is equivalent with T/prime|=l>i∈Iαψ
iandT/prime/prime|=l>j∈Jαθ
j. By deﬁnition this holds if
and only if there are kandlsuch thatT/prime|=lαψ
kandT/prime/prime|=lαθ
l, which is equivalent with
T|=lαψ
k∨αθ
l, by deﬁnition. Equivalently then T|=l>i∈I,j∈J(αψ
i∨αθ
j).
Supposeϕ=ψand thatψ≡>i∈Iαψ
i. By deﬁnition T|=lϕis equivalent with
T[1,∞]|=lψ. By the induction hypothesis the latter holds if and only if T[1,∞]|=l>i∈Iαψ
i,
which by deﬁnition is equivalent with T[1,∞]|=lαψ
kfor somek∈I. The latter holds if and
only ifT|=lαψ
kfor somek∈I, which is equivalent with T|=l>i∈Iαψ
i.
Supposeϕ=Gψand thatψ≡>i∈Iαψ
i. Suppose that T|=lϕ. By deﬁnition for
all functions f:T→P (N)+it holds that T[f,∞]|=lψ. By the induction hypothesis
CVIT 201623:10 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
T[f,∞]|=l>i∈Iαψ
ifor allf. Especially this holds for the total function deﬁned for every
t∈Tbyfmax(t):=N. ThusT[fmax,∞]|=lαψ
kfor somek. By downward closure it holds
thatT[f/prime,∞]|=lαψ
kfor allf/prime≤fmax. HenceT|=lGαψ
k, and thus T|=l>i∈IGαψ
i. The
other direction is analogous.
Supposeϕ=ψUθand thatψ≡>i∈Iαψ
iandθ≡>j∈Jαθ
j. Suppose T|=lϕ. By
deﬁnition there exists a function f:T→P(N)+such thatT[f,∞]|=lθand for all functions
f/prime:T/prime→P(N)+such thatf/prime<f,T/prime[f/prime,∞]|=lψ, whereT/prime:={t∈T|f(t)/negationslash= 0}. Hence
by the induction hypothesis T[f,∞]|=l>j∈Jαψ
j, which is equivalent with T[f,∞]|=lαψ
k
for somek∈J, and, for the function fmax(t):={n∈N|n < m, for somem∈f(t)},
it holds that T[fmax,∞]|=l>i∈Iαθ
i, which in turn is equivalent with T[fmax,∞]|=lαψ
l
for somel∈I. By downward closure the latter holds for all intermediary functions, and
thusT|=lαθ
kUαψ
land ﬁnally T|=l>i∈I,j∈J(αθ
iUαψ
j)as wanted. The other direction is
analogous.
In order to show the size estimates stated in the theorem, it suﬃces to note that our
translation to >-disjunctive normal from can be equivalently stated as follows:
ϕ≡>
i∈Iαψ
i=>
f∈Fϕf,
whereFis the set of all selection functions fthat select, separately for each occurrence,
either the left disjunct ψor the right disjunct θof each subformula of the form ψ>θofϕ,
andϕfdenotes the formula obtained from ϕby substituting each occurrence of a subformula
of type (ψ>θ)byf(ψ>θ). The size estimates follow immediately from this observation. J
Proofs for the following two corollaries can be found in Appendix A.
ICorollary 11. For every ﬂat TeamLTLl(6)-formula there exists an equivalent TeamLTLl-
formula.
ICorollary 12. TeamLTLl(6)<TeamLTL( 6)
4.2 TeamLTL with the Boolean negation
A normal form, similar to the one in Theorem 10, can also be obtained for TeamLTL extended
with the Boolean negation, however, since this extension is no longer downward closed, it
only holds for a speciﬁc fragment of the logic. The following normal form has been introduced
and used in [ 16,15] to analyse the complexity of modal team logic and FO2in the team
semantics context. Below ϕddenotes a formula obtained by transforming ¬ϕinto negation
normal form in the standard way in LTL.
IDeﬁnition 13. A formulaϕis quasi-ﬂat if ϕis of the form:
>
i∈I(αi∧/logicalanddisplay
j∈Ji∃βi,j),
whereαiandβi,jareLTL-formulae, and∃βi,jis an abbreviation for the formula ∼βd
i,j.
Note that, for LTL-formulaeαandβ, we haveT|=lαif and only if t|=α, for allt∈T.
MoreoverT|=l∃β, if and only if there exists some trace t∈Tsuch thatt|=β.
ITheorem 14. Every left-downward closed formula ϕ∈TeamLTLl(∼,>)is logically equi-
valent to a quasi-ﬂat formula ϕ∗.J. Kontinen, M. Sandström and J. Virtema 23:11
Proof.Proof by induction over the structure of ϕ. Atoms are ﬂat, and hence are in the
normal form. The translations and the proofs of correctness for the cases of conjunction,
disjunction, and Boolean negation are analogous to the simpler modal framework of [ 16,15].
Supposeϕ=ψ∧θand assume that ψis equivalent to >i∈I(αψ
i∧/logicalandtext
j∈Ji∃βψ
i,j)andθ
to>i∈I/prime(αθ
i∧/logicalandtext
j∈J/prime
i∃βθ
i,j). By the distributive laws of conjunction and disjunction, ϕis
clearly equivalent to
>
i∈I,k∈I/prime(αψ
i∧αθ
k∧/logicalanddisplay
j∈Ji∃βi,j∧/logicalanddisplay
j∈J/prime
k∃βk,j).
Supposeϕ=ψ∨θ. By the induction hypothesis and an argument analogous to the
disjunction case of the proof of Theorem 10, ϕis equivalent to
>
i∈I,k∈I/prime/parenleftbig
(αψ
i∧/logicalanddisplay
j∈Ji∃βψ
i,j)∨(αθ
k∧/logicalanddisplay
j∈J/prime
j∃βθ
k,j)/parenrightbig
. (1)
The above formula expresses that Tcan be split into two parts: T1in which each trace
satisﬁesαiand the subformulae βi,jare satisﬁed by some traces, and T2in which each trace
satisﬁesαkand the subformulae βk,jare satisﬁed by some traces. But this is equivalent
to saying that Tcan be split into two parts: T1in which each trace satisﬁes αi, andT2in
which each trace satisﬁes αk; and the subformulae αi∧βi,jandαk∧βk,jare satisﬁed by
some traces in T, and thus the formula (1) is equivalent with
>
i∈I,k∈I/prime/parenleftbig
(αψ
i∨αθ
k)∧/logicalanddisplay
j∈Ji∃(αψ
i∧βψ
i,j)∧/logicalanddisplay
j∈J/prime
k∃(αθ
j∧βθ
k,j)/parenrightbig
that is in the normal form.
Supposeϕ=∼ψand assume that ψis equivalent to >i∈I(αi∧/logicalandtext
j∈Ji∃βi,j).Nowϕis
clearly equivalent to/logicalandtext
i∈I(∃αd
i6>j∈Jiβd
i,j).This formula can be expanded back to the
normal form with exponential blow-up using the distributivity law of propositional logic.
Supposeϕ=ψand assume that ψis equivalent to >i∈I(αi∧/logicalandtext
j∈Ji∃βi,j). It is now
easy to check that ϕis equivalent to >i∈I(αi∧/logicalandtext
j∈Ji∃βi,j).
Supposeϕ=Gψ. Sinceϕwas assumed to be left-downward closed, ψis equivalent with
a formula of the form >iα. Now we can transform ϕto the normal form as in the previous
theorem.
Supposeϕ=ψUθ. By assumption ϕis left-downward closed hence ψis equivalent
with a formula of the form >i∈Iαψ
i(by the previous theorem) and θis equivalent to
>k∈I/prime(αθ
k∧/logicalandtext
j∈Jk∃βθ
k,j). Now using the fact that ψis downward closed, it is easy to see
thatϕis logically equivalent with the formula:
>
i∈I,k∈I/prime/parenleftbig
αψ
iU(αθ
k∧/logicalanddisplay
j∈Jk∃βψ
k,j)/parenrightbig
. (2)
It now suﬃces to show that the disjuncts (for any i∈I,k∈I/prime) of(2)can be equivalently
expressed as:
/parenleftbig
αψ
iUαθ
k∧/logicalanddisplay
j∈Jk∃(αψ
iU(αθ
k∧βψ
k,j)/parenrightbig
. (3)
We will show the logical implication from (3) to (2). Assume
T|=l/parenleftbig
αψ
iUαθ
k∧/logicalanddisplay
j∈Jk∃(αψ
iU(αθ
k∧βψ
k,j)/parenrightbig
.
CVIT 201623:12 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
Letfbe such that T[f,∞]|=lαθ
kand thatT[g,∞]|=lαψ
i, for allg<f. In order to show
T|=lαψ
iU(αθ
k∧/logicalanddisplay
j∈Jk∃βψ
k,j), (4)
we need to make sure that traces witnessing the truth of the formulae ∃βψ
k,jcan be found
inT[f,∞]. Here we can use the assumption that T|=l/logicalandtext
j∈Jk∃(αψ
iU(αθ
k∧βψ
k,j))implying
that for each j∈Jkthere exists tj∈Tsuch thattj|=αψ
iU(αθ
k∧βψ
k,j). Let nownjbe such
thattj[nj,∞]|=αθ
k∧βψ
k,jand thattj[l,∞]|=αψ
ifor alll<nj. Now by the ﬂatness of the
formulaeαψ
i,αθ
k, andβψ
k,j, the function f/primedeﬁned by
f/prime(t):=/braceleftBigg
f(t)∪{tj[nj,∞]}ift=tj, for somej∈Jk
f(t) otherwise
witnesses (4). The converse is proved analogously. J
The following example indicates that the restriction to left-downward closed formulae is
necessary for the proof to work in the above theorem.
IExample 15. Letϕbe the formula G(∃p1>∃p2)andT:={t}, wheret:= ({p1}{p2})ω.
It is now easy to check that T|=lϕbutT/negationslash|=lG∃pifori∈{1,2}.
5 Computational Properties
In this section we analyse the computational properties of the logics studied in the previous
section. We focus on the complexity of the model checking and satisﬁability problems.
For the model checking problem one has to determine whether a team of traces generated
by a given ﬁnite Kripke structure satisﬁes a given formula. We consider Kripke structures of
the form K:= (W,R,η,w 0), whereWis a ﬁnite set of states, R⊆W2a left-total transition
relation,η:W→2APa labelling function, and w0∈Wan initial state of W. A pathσ
through Kis an inﬁnite sequence σ∈Wωsuch thatσ[0]:=w0and(σ[i],σ[i+ 1])∈R
for everyi≥0. Thetrace ofσis deﬁned as t(σ):=η(σ[0])η(σ[1])···∈ (2AP)ω. A Kripke
structure Kthengenerates the trace set Traces(K) :={t(σ)|σis a path through K}.
IDeﬁnition 16. Themodel checking problem of a logicLis the following decision problem:
Given a formula ϕ∈Land a Kripke structure Kover AP, determine whether Traces (K)|=ϕ,
The(countable) satisﬁability problem of a logicLis the following decision problem: Given a
formulaϕ∈L, determine whether T|=ϕfor some (countable) T/negationslash=∅.
Below we will use the fact that the model checking and satisﬁability problems of LTL
arePSPACE -complete [ 23]. Furthermore, we use the facts that the satisﬁability problem of
propositional team logic PL(∼)isATIME-ALT(exp,poly)-complete [ 9], and that the com-
plexity of modal team logic is complete for the class TOWER(poly) :=TIME (expnO(1)(1)),
where exp0(1):= 1andexpk+1(1):= 2expk(1)[16, 15].
ITheorem 17. 1. The model checking and satisﬁability problems of TeamLTLl(6)are
PSPACE -complete.
2.The model checking and satisﬁability problems of the left-ﬂat fragment of TeamLTL (6)
arePSPACE -complete.
3.The model checking problem of the left-downward closed fragment of TeamLTLl(∼,6)is
PSPACE -hard and it is contained in TOWER(poly) .J. Kontinen, M. Sandström and J. Virtema 23:13
4.The satisﬁability problem of the left-downward closed fragment of TeamLTLl(∼,6)is
ATIME-ALT(exp,poly)-hard and it is contained in TOWER(poly) .
Proof.Let us ﬁrst consider the proofs of claims 1 and 2. Note that PSPACE -hardness holds
already for LTL-formulae, hence it suﬃces to show containment in PSPACE . Furthermore,
note that 2 follows immediately from 1 and Theorem 8. Assume a formula ϕ∈TeamLTLl(6)
and a Kripke structure Kis given as input. By Theorem 10, ϕis logically equivalent with a
formula of the form >f∈Fϕf, wherefvaries over selection functions selecting, separately
for each occurrence, either the left disjunct ψor the right disjunct θof each subformula of
the formψ>θofϕ. Now, without constructing the full formula >f∈Fϕf, using polynomial
space with respect to the size of ϕit is possible to check whether Traces (K)|=ϕffor some
f∈F. Hence the upper bound follows from the fact that LTLmodel checking is in PSPACE .
The upper bound for satisﬁability follows analogously.
Let us then consider the proof of claim (4). The proof of claim (3)is analogous. For
the lower bound it suﬃces to note that propositional team logic PL(∼)is a fragment of
the left-downward closed fragment of TeamLTLl(∼,6)and hence its satisﬁability problem
can be trivially reduced to the satisﬁability problem of the left-downward closed fragment.
Therefore ATIME-ALT(exp,poly)-hardness follows by the result of [9].
For the upper bound we ﬁrst transform an input formula ϕinto an equivalent quasi-ﬂat
formula of the form
>
i∈I(αi∧/logicalanddisplay
j∈Ji∃βi,j). (5)
Analogously to [ 16,15], this formula can be computed in time TIME (expO(|ϕ|)(1)). It is now
easy to see that the formula (5)is satisﬁable iﬀ there exists i∈I, such that SAT(αi∧βi,j) = 1
for allj∈Ji. Since LTL-satisﬁability checking is contained in PSPACE⊆TIME (2nO(1)),
the overall complexity of the above procedure is in TIME(exp(|ϕ|O(1))(1)). J
6 Connections to Other Forms of Asynchronicity
In [7] the authors introduced a novel team-based logic that can deal with diﬀerent modes of
asynchronous hyperproperties by using so-called time evaluation functions (tefs). Time eval-
uation functions facilitate ﬁne-grained asynchronous interactions between traces. Intuitively
given a trace t∈Tand a value of the global clock i∈N, a tefτoutputs the value τ(i,t)
of the local clock of trace tat global time i. IfTis a multiset of traces, a time evaluation
function forTis a function τ:N×T→Nthat satisﬁes the following two conditions. We
writeτ(i)to denote the function T→Ndeﬁned byt/mapsto→τ(i,t).
stepwiseness –∀i∈N∀t∈T:τ(i+ 1,t)∈{τ(i,t),τ(i,t) + 1},
strict monotonicity –∀i∈N:τ(i)/negationslash=τ(i+ 1).
A tef isinitial, ifτ(0,t) = 0for eacht∈T.
It was shown in [ 7] that when tefs are assumed to be synchronous, we obtain exactly
synchronous TeamLTL as deﬁned in [ 14]. In this section, we take a closer look on the
connections between asynchronous TeamLTL and team-based logics with tefs. We identify a
logic with tefs that corresponds almost exactly to asynchronous TeamLTL and to the left-ﬂat
fragment of asynchronous TeamLTL (6). This connection establishes the ﬁrst non-trivial
decidability result for logics with tefs without putting heavy restrictions on tefs.
We give the syntax TeamCTL with an additional synchronous next operator that was
shown in [7] to be expressible in the logic using simple gadgets.
ϕ::=p|¬p|(ϕ∧ψ)|(ϕ∨ψ)|ϕ|∃ϕ|∀ϕ|G∃ϕ|G∀ϕ|[ϕU∃ψ]|[ϕU∀ψ]
CVIT 201623:14 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
We follow with the semantics. In [ 7]TeamCTL∗-formulae were evaluated with respect to
pairs (T,τ), but since we conciser only TeamCTL here, we choose to internalise τintoT.
The cases for propositional atoms, Boolean connectives, and are as for asynchronous
TeamLTL (see Deﬁnition 1). Note that here the functions τ(i)take the role of the functions
fof Deﬁnition 1.
T|=∃ϕ⇔there is an initial tef τs.t.T[τ(1),∞]|=ϕ
T|=∀ϕ⇔for all initial tefs τ, we haveT[τ(1),∞]|=ϕ
T|=G∃ϕ⇔there is an initial tef τs.t.T[τ(k),∞]|=ϕ, for allk∈N
T|=G∀ϕ⇔for all initial tefs τ, we haveT[τ(k),∞]|=ϕ, for allk∈N
T|= [ϕU∃ψ]⇔there is an initial tef τandk∈Ns.t.T[τ(k),∞]|=ψand
∀m: 0≤m<k⇒T[τ(m),∞]|=ϕ
T|= [ϕU∀ψ]⇔for all initial tefs τ,∃k∈Ns.t.T[τ(k),∞]|=ψand
∀m: 0≤m<k⇒T[τ(m),∞]|=ϕ
We identify a collection of the above temporal operators that match as closely as possible
with the operators of asynchronous TeamLTL . For a collection of temporal operators C, we
write TeamCTL (C)to denote the logic built from propositional atoms by using ∧,∨, and
the operators inC.
In order to deal with the asynchronous until operator, we need to do two concessions.
Firstly, we need to restrict ourselves to the left-ﬂat fragment (c.f. Deﬁnition 7). Secondly,
instead of until, we use the strong release operator deﬁned by [ψMϕ]:= [ϕUϕ∧ψ]. The F
andGmodalities can be used without any restrictions. Finally, we say that two formulas ϕ
andψareﬁn-equivalent , ifT|=ϕ⇔T|=ψholds for all ﬁnite multiteams T. With these
restriction, we can prove the following theorem.
ITheorem 18. For every left-ﬂat- TeamCTL (,G∀,M∃,6)-formula there exists an ﬁn-
equivalent TeamLTLl(6)formula usingMinstead of U, and vice versa.
Proof.It is easy to check that all the logics in question are downward closed (cf. the proof
of Theorem 5 in the Appendix). We prove the equivalence with the left-ﬂat- TeamLTLl(6),
which by Theorems 8 and 10 is equivalent with TeamLTL( 6).
The translations simply swap MwithM∃andGwithG∀. Correctness of the translations
can be proven by induction on the structure of formulae. The only non-trivial cases are the
cases for strong release and globally.
The case for globally follow from the following chain of equivalences:
T|=lGϕ⇔ ∀f:T→NT[f,∞]|=ϕ
⇔for all initial tefs τ, we haveT[τ(k),∞]|=ϕ, for allk∈N
⇔T|=G∀ϕ.
It is straightforward to check the second equivalence holds (recall that ϕis ﬂat). The ﬁrst
and the last equivalence are simply the semantics of the respective operators.
Assume [ϕUϕ∧ψ]is such that ϕis ﬂat. Now
T|=l[ϕUϕ∧ψ]⇔ ∃f:T→P(N)such thatT[f,∞]|=ϕ∧ψand
∀f/prime:T/prime→P(N)s.t.f/prime<f, we haveT/prime[f/prime,∞]|=ϕ
whereT/prime:={t∈T|max(f(t))/negationslash= 0}J. Kontinen, M. Sandström and J. Virtema 23:15
⇔there is an initial tef τandk∈Ns.t.T[τ(k),∞]|=ϕ∧ψand
∀m: 0≤m<k⇒T[τ(m),∞]|=ϕ
⇔T|= [ϕU∃ϕ∧ψ].
The ﬁrst equivalence is the semantics of until and the second follows from ﬂatness of ϕ,
ﬁniteness of T, and the induction hypothesis. The last equivalence is the semantics of U∃.J
ICorollary19. For every TeamCTL (,G∀,M∃)-formula there exists a ﬁn-equivalent TeamLTL
formula usingMinstead of U, and vice versa. (Note that there is no diﬀerence between
TeamLTL andTeamLTLl.)
By combining Theorem 18 to Theorems 8 and 17, we obtain the following:
ICorollary 20. The model checking problem of left-ﬂat- TeamCTL (,G∀,M∃,6)restricted
to ﬁnite teams is PSPACE -complete.
We showed that over ﬁnite sets of traces the left-ﬂat fragment of TeamCTL (,G∀,M∃,6)
coincides with the left-ﬂat fragment of TeamLTL (6)usingMinstead of U. The following
example shows that the same does not hold over arbitrary sets of traces.
IExample 21. LetTconsist of the traces {p}k{q}ω,k∈N. Clearly T|=lpUqin
asynchronous TeamLTL , butT/negationslash|=pU∃qinTeamCTL .
7 Conclusion
We introduced a novel set-based semantics for asynchronous TeamLTL . We showed several
results on the expressive power and complexity of the extensions of TeamLTLlby the Boolean
disjunction TeamLTLl(>)and by the Boolean negation TeamLTLl(∼). In particular, our
results show that the complexity properties of the former logic are comparable to that of LTL
and that the left-downward closed fragment of the latter has also decidable model-checking
and satisﬁability problems. See Table 1 on page 4 for an overview of our expressivity results
and Table 2 for our complexity results. We obtained these results on TeamLTLl(>)and
TeamLTLl(∼)via normal forms that also allowed us to relate the expressive power of these
logics to the corresponding logics in the strict semantics. Our results show that, while the
synchronous TeamLTL can be viewed as a fragment of second-order logic, the asynchronous
TeamLTL (6)under the lax semantics is a sublogic of HyperLTL (see [ 2] for a deﬁnition).
Furthermore, our decidability results show, e.g, that it will probably be possible to devise a
complete proof system for the logic. We conclude with open questions:
Does Theorem 14 extend to all formulae of TeamLTLl(∼)? Note that any quasi-ﬂat–
TeamLTL(∼)-formula can be rewritten in HyperLTL .
Can the result (iii) of Theorem 17 be accompanied by an matching lower bound (i.e.,
TOWER(poly) -hardness result)?
Can a syntactic characterisation (similar to Corollary 11) be obtained for the downward
closedfragmentof TeamLTLl(∼)? Webelievethat TeamLTLl(6)isapromisingcandidate,
as its extensions with inﬁnite conjunctions and disjunctions suﬃces for all downward
closed properties of teams.
What is the complexity of model checking for TeamLTL( 6)under the strict semantics?
CVIT 201623:16 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
References
1Jan Baumeister, Norine Coenen, Borzoo Bonakdarpour, Bernd Finkbeiner, and César Sánchez.
A temporal logic for asynchronous hyperproperties. In CAV (1) , volume 12759 of Lecture
Notes in Computer Science , pages 694–717. Springer, 2021.
2Michael R. Clarkson, Bernd Finkbeiner, Masoud Koleini, Kristopher K. Micinski, Markus N.
Rabe, and César Sánchez. Temporal logics for hyperproperties. In POST 2014 , pages 265–284,
2014.
3Michael R. Clarkson and Fred B. Schneider. Hyperproperties. Journal of Computer Security ,
18(6):1157–1210, 2010.
4Norine Coenen, Bernd Finkbeiner, Christopher Hahn, and Jana Hofmann. The hierarchy of
hyperlogics. In LICS 2019 , pages 1–13. IEEE, 2019.
5Bernd Finkbeiner, Christopher Hahn, Philip Lukert, Marvin Stenger, and Leander Tentrup.
Synthesis from hyperproperties. Acta Informatica , 57(1-2):137–163, 2020.
6Pietro Galliani. Inclusion and exclusion dependencies in team semantics: On some logics of
imperfect information. Annals of Pure and Applied Logic , 163(1):68 – 84, 2012.
7Jens Oliver Gutsfeld, Arne Meier, Christoph Ohrem, and Jonni Virtema. Temporal team
semantics revisited. In Christel Baier and Dana Fisman, editors, LICS ’22: 37th Annual
ACM/IEEE Symposium on Logic in Computer Science, Haifa, Israel, August 2 - 5, 2022 ,
pages 44:1–44:13. ACM, 2022.
8Jens Oliver Gutsfeld, Markus Müller-Olm, and Christoph Ohrem. Automata and ﬁxpoints for
asynchronous hyperproperties. Proc. ACM Program. Lang. , 5(POPL):1–29, 2021.
9Miika Hannula, Juha Kontinen, Jonni Virtema, and Heribert Vollmer. Complexity of proposi-
tional logics in team semantic. ACM Trans. Comput. Log. , 19(1):2:1–2:14, 2018.
10Lauri Hella, Antti Kuusisto, Arne Meier, and Jonni Virtema. Model checking and validity in
propositional and modal inclusion logics. J. Log. Comput. , 29(5):605–630, 2019.
11Juha Kontinen, Julian-Steﬀen Müller, Henning Schnoor, and Heribert Vollmer. Modal in-
dependence logic. In Rajeev Goré, Barteld P. Kooi, and Agi Kurucz, editors, Advances in
Modal Logic 10, invited and contributed papers from the tenth conference on "Advances in
Modal Logic," held in Groningen, The Netherlands, August 5-8, 2014 , pages 353–372. College
Publications, 2014.
12Juha Kontinen and Max Sandström. On the expressive power of teamltl and ﬁrst-order team
logic over hyperproperties. In WoLLIC , volume 13038 of Lecture Notes in Computer Science ,
pages 302–318. Springer, 2021.
13Andreas Krebs, Arne Meier, and Jonni Virtema. A team based variant of CTL. In Fabio
Grandi, Martin Lange, and Alessio Lomuscio, editors, 22nd International Symposium on
Temporal Representation and Reasoning, TIME 2015, Kassel, Germany, September 23-25,
2015, pages 140–149. IEEE Computer Society, 2015.
14Andreas Krebs, Arne Meier, Jonni Virtema, and Martin Zimmermann. Team Semantics for
the Speciﬁcation and Veriﬁcation of Hyperproperties. In Igor Potapov, Paul Spirakis, and
James Worrell, editors, MFCS 2018 , volume 117, pages 10:1–10:16, Dagstuhl, Germany, 2018.
Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.
15Martin Lück. Axiomatizations of team logics. Ann. Pure Appl. Log. , 169(9):928–969, 2018.
16Martin Lück. On the complexity of team logic and its two-variable fragment. In MFCS, volume
117 ofLIPIcs, pages 27:1–27:22. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018.
17Martin Lück. On the complexity of linear temporal logic with team semantics. Theoretical
Computer Science , 2020.
18Martin Lück. Team logic: axioms, expressiveness, complexity . PhD thesis, University of
Hanover, Hannover, Germany, 2020.
19John McLean. Proving noninterference and functional correctness using traces. Journal of
Computer Security , 1(1):37–58, 1992.
20Amir Pnueli. The temporal logic of programs. In 18th Annual Symposium on Foundations of
Computer Science , pages 46–57. IEEE Computer Society, 1977.J. Kontinen, M. Sandström and J. Virtema 23:17
21Markus N. Rabe. A Temporal Logic Approach to Information-Flow Control . PhD thesis,
Saarland University, 2016.
22A. W. Roscoe. CSP and determinism in security modelling. In Proceedings of the 1995
IEEE Symposium on Security and Privacy, Oakland, California, USA, May 8-10, 1995 , pages
114–127. IEEE Computer Society, 1995.
23A. P. Sistla and E. M. Clarke. The complexity of propositional linear temporal logics. J. ACM,
32(3):733–749, jul 1985.
24Jouko Väänänen. Dependence Logic . Cambridge University Press, 2007.
25Jonni Virtema. Complexity of validity for propositional dependence logics. Inf. Comput. ,
253:224–236, 2017.
26Jonni Virtema, Jana Hofmann, Bernd Finkbeiner, Juha Kontinen, and Fan Yang. Linear-time
temporal logic with team semantics: Expressivity and complexity. CoRR, abs/2010.03311,
2020.
27Jonni Virtema, Jana Hofmann, Bernd Finkbeiner, Juha Kontinen, and Fan Yang. Linear-time
temporal logic with team semantics: Expressivity and complexity. In Mikolaj Bojanczyk
and Chandra Chekuri, editors, 41st IARCS Annual Conference on Foundations of Software
Technology and Theoretical Computer Science, FSTTCS 2021, December 15-17, 2021, Virtual
Conference , volume 213 of LIPIcs, pages 52:1–52:17. Schloss Dagstuhl - Leibniz-Zentrum für
Informatik, 2021.
28Steve Zdancewic and Andrew C. Myers. Observational determinism for concurrent program
security. In 16th IEEE Computer Security Foundations Workshop (CSFW-16 2003), 30 June -
2 July 2003, Paciﬁc Grove, CA, USA , page 29. IEEE Computer Society, 2003.
A Appendix
IProposition 4. LetTbe a team and ϕaTeamLTLl(∼)-formula with variables in AP.
NowT|=lϕiﬀTAP|=lϕ.
Proof.The proof is by induction on the structure of ϕ.
Supposeϕis a literal. By deﬁnition, T|=lϕif only ift|=ϕfor allt∈T. Now, seeing as
ϕis a literal of AP, the latter is equivalent with t|=ϕfor allt∈TAP. This, by deﬁnition,
is equivalent with TAP|=lϕ.
Supposeϕ=ψ1∧ψ2. By deﬁnition, T|=lϕif and only if T|=lψ1andT|=lψ2. By the
induction hypothesis, the latter holds if and only if TAP|=lψ1andTAP|=lψ2, which by
deﬁnition is equivalent with TAP|=lϕ.
Supposeϕ=ψ/prime∨ψ/prime/prime. By deﬁnition, T|=lϕif and only if there are subteams T/prime∪T/prime/prime=T
such thatT/prime|=lψ/primeandT/prime/prime|=lψ/prime/prime. By the induction hypothesis, the latter two claims are
equivalent with T/prime
AP|=lψ/primeandT/prime/prime
AP|=lψ/prime/prime. NowT/prime
AP∪T/prime/prime
AP=TAP, henceTAP|=lϕ.
For the converse, assume that TAP|=lϕis witnessed by subteams T/prime
APandT/prime/prime
AP. Now it
is easy to check that T/prime={t∈T|tAP∈T/prime
AP}andT/prime/prime={t∈T|tAP∈T/prime/prime
AP}witness
T|=lϕ.
Supposeϕ=ψ. By deﬁnition, T|=lϕif and only if T[1,∞]|=lψ, which by the
induction hypothesis is equivalent with T[1,∞]AP|=lψ. Note that T[1,∞]AP=TAP[1,∞],
wherebyT|=lψholds if and only if TAP|=lψholds.
Supposeϕ=Gψ. By deﬁnition T|=lϕis equivalent with that T[f,∞]|=lψfor
all functions f:T→P (N+). By the induction hypothesis the latter is equivalent with
T[f,∞]AP|=lψfor functions fas before. Now for any f/prime:TAP→P(N+)there is some
f, such that T[f,∞]AP=TAP[f/prime,∞], since we can pick the function f(s) =f/prime(t)for all
s∈Tsuch thatsAP=t. Similarly, for each fwe obtain a corresponding f/primeby taking its
restriction to AP. HenceT[f,∞]|=lψholds for all fif and only if TAP[f/prime,∞]|=lψholds
for allf/prime, and therefore T|=lGψis equivalent with TAP|=lGψ.
CVIT 201623:18 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
Supposeϕ=ψ1Uψ2. Assume T|=lϕ. By deﬁnition there is a function f1:T→
P(N+)such thatT[f1,∞]|=lψ1and for all f2<f1it holds that T0[f2,∞]|=lψ2, where
T0:={t∈T|max(f(t))/negationslash= 0}. By the induction hypothesis then T[f1,∞]AP|=lψ1and
T0[f2,∞]AP|=lψ2forf1andf2as previously. We deﬁne the function f/prime
1:TAP→P(N+)
by setting f/prime
1(s):=/uniontext
if1(ti), whereti∈Tare such that ti
AP=s. NowTAP[f/prime
1,∞] =
T[f1,∞]AP. Furthermore, by a similarly deﬁned f/prime
2, we get that T0
AP[f/prime
2,∞] =T0[f2,∞]AP.
ThusT[f1,∞]AP|=lψ1if and only if TAP[f/prime
1,∞]|=lψ1and for all f2<f1it holds that
T0[f2,∞]AP|=lψ2if and only if T0
AP[f2,∞]|=lψ2. Therefore TAP|=lϕ. The converse
follows analogously.
Supposeϕ=∼ψ. By deﬁnition T|=lϕif and only if T/negationslash|=lψ, which in turn is equivalent
withTAP/negationslash|=lψby the induction hypothesis. This, again, is equivalent with TAP|=lϕ, due
to the deﬁnition. J
ITheorem 5. TeamLTLlsatisﬁes downward closure, empty team property, singleton equi-
valence, and ﬂatness.
Proof.The proofs proceed by induction over the structure of the formulae. Note that while
downward closure follows from ﬂatness, we need that the induction steps work with the
weaker assumption of downward closure for the result to generalise to non-ﬂat extensions of
the logic.
Downward closure: Letϕ∈TeamLTL be a formula and T,Steams such that S⊆T
andT|=lϕ. We need to show that S|=lϕas well.
For atomic ϕthe claim is immediately true: T|=lϕif and only if t|=ϕfor allt∈T,
which also holds for all t∈S, and thusS|=lϕ.
For conjunction the claim follows immediately from the induction hypothesis. Let’s
consider the case of disjunction. Suppose T|=lϕ∨ψ. By deﬁnition then there are T1,T2⊆T
s.t.T1|=lϕandT2|=lψ. By the induction hypothesis S∩T1|=lϕandS∩T2|=lψ, since
S∩T1⊆T1andS∩T2⊆T2. Furthermore (S∩T1)∪(S∩T2) =S, and therefore S|=lϕ∨ψ.
The case for is straightforward. Suppose T|=lϕ. By deﬁnition T[1,∞]|=lϕ. Since
S[1,∞]⊆T[1,∞]follows from S⊆T, we obtain S[1,∞]|=lϕby the induction hypothesis.
ThusS|=ϕ.
Next we suppose T|=lGϕ. By deﬁnition then for all f:T→P (N)+it holds that
T[f,∞]|=lϕ. Now, for all f:S→P(N)+,S[f,∞]⊆T[f/prime,∞], wheref/primeis any extension of
ftoT. Hence by the induction hypothesis S[f,∞]|=lϕfor allfandS|=lGϕ.
Suppose then that T|=lϕUψ. For any function h:T→P(N)+, lethSdenote the reduct
ofhto the domain S. FromS⊆T, we get
S[hS,∞]⊆T[h,∞]. (6)
By deﬁnition, there is a function f:T→P(N)+such thatT[f,∞]|=lψ. Moreover, for all
f/prime:T0→P(N)+such thatf/prime<f, we haveT0[f/prime,∞]|=lϕ, whereT0:={t∈T|max(f(t))/negationslash=
0}. By the induction hypothesis and (6), we have that S[fS,∞]|=lψ. Moreover, for all
g:S0→P (N)+, whereS0:={t∈S|max(fS(t))/negationslash= 0}, such that g < fS,S[g,∞]|=lϕ
follows by the induction hypothesis and the fact that every gis equal tof/prime
Sfor a suitable f/prime.
ThusS|=lϕUψ.
Empty team property: SupposeT=∅. The claim is clear for atomic formulae; since
the team is empty, p∈t(0)andp /∈t(0)holds for all p∈APandt∈T. The cases for
conjunction and disjunction follow immediately from the induction hypothesis. The cases
for temporal operators follow immediately from the induction hypotheses as well, since
∅[f,∞] =∅for anyf:T→P(N)+.J. Kontinen, M. Sandström and J. Virtema 23:19
Flatness: We prove by induction on ϕthatT|=ϕif{t}|=ϕfor allt∈T, for every
teamT. The only if direction follows directly from downward closure.
The case for atomic formulae holds by deﬁnition, and the cases for conjunction and the
next step operator follows directly from the induction hypothesis. Let us consider the case
for disjunction. Assume that for all t∈T,{t}|=ϕor{t}|=ψ. LetT1andT2be the sets
of traces in Tthat satisfy ϕandψ, respectively. Clearly T1∪T2=T, and by induction
hypothesis T1|=lϕandT2|=lψ. ThusT|=lϕ∨ψ.
For the case of until, suppose {t}|=lϕUψfor allt∈T. Now, for each t∈T, there
exists a function ft:{t} → P (N)+such that{t}[ft,∞]|=ψand for all intermediary
f/prime
t:{t}→P (N)+, deﬁned for such traces twhere max(f(t))/negationslash= 0, such that f/prime
t< ftit
holds that{t}[f/prime
t,∞]|=ϕ. We deﬁne the functions f:T→P (N)+, andg:T/prime→P (N)+
throughf(t):=ft(t)andg(t):={j∈N|j <sup(f(t))}. By the induction hypothesis
T[f,∞]|=lψandT/prime[g,∞]|=lϕ. Letf/prime:T/prime→P(N)+be any function such that f/prime<f. If
we can show that T/prime[f/prime,∞]|=lψ, we obtain T|=ϕUψand are done. To that end, clearly
T/prime[f/prime,∞]⊆T/prime[g,∞], and thus we obtain T/prime[f/prime,∞]|=lψfrom downward closure.
Finally for the case for G, suppose{t}|=lGϕfor allt∈T. Now for each trace tand
functionf:{t}→P (N)+it holds that{t}[f,∞]|=lϕ. Now by the induction hypothesis, for
all functions F:T→P(N)+such thatF(t):=f(t)it holds that T[F,∞]|=lϕ. Now the
functionsFare all possible functions. Thus T|=lGϕ.
Singleton equivalence: We prove by induction on ϕthat, for every trace t,{t}|=lϕif
and only if t|=lϕ.
The case for literals is stated in the deﬁnition, whereas the case for conjunction follows
directly from the induction hypothesis. Hence, consider the next step operator. Suppose
ϕ=ψ. Now by deﬁnition {t}|=lϕis equivalent with {t}[1,∞]|=lψ, which in turn holds
if and only if t[1,∞]|=ψby induction hypothesis. By the deﬁnition of the next step operator
the latter is equivalent with t|=ψ.
Supposeϕ=ψ∨θ. By deﬁnition{t}|=lϕis equivalent with {t}|=lψor{t}|=lθ. By
the induction hypothesis the latter two are equivalent with t|=ψort|=θ, and thus by
deﬁnitiont|=ψ∨θif and only if{t}|=lϕ.
Supposeϕ=ψ1Uψ2. Assume{t}|=lϕ. By deﬁnition there is a function f:{t}→P (N)+
such that{t}[f,∞]|=lψ2and for all intermediary functions f/prime:T/prime→P(N)+it holds that
T/prime[f/prime,∞]|=lψ1, whereT/prime:={t}, iff(t)/negationslash={0}and otherwise T/prime=∅. We assume f(t)/negationslash={0},
as the other case is trivial. Let k:=min(f(t)). By induction hypothesis and downward
closuret[k,∞]|=ψ2. Now for every singleton-valued function f/prime:T/prime→P(N)+deﬁned by
f/prime(t):={k/prime}, such that k/prime< k, it holds that{t}[f/prime,∞]|=lψ1. Hence by the induction
hypothesis, for all k/prime<kit holds that t[k/prime,∞]|=ψ1. Thust|=ϕ.
Now assume t|=ϕ. By deﬁnition there exists a number k≥0such thatt[k,∞]|=ψ2and
for all 0≤k/prime<kit holds that t[k/prime,∞]|=ψ1. Thus we can deﬁne a function f:{t}→P (N)+
such thatf(t):={k}and functions f/prime:{t}→P (N)+such thatf/prime(t):={k/prime}. Now by the
induction hypothesis {t}[f,∞]|=lψ2and{t}[f/prime,∞]|=lψ1, and furthermore by ﬂatness the
latter actually holds for all intermediary functions g. Therefore{t}|=lϕ.
Supposeϕ=Gψ. Assume{t}|=lϕ. By deﬁnition for all functions f:{t}→P (N)+it
holds that{t}[f,∞]|=lψ. Especially this holds for every function fksuch thatfk(t):={k}.
By the induction hypothesis then t[k,∞]|=ψfor allk. Thus by deﬁnition t|=Gψ.
Now assume t|=ϕ. By deﬁnition for all k≥0it holds that t[k,∞]|=ψ. By the induction
hypothesis it follows that {t}[f,∞]|=lψfor allf:{t}→P (N)+such thatf={k}. Thus,
by ﬂatness{t}[f/prime,∞]|=lψfor all functions f/prime:{t}→P (N)+. Thus{t}|=lGψ. J
ITheorem 8. For allϕ∈TeamLTLl(6)the following two claims hold:
CVIT 201623:20 Set Semantics for Asynchronous TeamLTL: Expressivity and Complexity
1.ϕis downward closed, and
2.ifϕis left-ﬂat, then T|=ϕiﬀsupport(T)|=lϕfor all multiteams T.
Proof.In order to show (1)it suﬃces to extend the proof of Theorem 5 with a case for 6:
LetTbe a team of traces and let S⊆T. SupposeT|=lψ6ϕ. By deﬁnition T|=lψor
T|=lϕ. Without loss of generality we may assume T|=lψ, which entails by the induction
hypothesis that S|=lψandS|=lψ6ϕ.
The proof of claim (2)is a simple induction on the structure of ϕ. We show the claim
forϕ=αUψ, whereαis an LTL-formula. Assume T|=ϕ. Then there exists f:T→N
such thatT[f,∞]|=ψand, by ﬂatness, for all (i,t)∈Tandk < f ((i,t))it holds that
{(i,t[k,∞])}|=α. DeﬁneF:T→P(N)+byF(t):={f((i,t))|i∈N}. It is easy to check
that support (T[f,∞]) =support (T)[F,∞]. Now by application of the induction hypothesis
support (T)[F,∞]|=lψ. Likewise, for all F/prime<F, whereF/prime:T→P(N)+is deﬁned similarly
toF,support (T)[F/prime,∞]|=lαfollows by the ﬂatness of α. The proof of the converse
implication is similar. Assume support (T)|=lϕand letG: support (T)→P(N)+be such
that support (T)[G,∞]|=lψ. By downward closure we may assume that Gis single valued.
Now it is easy to pick g:T→Nsuch that support (T[g,∞]) =support (T)[G,∞]. From the
induction hypothesis it follows that T[g,∞]|=ψ. Just like above, using the fact that αis
ﬂat, it follows that T|=ϕ. J
ICorollary 11. For every ﬂat TeamLTLl(6)-formula there exists an equivalent TeamLTLl-
formula.
Proof.Letϕ∈TeamLTLl(6)be ﬂat, and let >iψibe an equivalent formula given by
Theorem 10, where ψiareTeamLTLl-formulae. The following equivalences hold:
T|=lϕ⇔ ∀t∈T:{t}|=l>
iψi⇔ ∀t∈T:{t}|=l/logicalordisplay
iψi⇔T|=l/logicalordisplay
iψi
The ﬁrst equivalence follows from the above mentioned Theorem, and ﬂatness of ϕ. The
second equivalence follows, for it is easy to check that, for logics that have the empty team
property, >iand/logicalortext
iare interchangeable over singleton teams. The last equivalence follows
from the ﬂatness of TeamLTLl(Theorem 5). J
ICorollary 12. TeamLTLl(6)<TeamLTL( 6)
Proof.Letϕis aTeamLTLl(6)-formula. By Theorem 10, ϕcan be equivalently written as
a disjunction >iαiofTeamLTLl-formulae. Now, for each multiteam T,
support(T)|=lϕ⇔ support(T)|=l>
iαi⇔T|=>
iαi,
where the last equivalence is due to Theorem 8 and the fact that the formulae αiare ﬂat.
Hence, for any given TeamLTLl(6)-formula, the normal form formula >iαiis, in fact, an
equivalent TeamLTL( 6)formula, from which TeamLTLl(6)≤TeamLTL( 6)follows.
For showing the strict inclusion, we generalize the result from Example 6 and show that
forTeamLTL (6)formula G(p>q)there exists no equivalent TeamLTLl(6)formula. For a
contradiction, suppose that ϕ∈TeamLTLl(6)is equivalent with G(p>q). By Theorem 10,
we may assume that ϕis a disjunction >iαiofnTeamLTLl-formulae. Deﬁne ti:={p}i{q}ω
fori≤n+ 1. Now clearly{(1,ti)}|=G(p>q)and thus{ti}|=lϕ, for eachi. By the
semantics of 6this implies that for each ithere exists ji≤nsuch that{ti}|=lαji. Now
from the pigeonhole principle, there exists 1≤k < l≤n+ 1such thatjk=jl. Thus
{tk}|=lαjkand{tl}|=lαjk, from which{tk,tl}|=lαjkfollows, by ﬂatness of αjk. Thus
{tk,tl}|=lϕand{(1,tk),(1,tl)}|=G(p>q), which is clearly false. J
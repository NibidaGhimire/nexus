Counterexample Guided Abstraction Reﬁnement with Non-Reﬁned Abstractions
for Multi-Agent Path Finding
Pavel Surynek
Faculty of Information Technology, Czech Technical University in Prague
Th´akurova 9, 160 00 Praha 6, Czechia
pavel.surynek@ﬁt.cvut.cz
Abstract
Counterexample guided abstraction reﬁnement
(CEGAR) represents a powerful symbolic tech-
nique for various tasks such as model checking and
reachability analysis. Recently, CEGAR combined
with Boolean satisﬁability (SAT) has been applied
for multi-agent path ﬁnding (MAPF), a problem
where the task is to navigate agents from their start
positions to given individual goal positions so that
the agents do not collide with each other.
The recent CEGAR approach used the initial ab-
straction of the MAPF problem where collisions
between agents were omitted and were eliminated
in subsequent abstraction reﬁnements. We propose
in this work a novel CEGAR-style solver for MAPF
based on SAT in which some abstractions are de-
liberately left non-reﬁned. This adds the necessity
to post-process the answers obtained from the un-
derlying SAT solver as these answers slightly dif-
fer from the correct MAPF solutions. Non-reﬁning
however yields order-of-magnitude smaller SAT
encodings than those of the previous approach and
speeds up the overall solving process making the
SAT-based solver for MAPF competitive again in
relevant benchmarks.
Keywords: multi-agent pathﬁnding (MAPF), counterex-
ample example guided abstraction reﬁnement (CEGAR),
Boolean satisﬁability (SAT)
1 Introduction
Multi-agent path ﬁnding (MAPF) [Silver, 2005; Ryan, 2008;
Surynek, 2009; Wang and Botea, 2011; Sharon et al. , 2013 ]is
a task of ﬁnding non-conﬂicting paths for k2Nagents A=
fa1; a2; :::; a kgthat move in an undirected graph G= (V; E)
across its edges such that each agent reaches its goal vertex
from the given start vertex via its path. Starting conﬁgura-
tion of agents is deﬁned by a simple assignment s:A!V
and the goal conﬁguration is deﬁned by a simple assignment
g:A!V. A conﬂict between agents is usually deﬁned as
simultaneous occupancy of the same vertex by two or more
agents or as a traversal of an edge by agents in opposite direc-
tions. Although MAPF started as purely theoretical studies ofgraph pebbling and puzzle solving [Kornhauser et al. , 1984;
Ratner and Warmuth, 1986; Ratner and Warmuth, 1990 ], it
has grown into artiﬁcial intelligence mainstream topic with a
signiﬁcant impact on many ﬁelds including warehouse logis-
tics[Liet al. , 2020b ].
Many problems in robotics [Chud ´yet al. , 2020; Wen et
al., 2022; Gharbi et al. , 2009 ], urban trafﬁc optimization
[Atzmon et al. , 2019; Ho et al. , 2019 ], FPGA circuit de-
sign [Nery et al. , 2017 ], and computer games [Sigurdson et
al., 2018 ]can be regarded from the perspective of MAPF
as listed by various surveys including [Felner et al. , 2017;
Maet al. , 2017 ].
Particular aspect that is motivated by practice and makes
MAPF challenging is the need to ﬁnd the optimal solutions
with respect to some cumulative cost [Yu and LaValle, 2013 ].
Commonly used cumulative costs in MAPF are makespan
andsum-of-costs [Stern, 2019 ]. The makespan corresponds
to the length of the longest agent’s path. The sum-of-costs
is the sum of costs of individual paths which corresponds to
the sum of unit costs of actions, the wait actions including.
An example of MAPF problem and its sum-of-costs optimal
solution is shown in Figure 1.
 
path (r1) = 
[v1, v4, v7, v8, v9] 
Cost = 4  
 
path (r2) = 
[v3, v6, v5, v4, v7] 
Cost = 4  
 
SoC = 8  
 s(a1) = v1 
a1 
 a2 
v2 
s(a1) = v3 
v4 
 v5 
 v6 
g(a1) = v7 
v8 
 g(a1) = v9 
a1 
 a2 
v1 
v4 
v7 
v2 
v5 
v8 
v3 
v6 
v9 
Figure 1: Multi-agent path ﬁnding (MAPF) with agents a1anda2.
We address MAPF from the perspective of compilation
techniques that represent a major alternative to search-based
solvers [Silver, 2005; Wagner and Choset, 2011; Sharon et
al., 2013; Sharon et al. , 2015 ]for MAPF. Compilation-based
solvers reduce the input MAPF instance to an instance in a
different well established formalism for which an efﬁcient
solver exists. Such formalisms are for example constraint
programming (CSP) [Dechter, 2003; Ryan, 2010 ],Boolean
satisﬁability (SAT) [Biere et al. , 2021; Surynek, 2012 ], or
mixed integer linear programming (MILP) [Rader, 2010;
Lam et al. , 2019 ].
The basic compilation scheme for sum-of-costs opti-arXiv:2301.08687v1  [cs.AI]  20 Jan 2023mal MAPF solving has been introduced by the MDD-SAT
[Surynek et al. , 2016 ]solver that uses so called complete
models to compile MAPF instances into SAT (see Figure 2).
The target Boolean formula of the complete model is sat-
isﬁable if and only if the input MAPF has a solution of a
speciﬁed sum-of-costs. The complete model as introduced in
MDD-SAT consists of three group of constraints:
•Agent propagation constraints - these constraints en-
sure that if an agent appears in vertex vat time step t
then the agent appears in some neighbor of v(including
v) at time step t+ 1. The side effect of these constraints
is that the agent never disappears. Cost calculation and
bounding is done together with agent propagation.
•Path consistency constraints - these constrains ensure
that agents move along proper paths, that is, agents do
not multiply and do not appear spontaneously.
•Conﬂict elimination constraints - to ensure that agents
do not conﬂict with each other according to the MAPF
rules (vertex and edge conﬂict).
 
 
 
Agent 
Propagation  
Constraints  Solving  Answer  
Interpretation  
Solution  Path 
Consistency  
Constraints  Conflict  
Elimination  
Constraints  Complete Model Encoding  
Figure 2: Schematic diagram of the basic MAPF compilation with
complete model.
A signiﬁcant improvement over complete models in prob-
lem compilation for MAPF is the introduction of laziness via
incomplete models in the CSP-based LazyCBS [Gange et al. ,
2019 ], SAT-based SMT-CBS [Surynek, 2019 ], and MILP-
based BCP [Lam et al. , 2019 ]. These solvers use incomplete
models of MAPF where the conﬂict elimination constraints
are omitted for which equivalent solvability no longer holds,
but only the implication: if the MAPF instance is solvable
then the instance in the target formalism is solvable too.
The discrepancy between the original formulation of
MAPF and its compiled variant in the target formalism is
eliminated by abstraction reﬁnements similarly as it is done in
thecounterexample guided abstraction reﬁnement (CEGAR)
[Clarke et al. , 2000 ]approach for model checking (see Fig-
ure 4). Speciﬁcally in MAPF the counterexamples are repre-
sented by conﬂicts between agents and their reﬁnements cor-
respond to elimination of these conﬂicts.
1.1 Contribution
We further generalize the CEGAR approach for MAPF by
further omitting the path consistency constraints. Hence only
agent propagation constraints remain in the initial abstrac-
tion. In addition to this, in the abstraction reﬁnement we do
not try to reﬁne with respect to all the omitted constraints
(path consistency and conﬂict elimination). Instead we only
generate counterexamples for conﬂicts and reﬁne the conﬂicts
while path consistency remains non-reﬁned - the abstractionreﬁnement in our case is inherently incomplete. To mitigate
the impact of non-reﬁned path consistency constraints we add
a new step in the CEGAR compilation architecture in which
we post-process the answer from the SAT solver.
The omitted path consistency constraints lead to ﬁnding di-
rected acyclic sub-graphs (DAGs) that connects agents’ initial
and goal positions instead of proper paths. The desired path
for agents need to be extracted from the sub-graphs in the new
post-processing step.
Our contribution can be understood in a broader perspec-
tive as a generalization how problems are compiled. In
the classic approaches such as SATPlan [Kautz and Selman,
1992 ]the problem solution is read from the assignment of
decision variables directly. In our approach the assignment
of decision variables does not represent the problem solution
directly, but the solution needs to be extracted from the as-
signment by non-trivial process, though this process should
be fast (polynomial time) to keep the problem compilation
viable.
2 Background
One of the ﬁrst uses of problem compilation can be seen in
the SATPlan algorithm [Kautz and Selman, 1992; Kautz and
Selman, 1999 ]for classical planning [Ghallab et al. , 2004 ].
A Boolean formula that is satisﬁable if and only if a plan
of speciﬁed length exists is constructed and checked for sat-
isﬁability by the SAT solver. To guarantee ﬁnding a plan of
the minimum length, the SATPlan planner iteratively consults
formulae encoding the existence of a plan of length l0,l0+1,
l0+ 2,... where l0is a lower bound for the plan length, until
the ﬁrst satisﬁable formula is found.
Similar approach has been used in SAT-based solvers for
MAPF such as MDD-SAT [Surynek et al. , 2016 ]where the
SAT solver is consulted about the existence of a solution
for the given MAPF instance of speciﬁed sum-of-cost SoC .
To ensure ﬁnding sum-of-costs optimal solution for solvable
MAPF, MDD-SAT checks using the SAT solver existence of
solutions for SoC 0,SoC 0+ 1,SoC 0+ 2, ... until the ﬁrst
positive answer which due to monotonicity of existence of
solutions w.r.t. bounded sum-of-costs is guaranteed to corre-
spond to the optimal sum-of-cost.
2.1 The MAPF Encoding as SAT
The complete model for the sum-of-costs optimal MAPF
as SAT built-in the MDD-SAT solver uses Boolean deci-
sion variables inspired by direct encoding [Walsh, 2000 ]
andmulti-valued decision diagrams [Andersen et al. , 2007 ].
We brieﬂy summarize the complete model as introduced by
MDD-SAT.
The decision variables need to represent all possible paths
of agents such that their sum-of-costs is at most given value
SoC >0. Since it is possible for an agent to visit a single
vertex multiple times, a so-called time expansion [Surynek,
2017 ]of the underlying graph Gis constructed for each agent
denoted TEG i.
TEG iis deﬁned for a given maximum length of indi-
vidual agent’s path T2Nconsisting of T+ 1 copies
of vertices of Gcalled layers indexed by 0;1; :::; T , wheref(v1; t);(v2; t); :::;(vn; t)gare nodes of the t-th layer of
TEG i. The layers correspond to individual time-steps
and are interconnected by directed edges that model pos-
sible transitions of agents, that is there is a directed edge
[(vj; t);(vj0; t+ 1)] whenever there is an edge fvj; vj0g2E.
Directed edges [(vj; t);(vj0; t+ 1)] are added to model wait
actions of agents.
The following proposition establishes the correspondence
between the actual paths traveled by agents in G1and di-
rected paths in TEGs.
Proposition 1. Any path of length at most Tof agent aigoing
froms(ai)tog(ai)is represented by a directed path in TEG i
connecting (s(ai);0)and(g(ai); T).
Having the proposition, we can speak about a representa-
tion of agent’s path (trajectory) in TEG.
Since not all nodes (vj; t)ofTEG iare actually reachable
considering the maximum agent’s path length Tand its start
s(ai)and goal g(ai)because either vjis farther than tsteps
froms(ai)or farther than T tsteps from g(ai), such nodes
be can pruned from TEG iwithout compromising the repre-
sentation of all relevant paths. TED iafter pruning unreach-
able nodes is called a multi-valued decision diagram for agent
aiand is denoted MDD i(nodes and edges of MDD iare de-
noted MDD i:VandMDD i:Erespectively). Example MDD
is shown in Figure 3. The complete model for MAPF in the
MDD-SAT solver is derived from MDDs.
The decision variable denoted Xt
i;vjis introduced for each
node (vj; t)2MDD iand expresses that agent aiappears in
vertex vjat time step t2.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
s(a 1)=v1 
a1 
v2 
 v3 
v4 
 v5 
 v6 
v7 
 v8 
 v9=g(a 1) 
(v1,0) 
(v2,1) 
(v4,1) 
(v3,2) 
(v5,2) 
(v7,2) 
(v6,3) 
(v8,3) 
(v9,4) 
MDD 1 for T=4  
Figure 3: Multi-valued decision diagram for the path length T= 4.
The three groups of constraints expressed on top of the
Xt
i;vjvariables are as follows:
Agent Propagation Constraints
Xt
i;vj!_
j0j[(vj;t);(vj0;t+1)]2MDD i:EXt+1
i;vj0(1)
This constraint is introduced for each ai,vj, and tand
speciﬁes that agent must proceed to the next level in MDD.
1The proper terminology for agents’ paths should be trajectories
or just sequences of vertices as a vertex can visited multiple times
by the agent which does not correspond to the standard graph termi-
nology where a path is a simple sequence of vertices.
2Auxiliary variables Et
i;vj;vj0to express that agent aimoves
fromvjtovj0between time-steps tandt+ 1can be used as well,
but we will base our description only on the Xt
i;vjvariables as the
Et
i;vj;vj0variables are direct consequence of of the Xt
i;vjvariables:
Et
i;vj;vj0$Xt
i;vj^Xt+1
i;vj0.In addition, to this we account among these constraints also
calculation and bounding of the cost. For each time-step tin
MDD an auxiliary variable is introduced which is TRUE if
and only if the agent performed an action. The cost bound-
ing over auxiliary variables is carried out through cardinal-
ity constraints encoded as Boolean circuits into the formula
[Bailleux and Boufkhad, 2003; Silva and Lynce, 2007 ].
X0
i;s(ai)^^
jjvj6=s(ai):X0
i;vj(2)
XT
i;g(ai)^^
jjvj6=g(ai):XT
i;vj(3)
These equations are introduced for each agent aiand en-
sure that agent aistarts in vertex s(ai)at time-step 0 and
ﬁnished in its goal vertex g(ai)at time-step T.
Path Consistency ConstraintsX
jj(vj;t)2MDD i:VXt
i;vj= 1 (4)
This constraint is introduced for each aiandtand speciﬁes
that agent can appear in exactly one vertex at a time.
Conﬂict Elimination ConstraintsX
ij(vj;t)2MDD i:VXt
i;vj1 (5)
This constraint is introduced for each vjandtand speciﬁes
that at most one agent can reside in vertex vjat time t. The
constraint eliminates vertex conﬂicts, edge conﬂicts can be
eliminated analogously.
As some of the constraint are deﬁned by pseudo-Boolean
expression, proper translation to CNF is needed which most
notably concerns the at-most-one constraints [Chen, 2010;
Nguyen and Mai, 2015 ]. The combination of pair-wise en-
coding and sequential counter are used in the MDD-SAT and
SMT-CBS solvers.
The formula collecting the above constraints is being built
for the speciﬁc sum-of-costs SoC and is denotedF(SoC).
The completeness of the model encoded by F(SoC)can be
summarized as follows [Surynek et al. , 2016 ]:
Proposition 2. The input MAPF has a solution of the given
sum-of-costs SoC,F(SoC)is satisﬁable.
The core of the proof of the proposition is a correspon-
dence of satisfying assignments of F(SoC)and directed
paths in MDDs which in turn due to Proposition 1 estab-
lishes a correspondence between agents’ paths and satisfying
assignments ofF(SoC).
2.2 CEGAR for MAPF
The next step in compilation-based MAPF solving is rep-
resented by the integration of ideas from counterexample
guided abstraction and reﬁnement (CEGAR) [Clarke et al. ,
2000; Clarke, 2003 ]. The two representative solvers SMT-
CBS [Surynek, 2019 ]based on SAT and Lazy-CBS [Gange
et al. , 2019 ]based on CSP resolve conﬂicts between agents
as done in the CEGAR approach (though the authors of these
MAPF solvers do not explicitly mention CEGAR). 
Solving  Answer 
Interpretation  Abstraction Refinement  
Counterexample 
Generation  
no counterexamples  
(no conflicts ) counterexamples  
(conflicts ) exist 
Solution  Agent 
Propagation  
Constraints  Path 
Consistency  
Constraints  Conflic ts 
Elimination  
Constraints  
Initial Abstraction  Figure 4: Schematic diagram of counterexample guided abstrac-
tion reﬁnement (CEGAR) for MAPF. Conﬂicts between agents are
treated as counterexamples and eliminated in the abstraction reﬁne-
ment loop.
The general CEGAR approach for compilation-based
problem solving starts with a so called initial abstraction of
the problem instance being solved in some target formalism
such as SAT [Biere et al. , 2021 ]or CSP [Dechter, 2003 ]. The
initial abstraction do not model the input instance in the full
details. However still the initial abstraction is passed to the
solver for the target formalism despite the solver is not pro-
vided all the details needed to solve it. Then the solver will
come with some answer and since it could not take some de-
tails into account during the solving phase, the answer must
be checked, usually against full details of how the problem
instance is deﬁned. Two cases need to be distinguished at this
stage. If the provided answer matches the instance deﬁnition
then it is returned and the solving process ﬁnishes. Otherwise
the CEGAR solving process generates counterexample that
is determined by the mismatch between the provided answer
and the requirements the expected answer should satisfy. This
mismatch is usually represented by the violation of some con-
straints that were not expressed in the abstraction. Then the
solving process continues with a so called abstraction reﬁne-
ment in which the abstraction is augmented to eliminate the
counterexample and the solving process continues with the
next iteration of (now reﬁned) abstraction solving.
To keep the problem solving in the CEGAR approach
sound, the abstractions must fulﬁll certain basic requirements
such as if the problem instance is solvable then any of its ab-
stractions should be solvable as well (the opposite does not
hold: the solvable abstraction does not necessarily imply that
the input instance is solvable).
The CEGAR approach for MAPF as implemented in SMT-
CBS and Lazy-CBS is illustrated in Figure 4. The initial
abstraction in both algorithms models existence of paths for
individual agents but omits the requirement to avoid con-
ﬂicts between agents. The abstraction reﬁnement hence must
check the answers of the target solver against the deﬁnition of
conﬂicts in MAPF. If a conﬂict is found then the abstraction
is reﬁned so that the conﬂict is eliminated.
The abstraction reﬁnement for a conﬂict, say between
agents aiandajin vertex vat time-step t, is done in the
case of CSP-based Lazy-CBS by adding a fresh ﬁnite domain
variable pv;t2Athat indicates what agent occupies vertex
vat time step t. The need to assign the variable pv;ta single
value eliminates the conﬂict.The SAT-based SMT-CBS algorithm reﬁnes the conﬂict by
adding a new constraint over the existing Boolean variables
that forbids the occupation of vertex vat time-step tby agents
aiandajsimultaneously::Xt
i;v_:Xt
j;v.
The edge conﬂicts and potentially different kinds of con-
ﬂicts in MAPF and its variants [Andreychuk et al. , 2019;
Bonnet et al. , 2018 ]can be treated analogously.
The abstraction at any point in SMT-CBS and Lazy-CBS
forms a so called incomplete model for MAPF. Unlike the
complete model from MDD-SAT, the equivalent-solvability
of the model in the target formalism and the input MAPF in-
stance does not hold for the incomplete MAPF model. Let
us express this property formally for the SAT-based formula-
tion. LetF0(SoC)be the formula obtained at some stage in
CEGAR loop of SMT-CBS used for answering the question
whether there is a solution of the input MAPF instance of
the given sum-of-costs SoC . Then the following proposition
holds [Surynek, 2019 ]:
Proposition 3. The input MAPF has a solution of the given
sum-of-costs SoC)F0(SoC)is satisﬁable.
The incompleteness property also represents the require-
ment that keeps the CEGAR approach sound for MAPF as it
says thatF0(SoC)is an abstraction for MAPF.
3 Non-Reﬁned Abstractions in MAPF
We are going further in the CEGAR architecture of the MAPF
solver. In addition to conﬂict elimination constrains we also
omit path consistency constraints in the initial abstraction.
Moreover we never make any reﬁnement with respect to the
omitted path consistency constraints - the corresponding ab-
straction remains non-reﬁned .
We call the new algorithm based on the non-reﬁned ab-
stractions Non-Reﬁned SAT orNRF-SAT in short. The
pseudo-code of NRF-SAT is shown as Algorithm 1.
The high-level function of the algorithm NRF-SAT-
MAPF() is analogous to SATPlan or MDD-SAT main loop
where search for the optimal sum-of-costs is done by trying
to answer questions whether there is a solution of MAPF of
a speciﬁed sum-of-costs SoC (lines 5-6). To answer these
questions, the algorithm uses low level function NRF-SAT-
Bounded() that implements the CEGAR architecture with
non-reﬁned abstractions as shown in Figure 5.
As the satisfying assignment of formula F00representing
the incomplete model in NRF-SAT does not correspond to
paths for agents (line 15) further post-processing of the SAT
solver’s answer is needed (line 16). As we will see later,
the answer obtained directly from the SAT solver can be in-
terpreted as special directed acyclic graph (DAG) that con-
nects agent’s start vertex with its goal vertex. Hence the post-
processing consists in extraction of proper agent’s path from
the DAG.
The rest of the low-level loop (lines 17-22) represents ab-
straction reﬁnements with respect to conﬂicts between agents.
Let us note that conﬂicts being discovered are collected and
reused in the next iteration of the high-level loop.
The NRF-SAT algorithm is sound and optimal, more pre-
cisely it returns a sum-of-costs optimal solution for a solvable 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Solving  Answer 
Interpretation  Counterexample 
Generation  Answer  
Post -processing  Incomplete Abstraction Refinement  
no counterexamples  
(no conflicts ) counterexamples  
(conflicts ) exist 
Solution  Agent 
Propagation  
Constraints  Conflict  
Elimination  
Constraints  
Initial Abstraction  Figure 5: Schematic diagram of CEGAR problem solver for MAPF
with non-reﬁned abstractions.
input MAPF instance. The following series of propositions
shows the claim.
Deﬁnition 1. DAG iis a directed acyclic sub-graph of
MDD isuch that (g(ai); T)2DAG i:Vand there exists a
directed path from any (vj; t)2DAG i:Vto(g(ai); T).
Proposition 4. The interpretation of satisfying assignment
ofF00(SoC)at any stage of the NRF-SAT algorithm corre-
sponds to DAG isuch that (s(ai);0)2DAG i:V.
Proof. Assume that Boolean decision variables of Xt
i;vjare
set to TRUE to reﬂect the choice of vertices in MDD iby a
given DAG i. Then the agent propagation constraints (1) and
(3) are satisﬁed since they directly correspond to existence of
paths towards (g(ai); T)from any node selected by DAG i
which is satisﬁed by the deﬁnition of DAG i. Conversely,
any assignment of Boolean decision variables that satisﬁes
constraints (1) and (3) corresponds to DAG isince any setting
ofXt
i;vjtoTRUE must be propagated via (1) and (3) towards
XT
i;g(ai). In addition to this, the constraint (2) ensures that
(s(ai);0)2DAG i:V.
The immediate corollary of Proposition 4 and the deﬁnition
ofDAG iis as follows:
Corollary 1. There exists a directed path connecting
(s(ai);0)and(g(ai); T)inDAG ifor each agent aiobtained
from satisfying assignment of F00(SoC).
This directed path will be extracted from the SAT solver
answer during the answer post-processing step as illustrated
in Figure 6.
Additional constraints that bound the cost and those that
eliminate conﬂicts included during abstraction reﬁnements
restrict the set of DAGs that can correspond to satisfying as-
signments ofF00(SoC).
The important property of DAG ithat directly follows from
its deﬁnition is that a path for agent aiof length Tgoing from
its start vertex s(ai)to its goal g(ai)can be represented as a
DAG i(we only add time indices to vertices visited by the
agent along the path to obtain the DAG i). HenceF00(SoC)
is an incomplete model (an abstraction) for MAPF:
Proposition 5. The input MAPF has a solution of the given
sum-of-costs SoC)F00(SoC)is satisﬁable.
The above propositions establish soundness of the NRF-
SAT algorithm. In other words, if the algorithm terminatesAlgorithm 1: NRF-SAT: MAPF solving via CEGAR
with non-reﬁned abstractions.
1NRF-SAT-MAPF(M= (G; A; s; g ))
2 SoC lower-Bound(M)
3 conicts ;
4 while TRUE do
5 (paths ;conicts ) 
6 NRF-SAT-Bounded( M,SoC ,conicts )
7 ifpaths6=UNSAT then
8 return paths
9 SoC SoC + 1
10NRF-SAT-Bounded( M,SoC ,conicts )
11F00 build-Initial-Abstraction( M,SoC ,conicts )
12 while TRUE do
13 assignment consult-SAT-Solver( F00)
14 ifassignment6=UNSAT then
15 DAGs interpret(M,assignment )
16 paths extract-Paths(M,DAGs )
17 conicts0 validate(M,paths )
18 ifconicts0=;then
19 return (paths ;conicts )
20 foreachc2conicts0do
21 F00 F00[eliminate-Conﬂict( c)
22 conicts conicts[conicts0
23 return (UNSAT ,conicts )
and returns an answer then it is a valid MAPF solution. How-
ever the termination needs a separate investigation.
Proposition 6. The abstraction reﬁnement loop for a speci-
ﬁedSoC is executed by the NRF-SAT algorithm ﬁnitely many
times.
Proof. Each iteration of the abstraction reﬁnement loop cor-
responds to a counterexample, a conﬂict between a pair of
agents. This conﬂict appears between two paths extracted
from a pair of DAGs say DAG iandDAG j. These two spe-
ciﬁc DAGs cannot be interpreted from the satisfying assign-
ment ofF00(SoC)again in any of the next iterations of the
abstraction reﬁnement loop since the conﬂict elimination con-
straint forbids them to appear simultaneously, either DAG ior
DAG jmust be different. Since there is ﬁnitely many pairs of
DAGs DAG iandDAG jthe algorithm either forbids them all
during the reﬁnements or terminates earlier.
We are now ready to state the main theoretical property of
the NRF-SAT algorithm.
Theorem 1. The NRF-SAT algorithm returns sum-of-costs
optimal solution for a solvable input MAPF instance.
Proof. For a solvable MAPF instance, the NRF-SAT ﬁnds
the ﬁrst sum-of-costs SoC for which the abstraction reﬁne-
ment loop ﬁnishes with a solution since all previous loops are
guaranteed to terminate due to Proposition 6. Due to mono-
tonicity of solvability of bounded MAPF with respect to the
sum-of-costs, this solution is optimal. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 (v2,1) (v3,2) 
(v1,0) (v6,3) 
(v5,2) (v9,4) 
(v4,1) 
(v7,2) (v8,3) SAT solver answer , DAG i 
(v2,1) (v3,2) 
(v1,0) (v6,3) 
(v5,2) (v9,4) 
(v4,1) 
(v7,2) (v8,3) after post -processing  Figure 6: Post-processing step in which path is extracted from DAG
answered by the SAT solver.
4 Experimental Evaluation
We performed an experimental evaluation of NRF-SAT on
a number of MAPF benchmarks from movingai.com
[Sturtevant, 2012 ]. We compared NRF-SAT against SAT-
based SMT-CBS [Surynek, 2019 ]and CSP-based LazyCBS
[Gange et al. , 2019 ]which are the solvers using similar
compilation-based approach to MAPF.
4.1 Benchmarks and Setup
We implemented NRF-SAT in C++ via reusing the code of
the original implementation of SMT-CBS. Both SAT-based
MAPF solvers are built on top the Glucose 3 SAT solver [Au-
demard and Simon, 2009; Audemard and Simon, 2018 ]still
ranking among top performing SAT solvers according to rel-
evant competitions [Froleyks et al. , 2021 ]. The extraction of
agent’s path from DAG is implemented as a simple breadth-
ﬁrst search.
The important feature of the Glucose SAT solver is that it
provides an interface for adding clauses incrementally that is
employed during abstraction reﬁnements. After reﬁning the
formula being answered by the SAT solver with new clauses,
the solving process does not need to start from scratch. In-
stead the learned state of the solver is utilized in its run after
the formula reﬁnement which usually speeds up the process.
As of LazyCBS, we used its original implementation in
C++. LazyCBS is built on top of the Geas CSP solver that
supports lazy clause generation [Stuckey, 2010 ], a feature
used by LazyCBS to eliminate MAPF conﬂicts lazily.
To obtain instances of various difﬁculties we varied the
number of agents from 1 to K, where Kis the maximum
number of agents for which at least one solver is able to
solve some instance in the given time limit of 300 seconds
(5 minutes). Kvaried from approximately 80 agents to 120
agents depending on the benchmark map. For each number of
agents, we generated 25 instances according to random sce-
narios provided on movingai.com (for each benchmark
map we generated 25Kinstances, i.e. approximately 2500
MAPF instances per map).
All experiments were run on a system consisting of Xeon
2.8 GHz cores, 32 GB RAM per solver instance, running
Ubuntu Linux 183.
4.2 The Effect of Non-Reﬁning
We investigated the effect of non-reﬁning w.r.t. the path con-
sistency constraints in SAT-based solvers. The comparison of
3To provide reproducibility of presented results the
complete source code of NRF-SAT is available on
https://github.com/surynek/boOX .the SMT-CBS and NRF-SAT solvers in terms of the number
of clauses being generated along the entire solving process is
shown in Figure 8 (this comparison is not relevant for Lazy-
CBS, hence it is not included in the test).
The table shows the median number of clauses being gen-
erated by SMT-CBS for speciﬁc map and selected number of
agents and the number of clauses generated by NRF-SAT for
the same instance. In this test, small to medium sized maps
have been used: empty-16-16 ,random-32-32-10 ,
androom-64-64-16 .
We can observe that NRF-SAT generates signiﬁcantly
fewer clauses than SMT-CBS. This trend is even more pro-
nounced as the number of agents increases. Order of mag-
nitude fewer clauses are generated by NRF-SAT for 60 and
more agents on the presented benchmarks.
The explanation of this result that path consistency con-
straints encompass many at-most-one constraints that yields
many clauses in most of its SAT representations [Nguyen and
Mai, 2015 ].
We also report the total number of abstraction reﬁnements
for the same set of instances as reported for the number of
clauses in Figure 8. Surprisingly non-reﬁning often leads to
a signiﬁcant reduction of the number of abstraction reﬁne-
ments. Although this not a rule as sometimes increase in the
number of abstractions in contrast to SMT-CBS can be ob-
served in NRF-SAT, the reduction prevails.
One reason of this difference is that the choice of ﬁnal
paths is done by the SAT solver in SMT-CBS while in NRF-
SAT the ﬁnal choice is made by the path-processing proce-
dure that extracts paths from DAGs in a ﬁxed order which
seems to be more suitable for abstraction reﬁnements.
In addition to this, we tested the impact of leaving the ab-
straction non-reﬁned on the overall performance of the SAT-
based MAPF solver. Runtime results comparing SMT-CBS
and NRF-SAT on the same set of maps: empty-16-16 ,
random-32-32-10 , and room-64-64-16 is shown in
Figure 7.
The runtime results are presented using cactus plots often
used to present the results of SAT competitions [Balyo et al. ,
2017 ], that is runtimes for all instances are sorted so the x-th
result along the horizontal axis represents the runtime for the
x-th fastest solved instance by the given MAPF solver. The
lower plot for the solver means better performance.
Instances with up to approximately 70 agents for
empty-16-16 , 110 agents for random-32-32-10 , and
60 agents for room-64-64-16 were solved by the solvers
in the given time limit. SMT-CBS solved 1564, 2120,
and 1152 and NRF-SAT solved 1633, 2266, and 1203
in total for empty-16-16 ,random-32-32-10 , and
room-64-64-16 respectively, that is, signiﬁcantly more
instances for NRF-SAT. It need to be taken into account that
the instances that were additionally solved by the NRF-SAT
solver rank among the difﬁcult ones.
We can observe in Figure 7 that NRF-SAT dominates in
harder instances while in easier instances SMT-CBS is some-
times better (most prominently on empty-16-16 ).
The explanation for the better performance of NRF-SAT
is twofold. First, it generates signiﬁcantly smaller formulae
across entire abstraction reﬁnement process hence the pro-0,010,11101001000
0 200 400 600 800 1000 1200 1400Runtime (seconds)
InstanceRuntime | empty -16-16
NRF-SAT
SMT-CBS
0,010,11101001000
0 250 500 750 1000 1250 1500 1750 2000Runtime (seconds)
InstanceRuntime| random -32-32-10
NRF-SAT
SMT-CBS
0,010,11101001000
0 200 400 600 800 1000Runtime (seconds)
InstanceRuntime | room -64-64-16
NRF-SAT
SMT-CBS
Figure 7: Runtime comparison of two SAT-based MAPF solvers NRF-SAT and SMT-CBS. Cactus plots of runtimes for the solvers are shown
(lower plot means better performance).
Refinements |clauses 
SMT -CBS  
NRF-SAT empty -16-16 random -32-32-10 room -64-64-16 
Number of agents  
10 2 
2    1.397  
       468 1 
2 6.018  
1.459  2 
2 6.380  
1.905  
20 2 
2 2.571  
919 10 
6 44.690  
8.560  3 
2 14.348  
4.445  
30 22 
17 46.412  
8.239  18 
14 63.672  
12.564  8 
7 273.997  
40.489  
40 23 
22 271.103  
36.146  9 
10 81.869  
16.327  8 
8 349.156  
52.137  
50 24 
22 510.689  
65.999  17 
15 1.373.944  
162.590  14 
14 3.644.645  
384.442  
60 44 
32 4.042.490  
491.733  42 
32 14.094.029  
1.498.631  54 
45 17.694.257  
1.697.465  
 
Figure 8: The total number of clauses and reﬁnements of SAT-based
solvers SMT-CBS and NRF-SAT.
cessing time itself is shorter. Second, the resulting formula
with omitted path consistency constraints is easier to solve by
the SAT solver which coupled with the fact the total number
of abstraction reﬁnements tends to be smaller in NRF-SAT
leads to overall better performance.
4.3 Competitive Comparison
The competitive comparison of NRF-SAT and LazyCBS in
terms of runtime is shown in Figure 9. This comparison
is focused on benchmarks that were identiﬁed by previous
studies as those where compilation-based MAPF solvers per-
form well [Kaduri et al. , 2021 ]. These benchmarks include
those on mazes, city maps, and game maps. The representa-
tives we selected for presentation are: maze-32-32-4 (a
maze map), ost003d (a game map), Berlin 1256 (a
city map). Additional experiments we made on other maps
from these categories yield similar results.
Again, the runtime results are presented using cactus
plots. The summary of the results is that LazyCBS solved
527, 1193, and 1599 while NRF-SAT solved 582, 1335,
and 2321 in total for maze-32-32-4 ,ost003d , and
Berlin 1256 respectively, that is NRF-SAT solver signif-
icantly more instances where again these extra instances rank
among difﬁcult ones.
Close look at the results reveals that the general trend is
that LazyCBS has slightly sharper increase in runtimes as in-
stances are getting harder. This results in reaching the time-out by LazyCBS sooner while NRF-SAT can still solve the
instances within the time limit. The advantage of NRF-SAT
tends to be more signiﬁcant as the size of the map grows
which is surprising for the SAT-based MAPF solvers that are
notorious to struggle on large maps.
The explanation for the better performance of NRF-SAT
on the presented benchmarks is that non-reﬁning in the CE-
GAR architecture is especially helpful when dealing with
large maps where it leads to signiﬁcantly smaller formulae
than in previous SAT-based solvers. Moreover this combined
with the rest of the CEGAR architecture leads to a competi-
tive solver.
There are many other benchmarks where LazyCBS per-
forms signiﬁcantly better than NRF-SAT. Hence we do not
claim that NRF-SAT is state-of-the-art solver for MAPF.
However, as we report, there are several important domains
where NRF-SAT achieves competitive performance which
shows the importance of non-reﬁned abstractions. Moreover,
it is needed to take into account that NRF-SAT is in fact a
vanilla solver for MAPF with no speciﬁc MAPF techniques
such as symmetry breaking [Liet al. , 2020a ]orrectangle rea-
soning [Liet al. , 2019 ]being used. Hence there is a potential
that the SAT-based MAPF solvers can return among top per-
forming MAPF solvers at least in certain domains and the
CEGAR architecture with non-reﬁned abstractions can con-
tribute to this.
5 Conclusion
We proposed a novel solver called NRF-SAT for MAPF based
on the CEGAR architecture and Boolean satisﬁability that
uses non-reﬁned abstraction during the solving process.
Unlike previous uses of CEGAR in MAPF we not only
eliminate conﬂicts between agents via abstraction reﬁne-
ments but we also further strengthen the initial abstraction.
Particularly our new solver NRF-SAT omits large group of
constraints in the initial abstraction and never makes reﬁne-
ments with respect to them which as we show can be miti-
gated by a fast post-processing step.
From a broader perspective, we not only apply the CEGAR
architecture with non-reﬁned abstractions for compilation-
based MAPF solving but we also generalize the architecture
itself. This generalization consists in ﬁnding a solution of a0,0010,010,11101001000
0 100 200 300 400Runtime (seconds)
InstanceRuntime | maze -32-32-4
NRF-SAT
LazyCBS
0,010,11101001000
0 200 400 600 800 1000 1200 1400Runtime (seconds)
InstanceRuntime | ost003d
NRF-SAT
LazyCBS
0,010,11101001000
0 250 500 750 1000 1250 1500 1750 2000 2250Runtime (seconds)
InstanceRuntime | Berlin_1_256
NRF-SAT
LazyCBS
Figure 9: Runtime comparison between NRF-SAT and LazyCBS. Cactus plots of runtimes for the solvers are shown (lower plot is better).
different, more general task, than is the original one using the
target formalism, rather than ﬁnding a solution of the original
task using the target formalism directly.
Acknowledgments
This research has been supported by GA ˇCR - the Czech Sci-
ence Foundation, grant registration number 22-31346S.
References
[Andersen et al. , 2007 ]Henrik Reif Andersen, Tarik Hadzic,
John N. Hooker, and Peter Tiedemann. A constraint store
based on multivalued decision diagrams. In Principles
and Practice of Constraint Programming - CP 2007, Pro-
ceedings , volume 4741 of LNCS , pages 118–132. Springer,
2007.
[Andreychuk et al. , 2019 ]Anton Andreychuk, Konstantin S.
Yakovlev, Dor Atzmon, and Roni Stern. Multi-agent
pathﬁnding with continuous time. In Proceedings of the
Twenty-Eighth International Joint Conference on Artiﬁcial
Intelligence, IJCAI 2019 , pages 39–45. ijcai.org, 2019.
[Atzmon et al. , 2019 ]Dor Atzmon, Amit Diei, and Daniel
Rave. Multi-train path ﬁnding. In Pavel Surynek and
William Yeoh, editors, Proceedings of the Twelfth Interna-
tional Symposium on Combinatorial Search, SOCS 2019,
Napa, California, 16-17 July 2019 , pages 125–129. AAAI
Press, 2019.
[Audemard and Simon, 2009 ]Gilles Audemard and Laurent
Simon. Predicting learnt clauses quality in modern SAT
solvers. In Craig Boutilier, editor, IJCAI 2009, Proceed-
ings of the 21st International Joint Conference on Artiﬁ-
cial Intelligence, Pasadena, California, USA, July 11-17,
2009 , pages 399–404, 2009.
[Audemard and Simon, 2018 ]Gilles Audemard and Laurent
Simon. On the glucose SAT solver. Int. J. Artif. Intell.
Tools , 27(1):1840001:1–1840001:25, 2018.
[Bailleux and Boufkhad, 2003 ]Olivier Bailleux and Yacine
Boufkhad. Efﬁcient CNF encoding of boolean cardinal-
ity constraints. In Francesca Rossi, editor, Principles and
Practice of Constraint Programming - CP 2003, 9th Inter-
national Conference, CP 2003, Kinsale, Ireland, Septem-
ber 29 - October 3, 2003, Proceedings , volume 2833ofLecture Notes in Computer Science , pages 108–122.
Springer, 2003.
[Balyo et al. , 2017 ]Tom´as Balyo, Marijn J. H. Heule, and
Matti J ¨arvisalo. SAT competition 2016: Recent develop-
ments. In Proceedings of the Thirty-First AAAI Conference
on Artiﬁcial Intelligence, February 4-9, 2017, San Fran-
cisco, California, USA , pages 5061–5063. AAAI Press,
2017.
[Biere et al. , 2021 ]A. Biere, M. Heule, and H. van Maaren.
Handbook of Satisﬁability: Second Edition . Frontiers in
Artiﬁcial Intelligence and Applications. IOS Press, 2021.
[Bonnet et al. , 2018 ]´Edouard Bonnet, Tillmann Miltzow,
and Pawel Rzazewski. Complexity of token swapping and
its variants. Algorithmica , 80(9):2656–2682, 2018.
[Chen, 2010 ]Jingchao Chen. A new sat encoding of the at-
most-one constraint. In Proceedings of the Tenth Interna-
tional Workshop of Constraint Modelling and Reformula-
tion, 2010.
[Chud ´yet al. , 2020 ]J´an Chud ´y, Nestor Popov, and Pavel
Surynek. Deployment of multi-agent pathﬁnding on a
swarm of physical robots centralized control via reﬂex-
based behavior. In Proceedings of the International Con-
ference on Robotics, Computer Vision and Intelligent Sys-
tems, ROBOVIS 2020, Budapest, Hungary, November 4-6,
2020 , pages 28–38. SCITEPRESS, 2020.
[Clarke et al. , 2000 ]Edmund M. Clarke, Orna Grum-
berg, Somesh Jha, Yuan Lu, and Helmut Veith.
Counterexample-guided abstraction reﬁnement. In Com-
puter Aided Veriﬁcation, 12th International Conference,
CAV 2000, Proceedings , volume 1855 of LNCS , pages
154–169. Springer, 2000.
[Clarke, 2003 ]Edmund M. Clarke. Sat-based counterexam-
ple guided abstraction reﬁnement in model checking. In
Automated Deduction - CADE-19, 19th International Con-
ference on Automated Deduction, Proceedings , volume
2741 of LNCS , page 1. Springer, 2003.
[Dechter, 2003 ]Rina Dechter. Constraint processing . Else-
vier Morgan Kaufmann, 2003.
[Felner et al. , 2017 ]Ariel Felner, Roni Stern, Solomon Eyal
Shimony, Eli Boyarski, Meir Goldenberg, Guni Sharon,Nathan R. Sturtevant, Glenn Wagner, and Pavel Surynek.
Search-based optimal solvers for the multi-agent pathﬁnd-
ing problem: Summary and challenges. In Proceedings
of the Tenth International Symposium on Combinatorial
Search, SOCS 2017 , pages 29–37. AAAI Press, 2017.
[Froleyks et al. , 2021 ]Nils Froleyks, Marijn Heule, Markus
Iser, Matti J ¨arvisalo, and Martin Suda. SAT competition
2020. Artif. Intell. , 301:103572, 2021.
[Gange et al. , 2019 ]Graeme Gange, Daniel Harabor, and
Peter J. Stuckey. Lazy CBS: implicit conﬂict-based
search using lazy clause generation. In Proceedings of
the Twenty-Ninth International Conference on Automated
Planning and Scheduling, ICAPS 2018 , pages 155–162.
AAAI Press, 2019.
[Ghallab et al. , 2004 ]Malik Ghallab, Dana S. Nau, and
Paolo Traverso. Automated planning - theory and prac-
tice. Elsevier, 2004.
[Gharbi et al. , 2009 ]Mokhtar Gharbi, Juan Cort ´es, and
Thierry Sim ´eon. Roadmap composition for multi-arm sys-
tems path planning. In 2009 IEEE/RSJ International Con-
ference on Intelligent Robots and Systems, October 11-15,
2009, St. Louis, MO, USA , pages 2471–2476. IEEE, 2009.
[Hoet al. , 2019 ]Florence Ho, Ana Salta, R ´uben Geraldes,
Artur Goncalves, Marc Cavazza, and Helmut Prendinger.
Multi-agent path ﬁnding for UA V trafﬁc management. In
Proceedings of the 18th International Conference on Au-
tonomous Agents and MultiAgent Systems, AAMAS ’19,
Montreal, QC, Canada, May 13-17, 2019 , pages 131–
139. International Foundation for Autonomous Agents and
Multiagent Systems, 2019.
[Kaduri et al. , 2021 ]Omri Kaduri, Eli Boyarski, and Roni
Stern. Experimental evaluation of classical multi agent
path ﬁnding algorithms. In Hang Ma and Ivan Serina, ed-
itors, Proceedings of the Fourteenth International Sympo-
sium on Combinatorial Search, SOCS 2021, Virtual Con-
ference [Jinan, China], July 26-30, 2021 , pages 126–130.
AAAI Press, 2021.
[Kautz and Selman, 1992 ]Henry A. Kautz and Bart Selman.
Planning as satisﬁability. In 10th European Conference
on Artiﬁcial Intelligence, ECAI, 1992. Proceedings , pages
359–363. John Wiley and Sons, 1992.
[Kautz and Selman, 1999 ]Henry A. Kautz and Bart Selman.
Unifying sat-based and graph-based planning. In Proceed-
ings of the Sixteenth International Joint Conference on
Artiﬁcial Intelligence, IJCAI 99 , pages 318–325. Morgan
Kaufmann, 1999.
[Kornhauser et al. , 1984 ]Daniel Kornhauser, Gary L.
Miller, and Paul G. Spirakis. Coordinating pebble motion
on graphs, the diameter of permutation groups, and
applications. In 25th Annual Symposium on Foundations
of Computer Science, West Palm Beach, Florida, USA,
24-26 October 1984 , pages 241–250. IEEE Computer
Society, 1984.
[Lam et al. , 2019 ]Edward Lam, Pierre Le Bodic,
Daniel Damir Harabor, and Peter J. Stuckey. Branch-and-
cut-and-price for multi-agent pathﬁnding. In Proceedingsof the Twenty-Eighth International Joint Conference on
Artiﬁcial Intelligence, IJCAI 2019 , pages 1289–1296.
ijcai.org, 2019.
[Liet al. , 2019 ]Jiaoyang Li, Ariel Felner, Eli Boyarski,
Hang Ma, and Sven Koenig. Improved heuristics for multi-
agent path ﬁnding with conﬂict-based search. In Proceed-
ings of the Twenty-Eighth International Joint Conference
on Artiﬁcial Intelligence, IJCAI 2019, Macao, China, Au-
gust 10-16, 2019 , pages 442–449. ijcai.org, 2019.
[Liet al. , 2020a ]Jiaoyang Li, Graeme Gange, Daniel Hara-
bor, Peter J. Stuckey, Hang Ma, and Sven Koenig. New
techniques for pairwise symmetry breaking in multi-agent
path ﬁnding. In Proceedings of the Thirtieth Interna-
tional Conference on Automated Planning and Schedul-
ing, Nancy, France, October 26-30, 2020 , pages 193–201.
AAAI Press, 2020.
[Liet al. , 2020b ]Jiaoyang Li, Andrew Tinka, Scott Kiesel,
Joseph W. Durham, T. K. Satish Kumar, and Sven Koenig.
Lifelong multi-agent path ﬁnding in large-scale ware-
houses. In Proceedings of the 19th International Confer-
ence on Autonomous Agents and Multiagent Systems, AA-
MAS ’20 , pages 1898–1900. International Foundation for
Autonomous Agents and Multiagent Systems, 2020.
[Maet al. , 2017 ]Hang Ma, Sven Koenig, Nora Ayanian,
Liron Cohen, Wolfgang H ¨onig, T. K. Satish Kumar,
Tansel Uras, Hong Xu, Craig A. Tovey, and Guni Sharon.
Overview: Generalizations of multi-agent path ﬁnding to
real-world scenarios. CoRR , abs/1702.05515, 2017.
[Nery et al. , 2017 ]Alexandre Solon Nery, Alexandre
da Costa Sena, and Leandro S. Guedes. Efﬁcient
pathﬁnding co-processors for fpgas. In 2017 International
Symposium on Computer Architecture and High Perfor-
mance Computing Workshops, SBAC-PAD Workshops,
Campinas, Brazil, October 17-20, 2017 , pages 97–102.
IEEE Computer Society, 2017.
[Nguyen and Mai, 2015 ]Van-Hau Nguyen and Son Thai
Mai. A new method to encode the at-most-one constraint
into SAT. In Proceedings of the Sixth International Sympo-
sium on Information and Communication Technology, Hue
City, Vietnam, December 3-4, 2015 , pages 46–53. ACM,
2015.
[Rader, 2010 ]D.J. Rader. Deterministic Operations Re-
search: Models and Methods in Linear Optimization . Wi-
ley, 2010.
[Ratner and Warmuth, 1986 ]Daniel Ratner and Manfred K.
Warmuth. Finding a shortest solution for the N x N ex-
tension of the 15-puzzle is intractable. In Proceedings
of the 5th National Conference on Artiﬁcial Intelligence.
Philadelphia, PA, USA, August 11-15, 1986. Volume 1:
Science , pages 168–172. Morgan Kaufmann, 1986.
[Ratner and Warmuth, 1990 ]Daniel Ratner and Manfred K.
Warmuth. Nxn puzzle and related relocation problem. J.
Symb. Comput. , 10(2):111–138, 1990.
[Ryan, 2008 ]Malcolm Ross Kinsella Ryan. Exploiting sub-
graph structure in multi-robot path planning. J. Artif. In-
tell. Res. , 31:497–542, 2008.[Ryan, 2010 ]Malcolm Ryan. Constraint-based multi-robot
path planning. In IEEE International Conference on
Robotics and Automation, ICRA 2010 , pages 922–928.
IEEE, 2010.
[Sharon et al. , 2013 ]Guni Sharon, Roni Stern, Meir Golden-
berg, and Ariel Felner. The increasing cost tree search for
optimal multi-agent pathﬁnding. Artif. Intell. , 195:470–
495, 2013.
[Sharon et al. , 2015 ]Guni Sharon, Roni Stern, Ariel Felner,
and Nathan R. Sturtevant. Conﬂict-based search for op-
timal multi-agent pathﬁnding. Artif. Intell. , 219:40–66,
2015.
[Sigurdson et al. , 2018 ]Devon Sigurdson, Vadim Bulitko,
William Yeoh, Carlos Hern ´andez, and Sven Koenig.
Multi-agent pathﬁnding with real-time heuristic search. In
2018 IEEE Conference on Computational Intelligence and
Games, CIG 2018, Maastricht, The Netherlands, August
14-17, 2018 , pages 1–8. IEEE, 2018.
[Silva and Lynce, 2007 ]Jo˜ao P. Marques Silva and In ˆes
Lynce. Towards robust CNF encodings of cardinality
constraints. In Christian Bessiere, editor, Principles and
Practice of Constraint Programming - CP 2007, 13th In-
ternational Conference, CP 2007, Providence, RI, USA,
September 23-27, 2007, Proceedings , volume 4741 of Lec-
ture Notes in Computer Science , pages 483–497. Springer,
2007.
[Silver, 2005 ]David Silver. Cooperative pathﬁnding. In Pro-
ceedings of the First Artiﬁcial Intelligence and Interactive
Digital Entertainment Conference , pages 117–122. AAAI
Press, 2005.
[Stern, 2019 ]Roni Stern. Multi-agent path ﬁnding - an
overview. In Artiﬁcial Intelligence - 5th RAAI Summer
School, Russia, 2019, Tutorial Lectures , volume 11866 of
LNCS , pages 96–115. Springer, 2019.
[Stuckey, 2010 ]Peter J. Stuckey. Lazy clause generation:
Combining the power of SAT and CP (and mip?) solving.
InIntegration of AI and OR Techniques in Constraint Pro-
gramming for Combinatorial Optimization Problems, 7th
International Conference, CPAIOR 2010, Bologna, Italy,
June 14-18, 2010. Proceedings , volume 6140 of Lecture
Notes in Computer Science , pages 5–9. Springer, 2010.
[Sturtevant, 2012 ]Nathan R. Sturtevant. Benchmarks for
grid-based pathﬁnding. IEEE Trans. Comput. Intell. AI
Games , 4(2):144–148, 2012.
[Surynek et al. , 2016 ]Pavel Surynek, Ariel Felner, Roni
Stern, and Eli Boyarski. Efﬁcient SAT approach to multi-
agent path ﬁnding under the sum of costs objective. In
ECAI 2016 - 22nd European Conference on Artiﬁcial In-
telligence , volume 285 of Frontiers in Artiﬁcial Intelli-
gence and Applications , pages 810–818. IOS Press, 2016.
[Surynek, 2009 ]Pavel Surynek. A novel approach to path
planning for multiple robots in bi-connected graphs. In
2009 IEEE International Conference on Robotics and Au-
tomation, ICRA 2009, Kobe, Japan, May 12-17, 2009 ,
pages 3613–3619. IEEE, 2009.[Surynek, 2012 ]Pavel Surynek. On propositional encodings
of cooperative path-ﬁnding. In IEEE 24th International
Conference on Tools with Artiﬁcial Intelligence, ICTAI
2012 , pages 524–531. IEEE Computer Society, 2012.
[Surynek, 2017 ]Pavel Surynek. Time-expanded graph-
based propositional encodings for makespan-optimal solv-
ing of cooperative path ﬁnding problems. Ann. Math. Artif.
Intell. , 81(3-4):329–375, 2017.
[Surynek, 2019 ]Pavel Surynek. Unifying search-based and
compilation-based approaches to multi-agent path ﬁnding
through satisﬁability modulo theories. In Sarit Kraus, ed-
itor,Proceedings of the Twenty-Eighth International Joint
Conference on Artiﬁcial Intelligence, IJCAI 2019 , pages
1177–1183. ijcai.org, 2019.
[Wagner and Choset, 2011 ]Glenn Wagner and Howie
Choset. M*: A complete multirobot path planning
algorithm with performance bounds. In Proceedings of
(IROS) IEEE/RSJ International Conference on Intelligent
Robots and Systems , pages 3260 – 3267, September 2011.
[Walsh, 2000 ]Toby Walsh. SAT v CSP. In Principles and
Practice of Constraint Programming - CP 2000, 6th Inter-
national Conference, Proceedings , volume 1894 of LNCS ,
pages 441–456. Springer, 2000.
[Wang and Botea, 2011 ]Ko-Hsin Cindy Wang and Adi
Botea. MAPP: a scalable multi-agent path planning al-
gorithm with tractability and completeness guarantees. J.
Artif. Intell. Res. , 42:55–90, 2011.
[Wen et al. , 2022 ]Licheng Wen, Yong Liu, and Hongliang
Li. CL-MAPF: multi-agent path ﬁnding for car-like robots
with kinematic and spatiotemporal constraints. Robotics
Auton. Syst. , 150:103997, 2022.
[Yu and LaValle, 2013 ]Jingjin Yu and Steven M. LaValle.
Structure and intractability of optimal multi-robot path
planning on graphs. In Proceedings of the Twenty-Seventh
AAAI Conference on Artiﬁcial Intelligence, July 14-18,
2013, Bellevue, Washington, USA . AAAI Press, 2013.
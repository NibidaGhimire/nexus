Spacetime codes of Clifford circuits
Nicolas Delfosse, Adam Paetznick
Microsoft Quantum, Redmond, Washington 98052, USA
May 29, 2023
Abstract
We propose a scheme for detecting and correcting faults in any Clifford circuit. The scheme
is based on the observation that the set of all possible outcome bit-strings of a Clifford circuit
is a linear code, which we call the “outcome code”. From the outcome code we construct a
corresponding stabilizer code, the “spacetime code”. Our construction extends the circuit-to-
code construction of Bacon, Flammia, Harrow and Shi [2], revisited recently by Gottesman [16],
to include intermediate and multi-qubit measurements. With this correspondence, we reduce
the problem of correcting faults in a circuit to the well-studied problem of correcting errors
in a stabilizer code. More precisely, a most likely error decoder for the spacetime code can
be transformed into a most likely fault decoder for the circuit. We give efficient algorithms to
construct theoutcome andspacetime codes. Wealso identifyconditions underwhichthese codes
are LDPC, and give an algorithm to generate low-weight checks, which can then be combined
with efficient LDPC code decoders.
Several small quantum computing platforms are available today. However, the high noise rate
of quantum hardware is a major obstacle to the scalability of these devices. Some form of quantum
error correction is likely necessary in order to achieve noise low enough for solving large-scale
industrial problems.
Thetraditionalsolutiontothenoiseproblemistoexecutequantumalgorithmsonerror-corrected
qubits. First, choose a quantum error correction code to encode each qubit. Second, design a
syndrome extraction circuit for this code. This quantum circuit is run regularly and returns a bit
string, the so-called syndrome, which is then used to identify errors. This code-centric approach has
limitations, however. For example, Floquet codes are not obtained through this traditional solution
and are instead defined directly by a circuit.
In this work, we take a circuit-centric approach. We describe a general method for correcting
faults in Clifford circuits. This methods applies not only to syndrome extraction circuits of stabilizer
codes and Floquet codes, but also to general Clifford circuits that were not initially designed as a
syndrome extraction circuit. The basic idea is that these circuits can include some other type of
redundancy that can be exploited to correct circuit faults. Such a circuit-centric approach was also
considered previously in [2, 16, 13]. Clifford circuits are central for quantum computing because
they implement standard protocols such as quantum teleportation, preparation of Bell states or
error correction with stabilizer codes. Even though they are not universal for quantum computing
directly, universality can be achieved with Clifford circuits by the injection of magic states [6].
1arXiv:2304.05943v2  [quant-ph]  26 May 2023We consider circuits made with unitary Clifford gates and Pauli measurements. We allow all
Pauli measurements, not just single-qubit measurements, and we allow for internal measurements
that can occur at any time step of the circuit.
Collectively, the measurement outcomes of a circuit produce a classical bit-string. Our basic
idea is to correct circuit faults using redundancy in these bit-strings. We prove that the set of
possible outcome bit-strings of a Clifford circuit is a linear code (up to relabeling the measurement
outcomes); see Theorem 1 and Corollary 2. We call this the “outcome code” of the circuit. Moreover,
we design an algorithm that returns a complete set of checks for the outcome code; see Algorithm 1.
The “outcome code” can be used directly to detect and correct circuit faults. Doing so, however,
requires designing a decoder, generally a non-trivial task. Instead of designing a new decoder that
maps check values onto circuit faults, we construct a stabilizer code associated with the circuit,
the “spacetime code”; see Theorem 2. Measuring the generators of the spacetime code provides
corresponding values of the checks of the outcome code. We show how to design a circuit decoder
that returns a most likely fault configuration using a most likely error decoder for the spacetime
stabilizer code; see Theorem 3.
The spacetime code defined in this paper is related to the circuit-to-code construction of Bacon,
Flammia, Harrow and Shi [2]. There, the authors proposed a transformation of a restricted class of
Clifford circuits with the goal of building new subsystem codes. They considered a subclass of post-
selection circuits and computed the parameters of the resulting subsystem code as a function of the
input circuit. Recently, Gottesman extended this formalism to circuits with Clifford unitaries and
single-qubit preparation and measurement [16].1The spacetime code we consider can be seen as the
stabilizer code associated with the subsystem code of [2, 16] after generalizing their constructions to
arbitrary Clifford circuits. The stabilizer generators of the spacetime code we consider here coincide
with “detectors” considered by [19], where they were used to optimize surface codes for particular
architecture constraints.
Throughout, we provide new proofs of the properties of the spacetime code based on the relation
between the forward and the backward propagation of the faults through the circuit. Namely, we
prove that backward propagation is the adjoint of forward propagation. This alternative approach
unifies the treatment of all Clifford circuits and sheds some light on the underlying mathematical
structure of the spacetime code. We believe that this relation could also be relevant for other
applications.
Equipped with the outcome code, one can build a scheme for the correction of any small Clifford
circuit using a lookup decoder. To push the range of application further, we propose an algorithm
to produce a set of low-weight stabilizer generators for the spacetime code 3, resulting in a Low-
Density Parity-Check (LDPC) spacetime code for which efficient decoders exist [12, 21, 24, 8].
Starting from a local code in Ddimensions, that is, a code defined by local stabilizer generators in a
D-dimensional grid of qubits, our algorithm produces local stabilizer generators in D+1dimensions
for which topological decoders such as the Renormalization Group decoder [5] can be used.
Our fault correction scheme applies to any Clifford circuit, but syndrome extraction circuits are
of special interest. The design of a quantum error correction scheme is a non-trivial task which
requires (i) a syndrome extraction circuit, (ii) a syndrome map, (iii) a decoder. With our work,
the construction of the syndrome map and the decoder can be automated in some cases. We do
not provide a performance guarantee for the resulting scheme, and we believe that some specialized
schemes, highly optimized for a specific circuit, are likely to perform better. The main advantage
1The term spacetime code follows terminology introduced by [16].
2Figure 1: Construction of codes from a Clifford circuit. Given a Clifford circuit as input, a modified
stabilizer simulation, Algorithm 1, produces the outcome code. The corresponding spacetime code
canthenbeconstructedbyaccumulatingmeasurementobservablesfromtheoutcomecodebackward
through the circuit. See Section 5.1. Low-weight generators of the spacetime code are obtained by
sparsification with Algorithm 3. The dashed arrow indicates that sparsification is not possible for
all circuits. All constructions run in polynomial time. The LDPC spacetime code can be decoded
using any quantum LDPC code decoder, thereby providing an automated and efficient means of
correcting faults given only the circuit as an input.
of our approach is its flexibility. Our approach only requires the circuit to be given as an input and
it applies to codes implemented with Clifford operations or Pauli measurements. This includes for
instance CNOT-based surface codes [10, 11] or color codes [4], Majorana-based surface codes [7] or
Floquet codes [17] that are implemented with only joint measurements.
This article is organized as follows. In order to motivate our results, we start by describing
an application of the outcome code and the spacetime code in Section 1. Namely, we discuss the
implementation of an automated scheme for the correction of faults in Clifford circuits. The rest of
the paper provides a complete description of all the ingredients. Background material is introduced
in Section 2. Then, Section 3 proves some core technical results and establishes the relation between
the propagation and the backpropagation operators. The outcome code is defined in Section 4 which
also describes an algorithm (Algorithm 1) to compute a complete set of checks for this code. The
spacetime code is introduced in Section 5 where we prove that a most-likely error decoder for the
spacetime code can be converted into a circuit decoder that returns a most likely set of faults
(Theorem 3). Section 6 provides an algorithm (Algorithm 3) to generate low-weight generators for
the spacetime code.
1 Applications of the outcome code and the spacetime code
In this section, we combine all the ingredients developed in this article to describe a flexible scheme
for the correction of faults in Clifford circuits. The full protocol is illustrated in Figure 1. Detailed
descriptions of all the ingredients are provided in subsequent sections.
1.1 Standard design procedure for a quantum error correction scheme
To emphasize the advantage of our approach, we first review the general approach to designing
and simulating a quantum error correction scheme. For simplicity, we focus on stabilizer codes and
consider the standard circuit noise model explained in Section 2.
To describe a complete quantum error correction scheme for a given stabilizer code, we must
design the following components:
1.Syndrome extraction circuit: A quantum circuit that takes as input a noisy encoded state
and returns a bit string.
32.Syndrome map: A classical procedure that takes as input the outcome of the syndrome
extraction circuit and returns bit string that we call the syndrome.
3.Decoder: Aclassicalprocedurethattakesasinputthesyndromeandthatreturnsacorrection
to apply to the encoded state.
These three components are non-trivial and tightly coupled, in general. Designing a syndrome
extraction circuit requires working within the constraints of a specific architecture. See, for exam-
ple, [7, 14, 23]. The decoding problem is notoriously difficult [3, 18]. Some specific cases have been
worked out. For example, with the surface code, one can consider the standard syndrome extraction
circuit [11], a carefully chosen sequence of CNOT gates and measurements of ancillary qubits. The
syndrome of this circuit is obtained by xor of consecutive outcomes for each ancilla. The syndrome
is then input to a surface code decoder such as a Minimum Weight Perfect Matching decoder [10]
or Union-Find decoder [9].
The effectiveness of the decoder depends tightly on the choice of syndrome map. Indeed, the
surface code decoders mentioned above may be ineffective for other choices of syndromes. The
syndrome map, in turn, depends on the details of both the code and the circuit; see Floquet
codes[17]. Anychangetothecircuitorthecoderequirescorrespondingmodificationofthesyndrome
map.
1.2 Automated circuit-fault correction
Here, we propose a protocol described in Figure 1 for correcting faults that requires only the Clifford
circuit as an input, instead of the three components required in the previous section. Consider a
Clifford circuit Cwith mmeasurements. The first step of the protocol is the computation of a set of
outcome checks u1, . . . , u r∈Zm
2using Algorithm 1. In the absence of faults, running the circuit C
produces an outcome bit-string o∈Zm
2that satisfies (o|u1) =···= (o|ur) = 0. Therefore, one can
use these values to detect and correct circuit faults. Moreover, the set of outcome checks returned
by Algorithm 1 is maximal. It fully describes the set of possible outcomes for the circuit, which
means that we are using all the information available to detect and correct faults.
Giventheoutcomechecks,weneedtodesignasyndromemapandadecoderinordertotransform
the check values (o|ui)into a correction to apply to the output state of the circuit. For small circuits,
this can be done with the syndrome map o7→σwhere σi= (o|ui)and a lookup decoder. Naively,
we can construct a lookup decoder for the circuit Cusing the outcome checks uias follows. Loop
over all the fault configurations of the circuit with up to Mfaults for some integer M. For each fault
configuration F, compute the syndrome value σand store a configuration made with a minimum
number of faults for each syndrome σ.
Lookup decoders are impractical for large codes. To make the decoding of large circuit possible,
we must restrict the set of schemes we consider because the decoding problem for linear codes and
stabilizer codes is generally intractable [3, 18]. We focus on circuits that admit local redundancy in
the sense that the spacetime code of the circuit has many low-weight stabilizers. This assumption is
even more justified because the value of an outcome check corresponding to a high-weight stabilizer
in the spacetime code will be very noisy and unreliable.
Aftercomputingtheoutcomechecks u1, . . . , u rusingAlgorithm1,wecomputethecorresponding
stabilizers← − − −F(u1), . . . ,← − − −F(ur)defined in Eq. (20). Then, we run Algorithm 3 to produce a set low-
weight stabilizer generators for the spacetime code. These generators define a new syndrome map
4whose components are related to the check values (o|ui)by a linear map. We are now equipped
with a set of low-weight generators and therefore one can use any LDPC code decoder for this code.
Existing LDPC decoder options include the Union-Find decoder for local topological codes [9] or
for LDPC codes [8]. Other decoding strategies can be used, such as the Renormalization Group
decoder [5] for topological codes or a Belief Propagation decoder for LDPC codes [21, 24].
2 Background
2.1 Linear codes
Alinear code with length nis aZ2-linear subspace of Zn
2. It encodes kbits into nbits where kis
the dimension of the code. The dual code of a linear code Cwith length n, denoted C⊥, is the set
of vectors of Zn
2that are orthogonal with all the vectors of C. Orthogonality is with respect to the
binary inner product (u|v) =Pn
i=1uivi(mod 2) .
A linear code can be defined by providing a set of generators of the code or by providing a set
of generators of the dual code. Given a set of generators of the dual code u1, . . . , u r∈Zn
2, the code
is the set of vectors v∈Zn
2that satisfy (ui|v) = 0for all i= 1, . . . , r. We refer to the vectors uias
the “checks” of the code.
Thesyndrome map associated with the checks u1, . . . , u r∈Zn
2is the map
σ:Zn
2−→Zr
2 (1)
that sends a vector vonto the vector swhose ith component is si= (ui|v). The vector sis called
thesyndrome ofu. The syndrome can be used to correct some bit flips of the corresponding vector
and to map it back to the code space.
2.2 Stabilizer codes
Astabilizer code with length nis defined by a set of commuting n-qubit Pauli operators S, that
we call stabilizer generators, such that the group ⟨S⟩they generate does not contain −I. We refer
to the group ⟨S⟩as thestabilizer group of the code and a Pauli operator Psuch that ±P∈ ⟨S⟩is
called a stabilizer.
The code space of a stabilizer code with length nis the subspace of (C2)⊗nthat is invariant
under the stabilizer generators. If Scontains rindependent operators, the code space is a subspace
of(C2)⊗nisomorphic with (C2)⊗n−r. We interpret this subspace as the encoding of k=n−r
(logical) qubits into n(physical) qubits.
Error correction with a stabilizer code is based on the measurement of a set of stabilizer gener-
atorsS={S1, . . . , S r}. This produces an outcome σ∈Zr
2called the syndrome . Here the outcome
σicorresponds to the eigenvalue (−1)σifor the ith measured stabilizer generator. If the state of the
system before syndrome measurement is a code state suffering from Pauli error E∈Pn, then the
measurement returns a syndrome σsuch that σi= [E, S i]where [E, S i]is 0 if EandSicommute
and 1 otherwise. In the absence of error, the syndrome is trivial. Therefore, a non-trivial syndrome
can be used to detect and correct errors on encoded states.
We denote by Pnthe set of n-qubit Pauli operators and by Pnits quotient by the phase
operators {±I,±iI}. In other words, in Pnwe consider Pauli operators up to a phase. It is natural
to consider Pauli errors up to a phase because a global phase has no effect on quantum states.
5Given a probability distribution over Pauli errors, a most likely error decoder (MLE decoder) is a
mapZr
27→Pnthat sends a syndrome σto the Pauli Ewith maximum probability among Pauli
errors with syndrome σ.
Alogical operator is a Pauli operator that commutes with all stabilizer generators of the code.
A logical operator is non-trivial if it is not a stabilizer. For any subset AofPn, we use the notation
A⊥={Q∈Pn| ∀P∈A,[P, Q] = 0} (2)
for the set of n-qubit Pauli operators that commute with all the elements of A. If⟨S⟩is a stabilizer
group, then S⊥is the set of logical operators and S⊥\⟨S⟩is the set of non-trivial logical operators
of the code.
2.3 Clifford circuits
We consider circuits composed of Clifford unitaries and Pauli measurements. Qubit preparation of
the state |0⟩can be emulated by measuring Z. We assume that all the qubits are present at the
beginning of the circuit and no qubit can be added through the circuit. This is not a restriction
because a qubit can be reinitialized using a single qubit measurement as explained above. We do
not impose any restriction on the size of the support of allowed operations, but our results also
apply to circuits limited to single-qubit and two-qubit gates or contexts in which connectivity is
limited to nearest neighbors, for example. Our results also hold for Clifford circuits with Pauli fixes,
but are not included here to keep the notation simple.
AClifford circuit is a sequence of sClifford operations C= (C1, . . . , C s)applied to nqubits.
Each operation Ciis applied at a given time step, denoted level( Ci)∈ {1,2, . . .}, that we call the
levelof the operation. The depthof a circuit, denoted ∆(C), is the maximum level of its operations.
To guarantee that they can be implemented simultaneously, we require that two operations with the
same level have disjoint support. We assume that the circuit operations are given in chronological
order, that is i≤jimplies level( Ci)≤level( Cj).
We refer to the state of the nqubits of the circuit before the first circuit operation as the input
stateof the circuit and the final state of the nqubits is the output state of the circuit. We do not
place any constraint on the input state of the circuit.
Throughout, mdenotes the number of Pauli measurements in the circuit and we denote by
S1, . . . , S mthe measured operators. For all j= 1, . . . , m, the level of the measurement Sjis
denoted ℓj. By definition, we have 0≤m≤s, where sis the number of operations of the circuit,
and each ℓjis an integer in the set {1, . . . , ∆(C)}.
2.4 Circuit faults
We consider a standard circuit noise model where each circuit operation Ciand each idle qubit is
faulty with probability pi. If a unitary gate or an idle qubit is faulty, it is followed by a uniform
random Pauli error Eacting on its support. A faulty measurement is followed by a uniform ran-
dom Pauli error Eacting on its support combined with a flip of the measurement outcome with
probability 1/2.
Following [2], it is convenient to represent faults as Pauli operators acting on half-integer time
steps as shown in Fig. 2. A fault operator for a circuit Cacting on nqubits with depth ∆is a Pauli
operator F∈Pn(∆+1)acting on n(∆+1)qubits indexed by pairs (ℓ+0.5, q)where ℓ∈ {0,1, . . . , ∆}
represents a level of the circuit and q∈ {1, . . . , n }corresponds to a qubit. We include ℓ= 0to
6(a)
(b)
Figure 2: A depth-three circuit with Pauli measurements and unitary Clifford gates. Pauli faults
are supported on the white circles. We show a fault operator in (a) and its back-cumulant in (b)
obtained by propagation of faults backward. In this circuit, the third measurement is redundant
and the three measurement outcomes o1, o2, o3satisfy o1+o2+o3= 0 (mod 2) . This defines a
check of the outcome code. The stabilizer generator of the spacetime code corresponding to this
check is obtained by the backward accumulation of the three measurements through the circuit.
This results in the weight-four Pauli operator shown in (b) supported on the circles.
represent faults on the input qubits of the circuit. The component of Fon qubit (ℓ+ 0.5, q)is
denoted Fℓ+0.5,q∈ {I, X, Y, Z }. It corresponds to the fault occurring right after level ℓon qubit q.
We also use the notation Fℓ+0.5for the n-qubit Pauli operator ⊗n
q=1Fℓ+0.5,qwhich represents the
fault occurring right after the level ℓof the circuit.
The flip of a measurement outcome can also be represented as a fault operator. Let P∈Pnbe
a measured Pauli operator and let Q∈Pnbe a weight-one operator Qthat anti-commutes with P.
Then, the fault operator Fsuch that Fℓ−0.5=QandFℓ+0.5=Qis a representation of the flip of
the outcome of the measurement of Pat level ℓ.
We assume a noise model that describes the probability of each combination of circuit faults.
The corresponding probability distribution over the set of fault operators is denoted by PF.
2.5 Propagation of Pauli faults and cumulant
The effect of a set of faults on the outcomes of a circuit can be determined by propagating the faults
through the circuit as shown in Fig. 2.
The basic idea of fault propagation is that a Pauli fault P∈Pnoccurring before a unitary
operation Uis equivalent to a fault UPU−1after the operation g. We refer to UPU−1as theconju-
gationofPbyU. In the case of a Pauli measurement, a fault propagates through the corresponding
projector unchanged, and it leads to a flip of the measurement outcome if the Pauli fault preceding
7the measurement anti-commutes with the measured operator.
Thecumulant of a fault operator Fthrough a circuit Cwith depth ∆, is the fault operator
denoted− →Fobtained by the following procedure.
1. Initialize− →Fas− →F=F.
2. For all levels ℓ= 1,2, . . . , ∆do:
(a) Let E=− →Fℓ−0.5.
(b) Conjugate Eby the product of all unitary operations of Cwith level ℓ.
(c) Multiply− →Fℓ+0.5byE.
When propagating− →Fℓ−0.5through the operations with level ℓ, the order in which these operations
are selected is not relevant because they do not overlap.
The cumulant− →Fis defined in such a way that the operator− →Fℓ+0.5is the Pauli error resulting
from the combination of all the faults occurring during the first ℓlevels of the circuit. The cumulant
was introduced in [2] as the spackle operator.
2.6 Effect of circuit faults
Consider a depth- ∆Clifford circuit Cacting on nqubits. Assume that the circuit contains mPauli
measurements. The mmeasured operators are denoted by S1, . . . , S mand for all j= 1, . . . , mlet
ℓjdenote the level of the measurement of the operator Sj.
Executing the quantum circuit Cproduces two types of data:
•theoutcome bit-string o∈Zm
2is the bit-string with jth component corresponding to the
outcome of measurement Sjand
•theoutput state ρois the state of the nqubits of the system after running the circuit.
The outcome bit-string is generally not deterministic. We denote by PC,ρtheoutcome distribution
of the circuit when the input state of the circuit is ρ. Given input ρ, the circuit Cyields the outcome
bit-string owith probability PC,ρ(o). The output state ρogenerally depends on the outcome bit-
string o. A set of circuit faults represented by a fault operator F∈Pn(∆+1)can affect the outcome
bit-string and the output state of the circuit.
Our goal is to protect the outcome bit-string and the output state of the circuit from the effect
of faults occurring throughout the circuit. Faults are represented by a fault operator F∈Pn(∆+1).
We use the notation P(F)
C,ρfor the outcome distribution of the circuit Cwith input state ρand faults
corresponding to F. The corresponding output state is denoted by ρ(F)
o.
The impact of a fault Fon outcome ojis determined by the cumulant of Fjust prior to
measurement Sj. If− →Fℓj−0.5anti-commutes with Sj, then the outcome is flipped. Likewise, the
impact on the output state ρois determined by the cumulant of Fat the end of the circuit.
Proposition 1 (Effect of faults) .IfF∈Pn(∆+1)then, we have
•P(F)
C,ρ(o) =PC,ρ(o+f)where f= (f1, . . . , f m)∈Zm
2such that fj= [− →Fℓj−0.5, Sj],
8•ρ(F)
o=Eρo+fEwhere E=− →F∆+0.5.
The pair (f, E)associated with a fault operator Fis called the effectofFand is denoted eff(F).
We say that Fflips the j-th outcome of the circuit if[− →Fℓj−0.5, Sj] = 1and we refer to the Pauli
error E=− →F∆+0.5as theresidual error ofF.
Proof.By definition of the cumulant− →F, the accumulation of all the circuit faults occurring before
the measurement of Sjis equivalent to the Pauli error− →Fℓj−0.5. As a result, an outcome bit-string
ois mapped onto the vector o+fgiven in the proposition. When the vector ois observed, the
output state is the state Eρo+fEbecause owas mapped onto o+fand the accumulation of all the
circuit faults acts as an error E=− →F∆+0.5on the output state of the circuit.
2.7 Correction of circuit faults with circuit decoders
For the circuit to be correct in the presence of faults, we must guarantee that both the outcome
bit-string and the output states can be recovered. An error affecting the outcome bit-string can
be just as harmful as an error on the output state. For example, one can prepare a state |+⟩by
measuring X, which produces either |+⟩with outcome 0 or |−⟩with outcome 1. To obtain the
state|+⟩, we apply Zto the qubit when the outcome 1 is observed. An incorrect outcome in this
protocol directly translates into a qubit error.
The output of the circuit lives in a stabilizer code (which is a trivial code for some circuits) and
therefore it is sufficient to correct the residual error up to a stabilizer of this code. Formally, define
theoutput stabilizer group of the circuit, denoted ⟨So⟩, to be the stabilizer group that keeps invariant
all the possible output states ρoof the circuit corresponding to the outcome oin the absence of noise.
For a fixed outcome o, we refer to an operator of ⟨So⟩as anoutput stabilizer and the stabilizer code
associated with the stabilizer group generated by ⟨So⟩as theoutput stabilizer code of the circuit.
The output stabilizer group of a circuit can be computed efficiently as in Algorithm 1 as originally
proposed in [15, 1].
Acircuit decoder for the circuit Cis defined to be a map
Zm
2−→Zm
2×Pn
o7−→(ˆf,ˆE)
that takes as an input an outcome bit-string oand that returns an estimation of the outcome flips
ˆfand an estimation of the residual error ˆE.
Assume that the faults corresponding to F∈Pn(∆+1)occur, and let (f, E) = eff( F)be the
effect of F. The decoder is said to be successful ifˆf=fand if the error ˆEEis correctable for
the output stabilizer code. Here by correctable, we mean correctable for the output stabilizer code
equipped with a decoder and a noiseless syndrome extraction circuit for the measurement of the
stabilizer generators. This notion of correctability depends on the decoder used for the output code.
Unless otherwise stated, we pick a minimum-weight error decoder for the output code, that is a
decoder returning a minimum weight Pauli error for a given syndrome.
Denote by ρMthe density matrix of the maximally mixed state ρM= I
2⊗n. Amost likely fault
operator given an outcome bit-string o∈Zm
2is defined to be a fault operator ˆF∈Pn(∆+1)that
maximizes the product
QMLF(ˆF, o) =P(ˆF)
C,ρM(o)PF(ˆF)· (3)
9This definition is motivated by Bayes’ theorem, from which the probability of a fault operator ˆF
given an outcome ocan be written as
P(ˆF|o) =P(ˆF)
C,ρM(o)PF(ˆF)
P
ˆF∈Pn(∆+1)PF(ˆF)P(ˆF)
C,ρM(o)(4)
where the input state of the circuit is chosen to be the maximally mixed state ρMbecause we do
not want to assume a specific input state. For a fixed circuit and a fixed outcome bit-string, this
number is proportional with P(ˆF)
C,ρM(o)PF(ˆF)because the denominator is independent of ˆF.
A circuit decoder that returns the effect of a most likely fault operator is said to be a most likely
fault decoder or MLF decoder.
3 Properties of the cumulant
This section introduces the main technical tools of this paper. In particular we introduce the back-
cumulant← −Fobtained by propagating a fault operator backward, and we show in Proposition 3 that
theaccumulator
Pn(∆+1)−→F∈Pn(∆+1) (5)
F7−→− →F (6)
is the adjoint of the back-accumulator
Pn(∆+1)−→F∈Pn(∆+1) (7)
F7−→← −F· (8)
This relation allows us to replace the fault propagation by the backpropagation of the measured
operators and leads to the definition of stabilizer generators of the spacetime code in Section 5.1.
3.1 Definition of the back-cumulant
Theback-cumulant of a fault operator F, denoted← −F, is defined similarly to the cumulant with the
following procedure.
1. Initialize← −Fas← −F=F.
2. For all levels ℓ= ∆,∆−1, . . . , 1do:
(a) Let E=← −Fℓ+0.5.
(b) Conjugate Eby the inverse of the product of all unitary operations of Cwith level ℓ.
(c) Multiply← −FbyE.
Similar to the cumulant, the back-cumulant← −Fis defined in such a way that the operator Fℓ−0.5
is equivalent to the accumulation (backward in time) of all the faults occurring during the levels
ℓ′≥ℓof the circuit.
103.2 Explicit cumulant and back-cumulant
The following proposition provides an explicit description of the cumulant and back-cumulant of a
fault operator.
Proposition 2 (Explicit cumulant and back-cumulant) .LetCbe a Clifford circuit. Let Uℓbe the
product of all the unitary operations of the circuit with level ℓand let Ui,j=UjUj−1. . . U i+1for
j≥i. IfFis a fault operator then for all ℓ∈ {0,1, . . . , ∆}, we have
− →Fℓ+0.5=ℓY
i=0Ui,ℓFi+0.5U−1
i,ℓ(9)
and
← −Fℓ+0.5=∆Y
j=ℓU−1
ℓ,jFj+0.5Uℓ,j· (10)
Here, we use the convention Ui,j=Iifj≤i. When j > i, the operation Ui,jis defined in such a
way that it maps the faults occurring right after level ionto equivalent faults occurring right after
level j.
Proof.The component− →Fℓ+0.5of− →Fis obtained by conjugating all the components Fi+0.5ofFwith
i≤ℓthrough the level i+ 1, i+ 2, . . . ℓof the circuit. This corresponds to the conjugation by Ui,ℓ,
justifying the propagation formula.
To back-propagate Fj+0.5from level j+0.5to level ℓ+0.5with j≥ℓ, we conjugate this operator
by the inverse of the unitary operations of the circuit at levels ℓ, ℓ−1, . . . , j + 1in that order. This
is equivalent to the conjugation by
U−1
j+1. . . U−1
ℓ−1U−1
ℓ
which is equal to U−1
ℓ,j.
The operators Ui,jobey the relations
Ua,c=Ub,cUa,b, (11)
U−1
b,cUa,c=Ua,b (12)
and
Ua,bU−1
a,c=U−1
b,c(13)
where a, b, care three integers such that 0≤a≤b≤c≤∆.
Corollary 1. The accumulator and the back-accumulator are automorphisms of the group Pn(∆+1).
Thanks to this corollary, one can write
− − →FG=− →F− →G (14)
and
← − −FG=← −F← −G (15)
for all fault operators F, G.
11Proof.Based on Eq. (9), we see that
− − →FGℓ+0.5=ℓY
i=0Ui,ℓFi+0.5Gi+0.5U−1
i,ℓ
=ℓY
i=0Ui,ℓFi+0.5U−1
i,ℓUi,ℓGi+0.5Gi+0.5U−1
i,ℓ
=ℓY
i=0Ui,ℓFi+0.5U−1
i,ℓℓY
j=0Uj,ℓGj+0.5U−1
j,ℓ
=− →Fℓ+0.5− →Gℓ+0.5
Therein, we can reorder the Pauli operators Ui,ℓFi+0.5U−1
i,ℓandUj,ℓGj+0.5U−1
j,ℓbecause we consider
Pauli operators up to a phase. This proves that the accumulator is a group morphism.
Therefore, the accumulator is a Z2-linear map over Pn(∆+1) ≃Z2n(∆+1)
2. To show that it is
bijective, it suffices to see that its matrix is lower triangular with the identity on the diagonal in
the basis obtained by concatenating Pauli operators acting on level 0,1, . . . , ∆.
One can show that the back-accumulator is a group automorphism with the same technique.
3.3 Basic properties of Pauli commutators
For two Pauli operators PandQ, denote by [P, Q]∈Z2the commutator of PandQwhich takes
the value 0ifPandQcommute and takes the value 1 otherwise. We will use the following basic
properties of the commutator. Let n, mbe integers. For all Pauli operators P, Q∈Pn, we have
[P, Q] = [Q, P]. (16)
For all Pauli operators P, Q, R ∈Pn, we have
[P, QR ] = [P, Q] + [P, R] (mod 2) . (17)
For all Pauli operators P, Q∈PnandP′, Q′∈Pm, we have
[P⊗P′, Q⊗Q′] = [P, Q] + [P′, Q′] (mod 2) . (18)
For all Pauli operators P, Q∈Pnand for all Clifford unitary operations U, we have
[P, Q] = [UPU−1, UQU−1]. (19)
3.4 Interplay between accumulation and commutation
Based on Proposition 1, to clarify the effect of faults on the outcomes of a circuit, it is important
to understand the interplay between fault propagation and commutation; see definition of fj. The
following proposition is a key technical result and is used many times in the rest of the paper. It
proves that the back-accumulator is the adjoint of the accumulator.
Proposition 3 (Adjoint of the accumulator) .For all fault operators F, Gof a circuit C, we have
[− →F , G] = [F,← −G]·
12Proof.Because− →F=⊗∆
ℓ=0− →Fℓ+0.5andG=⊗∆
ℓ=0Gℓ+0.5, we can write
[− →F , G] =∆X
ℓ=0h− →Fℓ+0.5, Gℓ+0.5i
Using Eq. (18)
=∆X
ℓ=0"ℓY
i=0
Ui,ℓFi+0.5U−1
i,ℓ
, Gℓ+0.5#
Using Eq. (9)
=∆X
ℓ=0ℓX
i=0h
Ui,ℓFi+0.5U−1
i,ℓ, Gℓ+0.5i
Using Eq. (17)
=∆X
ℓ=0ℓX
i=0h
Fi+0.5, U−1
i,ℓGℓ+0.5Ui,ℓi
Using Eq. (19)
=∆X
i=0∆X
ℓ=ih
Fi+0.5, U−1
i,ℓGℓ+0.5Ui,ℓi
Interchanging the summation order
=∆X
i=0"
Fi+0.5,∆Y
ℓ=i
U−1
i,ℓGℓ+0.5Ui,ℓ#
Using Eq. (17)
=∆X
i=0h
Fi+0.5,← −Gi+0.5i
Using Eq. (10)
= [F,← −G] Using Eq. (18) ·
In the last equality we use the factorizations F=⊗∆
i=0Fi+0.5and← −G=⊗∆
i=0← −Gi+0.5.
4 The outcome code of a Clifford circuit
In this section, we show that the set of possible outcome bit-strings of a Clifford circuit is almost
linear code2and we propose an algorithm to efficiently compute a set of checks for this code. Our
algorithm is derived from the standard stabilizer simulation algorithm of [15, 1]. In fact, removing
steps 10 to 16 in Algorithm 1, we recover a standard algorithm that computes the output stabilizer
group of a Clifford circuit. The outcome code can be used to detect and correct faults in a Clifford
circuit.
We consider a depth- ∆Clifford circuit Cacting on nqubits containing mmeasurements. We
denote by Sjthe measured operators for j= 1, . . . , mand by ℓjthe level of the measurement of
the operator Sj.
In many cases, the outcomes observed through a circuit are not independent. For instance, if a
measurement is repeated twice in a row, we expect to obtain the same outcome twice. The following
theorem proves that the set of outcomes of a Clifford circuit is an affine subspace. It is defined by
a set of affine checks of the formP
k∈Kok= 0or 1.
2By almost, we mean that it is not a linear subspace but an affine subspace of Zm
2for some integer m. However,
by changing the description of the circuit, one can make it a proper linear code.
13Theorem 1 (Outcome code of a Clifford circuit) .The set of all possible outcome bit-strings for a
Clifford circuit CwithmPauli measurements is an affine subspace O(C)ofZm
2. Moreover a set of
affine equations defining O(C)is computed by Algorithm 1.
Algorithm 1: Outcome code of a Clifford circuit.
input : A Clifford circuit C= (C1, . . . , C s)acting on nqubits.
output: A set Rof checks for the circuit C.
1SetU=I.
2foralli= 1, . . . , s do
3ifCiis a unitary gate then
4 Replace UbyCiU.
5ifCiis a measurement of a Pauli operator Sj∈ Pn.then
6 Compute S′
i=U−1SiU.
7SetR={}andS={}.
8foralli= 1, . . . , s do
9ifCiis a measurement of a Pauli operator Sj∈ Pn.then
10 if±S′
j∈ ⟨S⟩ then
11 Decompose ±S′
jas a product of operators in S.
12 Rewrite this decomposition in the form ±S′
j=Q
k∈KjS′
k.
13 if+S′
j∈ ⟨S⟩ then
14 Add the affine check oj+P
k∈Kjok= 0toR.
15 if−S′
j∈ ⟨S⟩ then
16 Add the affine check oj+P
k∈Kjok= 1toR.
17 else
18 ifthere exists T∈ Sthat anti-commutes with S′
jthen
19 forT′∈ Ssuch that T′̸=Tdo
20 ifT′anti-commutes with S′
jthen
21 Replace T′byTT′inS.
22 Remove TfromS.
23 AddS′
jtoS.
24return R.
The goal of the first subroutine of Algorithm 1 (steps 1−6) is to move the Clifford unitaries
to the end of the circuit. This is done by conjugating the measured operators Sjby the previous
unitary gates, producing S′
j. Then, the relations between the measurement outcomes are extracted
by tracking the stabilizer group of this sequence of measurements.
Except for steps 10−16, Algorithm 1 matches the standard algorithm for stabilizer simula-
tion [15, 1]. The only difference is the action taken when a measured Pauli operator S′
jis already an
element of the stabilizer group ⟨S⟩. In that case, the usual action is to simply output the measure-
ment result ±1. Instead, we determine the decomposition of S′
jas a product of existing elements
ofS. The formula ±S′
j=Q
k∈KjS′
kasserts that the outcome of measument Cjmustmatch sum of
14outcomes from prior measurements Ckthe circuit. All together, they form a check of the outcome
code.
The decomposition (step 12) can be computed by a variation of Gauss-Jordan elimination in
which the elements of Sare augmented to indicate the indexes of their corresponding measurements.
For a circuit with nqubits and mmeasurements, the worst-case computational complexity of this
step is O(n2(n+m)). Note also that this step can be combined with checking ±S′
j∈ ⟨S⟩(step 10),
which also requires Gaussian elimination.
The proof of Theorem 1 is derived from the following lemma which is similar to Gottesman’s
update rules [15].
Lemma 1 (Stabilizer update rules) .Let|ψ⟩be a state of a stabilizer code C(S)with length nand
assume that the Pauli operator M∈ Pnis measured with outcome o∈ {− 1,+1}. Then, the following
holds.
1. If±M∈ ⟨S⟩, the outcome of the measurement of Mis±1and the state of the system is
unchanged after measurement.
2. If±M /∈ ⟨S⟩andMcommutes with all the elements of S. Denote S′=S ∪ { M}.
•For all outcomes o∈ {+1,−1}there exists a state of C(S)such that the measurement of
Mhas outcome owith non-zero probability.
•For all states |ψ′⟩inC(S′)there exists a state |ψ⟩ ∈C(S)such that the measurement of
Mprojects |ψ⟩onto|ψ′⟩with non-zero probability.
3. If±M /∈ ⟨S⟩andManti-commutes with an element S1of⟨S⟩. Let S1, S2, . . . , S rbe a
generating set for ⟨S⟩such that S2, . . . , S rcommute with M. Denote S′={M, S 2, . . . , S r}.
•For all outcomes o∈ {+1,−1}there exists a state of C(S)such that the measurement of
Mhas outcome owith non-zero probability.
•For all states |ψ′⟩inC(S′)there exists a state |ψ⟩ ∈C(S)such that the measurement of
Mprojects |ψ⟩onto|ψ′⟩with non-zero probability.
Proof.The first item is an immediate consequence of the postulates of quantum mechanics.
Consider the second item. For the state |ψo⟩=I+(−1)oM
2|ψ⟩where |ψ⟩is a state of C(S),
the outcome of the measurement Misowith probability 1 proving the first part. Moreover, the
measurement of Mmaps any state |ψ′⟩ofC(S′)onto itself with probability 1.
It remains to prove the third item. Consider a set of logical operators ¯X1,¯Z1, . . . , ¯Xk,¯Zkof
the stabilizer code C(S). Without loss of generality, we can assume that all these logical operators
commutewith M. Otherwise, ifalogicaloperator Lanti-commuteswith M, replace LbyLS1which
is another representative of the same logical operator. Therefore, the operators ¯X1,¯Z1, . . . , ¯Xk,¯Zk
also form a basis of logical operators for the code C(S′).
Consider the logical state |¯x⟩in the stabilizer code C(S)where x∈Zk
2. It is the state of
C(S)fixed by the operators (−1)xi¯Zi. This state is mapped onto the logical state |¯x⟩ofC(S′)
with probability 1/2. To see this, denote Sx=S ∪ { (−1)x1¯Z1, . . . , (−1)xk¯Zk}. Then, |¯x⟩⟨¯x|=
2−nP
S∈SxSand the measurement of Mproduces the outcome owith probability
trI+ (−1)oM
2|¯x⟩⟨¯x|
= 2−(n+1)
trX
S∈⟨Sx⟩S+ (−1)otrX
S∈⟨Sx⟩MS
= 1/2·
15Indeed, the first sum isP
S∈⟨Sx⟩S= 2nbecause all the Pauli operators are traceless except the
identity which has trace 2n. The second sum is trivial because MS=±Iwould imply ±M /∈ Sx
which is impossible because Manti-commute with Sx.
Therefore, we demonstrated the existence of a state |¯x⟩ofC(S)which leads both measurement
outcomes o= 0or1with probability 1/2. Moreover, its image when the outcome is trivial is the
state|¯x⟩of the code C(S′). Therefore, we can reach any of the basis state |¯x⟩ofC(S′)from some
state of C(S)by measuring M. By linearity of the projection, this proves that one can reach any
state of the code C(S′).
Proof of Theorem 1. Based on Lemma 1, the set of states that belong to the output of the subcircuit
(C1, . . . , C i−1)is a stabilizer code. Moreover, a set of stabilizer generators Si−1for this code is
computed by updating the stabilizer generators of the circuit after each operation as in Algorithm 1.
If the operator Ciis the measurement of an operator Sjsuch that neither Sjnor−Sjbelong to
the stabilizer group of the outcome of the circuit (C1, . . . , C i−1), then the outcome ojcan be either
0 or 1. However, if ±Sjbelongs to the stabilizer group, its outcome is constrained and this defined
a check of the affine code. This check is computed in Algorithm 1.
Without loss of generality, we can assume that the outcome code O(C)of a Clifford circuit not
only an affine subspace but also a proper Z2-linear code. Indeed, replacing the measured operator
Sjby−Sjfor all the measurements such that −Sj∈ ⟨S⟩in Algorithm 1 makes all the checks linear
without modifying the output of the circuit. This leads to the following corollary.
Corollary 2 (Linearization of the outcome code) .LetCbe a Clifford circuit and C′the circuit
obtained by running Algorithm 1, replacing Sjby−Sjupon encountering condition −Sj∈ ⟨S⟩.
Then the outcome code of C′is a linear code.
For all remaining sections, we assume that the outcome code O(C)is linear. For obvious reasons,
we may refer to a vector of O(C)⊥as a check of the outcome code O(C). The outcome code can be
immediately used to correct faults in a quantum circuit. Indeed, if a fault configuration induces a
flip of some of the circuit outcomes, then it can be detected using the values of the checks of the
outcome code.
5 The spacetime code of a Clifford circuit
As a linear code, the outcome code provides natural means of detecting and correcting errors in
the classical bit-string of measurement outcomes of a circuit. However, we also need to correct the
output qubits of the circuit. In order to correct qubit errors, we need a way of mapping syndromes
of the outcome code back on to corresponding qubit errors, i.e., a circuit decoder. One way to
build this map is to construct a lookup table by enumerating combinations of faults recording their
syndrome. But this approach scales exponentially with circuit size, and so is feasible only for small
circuits.
Instead, we might hope to leverage existing techniques for constructing decoders for stabilizer
codes. In this setting, we imagine that Pauli errors can occur on qubits, but syndrome information
is obtained perfectly. Contrast this with the circuit setting in which errors can occur on any
component, including measurement outcomes.
16In this section, we introduce a stabilizer code, the spacetime code, associated with a Clifford
circuit. We then show that the problem of correcting faults in the circuit reduces to the problem of
correcting Pauli errors in this stabilizer code.
5.1 Definition of check operators
Here, we define the check operators that are the stabilizers of the spacetime code.
Itisconvenienttointroduceanothernotationfrom[2]. Thefaultoperator F∈Pn(∆+1)obtained
by placing a n-qubit Pauli operator Pat level ℓ+ 0.5is denoted ηℓ+0.5(P). By definition, we have
Fℓ+0.5=PandFℓ′+0.5=Ifor all ℓ′̸=ℓ.
For any vector u∈ O(C)⊥, define the check operator to be the back-cumulant← − − −F(u)of the fault
operator
F(u) =mY
j=1ηℓj−0.5(Suj
j) (20)
Recall that S1, . . . , S mare the mmeasured operators of the circuit and Sjis measured at level
ℓj. In other words, F(u)is the fault operator obtained by placing each measured operator Sjwith
uj= 1at the level right before it is measured.
One may prefer to use a cumulant instead of a back-cumulant. Then, we can define the check
operators as− − − →F′(u)where
F′(u) =mY
j=1ηℓj+0.5(Suj
j)· (21)
The definition is discussed in Appendix E where we prove that← − − −F(u) =− − − →F′(u)for vectors uofO(C)⊥.
We prefer using← − − −F(u)because it makes some proofs more straightforward. What makes the back-
accumulator natural is the fact that it is the adjoint of the accumulator (Proposition 3). Informally,
this means that we can replace the propagation of faults by the backpropagation of measurements.
We will make this claim rigorous throughout this section.
Proposition 4. The map u7→← − − −F(u)is an injective group morphism from Zm
2toPn(∆+1).
Proof.For all u, v∈Zm
2, the operators F(u)andF(v)satisfy F(u)F(v) =F(u+v). Combined with
Eq. (15), this leads to← − − −F(u)← − −F(v) =← − − − − − −F(u+v)which proves that u7→← − − −F(u)is a group morphism. It is
injective as the composition of an injective map u7→F(u)and a bijection F7→← −F(Corollary 1).
We will use extensively the relation← − − − − − −F(u+v) =← − − −F(u)← − −F(v)which is a consequence of Proposi-
tion 4.
5.2 The spacetime code
The following theorem proves that the check operators← − − −F(u)form a stabilizer group. We refer to
the corresponding stabilizer code as the spacetime code of the circuit, denoted Q(C).
17Theorem 2 (The spacetime code) .LetCbe a Clifford circuit with depth ∆. Then, the set of all
the check operators← − − −F(u)foru∈ O(C)⊥is a stabilizer group. Moreover, if the outcome code O(C)
of the circuit has parameters [m, k], the spacetime code of the circuit Q(C)has parameters [[N, K ]]
withN=n(∆ + 1)andK=N−(m−k).
Proof.Based on Proposition 4, the set of operators of the form← − − −F(u)with u∈ O(C)⊥is a subgroup
ofPn(∆+1). Proposition 9 proves that this subgroup is commutative. Moreover, it cannot contain
−Ibecause the map u7→← − − −F(u)with value in Pn(∆+1)is injective. Indeed, if there exists u̸= 0
such that← − − −F(u) =−I, then modulo a phase we have← − − −F(u) =← − −F(0)which contradicts the injectivity.
Another consequence of the injectivity is that the rank of the image stabilizer group is equal to the
dimension of O(C)⊥which is m−k. This provides the stabilizer code parameters.
5.3 Application to the correction of circuit faults
Here, we use the spacetime code to show that one can reduce the problem of correcting circuit faults
to the correction of Pauli errors in a stabilizer code.
We consider a set of checks u1, . . . , u rfor the outcome code O(C)of a Clifford circuit. The
syndrome map associated with these checks is denoted
σO:Zm
2→Zr
2.
Recall that the ith syndrome bit of a vector v∈Zm
2is(ui|v). We consider the spacetime code Q(C)
with stabilizer generators← − − −F(u1), . . . ,← − − −F(ur). The corresponding syndrome map is denoted
σQ:Pn(∆+1)−→Zr
2
and the ith syndrome bit of a Pauli error F∈Pn(∆+1)is[← − − −F(ui), F].
An MLE decoder for the stabilizer code Q(C)is a map
DQ:Zr
2−→Pn(∆+1)
that returns a most likely Pauli error given a syndrome σQ(F). Here, we consider Pauli errors
according to the distribution PFof circuit faults.
Finally, recall that the effect of a fault operator Fin a circuit is obtained from a map
eff :Pn(∆+1)−→Zm
2×Pn
that maps a fault operator onto its corresponding outcome bit-string and the output state.
Theorem 3 (Circuit decoder from stabilizer code decoder) .LetCbe a Clifford circuit. If DQis a
MLE decoder for stabilizer code Q(C), then eff◦DQ◦σOis a MLF circuit decoder for the circuit C.
We first prove a lemma. Recall that ρMdenotes the n-qubit maximally mixed state. The
indicator function of a set Ais denoted δA. It takes the value δA(x) = 1ifx∈Aand 0 otherwise.
Lemma 2. LetCbe a Clifford circuit and let Fbe a fault operator with effect eff(F) = ( f, E). If
O(C)is the outcome code of C, then we have
P(F)
C,ρM(o) =1
2kδf+O(C)(o) (22)
where k= dim O(C).
18Proof.Consider first the case of a trivial fault operators F=I. Then, we know from Theorem 1
that the set of outcomes owith non-zero probability is a subset of the outcome code O(C). The
main difference with Theorem 1 is that we restrict the input state to be the maximally mixed state.
The unitary operations of the circuit preserve the maximally mixed states and applying a Pauli
measurement to the maximally mixed state returns a uniform outcome and the post-measurement
state is the maximally mixed state. This proves that all outcome bit-strings of O(C)can occur when
the input state of the circuit is fixed to be the maximally mixed state ρM. Moreover, they occur
with the same probability. This proves that
P(I)
C,ρM(o) =1
2kδO(C)(o)·
Injecting Fin the circuit shifts the outcome bit-string obyf, which leads to the shifted indicator
function in the lemma.
Proof of Theorem 3. We need to prove that for all o∈Zm
2, the fault operator F=DQ◦σO(o)
maximizes the function QMLF(F, o)introduced in Eq. (3). First, denote (f, E) = eff( F). Based on
Lemma 2, we have
QMLF(F, o) =1
2kδf+O(C)(o)PF(F) (23)
which means that one can maximize QMLF(F, o)by selecting a fault operator Fsuch that o∈
f+O(C)that has maximum probability PF(F). The condition o∈f+O(C)is equivalent to
σO(f) =σO(o). Finally, Lemma 4, we know that σO(f) =σQ(F). Overall, we showed that a MLF
decoder for the circuit Cis a circuit decoder that returns the effect of a fault operator Fsuch that
σQ(F) =σO(o)with maximum probability. Therefore the map eff◦DQ◦σOis a MLF decoder.
5.4 Beyond MLF circuit decoders
A MLF decoder is sometimes good enough but it ignores the fact that two fault operators may
have the same effect and two residual errors that differ in an output stabilizer can be considered
equivalent.
In some cases one may prefer a most likely coset decoder (MLC decoder), which is defined to
be a circuit decoder that takes as an input an outcome bit-string oand returns a pair (ˆf,ˆE)that
maximizes the sum
QMLC(ˆf,ˆE, o) =X
E′∈ˆE⟨So⟩X
ˆF∈Pn(∆+1)
eff(ˆF)=(ˆf,E′)P(ˆF)
C,ρM(o)PF(ˆF)· (24)
Wherein, ˆE⟨So⟩denotes the coset of ˆEin the output stabilizer group. Based on Eq. (4), this sum
is proportional with the sum of the probabilities of all the fault operators that leads to an effect
(ˆf, E′)where the Pauli error E′is equivalent to ˆEup to a stabilizer of the output code.
One can design a MLC decoder using a subsystem version of the spacetime code obtained by
gauging logical operators which correspond to faults with trivial effect. Namely, one can define a
subsystem code from the union of two sets of gauge operators: (i) the operators G(P, ℓ), defined
by Eq. (25), for each ℓand for each Pthat commutes with all the measurements at level ℓand
(ii) the operators ηℓj−0.5(Sj)where Sjis an operator measured at level ℓj. Then, the center of the
19gauge group is the stabilizer group of the spacetime code. Equivalently, the subsystem spacetime
code can be seen as a variant of the stabilizer spacetime code obtained by gauging the logical qubits
corresponding to the operators G(P, ℓ)such that Pcommutes with all the measured operators at
level ℓ. This subsystem code can be seen as a generalization of the circuit-to-code construction
proposed in [2]. Here we consider circuits including intermediate measurements and multi-qubit
measurement whereas [2] focuses on post-selection circuits.
Then, one could design a a MLC decoder from a decoder for the subsystem spacetime code that
returns a most likely coset of the gauge group. We do not expand on this strategy because designing
a most likely coset for a subsystem code is generally challenging. In what follows, we focus on the
strategy suggested by Theorem 3 and we use decoders for the stabilizer spacetime code.
6 LDPC spacetime code
To obtain a complete scheme for the correction of faults in a Clifford circuit, we need to provide
a decoder. However, decoding a general code is quite difficult. Indeed, the maximum likelihood
decoding problem is NP-hard for linear codes [3] and #P-hard for stabilizer codes [18]. However,
someclassesofcodessuchasLDPCcodes, whicharedefinedbylow-weightchecks, admitanefficient
decoder with good performance [12].
Here, we consider restrictions induced by a limited connectivity in the quantum hardware im-
plementing the circuit. This imposes constraints on the spacetime code which, in some cases, make
it easier to decode. Our basic idea is to produce a set of low-weight stabilizer generators for the
spacetime code and to use an LDPC code decoder.
6.1 Qubit connectivity and LDPC spacetime codes
Because the back-cumulant can spread errors through the entire circuit, the check operators← − − −F(u)
are not expected to have low weight. However, if the circuit connectivity is limited, then then
back-cumulant does not spread F(u)as quickly. Below we identify sufficient conditions that ensure
that the spacetime code admit low-weight generators.
A family of stabilizer codes is said to be LDPCif each stabilizer group admit generators acting
onO(1)qubits. A family of stabilizer codes is said to be D-dimensional local if the nqubits of the
codes can be mapped onto the vertices of a D-dimensional grid ZDin such a way that the stabilizer
generators are all supported on a ball with radius O(1)in the grid. D-dimensional local codes are
a subset of quantum LDPC codes.
The depth of an outcome bit-string u∈Zm
2, denoted depth( u)is defined as
depth( u) = max {ℓj|uj= 1} −min{ℓj|uj= 1}+ 1·
Recall that ℓjis the level of the jth measurement of the circuit. The measurements indexed by j
satisfying uj= 1are supported in a subset of depth( u)consecutive levels of the circuit C.
A family of circuits is said to be bounded if the outcomes codes of the circuits admit a set of
checks with weight O(1)and depth O(1).
Proposition 5 (LDPC spacetime codes) .Let(Ct)t∈Nbe a family of Clifford circuits. If the family
of circuits is bounded and if all circuit operations act on O(1)qubits, then the spacetime codes of
the circuits are LDPC.
20Proof.The stabilizer group of the spacetime code is generated by the check operators← − − −F(ui)corre-
sponding to the generators u1, . . . , u rofO(Ct)⊥with bounded depth. By Lemma 8, the stabilizer
generators← − − −F(ui)have support on O(1)levels. Moreover, because the circuits are bounded, the
weight of F(u)is bounded. Back-accumulating F(u)through a circuit made with operations acting
onO(1)qubits leads to a bounded weight operator← − − −F(u).
Proposition 6 ((D+ 1)-dimensional spacetime codes) .Let(Ct)t∈Nbe a family of Clifford circuits
acting on qubits placed on a D-dimensional grid ZD. If the family of circuits is bounded and if all
circuit operations act on qubits separated by a distance O(1), then the spacetime codes of the circuits
are(D+ 1)-dimensional local.
Proof.By the same argument as in the proof of Proposition 5, the stabilizer generators← − − −F(u)are
obtained by back-accumulation of bounded weight operators F(u). Because the back-cumulant goes
through local operations in Ddimensions, this results in local generators in (D+1)dimensions.
6.2 Restriction of a stabilizer to a subset of qubits
To generate low-weight generators for a spacetime code, we will first consider a simpler task. We are
given a stabilizer group ⟨S⟩with length nand a subset A⊂ {1, . . . , n }of the qubits. Our objective
is to compute a generating set for the subgroup of operators S∈ ⟨S⟩whose support is included in
A.
Let us first describe a naive solution. Assume that we are given a set of stabilizer generators
S=S1, . . . , S r. It suffices to solve the linear system with the n− |A|equations
rY
i=1(Si,j)λi=I
in the rvariables λ1, . . . λ r∈Z2where Si,j∈P1is the jth component of Siandjvaries over
{1, . . . , n }\A. Using Gaussian elimination, the complexity of this approach is cubic in n.
This scaling may be too slow for large circuits. We can achieve a more favorable complexity
in the case of a small subset Ausing the following proposition. Before describing our solution, we
need to introduce some notations.
Therestriction of a Pauli operator P∈Pnto a subset of qubits Ais the operator P|Aobtained
by setting all the components of Poutside of AtoI. Therestriction of a subgroup GofPnto
the subset A, denoted G|A, is the set that contains the restrictions of all the operators of G. For
example, the set of n-qubit Pauli operators supported on a subset Aof{1, . . . , n }isPn|A.
The following proposition yields a more efficient way to compute the restriction of a stabilizer
group to a small subset of qubits. Recall that we use the notation G⊥for the set of Pauli operators
that commutes with the operators included in the subset GofPn. For a stabilizer code S, the set
S⊥is the set of logical operators of the code.
Proposition 7 (Restricted stabilizer subgroup) .Let⟨S⟩be a length- nstabilizer code with stabilizer
generators S={S1, . . . , S r}and logical operators ¯X1,¯Z1, . . . , ¯Xk,¯Zk. Let A⊂ {1, . . . , n }. A Pauli
operator Pwith support contained in Ais a stabilizer iff it commutes with the restricted operators
S1|A, . . . , S r|A,¯X1|A,¯Z1|A, . . . , ¯Xk|A,¯Zk|A.
21Proof.A Pauli operator Pbelongs to the stabilizer group ⟨S⟩iff it commutes with all the stabilizer
generators and logical operators of the code, that is iff [P, L] = 0for all L∈ S⊥. The commutator
can be decomposed as a sum over Aand its complement AC,
[P, L] = [P, L|A] + [P, L|AC].
For a Pauli operator Pwith support contained in Awe have [P, L|AC] = 0and therefore [P, L] =
[P, L|A].
Based on Proposition 7, we design Algorithm 2 which returns a set of generators for the restric-
tion of a stabilizer group to a subset of qubits. If each qubit is acted on by O(1)stabilizer generators
SiandO(1)logical operators, the matrix Gobtained at the end of line 2 has size O(|A|)×O(|A|)
and it can be constructed in O(|A|2)bit operations. Then, the most expensive subroutine of Algo-
rithm 2 is the transformation of the matrix Gin reduced row echelon form which can be done in
O(|A|3)bit operations using Gaussian elimination.
Algorithm 2: Restricted Stabilizer group
input : A set of stabilizer generators S={S1, . . . , S r}and logical operators
¯X1,¯Z1, . . . , ¯Xk,¯Zkfor a stabilizer code with length n.
output: A generating set for the restriction of ⟨S⟩to a subset A⊂ {1, . . . , n }.
1Construct a Pauli matrix Gwhose rows are the restricted operators of the form
S1|A, . . . , S r|A, X1|A,¯Z1|A, . . . , ¯Xk|A,¯Zk|A.
2Remove the rows supported on the complement ACofAand the trivial rows of G.
3PutGin reduced row echelon form (using Gaussian elimination).
4Using the reduced row echelon form of G, construct a Pauli matrix Hwhose rows satisfy
[Hi,Gj] =δi,j.
5Construct a Pauli matrix S′whose rows are the 2|A|single-qubit operators Xi, Zifori∈A.
6foreach row S′
iofS′do
7foreach row HjofHdo
8 if[S′
i,Gj] = 1then
9 Multiply S′
ibyHj.
10returnthe rows of S′.
6.3 Construction of low-weight generators for the spacetime code
To find a set of low-weight generators for a given stabilizer group, one could apply Algorithm 2 to
all subsets of wqubits with w= 1,2, . . .until there are enough generators to span the full stabilizer
group. In this section, we show that one can use some information about the structure of spacetime
code to help probe the right subsets of qubits and generate low-weight stabilizer generators.
Thespacetime graph of a circuit is a graph with vertex set V={1, . . . , n }×{0.5,1.5, . . . , ∆−0.5}
corresponding to the qubits supporting the fault operators except the last level. The edges of the
spacetime graph are constructed by looping over all the operations of the circuit and for each
operation with level ℓacting on qubits qi1, . . . , q it, connecting together all the qubits of the form
(q, ℓ−0.5)or(q, ℓ′+ 0.5). An operation acting on wqubits induces a clique with 2wvertices
supported on level ℓ−0.5andℓ+ 0.5. If the circuit is made with operations acting on at most w
qubits, the maximum degree of the spacetime graph is upper bounded by 2(2w−1).
22A stabilizer of a stabilizer code is said to be connected if its support is connected in the spacetime
graph. In Appendix F, we prove Proposition 12 that the restriction of a stabilizer of the spacetime
code to any connected component of its support is a stabilizer. This proves that stabilizers of the
spacetime code can be decomposed as products of connected stabilizers. Instead of running over all
subsets of qubits, Algorithm 3 returns all the connected stabilizers of a spacetime code by running
over the neighborhoods of vertices in the space time graph.
Proposition 8. LetCbe a Clifford circuit. Then Algorithm 3 returns all the connected stabilizers
of the space time code with weight up to M.
Algorithm 3: Low weight stabilizers of a spacetime code
input : A Clifford circuit C. An integer M.
output: A set containing all the connected stabilizers of the spacetime code of Cwith
weight ≤M.
1SetSM={}.
2Construct a set of generators {u1, . . . , u r}of the code O(C)⊥using Algorithm 1.
3Construct the set Sof stabilizer generators Si=← − − −F(u1)of the spacetime code.
4Construct a set of logical operators ¯X1,¯Z1, . . . , ¯XK,¯ZKof the spacetime code.
5Construct the spacetime graph G= (V, E)ofC.
6forall vertices v∈Vdo
7LetAbe the set of vertices of Gat distance ≤ ⌊M/2⌋from v.
8Using Algorithm 2, compute a set S(A)of generators of ⟨S⟩restricted to A.
9forall vectors Fof⟨S(A)⟩with weight |F| ≤Mdo
10 Compute the connected components of the support of F.
11 If the support of Fhas a single connected component, add FtoSM.
12return SM.
In the case of a depth- ∆circuit acting on nqubits with operations acting on at most wqubits,
Algorithm 3 explores n∆subsets Aof qubits with size at most |A| ≤1 +P⌊M/2⌋
i=1 δ(δ−1)i−1.where
δ= 2(2 w−1)is the degree of the spacetime graph.
The proof of Proposition 8 provided below relies on Proposition 12.
Proof.Any connected stabilizer is supported on a connected subgraph of the spacetime graph. As
a result, any connected stabilizer with weight ≤Mis included in a ball with radius ⌊M/2⌋of the
spacetime. This guarantees that it will be discovered by Algorithm 3.
7 Conclusion
We proposed an efficient and versatile strategy for the correction of circuit faults in Clifford circuits
by reducing to error correction of a stabilizer code. The main advantage of our approach is its
flexibility. It applies to any Clifford syndrome extraction circuit, including those of topological codes
and Floquet codes, and eliminates the tedious step of mapping circuit outcomes to corresponding
syndromes. It also applies to general Clifford circuits which are not necessarily based on a quantum
code.
23Our scheme can be used to automatically generate low-weight checks in Clifford circuits. Alter-
natively, it may be useful as a compilation tool for detecting and removing redundancy in a Clifford
circuit, thereby reducing circuit size. Adapting Algorithm 1 for this task is immediate.
In the future, our scheme may be improved by designing a decoder that exploits the equivalence
between different fault configurations like in the work of Pryadko [22]. Design of better decoders
for quantum LDPC codes may also improve our scheme.
Conceptually, our work emphasizes and formally captures a circuit-centric approach of quantum
errorcorrectionandfaulttolerance. Thiscircuit-centricapproachiscentraltoFloquetcodes[17]and
has also lead to new ideas for surface codes [19]. Our formalism could be used to take this approach
further by, for example, searching over the space of quantum codes and circuits. In particular,
machine learning techniques which were limited to Kitaev’s codes in [20] could be expanded to a
much broader range of codes and circuits.
Acknowledgements
We would like to thank David Aasen, Michael Beverland, Jeongwan Haah, Vadym Kliuchnikov and
Marcus Silva for insightful discussions. We thank Rui Chao for his comments.
References
[1] Scott Aaronson and Daniel Gottesman. Improved simulation of stabilizer circuits. Physical
Review A , 70(5):052328, 2004.
[2] Dave Bacon, Steven T Flammia, Aram W Harrow, and Jonathan Shi. Sparse quantum codes
from quantum circuits. In Proceedings of the forty-seventh annual ACM symposium on Theory
of Computing , pages 327–334, 2015.
[3] Elwyn Berlekamp, Robert McEliece, and Henk Van Tilborg. On the inherent intractability of
certain coding problems (corresp.). IEEE Transactions on Information Theory , 24(3):384–386,
1978.
[4] Hector Bombin and Miguel Angel Martin-Delgado. Topological quantum distillation. Physical
review letters , 97(18):180501, 2006.
[5] Sergey Bravyi and Jeongwan Haah. Quantum self-correction in the 3d cubic code model.
Physical review letters , 111(20):200501, 2013.
[6] Sergey Bravyi and Alexei Kitaev. Universal quantum computation with ideal clifford gates and
noisy ancillas. Physical Review A , 71(2):022316, 2005.
[7] Rui Chao, Michael E Beverland, Nicolas Delfosse, and Jeongwan Haah. Optimization of the
surface code design for majorana-based qubits. Quantum , 4:352, 2020.
[8] Nicolas Delfosse, Vivien Londe, and Michael E Beverland. Toward a union-find decoder for
quantum ldpc codes. IEEE Transactions on Information Theory , 2022.
[9] NicolasDelfosseandNaomiHNickerson. Almost-lineartimedecodingalgorithmfortopological
codes.Quantum , 5:595, 2021.
24[10] Eric Dennis, Alexei Kitaev, Andrew Landahl, and John Preskill. Topological quantum memory.
Journal of Mathematical Physics , 43(9):4452–4505, 2002.
[11] Austin G Fowler, Matteo Mariantoni, John M Martinis, and Andrew N Cleland. Surface codes:
Towards practical large-scale quantum computation. Physical Review A , 86(3):032324, 2012.
[12] Robert Gallager. Low-density parity-check codes. IRE Transactions on information theory ,
8(1):21–28, 1962.
[13] Craig Gidney. Stim: a fast stabilizer circuit simulator. Quantum , 5:497, 2021.
[14] Craig Gidney. A pair measurement surface code on pentagons. arXiv preprint
arXiv:2206.12780 , 2022.
[15] Daniel Gottesman. The heisenberg representation of quantum computers. arXiv preprint
quant-ph/9807006 , 1998.
[16] Daniel Gottesman. Opportunities and challenges in fault-tolerant quantum computation, 2022.
[17] Matthew B Hastings and Jeongwan Haah. Dynamically generated logical qubits. Quantum ,
5:564, 2021.
[18] Pavithran Iyer and David Poulin. Hardness of decoding quantum stabilizer codes. IEEE
Transactions on Information Theory , 61(9):5209–5223, 2015.
[19] Matt McEwen, Dave Bacon, and Craig Gidney. Relaxing hardware requirements for surface
code circuits using time-dynamics. arXiv preprint arXiv:2302.02192 , 2023.
[20] Hendrik Poulsen Nautrup, Nicolas Delfosse, Vedran Dunjko, Hans J Briegel, and Nicolai Friis.
Optimizing quantum error correction codes with reinforcement learning. Quantum , 3:215, 2019.
[21] Pavel Panteleev and Gleb Kalachev. Degenerate quantum ldpc codes with good finite length
performance. Quantum , 5:585, 2021.
[22] Leonid P Pryadko. On maximum-likelihood decoding with circuit-level errors. Quantum , 4:304,
2020.
[23] Matthew J Reagor, Thomas C Bohdanowicz, David Rodriguez Perez, Eyob A Sete, and
William J Zeng. Hardware optimized parity check gates for superconducting surface codes.
arXiv preprint arXiv:2211.06382 , 2022.
[24] Joschka Roffe, David R. White, Simon Burton, and Earl Campbell. Decoding across the
quantum low-density parity-check code landscape. Physical Review Research , 2(4), Dec 2020.
A Outcomes of the check operators
This section relates the value of a check of the outcome code to the measurement outcome of a
check operator, justifying the definition of check operators. The first lemma provides a description
of the outcomes flipped by a set of faults as a commutator of the corresponding fault operator.
25Lemma 3 (Outcome flip) .LetFbe a fault operator. The faults corresponding to Finduce a flip
of the measurement of Sjiff[− →F , η ℓj−0.5(Sj)] = 1.
Proof.Based on Proposition 1, the faults represented by Finduce a flip of the outcome of Sjiff
[− →Fℓj−0.5, Sj] = 1and because ηℓj−0.5(Sj)is trivial except at level ℓj−0.5, we have [− →Fℓj−0.5, Sj] =
[− →F , η ℓj−0.5(Sj)].
The following Lemma shows that measurement of a check operator returns the value of the
corresponding check of the outcome code.
Lemma 4 (Check operator outcome) .LetFbe a fault operator. The faults corresponding to F
induce a flip of an outcome check u∈ O(C)⊥iff[F,← − − −F(u)] = 1.
Proof.By definition of F(u), we have
[F,← − − −F(u)] = [ F,← − − − − − − − − − − −mY
j=1ηℓj−0.5(Suj
j)]
which leads to
[F,← − − −F(u)] = [ F,mY
j=1← − − − − − − − −
ηℓj−0.5(Suj
j)] Using Eq. (15)
=mX
j=1[F,← − − − − − − − −
ηℓj−0.5(Suj
j)] Using Eq. (17)
=mX
j=1[− →F , η ℓj−0.5(Suj
j)] By Proposition. 3
By Lemma. 3, this last sum coincides with the checkP
jujojof the outcome code corresponding
to the vector u.
The next lemma states that an error Sjright before or right after the measurement of Sjdoes
not flip any of the check operator outcomes.
Lemma 5 (Stabilizer error) .For all u∈ O(C)⊥and for all measured operators Sj, we have
[ηℓj±0.5(Sj),← − − −F(u)] = 0 .
Proof.Because Sjbelongs to the stabilizer group of the system right after level ℓj, the faults
corresponding to ηℓj+0.5(Sj)do not flip any of the checks of the outcome code. Based on Lemma 4,
this leads to the lemma for the sign ℓj+ 0.5. The same result holds for ℓj−0.5because a fault Sj
after the measurement of Sjis equivalent to a fault Sjbefore this measurement.
A Pauli error on the input state also keeps the check operator outcomes trivial.
Lemma 6 (Input error) .For all u∈ O(C)⊥and for all P∈Pn, we have [η0.5(P),← − − −F(u)] = 0 .
Proof.An fault Pon the input state of the circuit cannot flip the value of a check because the
outcome code O(C)is the set of checks for all possible input states. Based on Lemma 4, this implies
[η0.5(P),← − − −F(u)] = 0for all check uof the outcome code.
26B Commutation of the check operators
The goal of this section is to prove that check operators are pairwise commuting. More precisely,
we show by induction on ℓthat [← − − −F(u)ℓ+0.5,← − −F(v)ℓ+0.5] = 0for all ℓ.
Proposition 9. LetCbe a Clifford circuit. For all u, v∈ O(C)⊥, we have [← − − −F(u),← − −F(v)] = 0 .
Proof.Based on Eq. (18), we have
[← − − −F(u),← − −F(v)] =∆X
ℓ=0[← − − −F(u)ℓ+0.5,← − −F(v)ℓ+0.5]
In the remainder of this proof, we demonstrate by induction on ℓ(in decreasing order) that
[← − − −F(u)ℓ+0.5,← − −F(v)ℓ+0.5] = 0for all ℓ.
Forℓ= ∆, by definition we have F(u)∆+0.5=F(v)∆+0.5=Iand therefore← − − −F(u)∆+0.5=← − −F(v)∆+0.5=Iwhich yields [← − − −F(u)∆+0.5,← − −F(v)∆+0.5] = 0.
Assume now that [← − − −F(u)ℓ+1.5,← − −F(v)ℓ+1.5] = 0and let us prove that [← − − −F(u)ℓ+0.5,← − −F(v)ℓ+0.5] = 0.
Using Proposition 2 and Eq. (11), we find
← − − −F(u)ℓ+0.5=∆Y
j=ℓU−1
ℓ,jF(u)j+0.5Uℓ,j
=F(u)ℓ+0.5∆Y
j=ℓ+1U−1
ℓ,jF(u)j+0.5Uℓ,j
=F(u)ℓ+0.5∆Y
j=ℓ+1(Uℓ+1,jUℓ,ℓ+1)−1F(u)j+0.5Uℓ+1,jUℓ,ℓ+1
=F(u)ℓ+0.5U−1
ℓ,ℓ+1
∆Y
j=ℓ+1U−1
ℓ+1,jF(u)j+0.5Uℓ+1,j
Uℓ,ℓ+1
=F(u)ℓ+0.5U−1
ℓ,ℓ+1← − − −F(u)ℓ+1.5Uℓ,ℓ+1
The same holds for v, that is← − −F(v)ℓ+0.5=F(v)ℓ+0.5U−1
ℓ,ℓ+1← − −F(v)ℓ+1.5Uℓ,ℓ+1.Using these expressions
for← − − −F(u)ℓ+0.5and← − −F(v)ℓ+0.5and applying Eq. (17), we obtain
[← − − −F(u)ℓ+0.5,← − −F(v)ℓ+0.5] = [F(u)ℓ+0.5, F(v)ℓ+0.5]
+ [U−1
ℓ,ℓ+1← − − −F(u)ℓ+1+0 .5Uℓ,ℓ+1, U−1
ℓ,ℓ+1← − −F(v)ℓ+1+0 .5Uℓ,ℓ+1]
+ [F(u)ℓ+0.5, U−1
ℓ,ℓ+1← − −F(v)ℓ+1+0 .5Uℓ,ℓ+1]
+ [U−1
ℓ,ℓ+1← − − −F(u)ℓ+1+0 .5Uℓ,ℓ+1, F(v)ℓ+0.5]·
Let us show that each of these four terms is trivial. The first one [F(u)ℓ+0.5, F(v)ℓ+0.5]is trivial by
definition of the F(u)andF(v). Using Eq. (19) and the induction hypothesis, we get
[U−1
ℓ,ℓ+1← − − −F(u)ℓ+1.5Uℓ,ℓ+1, U−1
ℓ,ℓ+1← − −F(v)ℓ+1.5Uℓ,ℓ+1] = [← − − −F(u)ℓ+1.5,← − −F(v)ℓ+1.5] = 0
27proving that the second term is trivial. Because the operator Uℓ,ℓ+1is the product of the unitary
gates at level ℓ+ 1andF(u)ℓ+0.5andF(v)ℓ+0.5corresponds to measurements at the same level, the
support of Uℓ,ℓ+1cannot overlap with the supports of F(u)ℓ+0.5andF(v)ℓ+0.5. As a result Uℓ,ℓ+1
acts trivially on F(u)ℓ+0.5andF(v)ℓ+0.5. Therefore, we have
[F(u)ℓ+0.5, U−1
ℓ,ℓ+1← − −F(v)ℓ+1+0 .5Uℓ,ℓ+1] = [Uℓ,ℓ+1F(u)ℓ+0.5U−1
ℓ,ℓ+1,← − −F(v)ℓ+1.5]
= [F(u)ℓ+0.5,← − −F(v)ℓ+1.5]·
Therein, we used Eq. (19) in the first equality. To see that [F(u)ℓ+0.5,← − −F(v)ℓ+1.5] = 0, write this
commutator as
[F(u)ℓ+0.5,← − −F(v)ℓ+1.5] = [ηℓ+1.5(F(u)ℓ+0.5),← − −F(v)]·
and apply Lemma 5. We can apply this lemma because F(u)ℓ+0.5is a product of some measured
operators Sjwith level ℓj=ℓ+ 1in the circuit. We proved that the third term is trivial. By
symmetry, thefourthtermistrivialbythesameargument. Thisprovesthat [← − − −F(u)ℓ+0.5,← − −F(v)ℓ+0.5] =
0concluding the proof of the proposition.
C Logical operators of the spacetime code
To describe the logical operators of the spacetime code, we introduce some notation. For any
ℓ= 1, . . . , ∆and for any P∈Pn, define the fault operator G(P, ℓ)as
G(P, ℓ) =ηℓ−0.5(P)ηℓ+0.5(Uℓ−1,ℓPU−1
ℓ−1,ℓ)· (25)
These operators satisfy
− − − − →G(P, ℓ) =ηℓ−0.5(P)· (26)
For any vector v∈Zm
2, define the fault operator L(v)as
L(v) =mY
j=1G(Pj, ℓj)vj(27)
where ℓjis the level of the jth measured operator SjandPj∈Pnis an arbitrary Pauli operator
acting on the support of Sjthat anti-commutes with Sj. Because Pjis included in the support of
Sjit commutes with all other measured operators at level ℓj.
Proposition 10. LetCbe a depth- ∆Clifford circuit acting on nqubits. The stabilizers and logical
operators of the spacetime code are generated by the following operators.
•A set of operators η∆+0.5(P)where P∈Pnruns over a basis of Pn.
•A set of operators G(P, ℓ)for all ℓ= 1, . . . , ∆where P∈Pnruns over a basis of the space of
Pauli operators that commutes with all the measured operators at level ℓ.
•A set of operators L(v)where v∈Zm
2runs over a basis of the space O(C).
28The following lemma is used in the proof of the proposition.
Lemma 7. For all u, v∈Zm
2, we have [← − − −F(u), L(v)] = ( u|v).
Proof.
[← − − −F(u), L(v)] = [ F(u),− − →L(v)] By Proposition 3
= [F(u),− − − − − − − − − − →mY
j=1L(Pj, ℓj)vj] By definition of L(v)
= [F(u),mY
j=1− − − − − − − →G(Pj, ℓj)vj] By Eq. (14)
=mX
j=1vj[F(u),− − − − − − →G(Pj, ℓj)] By Eq. (17)
=mX
j=1vj[F(u), ηℓj−0.5(Pj)] By Eq. (26)
=mX
j=1vj[F(u)ℓj−0.5, Pj]
By definition of Pi, we have [F(u)ℓj−0.5, Pj] =ujwhich yields [← − − −F(u), L(v)] = ( u|v).
Proof of Proposition 10. First, let us prove that these three families of operators are logical opera-
tors of the spacetime code, that is that they commute with all stabilizers← − − −F(u)with u∈ O(C)⊥.
The operators of the form η∆+0.5(P)satisfy
[← − − −F(u), η∆+0.5(P)] = [ F(u),− − − − − − − →η∆+0.5(P)]
= [F(u), η∆+0.5(P)]
which is trivial because F(u)is trivial over level ∆ + 0 .5.
For the operators G(P, ℓ), we get
[← − − −F(u), G(P, ℓ)] = [ F(u),− − − − →G(P, ℓ)]
which is equal to [F(u), ηℓ−0.5(P)]by Eq. 26. Because Pcommute with all the measured operators
at level ℓ, we get
[← − − −F(u), G(P, ℓ)] = [ ηℓ−0.5(P), F(u)]
= [F(u)ℓ−0.5, P] = 0·
For the operators L(v), based on Lemma 7 we have [← − − −F(u), L(v)] = ( u|v)and this inner product
is trivial because vis in the code O(C)andubelongs to its dual.
To prove that these three families of operators generate all stabilizers and logical operators, it
is enough to show that the group they generate has rank 2K+Rwhere Kis the number of logical
29qubits of the stabilizer code and Ris the rank of the stabilizer group. For the spacetime code, we
know that K=n(∆ + 1) −randR=r
Denote by L1, L2, L3the subgroups of Pn(δ+ 1)generated by these three sets of operators. We
have L1∩L2={I}because the operators of L2are supported on at least two levels and L1has
support on level ∆ + 0 .5. We also have L1∩L3={I}because the operators of L1cannot flip any
outcome and the only operator of L3that induces no outcome flip is I. The same argument also
shows that L2∩L3={I}. As a result, the rank of the subgroup of Pn(δ+ 1)generated by all the
operators of L1, L2andL3is the sum of the ranks of the three subgroups rank( L1) + rank( L2) +
rank( L3).
It is immediate to see that rank( L1) = 2 n. For a circuit without measurement the rank of L2is
2n∆. The constraint associated with the commutation with each measurement decreases the rank
by1, which yields rank( L2) = 2 n∆−mwhere mis the number of measurements of the circuit.
Finally, the rank of L3is given by the dimension of the outcome code, that is rank( L3) =m−r.
Putting things together this proves that these three sets of operators generate a group with rank
2n(∆ + 1) −rwhich coincides with the value of 2K+R. This proves that this family of operators
generate all stabilizer and logical operators.
D Levels supporting a check operator
In this section, we prove the support of a check operator of the spacetime code is related to the
support of the measurements involved in the corresponding check of the outcome code.
Lemma 8. Letu∈ O(C)⊥be a non-zero vector. Denote by ℓu(respectively ℓ′
u) the minimum
(respectively maximum) level of a measured operator Sjwith uj= 1. Ifℓ < ℓ uorℓ≥ℓ′
uthen we
have← − − −F(u)ℓ+0.5=I.
Proof.By definition of ℓ′
u, for all ℓ≥ℓ′
uthe component F(u)ℓ+0.5is trivial. Applying Proposition 2,
this shows that← − − −F(u)ℓ+0.5is also trivial for all ℓ≥ℓ′
u.
Assume now that ℓ= 0. We know from Lemma 6 that← − − −F(u)commutes with all fault operators
η0.5(P)supported on level 0.5. Because Pcan be any operator of Pn, this implies← − − −F(u)0.5=I.
Consider now the case ℓ < ℓ uand let us prove that← − − −F(u)ℓ+0.5=← − − −F(u)0.5which is the identity.
Applying Proposition 2, we find
← − − −F(u)0.5=∆Y
j=ℓ
U−1
0,jFj+0.5U0,j
because for all j < ℓ, we know that F(u)j+0.5=I. Using Eq. (11), we can write U0,j=Uℓ,jU0,ℓfor
allj≤ℓwhich yields
← − − −F(u)0.5=∆Y
j=ℓ 
(Uℓ,jU0,ℓ)−1Fj+0.5Uℓ,jU0,ℓ
=U−1
0,ℓ∆Y
j=ℓ
U−1
ℓ,jFj+0.5Uℓ,j
U0,ℓ
=U−1
0,ℓ← − − −F(u)ℓ+0.5U0,ℓ·
30Because← − − −F(u)0.5is trivial, this relation implies← − − −F(u)ℓ+0.5=U0,ℓ← − − −F(u)0.5U−1
0,ℓ=I.
E Alternative definition of the check operators
One may prefer to use the cumulant obtained by propagating faults forward instead of the back-
cumulant obtained from the backward propagation of faults. Here, we show that we can obtain the
check operators by propagating forward the fault operators F′(u)defined in Section 5.1.
Proposition 11. Ifu∈ O(C)⊥, then, we have
← − − −F(u) =− − − →
F′(u)· (28)
Let us first prove a lemma.
Lemma 9. Letu∈Zm
2. If← − − −F(u)0.5=Ithen we have
← − − −F(u) =− − − →
F′(u)· (29)
Proof.Let us prove by induction that we have the equality← − − −F(u)ℓ+0.5=− − − →F′(u)ℓ+0.5for all level ℓ.
Forℓ= 0, we have← − − −F(u)0.5=Iby assumption and by definition of the cumulant we have− − − →F′(u)0.5=I.
Assume that the result is true for level ℓ−1<∆. Using Proposition 2, we obtain
− − − →
F′(u)ℓ+0.5=Uℓ− − − →
F′(u)ℓ−0.5U−1
ℓF′(u)ℓ+0.5 (30)
and
← − − −F(u)ℓ−0.5=U−1
ℓ← − − −F(u)ℓ+0.5UℓF(u)ℓ−0.5· (31)
Using the induction hypothesis, we can replace− − − →F′(u)ℓ−0.5by← − − −F(u)ℓ−0.5in Eq. (30) and we can use
Eq. (31) for the value of← − − −F(u)ℓ−0.5. This leads to the equation
− − − →
F′(u)ℓ+0.5=Uℓ← − − −F(u)ℓ−0.5U−1
ℓF′(u)ℓ+0.5
=UℓU−1
ℓ← − − −F(u)ℓ+0.5UℓF(u)ℓ−0.5U−1
ℓF′(u)ℓ+0.5
=← − − −F(u)ℓ+0.5UℓF(u)ℓ−0.5U−1
ℓF′(u)ℓ+0.5
By definition of Uℓacts trivially on F(u)ℓ−0.5implying UℓF(u)ℓ−0.5U−1
ℓ=F(u)ℓ−0.5.Injecting this
in the previous equation produces
− − − →
F′(u)ℓ+0.5=← − − −F(u)ℓ+0.5F(u)ℓ−0.5F′(u)ℓ+0.5
which leads to− − − →F′(u)ℓ+0.5=← − − −F(u)ℓ+0.5because F(u)ℓ−0.5=F′(u)ℓ+0.5by definition.
Proof of Proposition 11. By Lemma 6, we know that← − − −F(u)0.5commutes with all Pauli operators
P∈Pn. The only Pauli operator that satisfies this property is← − − −F(u)0.5=I. Therefore, the
operator← − − −F(u)satisfies the assumption of Lemma 9 which proves the Proposition.
31F The connected components of a stabilizer of the spacetime code
The proof of proposition 8 relies on the following proposition. The proof of this proposition relies
on lemmas proven after the proposition.
Proposition 12. LetSbe a stabilizer for a spacetime code. The restriction S|κofSto a connected
component κof the support of Sin the spacetime graph is a stabilizer of the spacetime code.
Proof.Based on lemma 10, the restriction S|κcan be written as← − −F(v)for some vector v. To show
that this is a stabilizer of the spacetime code, we must show that v∈ O(C)⊥. Denote by ℓ′
vthe
maximum level of a measured operator Sjof the circuit such that vj= 1. The product of the
measured operators indexed by vat level ℓ′
visF(v)ℓ′v−0.5. By Lemma 11, this operator is equal to
− − − →F′(v)ℓ′v−0.5. This is a stabilizer for the output of the circuit C[ℓ′
v−1]based on Lemma 12 (recall
thatC[ℓ′
v]is the subcircuit containing all the operations of Cwith level ≤ℓ′
v). This implies that,
in the absence of circuit faults, the outcomes of the measurements of the operators Sjwith vj= 1
have a fixed parity 0, which means that (o|v) = 0for all o∈ O(C). This proves the proposition.
Lemma 10. LetCbe a Clifford circuit with mmeasurements. Let Sbe a stabilizer for the corre-
sponding spacetime code. We can decompose Sas
S=Y
i← − − − − −F(u(i))
where u(i)∈Zm
2. Moreover, the support of the operators← − − − − −F(u(i))have disjoint supports.
Proof.We can decompose Sas
S=Y
iS|κi
where κ1, κ2, . . .are the connected components of the support of Sin the spacetime graph. By
construction, the operators S|κihave disjoint support.
Because it is a stabilizer, the operator Sis of the form← − − −F(u)with u∈ O(C)⊥. Given a measured
operator Sjof the circuit with level ℓj, define V(Sj)to be the set of vertices of spacetime graph of
the form (ℓj±0.5, q)where qis a qubit of the support of Sj. Define the vector u(i)∈Zm
2to be the
restriction of uto the set of coordinates jsuch that the circuit operation V(Sj)overlaps with κi.
Because it is a clique of the spacetime graph, a set V(Sj)can only overlap with a single connected
component κi. Therefore, ucan be decomposed as u=P
iu(i)and the vectors u(i)do not overlap.
Applying Proposition 4, this yields← − − −F(u) =Y
i← − − − − −F(u(i))·
Now let us show that the support of← − − − − −F(u(i))is the component κi. By definition of the back-
cumulant, if a qubit Q= (ℓ+ 0.5, q)belongs to the support of← − − − − −F(u(i)), there must exists a path in
this support that connects Qto a set V(Sj)for some j∈supp( u(i))(otherwise one cannot reach Q
by back-propagating F(u(i))). By definition of the set u(i), the proves that the qubit Qis part of
the connected component κi. This shows that supp(← − − − − −F(u(i))) = κiwhich implies← − − − − −F(u(i)) =Sκiand
leads to the decomposition claimed in the lemma.
32Lemma 11. LetCbe a Clifford circuit with depth ∆and with mmeasurements. Let v∈Zm
2. If← − −F(v)0.5=I, then we have
F(v)ℓ′v−0.5=− − − →
F′(v)ℓ′v−0.5
where ℓ′
vis the maximum level of a measured operator Sjwithvj= 1.
Proof.By definition, level ℓ′
v−0.5is the largest non-trivial level of← − −F(v)and for this level we have
← − −F(v)ℓ′v−0.5=F(v)ℓ′v−0.5.
Combining this with Lemma 9 this proves result.
In the following lemma C[ℓ]denotes the subcircuit of Cthat contains all the operations of Cwith
level≤ℓ.
Lemma 12. LetCbe a Clifford circuit with depth ∆and with mmeasurements. Let u∈ O(C)⊥
and let v∈Zm
2such that← − −F(v)is the restriction of← − − −F(u)to one of a connected component of its
support in the spacetime graph. Then for all ℓ= 1, . . .∆, the operator− − − →F′(v)ℓ+0.5belongs to output
stabilizer group of the subcircuit C[ℓ].
Proof.Let us prove this result by induction on ℓ.
Forℓ= 1, the result holds because the stabilizer group of the output of the subcircuit C[1]is
generated by the measured operators at level 1and− − − →F′(v)1.5=F′(v)1.5is a product of measured
operators at level 1.
Assume now that− − − →F′(v)ℓ−1+0.5is a stabilizer of the output state of the circuit C[ℓ−1]and let
us prove that the result is true at level ℓ.
The measurements performed at level ℓdo not affect the stabilizer− − − →F′(v)ℓ−1+0.5of the circuit
because it commutes with these measurements. Indeed, consider a measured operator Mof the
level ℓ. From Lemma 5, we know that [ηℓ−0.5(M),← − − −F(u)] = 0because← − − −F(u)is a stabilizer of the
spacetime code. This equation leads to [M,← − − −F(u)ℓ−0.5] = 0and[M,− − − →F′(u)ℓ−0.5] = 0using Lemma 9.
By definition of the spacetime graph of the circuit, the operation Mcan only overlap with at most
one of the connected component of the− − − →F′(u). Therefore, we also have [M,− − − →F′(v)ℓ−0.5] = 0 .This
proves that the stabilizer− − − →F′(v)ℓ−0.5commutes with all the operators measured at level ℓ. As a
result, it is still a stabilizer after applying these measurements. Moreover, the measured operators
are also stabilizers.
Consider now the effect of the unitary operations. The unitary operations of level ℓinduce a
conjugation of the stabilizers by Uℓwhich is the product of all unitary operations at level ℓ. This
maps the stabilizer− − − →F′(v)ℓ−1+0.5onto
Uℓ− − − →
F′(v)ℓ−1+0.5Uℓ=ℓ−1Y
j=0Uj,ℓF′(v)j+0.5U−1
j,ℓ· (32)
Moreover, we know that F′(v)ℓ+0.5is a stabilizer because it is a product of measured operators at
level ℓ. Multiplying the stabilizer obtained Eq. (32) with F′(v)ℓ+0.5we get the stabilizer− − − →F′(v)ℓ+0.5
for the output of the circuit C[ℓ].
33
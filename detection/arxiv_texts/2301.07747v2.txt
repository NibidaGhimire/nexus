arXiv:2301.07747v2  [cs.LO]  23 Nov 2023AnAutomata-basedFrameworkforVerification andBug
Hunting in /Q_uantumCircuits (Technical Report)
YU-FANG CHEN, Academia Sinica, Taiwan
KAI-MINCHUNG, Academia Sinica, Taiwan
ONDŘEJLENGÁL, Brno University ofTechnology, Czech Republic
JYUN-AOLIN, Academia Sinica, Taiwan
WEI-LUN TSAI, Academia Sinica, Taiwan and National TaiwanUniversity, Ta iwan
DI-DEYEN, Max Planck InstituteforSoftwareSystems, Germany
Weintroduceanew paradigmforanalysing andﬁndingbugsinq uantumcircuits.Inourapproach,theprob-
lem is given by a triple {/u1D443}/u1D436{/u1D444}and the questionis whether, given a set /u1D443of quantum states onthe input
of a circuit /u1D436, the set of quantum states on the output is equal to (or includ ed in) a set /u1D444. While this is not
suitable to specify, e.g., functional correctness of a quan tum circuit, it is suﬃcient to detect many bugs in
quantum circuits. We propose a technique based on tree automata to compactly represent sets of quantum
states and develop transformers toimplement thesemantics of quantumgates over this representation. Our
techniquecomputeswithanalgebraicrepresentationofqua ntumstates,avoidingtheinaccuracyofworking
with ﬂoating-point numbers. We implemented the proposed ap proach in a prototype tool and evaluated its
performanceagainstvariousbenchmarksfromtheliteratur e.Theevaluationshowsthatourapproachisquite
scalable, e.g., we managed to verify a large circuit with 40 q ubits and 141,527 gates, or catch bugs injected
intoacircuitwith320qubitsand 1,758gates,wherealltool swecomparedwithfailed.Inaddition,ourwork
establishes a connection between quantumprogram veriﬁcat ion and automata,opening new possibilities to
exploittherichnessofautomatatheoryandautomata-based veriﬁcationintheworldofquantumcomputing.
This is atechnical reportfora paperwith thesamename thata ppeared atPLDI’23 [ 25].
1 INTRODUCTION
The concept of quantum computing appeared around 1980 with the promise to solve many prob-
lems challenging for classical computers. Quantum algorithms for such problems started appear-
ing later, such as Shor’s factoring algorithm [ 67], a solution to the hidden subgroup problem
by Ettinger et al. [38], Bernstein-Vazirani’s algorithm [ 13], or Grover’s search [ 46]. For a long
time,nopracticalimplementation ofthese algorithmshasbee navailable dueto themissing hard-
ware.Recentyearshave,however,seentheadventofquantumchi psclaimingtoachieve quantum
supremacy [12], i.e., the ability to solve a problem that a state-of-the-a rt supercomputer would
take thousands of years to solve. As it seems that quantum compu ters will occupy a prominent
roleinthefuture,systemsandlanguagesfortheirprogramming areinactivedevelopment(e.g.,[ 7,
45,77]), and eﬃcient quantum algorithms for solutions of real-world p roblems, such as machine
learning [ 14,30], recommendation systems [ 52], optimization [ 58], or quantum chemistry [ 22],
have started appearing.
Theexponentialsizeoftheunderlyingcomputationalspaceandthe probabilistic nature makes
it,however,extremelychallengingtoreasonaboutquantumpro grams—bothforhumanusersand
automatedanalysistools.Currently,existing automatedanaly sisapproachesaremostlyunableto
handle large-scale circuits [ 41,42,83–85], inﬂexible in checking user-speciﬁed properties [ 8,20,
Authors’ addresses: Yu-Fang Chen, Academia Sinica, Institute of Info rmation Science, Taiwan, yfc@iis.sinica.edu.tw;
Kai-Min Chung, Academia Sinica, Institute of Information Science, Taiwan, k mchung@iis.sinica.edu.tw; Ondřej Lengál,
Faculty of Information Technology, Brno University of Technology, C zech Republic, lengal@ﬁt.vutbr.cz; Jyun-Ao Lin,
Academia Sinica, Taiwan, jyalin@gmail.com; Wei-Lun Tsai, Academia Sinica, Institute of Information Science, Taiwan,
alan23273850@gmail.com, National TaiwanUniversity,GraduateInst ituteofElectronics Engineering,Taiwan;Di-DeYen,
MaxPlanck InstituteforSoftware Systems, Germany, bottlebott le13@gmail.com.Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
31,39,45,62,63,66,70,73,74,90,91],orimpreciseandunabletocatchbugs[ 65,88].Scalableand
ﬂexible automatedanalysis toolsforquantumcircuits are inde ed missing.
Inthispaper,weproposeanewparadigmforanalysingandﬁndingbug sinquantumcircuits.In
ourapproach,theproblemisgivenbyatriple {/u1D443}/u1D436{/u1D444},where/u1D436isaquantumcircuitand /u1D443and/u1D444
are sets ofquantum states. The veriﬁcation question that we a ddress is whether the set of output
quantum states obtained by running /u1D436on all states from /u1D443is equal to (or included in) the set /u1D444.
While this kind of property is not suitable to specify, e.g., fu nctional correctness of a quantum
circuit,itissuﬃcienttoobtainalotofusefulinformationab outaquantumcircuit,suchasﬁnding
constants(will acircuit evaluate to the same quantumstate for all inputs in /u1D443) ordetecting bugs.
Wecreateaframeworkforanalysingtheconsideredclassofprop ertiesbasedon (ﬁnite)treeau-
tomata(TAs)[32].LanguagesofTAsaresetoftrees;inourcase,weconsiderTAs whoselanguages
contain full binary trees with the height being the number of qubi ts in the circuit. Each branch
(apathfromaroottoaleaf)insuchatreecorrespondstoone computationalbasisstate (e.g.,|0000/a\}bracke⊔ri}h⊔
or|0101/a\}bracke⊔ri}h⊔forafour-qubit circuit),andthecorrespondingleafrepresent s thecomplex amplitude of
the state (we use an algebraic encoding of complex numbers by tup les of integers to have a pre-
cise representation and avoid possible inaccuracies when deal ing with ﬂoating-point numbers1;
thisencodingissuﬃcient forawidevariety ofquantumgates,incl uding theCliﬀord+Tuniversal
set[17]).Setsofsuchtreescanbeinmanycasesencodedcompactlyusi ngTAs,e.g.,storingtheout-
put ofBernstein-Vazirani’s algorithm[ 13]over/u1D45Bqubitsrequires avectorof 2/u1D45Bcomplexnumbers,
but can be encoded by a linear-sized TA. For each quantum gate, we construct a transformation
thatconvertstheinputstatesTAtoaTArepresentingthegate’so utputstates,inasimilarwayas
classical program transformations are represented in [ 35]. Testing equivalence and inclusion be-
tweentheTArepresentingthesetofoutputsofacircuitandthep ostcondition /u1D444(from{/u1D443}/u1D436{/u1D444})
canthen be done bystandard TAlanguage inclusion/equivalence tes ting algorithms[ 3,4,32,53].
Ifthe test fails,the frameworkgeneratesa witness fordiagnos is.
One application of our framework is as a quick underapproximation of a quantum circuit non-
equivalencetest .Ourapproachcanswitchtoalightweightspeciﬁcationwhen equivalencecheckers
failduetoinsuﬃcientresourcesandstillﬁndbugsinthedesign.Q uantumcircuit(non-)equivalence
testing isan essential part ofthe quantumcomputing toolkit.It sprominent use is in verifying re-
sults ofcircuit optimization, whichis a necessary part ofqua ntum circuit compilation in order to
achieve the expected ﬁdelity of quantum algorithms running on re al-world quantum computers,
whichareheavilyaﬀectedbynoiseanddecoherence[ 9,47,49,50,58,59,64,68,79].Alreadyinthe
world of classical programs, optimizer bugs are being found on a regular basis in compilers used
dailybytensofthousandsofprogrammers(see,e.g.,[ 55]).Intheworldofquantum,optimizationis
muchharderthanintheclassicalsetting,withmanyopportunit iestointroducesubtleandhard-to-
discoverbugsintotheoptimizedcircuits.Itisthereforees sentialtobeabletocheckthatanoutput
of an optimizer is functionally equivalent to its input. Moreove r, global optimization techniques,
suchasgeneticalgorithms[ 56,69],mayuse(somehowquantiﬁed)circuit(non-)equivalenceasthe
ﬁtness function.
Testingquantumcircuit(non-)equivalenceis,however,achalle ngingtask(QMA-complete[ 51]).
Due to its complexity, approaches that can quickly establis h circuit non-equivalence are highly
desirable to be used, e.g., as a preliminary check before a mor e heavy-weight procedure, such
as[20,64,72,75,80],isused.Onecurrentlyemployedfastnon-equivalencecheckist ouserandom
stimuli generation [ 19]. Finding subtle bugs by random testing is, however, challenging w ith no
guaranteesdue to the immense (in generaluncountable)underlying s tate space.
1Integernumbersof an arbitraryprecision can behandled,e.g.,byt hepopular GMP[1] package.An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Ourapproachcanbeusedasfollows:westartwithaTAencodingt hesetofpossibleinputstates
(createdbytheuserorautomatically)andrunouranalysisoft hecircuitoverit,obtainingaTA A
representing the set of all outputs. Then, we take the optimized circuit, run it over the same TA
with inputs and obtain a TA A′. Finally, we checkwhether L(A)=L(A′). If the equality does
not hold, we can conclude that the circuits are not functionally eq uivalent (if the equality holds,
there can,however, still besome bugthat doesnot manifest in th e set of output states).
WeimplementedourtechniqueinaprototypecalledA /u.sc/t.sc/o.scQandevaluateditoverawiderange
ofquantumcircuits,includingsomeprominentquantumalgorithms ,randomlygeneratedcircuits,
reversiblecircuitsfrom R/e.sc/v.scL/i.sc/b.sc[76],andbenchmarksfromthetool F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc [8].Theresultsshow
thatourapproachisquitescalable.Wedidnotﬁndanytoolwitht hesamefunctionalitywithours
andhencepickthecloseststate-of-thearttools:acircuitsi mulatorS/l.sc/i.scQS/i.sc/m.sc[70]andcircuitequiva-
lencecheckers F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc [8](basedonpath-sum)and Q/c.sc/e.sc/c.sc[20](combiningZX-calculus,decision
diagrams,andrandomstimuligeneration),asthebaselinetoolst ocomparewith.Intheﬁrstexper-
iments,weevaluated A/u.sc/t.sc/o.scQ’scapabilityinveriﬁcationagainstpre-andpost-conditions. Weman-
agedtoverifythefunctionalcorrectness(w.r.t.oneinputstate )ofacircuitimplementingGrover’s
search algorithmwith 40 qubits and 141,527gates.We then eva luatedA/u.sc/t.sc/o.scQon circuits with in-
jectedbugs.Theresultsconﬁrmourclaim— A/u.sc/t.sc/o.scQwasabletoﬁndinjectedbugsinvarioushuge-
scale circuits, includingone with 320qubitsand 1,758gates,wh ichthe othertoolsfailedto ﬁnd.
Inadditiontothepracticalutility,ourworkalsobridgest hegapbetweenquantumandclassical
veriﬁcation, particularlyautomata-based approachessuch asregular (tree) modelchecking [15,16,
60]orstringmanipulationveriﬁcation [ 86,87].Asfarasweknow,ourapproachtoveriﬁcation of
quantum circuits is the ﬁrst based on automata. The enabling tec hniques and concepts involved
in this work are, e.g., the use of TAsto represent sets of quantu m states and express the pre- and
post-conditions, the compactness of the TA structure enabling eﬃ cient gate operations, and our
TAtransformationalgorithmsenablingtheexecutionofquantum gatesoverTAs.Webelieve that
the connection of automata theory with the quantum world we esta blish can start new fruitful
collaborationsbetween the two richﬁelds.
Overview: We use a concrete example to demonstrate how to use our approach . Assume that
we want to design a circuit constructing the Bell state, i.e., a 2 -qubit circuit converting a basis
state|00/a\}bracke⊔ri}h⊔to a maximally entangled state1√
2(|00/a\}bracke⊔ri}h⊔+|11/a\}bracke⊔ri}h⊔). We ﬁrst prepare TAs corresponding to
the precondition (Fig. 1a) and postcondition (Fig. 1b).Both TAsuse /u1D45Eas the root state and accept
only one tree. One can see the correspondence between quantum state s and TAs by traversing
their structure. The precise deﬁnition will be given in Secti on2and Section 3. Our approach will
then use the transformers from Sections 4to6to construct a TA Arecognizing the quantum
statesafterexecutingtheEPRcircuit(Fig. 1c)fromthepreconditionTA(Fig. 1a).Wewillthenuse
TA language inclusion/equivalence tool VATA [ 53] to checkAagainst the postcondition TA. If
the circuit is buggy, our approach will return a witness quantu m state that is reachable from the
precondition,butnotallowedbythepostcondition.Fromourexpe rienceofpreparingbenchmark
examples,in manycases, thisapproachhelpsus ﬁnding out bugsf rom incorrectdesigns.
2 PRELIMINARIES
We assume basic knowledge of linear algebra and quantum circuits . Below, we only give a short
overview and ﬁx notation; see,e.g.,the textbook[ 61]formore details.
By default, we work with vectors and matrices over complex numb ersC. In particular, we use
C/u1D45A×/u1D45Bto denote the set of all /u1D45A×/u1D45Bcomplex matrices. Given a /u1D458×ℓmatrix(/u1D44E/u1D465/u1D466.alt), itstranspose is
theℓ×/u1D458matrix(/u1D44E/u1D465/u1D466.alt)/u1D447=(/u1D44E/u1D466.alt/u1D465)obtained by ﬂipping (/u1D44E/u1D465/u1D466.alt)over its diagonal. A 1 ×/u1D458matrix is
called arow vector and a/u1D458×1 matrix is called a column vector. To save vertical space, we oftenYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
/u1D45E/u1D4651(/u1D45E1,/u1D45E0)
/u1D45E0/u1D4652(/u1D45E2,/u1D45E2)/u1D45E20()
/u1D45E1/u1D4652(/u1D45E3,/u1D45E2)/u1D45E31()
(a) The TA of|00/a\}bracke⊔ri}h⊔./u1D45E/u1D4651(/u1D45E0,/u1D45E1)
/u1D45E1/u1D4652(/u1D45E2,/u1D45E3)/u1D45E20()
/u1D45E0/u1D4652(/u1D45E3,/u1D45E2)/u1D45E31/√
2()
(b)TheTA of1√
2(|00/a\}bracke⊔ri}h⊔+|11/a\}bracke⊔ri}h⊔).|/u1D4651/a\}bracke⊔ri}h⊔/u1D43B
|/u1D4652/a\}bracke⊔ri}h⊔
(c)The EPR circuit
Fig.1. Constructing the Bellstate
write a column vector /u1D463using its row transpose /u1D463/u1D447. We use/u1D43Cto denote the identitymatrix of any
dimension(whichshouldbeclearfromthecontext).The conjugate ofacomplexnumber /u1D44E+/u1D44F/u1D456isthe
complexnumber /u1D44E−/u1D44F/u1D456,andtheconjugatetranspose ofamatrix /u1D434=(/u1D44E/u1D465/u1D466.alt)isthematrix /u1D434†=(/u1D450/u1D466.alt/u1D465)
where/u1D450/u1D466.alt/u1D465istheconjugateof /u1D44E/u1D466.alt/u1D465.Forinstance,/parenleftbigg1+/u1D4562−2/u1D4563
4−7/u1D4560 0/parenrightbigg†
=/parenlefttpA/parenleftexA
/parenleftbtA1−/u1D4564+7/u1D456
2+2/u1D4560
3 0/parenrighttpA/parenrightexA
/parenrightbtA.Theinverse
of a matrix /u1D434is denoted as /u1D434−1. A square matrix /u1D434isunitaryif/u1D434†=/u1D434−1. TheKronecker product
of/u1D434=(/u1D44E/u1D465/u1D466.alt)∈C/u1D458×ℓand/u1D435∈C/u1D45A×/u1D45Bis the/u1D458/u1D45A×ℓ/u1D45Bmatrix/u1D434⊗/u1D435=(/u1D44E/u1D465/u1D466.alt/u1D435),forinstance,
/parenleftbigg1+/u1D4563
4−7/u1D4560/parenrightbigg
⊗/parenleftbigg1
21
−1
20/parenrightbigg
=/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA(1+/u1D456)·/parenleftbigg1
21
−1
20/parenrightbigg
3·/parenleftbigg1
21
−1
20/parenrightbigg
(4−7/u1D456)·/parenleftbigg1
21
−1
20/parenrightbigg
0·/parenleftbigg1
21
−1
20/parenrightbigg/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA=/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA1
2+1
2/u1D4561+/u1D4563
23
−1
2−1
2/u1D4560−3
20
2−7
2/u1D4564−7/u1D4560 0
−2+7
2/u1D4560 0 0/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA.(1)
2.1 /Q_uantum Circuits
Quantum states. Inaquantumsystem with /u1D45Bqubits, thequbitscanbeentangled,andits quantum
statecanbeaquantumsuperpositionof computational basisstates {|/u1D457/a\}bracke⊔ri}h⊔|/u1D457∈{0,1}/u1D45B}.Forinstance,
givenasystemwiththreequbits /u1D4651,/u1D4652,and/u1D4653,thecomputationalbasisstate |011/a\}bracke⊔ri}h⊔denotesastate
where qubit /u1D4651is set to 0 and qubits /u1D4652and/u1D4653are set to 1. The superposition is then denoted in
theDiracnotationasaformalsum/summationtext.1
/u1D457∈{0,1}/u1D45B/u1D44E/u1D457·|/u1D457/a\}bracke⊔ri}h⊔,where/u1D44E0,/u1D44E1,...,/u1D44E2/u1D45B−1∈Carecomplexampli-
tudes2satisfyingthepropertythat/summationtext.1
/u1D457∈{0,1}/u1D45B|/u1D44E/u1D457|2=1.Intuitively,|/u1D44E/u1D457|2istheprobabilitythatwhen
wemeasurethestateinthecomputationalbasis,weobtainthe state|/u1D457/a\}bracke⊔ri}h⊔;theseprobabilitiesneedto
sumupto1forallcomputationalbasisstates.Wenotethattheq uantumstatecanalternativelybe
represented bya2/u1D45B-dimensionalcolumnvector3(/u1D44E0,...,/u1D44E2/u1D45B−1)/u1D447orbyafunction /u1D447:{0,1}/u1D45B→C,
where/u1D447(/u1D457)=/u1D44E/u1D457forall/u1D457∈{0,1}/u1D45B.Inthe following,we will workmainlywith thefunctionrepre-
sentation, which we will see as a mapping from the domain of assig nments to Boolean variables
(correspondingtoqubits)to C.Forinstance,thequantumstate1√
2·|00/a\}bracke⊔ri}h⊔+1√
2·|01/a\}bracke⊔ri}h⊔canberepresented
bythe vector(1√
2,1√
2,0,0)/u1D447orthe function /u1D447={00/u\i∈1A6.e\dl→1√
2,01/u\i∈1A6.e\dl→1√
2,10/u\i∈1A6.e\dl→0,11/u\i∈1A6.e\dl→0}.
Quantumgates. Operationsinquantumcircuitsarerepresentedusingquantumgat es.A/u1D458-qubit
quantumgate (i.e.,aquantumgatewith /u1D458inputsand /u1D458outputs)canbedescribedusinga2/u1D458×2/u1D458uni-
tarymatrix.Whencomputingtheeﬀectofa /u1D458-qubitquantumgate /u1D448onthequbits /u1D465ℓ,...,/u1D465ℓ+/u1D458−1of
an/u1D45B-qubitquantumstaterepresentedusinga2/u1D45B-dimensionalvector /u1D463,weproceedasfollows.First,
we compute an auxiliary matrix /u1D448′=/u1D43C/u1D45B−(ℓ+/u1D458−1)⊗/u1D448⊗/u1D43Cℓ−1where/u1D43C/u1D457denotes the 2/u1D457-dimensional
identity matrix. Note that if /u1D448is unitary, then /u1D448′is also unitary. Then,the new quantum state is
2Weabusenotation andsometimesidentifyabinarystringwithits(unsigned)inte gervalueinthe mostsigniﬁcant bitﬁrst
(MSBF)encoding, e.g.,thestring 0101withthenumber 5.
3Observethat in ordertosatisfy therequirement for theamplitude sof quantum states, itmust bea unitvector.An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
computedas /u1D463′=/u1D448′×/u1D463.For instance, let /u1D45B=2 and/u1D448be the Pauli- /u1D44Bgateapplied to the qubit /u1D4651.
/u1D44B′=/u1D44B⊗/u1D43C=/parenleftbigg0 1
1 0/parenrightbigg
⊗/parenleftbigg1 0
0 1/parenrightbigg
=/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA0 0 1 0
0 0 0 1
1 0 0 0
0 1 0 0/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA, /u1D463′=/u1D44B′×/u1D463=/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA0 0 1 0
0 0 0 1
1 0 0 0
0 1 0 0/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA×/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA/u1D45000
/u1D45001
/u1D45010
/u1D45011/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA=/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA/u1D45010
/u1D45011
/u1D45000
/u1D45001/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA(2)
Representationofcomplexnumbers. Inordertoachieveaccuracywithnolossofprecision,inthis
paper,whenworkingwith C,weconsideronlyasubsetofcomplexnumbersthatcanbeexpress ed
bythe following algebraicencodingproposed in [ 91](and also usedin [ 70]):
/parenleftBig1√
2/parenrightBig
/u1D458(/u1D44E+/u1D44F/u1D714+/u1D450/u1D7142+/u1D451/u1D7143), (3)
where/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458∈Zand/u1D714=/u1D452/u1D456/u1D70B
4, the unit vector that makes an angle of 45◦with the positive
realaxisinthecomplexplane).Acomplexnumberisthenrepres entedbyaﬁve-tuple (/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458).
Althoughtheconsideredsetofcomplexnumbersisonlyasmallsu bsetofC(itiscountable,while
the setCis uncountable), the subset is already suﬃcient to describe a se t of quantum gates that
can implement universal quantum computation (cf. Section 4for more details)4. The algebraic
representation also allows eﬃcient encoding of some operations. For example, because /u1D7144=−1,
themultiplicationof (/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458)by/u1D714canbecarriedoutbyasimplerightcircularshiftoftheﬁrst
four entries and then taking the opposite number forthe ﬁrst entry , namely(−/u1D451,/u1D44E,/u1D44F,/u1D450,/u1D458), which
represents the complex number/parenleftbig1√
2/parenrightbig/u1D458(−/u1D451+/u1D44E/u1D714+/u1D44F/u1D7142+/u1D450/u1D7143). In the rest of the paper, we use 0
and1to denote the tuples for zero and one, i.e., (0,0,0,0,0)and(1,0,0,0,0), respectively. Using
suchan encoding,we represent quantumstates byfunctions ofthe fo rm/u1D447:{0,1}/u1D45B→Z5.
QubitMeasurement. Afterexecutingaquantumcircuit,onecanmeasuretheﬁnalquantu mstate
in the computational basis. The probability that the qubit /u1D465/u1D457of a quantum state/summationtext.1
/u1D456∈{0,1}/u1D45B/u1D44E/u1D456·
|/u1D456/a\}bracke⊔ri}h⊔is measured as the basis state |0/a\}bracke⊔ri}h⊔can be computed from the amplitude: Prob[/u1D465/u1D457=|0/a\}bracke⊔ri}h⊔]=/summationtext.1
/u1D456∈{0,1}/u1D45B−/u1D457×{0}×{0,1}/u1D457−1|/u1D44E/u1D456|2.When/u1D465/u1D457collapsesto|0/a\}bracke⊔ri}h⊔after the measurement, amplitudes of states
with/u1D465/u1D457=|1/a\}bracke⊔ri}h⊔become0and amplitudesof states with /u1D465/u1D457=|0/a\}bracke⊔ri}h⊔are normalized using1√
Prob[/u1D465/u1D457=|0/a\}bracke⊔ri}h⊔].
2.2 Tree Automata
/u1D453
/u1D453 /u1D454
/u1D4501/u1D4502/u1D453/u1D4501
/u1D4502/u1D4503Binary Trees. We use a ranked alphabet Σwith binary symbols /u1D453,/u1D454, ... and
constantsymbols /u1D4501,/u1D4502,.... Abinarytree isagroundterm overΣ.Forinstance,
/u1D447=/u1D453(/u1D453(/u1D4501,/u1D4502),/u1D454(/u1D453(/u1D4502,/u1D4503),/u1D4501)), shown in the right, represents a binary tree.
The set of nodesof a binary tree /u1D447, denoted as /u1D441/u1D447, is deﬁned inductively as
a set of words over {0,1}such that for every constant symbol /u1D450, we deﬁne
/u1D441/u1D450={/u1D716}, and for every binary symbol /u1D453, we deﬁne /u1D441/u1D453(/u1D4470,/u1D4471)={/u1D716}∪{/u1D44E./u1D464|
/u1D44E∈{0,1}∧/u1D464∈/u1D441/u1D447/u1D44E}, where/u1D716is the empty word and ‘ .’ is concatenation. Each binary tree /u1D447
is associated with a labeling function /u1D43F/u1D447:{0,1}∗→Σ, which maps a node in /u1D447to its label in Σ.
Atree issingle-valued if it contains onlyoneconstant symbol.
TreeAutomata. Wefocusontreeautomataonbinarytreesandrefertheintereste dreaderto[ 32]
fora generaldeﬁnition. A (nondeterministic ﬁnite) treeautomaton (TA)isa tupleA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔
where/u1D444isaﬁnitesetof states,Σisarankedalphabet, R⊆/u1D444isthesetof rootstates ,andΔ=Δ/u1D456∪Δ/u1D459
isasetoftreetransitionsconsistingoftheset Δ/u1D456ofinternaltransitions oftheform /u1D45E/u1D453(/u1D45E0,/u1D45E1)
4From Solovay-Kitaev theorem [ 36], rotations of /u1D70B/2/u1D458gates, used, e.g., in Shor’s algorithm [ 67] andquantum Fourier
transform (QFT)[33],can beapproximated with O(log3.97(1
/u1D716))-many H, CNOT,and Tgates withan errorrate /u1D716.Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
(forabinary symbol /u1D453)andtheset Δ/u1D459ofleaf transitions oftheform /u1D45E/u1D450()(foraconstantsym-
bol/u1D450),for/u1D45E,/u1D45E0,/u1D45E1∈/u1D444.W.l.o.g.,to simplifyourcorrectnessproof,we assumeever y leaftransition
ofTAshasauniqueparentstate,namely,foranytwoleaftransitio ns/u1D45E/u1D450(),/u1D45E′/u1D450′()∈Δ,it
holdsthat /u1D450≠/u1D450′=⇒/u1D45E≠/u1D45E′.We canconvenientlydescribeTAsbyproviding onlytheset ofroot
statesRand the set of transitions Δ. The alphabet and states are implicitly deﬁned as those that
appear in Δ. For example, Δ={/u1D45E/u1D4651(/u1D45E1,/u1D45E0),/u1D45E/u1D4651(/u1D45E0,/u1D45E1),/u1D45E00(),/u1D45E11()}implies
thatΣ={/u1D4651,0,1}and/u1D444={/u1D45E,/u1D45E0,/u1D45E1}.
RunandLanguage. ArunofAonatree/u1D447isanothertree /u1D70Clabeledwith /u1D444suchthat(i) /u1D447and/u1D70C
havethesamesetofnodes,i.e., /u1D441/u1D447=/u1D441/u1D70C,(ii)forallleafnodes /u1D462∈/u1D441/u1D447,wehave /u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)()∈
Δ, and (iii) for all non-leaf nodes /u1D463∈/u1D441/u1D447, we have /u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δ. The
run/u1D70Cisaccepting if/u1D43F/u1D70C(/u1D716)∈R. ThelanguageL(A)ofAis the set of trees accepted by A, i.e.,
L(A)={/u1D447|there exists an acceptingrun of Aover/u1D447}. A TA is (top-down) deterministic if it
hasatmostonerootstateandforanyofitstransitions /u1D45E/u1D465(/u1D45E/u1D459,/u1D45E/u1D45F)and/u1D45E/u1D465(/u1D45E′
/u1D459,/u1D45E′
/u1D45F)itholds
that/u1D45E/u1D459=/u1D45E′
/u1D459and/u1D45E/u1D45F=/u1D45E′
/u1D45F.Anytreefromthelanguageofadeterministic TAhasauniqueruni nthe
TA.
Example 2.1 (Accepted tree and its run). Assume a TAA3with/u1D45Easits single root state and the
followingtransitions:
/u1D45E/u1D4651(/u1D45E1
0,/u1D45E1
1)/u1D45E1
1/u1D4652(/u1D45E2
0,/u1D45E2
1)/u1D45E2
1/u1D4653(/u1D45E0,/u1D45E1)/u1D45E00()
/u1D45E/u1D4651(/u1D45E1
1,/u1D45E1
0)/u1D45E1
1/u1D4652(/u1D45E2
1,/u1D45E2
0)/u1D45E2
1/u1D4653(/u1D45E1,/u1D45E0)/u1D45E11()
/u1D45E1
0/u1D4652(/u1D45E2
0,/u1D45E2
0)/u1D45E2
0/u1D4653(/u1D45E0,/u1D45E0)
/u1D4651
/u1D4652 /u1D4652
/u1D4653/u1D4653/u1D4653/u1D4653
10 0 0 0 0 0 0/u1D45E
/u1D45E1
1/u1D45E1
0
/u1D45E2
1/u1D45E2
0/u1D45E2
0/u1D45E2
0
/u1D45E1/u1D45E0/u1D45E0/u1D45E0/u1D45E0/u1D45E0/u1D45E0/u1D45E0
Amongothers,A3acceptsthe above tree (in the left) with the run (in the right ). Observe that all
treenodessatisfytherequirementofavalidrun.E.g.,thenode 111correspondstothetransition
/u1D45E00(),01to/u1D45E2
0/u1D4653(/u1D45E0,/u1D45E0),and/u1D716to/u1D45E/u1D4651(/u1D45E1
1,/u1D45E1
0),etc.
InA3, we use states named /u1D45E/u1D45B
0to denote only subtrees with all zeros ( 0) in leaves that can be
generatedfromhere,andstatesnamed /u1D45E/u1D45B
1todenoteonlysubtreeswithasingle 1intheleavesthat
canbegeneratedfromit.Intuitively,theTAacceptsalltrees oftheheightthreewithexactlyone 1
leaf and all other leaves 0(in our encoding of quantum states, this might correspond to sayi ng
thatA3encodesanarbitrary computational basis state of athree-qub it system). /square
3 ENCODING SETS OF QUANTUMSTATES WITH TREEAUTOMATA
Observe that we can use (full) binary trees to encode functions {0,1}/u1D45B→Z5, i.e., the function
representation ofquantumstates. Forinstance, the tree
/u1D4651(/u1D4652(/u1D4653(1,0),/u1D4653(0,0)),/u1D4652(/u1D4653(0,0),/u1D4653(0,0))) (4)
encodes the function /u1D447where/u1D447(000)=1and/u1D447(/u1D456)=0for all/u1D456∈{0,1}3\{000}. Since TAs can
conciselyrepresent sets of binary trees,they canbe used to enco desets ofquantumstates.An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Example 3.1 (Concise representation of sets of quantum stat es by TAs). Here we consider the set
of/u1D45B-qubit quantum states /u1D444/u1D45B={|/u1D456/a\}bracke⊔ri}h⊔|/u1D456∈{0,1}/u1D45B}, i.e., the set of all basis states. Note that |/u1D444/u1D45B|=
2/u1D45B, which is exponential. Representing all possible basis states na ively would require storing 22/u1D45B
complexnumbers.TAscan,however, represent such aset muchmor e eﬃciently.
For the case when /u1D45B=3, the set /u1D4443can be represented by the TA A3from Example 2.1with
3/u1D45B+1transitions(i.e.,linear-sized).TheTA A3canbegeneralizedtoencodethesetofall /u1D45B-qubit
states/u1D444/u1D45B={|/u1D456/a\}bracke⊔ri}h⊔|/u1D456∈{0,1}/u1D45B}foreach/u1D45B∈Nbysetting the transitions to
/u1D45E/u1D4651(/u1D45E1
0,/u1D45E1
1)/u1D45E1
1/u1D4652(/u1D45E2
0,/u1D45E2
1)... /u1D45E/u1D45B−1
1/u1D465/u1D45B(/u1D45E0,/u1D45E1)/u1D45E00()
/u1D45E/u1D4651(/u1D45E1
1,/u1D45E1
0)/u1D45E1
1/u1D4652(/u1D45E2
1,/u1D45E2
0)... /u1D45E/u1D45B−1
1/u1D465/u1D45B(/u1D45E1,/u1D45E0)/u1D45E11()
/u1D45E1
0/u1D4652(/u1D45E2
0,/u1D45E2
0)... /u1D45E/u1D45B−1
0/u1D465/u1D45B(/u1D45E0,/u1D45E0)
We denote the resulting TA by A/u1D45B. Notice that although /u1D444/u1D45Bhas 2/u1D45Bquantum states,A/u1D45Bhas only
2/u1D45B+1states and 3 /u1D45B+1transitions. /square
Formally a TAArecognizing a set of quantum states is a tuple /a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔, whose alphabet Σ
can be partitioned into two classes of symbols: binary symbols /u1D4651,...,/u1D465/u1D45Band a ﬁnite set of leaf
symbolsΣ/u1D450⊆Z5representingallpossibleamplitudesofquantumstatesinterm sofcomputational
bases. By slightly abusing the notation, for a full binary tree /u1D447∈L(A), we also use /u1D447to denote
the function{0,1}/u1D45B→Z5that mapsa computationalbasis to the correspondingamplitude of/u1D447’s
quantumstate. The two meaningsof /u1D447are used interchangeablythroughoutthe paper.
Remark.Note that TAs allow representation of inﬁnitelanguages, yet we only use them for
ﬁnitesets,whichmightseemlikethemodelisoverlyexpressive.W e,however,sticktoTAsforthe
followingtworeasons:(i)thereisanexisting richtoolboxfor TAmanipulationandminimization,
e.g.,[3,4,32,53],and(ii) we want to have a robust formalmodelforextending ourf rameworkto
parameterized veriﬁcation, i.e., proving that an /u1D45B-qubit algorithmis correct for any /u1D45B, which will
requireustodealwithinﬁnitelanguages(cf.,theframeworkof regulartreemodelchecking [5,15]).
Moreover,wechose fullbinarytreesastherepresentationofquantumstates.Wethough tabout
using amorecompactstructure, e.g.,allowingjumpover atrans ition with commonleftandright
children (similar to ROBDD’s elimination of a node with isomor phic subtrees [ 18]). We decided
against that becauseTAsalready allowan eﬃcient representati on of commonchildrenvia a tran-
sition to the same left and right states, e.g., /u1D45E/u1D465(/u1D45E′,/u1D45E′). The beneﬁt of using a more compact
tree representation is thus limited. Using a more eﬃcient data s tructure would also make the al-
gorithms in the following sections harder to understand. We ther efore leave the investigation of
designing a moreeﬃcient data structure to ourfuture work.
4 SYMBOLIC REPRESENTATION OF QUANTUMGATES
WithTAsusedtoconciselyrepresentsetsofquantumstates,the nexttaskistocapturetheeﬀects
ofapplyingquantumgatesonthisrepresentation.Whenquantumst atesarerepresentedasvectors,
gatesare represented asmatricesandgateoperationsare matri xmultiplications. Whenstates are
representedasbinarytrees,weneedanewrepresentationforquant umgatesandtheiroperations.
Inspired by the work of [ 70], we introduce symbolic update formulae , which are formulae that
describe how a gate transforms a tree representing a quantum stat e. Later, we will lift the tree
update operationto a set of treesencodedin a TA.
We use the algebraicrepresentation ofquantum states fromEq. (3)also fortheir symbolichan-
dling.For instance,consider a system with qubits /u1D4651,/u1D4652and its state
/u1D447=/u1D45000·|00/a\}bracke⊔ri}h⊔+/u1D45001·|01/a\}bracke⊔ri}h⊔+/u1D45010·|10/a\}bracke⊔ri}h⊔+/u1D45011·|11/a\}bracke⊔ri}h⊔ (5)Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
|/u1D4651/a\}bracke⊔ri}h⊔/u1D44B
|/u1D4652/a\}bracke⊔ri}h⊔
(a)/u1D44Bgate applied
toqubit/u1D4651/u1D44B=/parenleftbigg0 1
1 0/parenrightbigg
(b) Matrix of
the/u1D44Bgate|/u1D4651/a\}bracke⊔ri}h⊔
|/u1D4652/a\}bracke⊔ri}h⊔
(c)CNOT2
1gate with target
qubit/u1D4651and control qubit /u1D4652CNOT=/parenlefttpA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0/parenrighttpA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA
(d) Matrix of the CNOT
gate
Fig. 2. Applications of /u1D44BandCNOTgates and theirmatrices
for/u1D45000,/u1D45001,/u1D45010,/u1D45011∈Z5, four complexnumbersrepresented in the algebraic way.The re sult of ap-
plyingthe /u1D44Bgate(thequantumversionofthe NOTgate)onqubit /u1D4651(cf.Fig.2a)is(/u1D45010,/u1D45011,/u1D45000,/u1D45001)/u1D447
(cf.Eq.(2)).Intuitively,weobservethattheeﬀectofthegateisaperm utationofthecomputational
basis states that swaps the amplitudes of states where the /u1D4651’s value is 1 with states where the
/u1D4651’s value is 0 (and the values of qubits other than /u1D4651stay the same). Concretely, it swaps the
amplitudes ofthe pairs (|00/a\}bracke⊔ri}h⊔,|10/a\}bracke⊔ri}h⊔)and(|01/a\}bracke⊔ri}h⊔,|11/a\}bracke⊔ri}h⊔)to obtain the quantumstate
/u1D44B(/u1D447)=/u1D45010·|00/a\}bracke⊔ri}h⊔+/u1D45011·|01/a\}bracke⊔ri}h⊔+/u1D45000·|10/a\}bracke⊔ri}h⊔+/u1D45001·|11/a\}bracke⊔ri}h⊔. (6)
Instead of executing the quantum gate by performing a matrix-vec tor multiplication, we will
captureitssemantics symbolically bydirectlymanipulatingthetreefunction /u1D447:{0,1}/u1D45B→Z5.For
this, we will use the following operatorson /u1D447,parameterized bya qubit /u1D465/u1D461(/u1D461for“target”):
/u1D447/u1D465/u1D461(/u1D44F/u1D45B.../u1D44F/u1D461.../u1D44F1)=/u1D447(/u1D44F/u1D45B...1.../u1D44F1) /u1D435/u1D465/u1D461(/u1D44F/u1D45B.../u1D44F/u1D461.../u1D44F1)=/u1D44F/u1D461
/u1D447/u1D465/u1D461(/u1D44F/u1D45B.../u1D44F/u1D461.../u1D44F1)=/u1D447(/u1D44F/u1D45B...0.../u1D44F1) /u1D435/u1D465/u1D461(/u1D44F/u1D45B.../u1D44F/u1D461.../u1D44F1)=/u1D44F/u1D461.
(Projection) (Restriction)
In the previous, /u1D44F/u1D461denotes the complement of the bit /u1D44F/u1D461(i.e.,0=1 and1=0).Intuitively, /u1D447/u1D465/u1D461and
/u1D447/u1D465/u1D461ﬁxthevalueofqubit /u1D465/u1D461tobe1and0respectively.Ontheotherhand, /u1D435/u1D465/u1D461and/u1D435/u1D465/u1D461justtakethe
value ofqubit /u1D465/u1D461(orits negation) in the computationalbasis state.
Equipped with the operators, we can now proceed to express the semantics of /u1D44Bsymbolically.
Letusﬁrstlookattheﬁrsttwosummandsontheright-handsideo fEq.(6):/u1D4470=/u1D45010·|00/a\}bracke⊔ri}h⊔+/u1D45011·|01/a\}bracke⊔ri}h⊔.
These summandscanbe obtainedby manipulating the input function /u1D447in the followingway:
/u1D4470=/u1D435/u1D4651·/u1D447/u1D4651. (7)
Here,/u1D4470=/u1D435/u1D4651·/u1D447/u1D4651isashorthandfor /u1D4470(/u1D44F1.../u1D44F/u1D45B)=/u1D435/u1D4651(/u1D44F1.../u1D44F/u1D45B)·/u1D447/u1D4651(/u1D44F1.../u1D44F/u1D45B).Whenweview /u1D447
as a tree, the operation /u1D447/u1D4651essentially copies the right subtree of every /u1D4651-node to its left subtree,
and/u1D435/u1D4651·/u1D447/u1D4651makesall leavesin every rightsubtree of /u1D447/u1D4651’s/u1D4651-node zero.Thiswould give us
/u1D4470=/u1D45010·|00/a\}bracke⊔ri}h⊔+/u1D45011·|01/a\}bracke⊔ri}h⊔+0·|10/a\}bracke⊔ri}h⊔+0·|11/a\}bracke⊔ri}h⊔=/u1D45010·|00/a\}bracke⊔ri}h⊔+/u1D45011·|01/a\}bracke⊔ri}h⊔.(8)
On the other hand, the last two summands in the right-hand side of Eq. (6), i.e.,/u1D4471=/u1D45000·|10/a\}bracke⊔ri}h⊔+
/u1D45001·|11/a\}bracke⊔ri}h⊔,couldbe obtainedby manipulating /u1D447asfollows:
/u1D4471=/u1D435/u1D4651·/u1D447/u1D4651. (9)
The tree view of /u1D435/u1D4651·/u1D447/u1D4651is symmetricto /u1D435/u1D4651·/u1D447/u1D4651,whichwould give usthe followingstate:
/u1D4471=0·|00/a\}bracke⊔ri}h⊔+0·|01/a\}bracke⊔ri}h⊔+/u1D45000·|10/a\}bracke⊔ri}h⊔+/u1D45001·|11/a\}bracke⊔ri}h⊔=/u1D45000·|10/a\}bracke⊔ri}h⊔+/u1D45001·|11/a\}bracke⊔ri}h⊔.(10)
Finally,bysumming /u1D4470and/u1D4471,weobtainEq.( 6):/u1D4470+/u1D4471=/u1D45010·|00/a\}bracke⊔ri}h⊔+/u1D45011·|01/a\}bracke⊔ri}h⊔+/u1D45000·|10/a\}bracke⊔ri}h⊔+/u1D45001·|11/a\}bracke⊔ri}h⊔.
That is,the semantics ofthe /u1D44Bgatecouldbe expressed using the followingsymbolicformula:
/u1D44B1(/u1D447)=/u1D435/u1D4651·/u1D447/u1D4651+/u1D435/u1D4651·/u1D447/u1D4651. (11)An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Table1. Symbolicupdateformulae for theconsideredquantum gates;/u1D465/u1D450and/u1D465′/u1D450denotecontrol bits(ifthey
exist), and /u1D465/u1D461denotes the targetbit.
Gate Update
X/u1D461/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461
Y/u1D461/u1D7142·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461−/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461)
Z/u1D461/u1D435/u1D465/u1D461·/u1D447−/u1D435/u1D465/u1D461·/u1D447
H/u1D461(/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461−/u1D435/u1D465/u1D461·/u1D447)/√
2
S/u1D461/u1D435/u1D465/u1D461·/u1D447+/u1D7142·/u1D435/u1D465/u1D461·/u1D447
T/u1D461/u1D435/u1D465/u1D461·/u1D447+/u1D714·/u1D435/u1D465/u1D461·/u1D447
Rx(/u1D70B
2)/u1D461(/u1D447−/u1D7142·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461))/√
2
Ry(/u1D70B
2)/u1D461(/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447−/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461)/√
2
CNOT/u1D450
/u1D461/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461)
CZ/u1D450
/u1D461/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D461·/u1D447−/u1D435/u1D465/u1D461·/u1D447)
Toﬀoli/u1D450,/u1D450′
/u1D461/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D450′·/u1D447+/u1D435/u1D465/u1D450′·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461))
Observe that the sum eﬀectively swaps theleft and rightsubtr ees of each /u1D4651-node.
Formulti-qubit gates,theupdateformulaegetmorecomplic ated,since theyinvolve morethan
onequbit.Consider,e.g.,the“controlled-NOT”gate CNOT/u1D450
/u1D461(seeFig.2cforthegraphicalrepresen-
tationandFig. 2dforitssemantics).The CNOT/u1D450
/u1D461gateuses /u1D465/u1D461and/u1D465/u1D450asthetargetandcontrolqubit
respectively. Intuitively, it “ﬂips” the target qubit’s val ue when the control qubit’s value is 1 and
keeps the original value if it is 0. Similarly as for the /u1D44Bgate, we can deduce a symbolic formula
forthe update doneby a CNOTgate:
CNOT/u1D450
/u1D461(/u1D447)=/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461). (12)
The sumconsists of thefollowing two summands:
•Thesummand /u1D435/u1D465/u1D450·/u1D447saysthat when the controlqubit is 0, /u1D465/u1D461and/u1D465/u1D450stay the same.
•Thesummand /u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461)handlesthe case when /u1D465/u1D450is 1.In such a case, we
applythe /u1D44Bgateon/u1D465/u1D461(observethattheinnertermistheupdateformulaof /u1D44B/u1D461inEq.(11)).
One can obtain symbolic update formulae for other quantum gate s in a similar way.In Table 1
we give the formulae for the gates supported by our framework (see Appendix Afor their usual
deﬁnition using matrices). For a gate G, we use the superscript s/u1D450and/u1D450′to denote that /u1D465/u1D450and/u1D465′
/u1D450
are the gate’s control qubits (if they exist) and the subscript /u1D461to denote that /u1D465/u1D461is the target bit
(e.g., G/u1D450,/u1D450′
/u1D461). We note that the supported set of gates is much larger than is required to achieve
(approximate)universalquantumcomputation(forwhichitsu ﬃcestohave,e.g.,(i)Cliﬀordgates
(/u1D43B,/u1D446,andCNOT) and/u1D447(see [17])or(ii) Toﬀoliand /u1D43B(see[6])).
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 4.1. The symbolic update formulae in Table 1are correct (w.r.t. the standard semantics
of quantum gates, cf. [ 61]).
Anote on expressivity. Theexpressivity of ourframeworkis aﬀectedbythe following factors:
(1)Algebraic complex number representation (/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458): This representation can arbitrarily
closelyapproximateanycomplexnumber:First,notethat /u1D714=cos45◦+/u1D456sin45◦=1√
2+/u1D4561√
2
and when /u1D44F=/u1D451=0,we have(/u1D44E,0,/u1D450,0,/u1D458)=1√
2/u1D458(/u1D44E+/u1D450/u1D7142)=/u1D44E√
2/u1D458+/u1D450/u1D456√
2/u1D458. Then any complex
numbercan beapproximated arbitrarily closelyby pickingsui table/u1D44E,/u1D450,and/u1D458.
(2)Supported quantum gates : We covered all standard quantum gates supported in modern
quantumcomputersexceptparameterizedrotationgate.From Solovay-Kitaevtheorem[ 36],
gatesperformingrotationsby/u1D70B
2/u1D458canbeapproximatedwithanerrorrate /u1D716withO(log3.97(1
/u1D716))-
manygatesthat we support.Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
Algorithm 1: Algorithmfor constructingU (A), forU∈{/u1D44B/u1D461,/u1D44C/u1D461,/u1D44D/u1D461,/u1D446/u1D461,/u1D447/u1D461}
Input:A TAA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔and a gateU
Output:TheTAU(A)
1ifU∈{/u1D44C/u1D461,/u1D44D/u1D461,/u1D446/u1D461,/u1D447/u1D461}then// need constant scaling
2Let/u1D44E1and/u1D44E0bethe left andright scalarin U (/u1D447)=/u1D44E1·/u1D435/u1D465/u1D461·/u1D4471+/u1D44E0·/u1D435/u1D465/u1D461·/u1D4470;
3A1:=/a\}bracke⊔le{⊔/u1D444′,Σ,Δ1,R′/a\}bracke⊔ri}h⊔,whereΔ1=Δ′
/u1D456∪{/u1D45E′/u1D44E1·/u1D450()|/u1D45E/u1D450()∈Δ/u1D459};
4A/u1D445:=/a\}bracke⊔le{⊔/u1D444∪/u1D444′,Σ,Δ/u1D445∪Δ1,R/a\}bracke⊔ri}h⊔, where
Δ/u1D445={/u1D45E/u1D44E0·/u1D450()|/u1D45E/u1D450()∈Δ/u1D459}∪
{/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458≠/u1D461}∪
{/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E′
1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458=/u1D461}
5else
6A/u1D445:=A;// when U=X/u1D461
7ifU∈{/u1D44B/u1D461,/u1D44C/u1D461}then// need swapping
8AssumeA/u1D445=/a\}bracke⊔le{⊔/u1D444/u1D445,Σ,Δ/u1D445,R/a\}bracke⊔ri}h⊔;
9A/u1D445:=/a\}bracke⊔le{⊔/u1D444/u1D445,Σ,Δ/u1D445
1,R/a\}bracke⊔ri}h⊔, where
Δ/u1D445
1={/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D445
/u1D456∧/u1D458≠/u1D461}∪
{/u1D45E/u1D465/u1D458(/u1D45E1,/u1D45E0)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D445
/u1D456∧/u1D458=/u1D461}∪{/u1D461|/u1D461∈Δ/u1D445
/u1D459}
10returnA/u1D445;
(3)Treeautomatastructure :Weusenon-deterministictransitionsoftreeautomatatorepres ent
a set of trees compactly. Nevertheless, we can currently encod e only a ﬁnite set of states,
so encoding,e.g., allquantum states thatsatisfy ||10/a\}bracke⊔ri}h⊔|=||01/a\}bracke⊔ri}h⊔|is future work.
Inthenexttwosections,wediscusshowtoliftthetreeupdateo perationtoasetoftreesencoded
inaTA.Ourframeworkallowsdiﬀerentinstantiations.Wewillint roducetwointhispaper,namely
the (i)permutation-based (Section5) and (ii) composition-based (Section6) approach. The former
is simple, eﬃcient, and works for all but the H /u1D461, Rx(/u1D70B
2)/u1D461, and Ry(/u1D70B
2)/u1D461gates from Table 1(those
whoseeﬀectisapermutationoftreeleaves,i.e.,forgatesw hosematrixcontainsonlyonenon-zero
element in each row, potentially with a constant scaling of amplit ude), while the latter supports
all gates in the table but is less eﬃcient. The two approaches a re compatible with each other, so
onecan,e.g.,choosetousethepermutation-basedapproachbyd efaultandforunsupportedgates
fallbackonthe composition-based approach.
5 PERMUTATION-BASED ENCODING OF QUANTUMGATES
LetusﬁrstlookatthesimplestgateX /u1D461(/u1D447)=/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461.RecallthatinSection 4,weshowed
thattheformulaessentiallyswapstheleftandrightsubtrees ofeach/u1D465/u1D461-labelednode.ForaTA A,
we can capture the eﬀect of applying X /u1D461to all states inL(A)by swapping the left and the right
children of all /u1D465/u1D461-labeled transitions /u1D45E/u1D465/u1D461(/u1D45E0,/u1D45E1),i.e., update them to /u1D45E/u1D465/u1D461(/u1D45E1,/u1D45E0). We use
X/u1D461(A)to denote the TAconstructedfollowingthis procedure.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc5.1.L(X/u1D461(A))={X/u1D461(/u1D447)|/u1D447∈L(A)} .
TheupdateformulaeofgatesZ /u1D461,S/u1D461,andT/u1D461areallintheform /u1D44E1·/u1D435/u1D465/u1D461·/u1D447+/u1D44E0·/u1D435/u1D465/u1D461·/u1D447for/u1D44E1,/u1D44E0∈C.
Intuitively, the formulae scale the left and right subtrees of /u1D447with scalars /u1D44E0and/u1D44E1, respectively.An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Algorithm 2: Algorithmfor constructingU (A), forU∈{CNOT/u1D450
/u1D461,CZ/u1D450
/u1D461,Toﬀoli/u1D450,/u1D450′
/u1D461}
Input:A TAA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔and a gateU
Output:TheTAU(A)
1ifU=CNOT/u1D450
/u1D461thenA1:=X/u1D461(A);
2ifU=CZ/u1D450
/u1D461thenA1:=Z/u1D461(A);
3ifU=Toﬀoli/u1D450,/u1D450′
/u1D461thenA1:=CNOT/u1D450′
/u1D461(A);
4LetA′
1=/a\}bracke⊔le{⊔/u1D444′
1,Σ,Δ′
1,R′/a\}bracke⊔ri}h⊔be obtainedfromA1by priming alloccurrencesofstates;
5A/u1D445:=/a\}bracke⊔le{⊔/u1D444∪/u1D444′
1,Σ,Δ/u1D445∪Δ′
1,R/a\}bracke⊔ri}h⊔, where
Δ/u1D445={/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458≠/u1D450}∪
{/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E′
1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458=/u1D450}∪{/u1D461|/u1D461∈Δ/u1D459}
returnA/u1D445;
Their construction (Algorithm 1) can be done by (1) making one primed copy of Awhose leaf
labels are multiplied with /u1D44E1(Line 3), (2) multiplying all leaf labels of Awith/u1D44E0(Line 4), and
(3) updating all /u1D465/u1D461-labeled transitions /u1D45E/u1D465/u1D461(/u1D45E0,/u1D45E1)to/u1D45E/u1D465/u1D461(/u1D45E0,/u1D45E′
1), i.e., for the right child,
jump to the primed version (Line 4).In the algorithms, we deﬁne /u1D444′={/u1D45E′|/u1D45E∈/u1D444}for any set of
state/u1D444andΔ′={/u1D45E′/u1D465(/u1D45E′
/u1D459,/u1D45E′
/u1D45F)|/u1D45E/u1D465(/u1D45E/u1D459,/u1D45E/u1D45F)∈Δ}for any set of transitions Δ. The case of
Y/u1D461issimilar,butweneedboth constant scaling (Lines1-4)and swapping (Lines7-9)(theleft-hand
side andright-hand side scalarsbeing /u1D7142and−/u1D7142,respectively).
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc5.2.L(U(A))={U(/u1D447)|/u1D447∈L(A)} , forU∈{Y/u1D461,Z/u1D461,S/u1D461,T/u1D461}.
Thecases ofmulti-qubit gatesCNOT/u1D450
/u1D461, CZ/u1D450
/u1D461, and Toﬀoli/u1D450,/u1D450′
/u1D461canbe handled when /u1D461is the lowest
of the three qubits, i.e., /u1D450</u1D461∧/u1D450′</u1D461. We can assume w.l.o.g. that /u1D450</u1D450′. Output of these gates
can be constructed recursively following Algorithm 2. Let us look at the corresponding update
formulae:
CNOT/u1D450
/u1D461(/u1D447)=/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461)
CZ/u1D450
/u1D461(/u1D447)=/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D461·/u1D447−/u1D435/u1D465/u1D461·/u1D447)
Toﬀoli/u1D450,/u1D450′
/u1D461(/u1D447)=/u1D435/u1D465/u1D450·/u1D447+/u1D435/u1D465/u1D450·(/u1D435/u1D465/u1D450′·/u1D447+/u1D435/u1D465/u1D450′·(/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461+/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461))
We ﬁrst construct the TA of the inner term, the shadedarea , which are TAs for X/u1D461, Z/u1D461, or
CNOT/u1D450′
/u1D461. We call it the primed version here (cf. A′
1at Line4). We then update all /u1D465/u1D450-labeled tran-
sitions/u1D45E/u1D465/u1D450(/u1D45E0,/u1D45E1)to/u1D45E/u1D465/u1D450(/u1D45E0,/u1D45E′
1),i.e., jumpto the primedversion in theright subtree.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc5.3.L(U(A))={U(/u1D447)|/u1D447∈L(A)} , forU∈{CNOT/u1D450
/u1D461,CZ/u1D450
/u1D461,Toﬀoli/u1D450,/u1D450′
/u1D461}.
6 COMPOSITION-BASED ENCODING OF QUANTUMGATES
Weintroducethecomposition-basedapproachinthissection.T hetaskistodevelopTAoperations
thathandletheupdateformulaeinTable 1compositionally.Theideaistoliftthebasictreeopera-
tions, suchas projection /u1D447/u1D465/u1D458,restriction /u1D435·/u1D447, andbinary operation ±to operationsover TAsand
thencomposethemtohavethedesiredgatesemantics.Theupda teformulaeinTable 1arealways
in the formof term1±term2.For example,forthe /u1D44B/u1D461gate,term1=/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461andterm2=/u1D435/u1D465/u1D461·/u1D447/u1D465/u1D461.
Our idea is to ﬁrst construct TAs Aterm1andAterm2, recognizing quantum states of term1andYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
Algorithm 3: ThetaggingprocedureTag (A).
Input:A TAA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔
Output:AtaggedTA/a\}bracke⊔le{⊔/u1D444,Σ′,Δ′,R/a\}bracke⊔ri}h⊔
1Δ1:={/u1D45E/u1D450()|/u1D45E/u1D450()∈Δ};
2Δ2:={/u1D45E/u1D465/u1D457
/u1D458(/u1D45E1,/u1D45E2)|/u1D6FF=(/u1D45E/u1D465/u1D458(/u1D45E1,/u1D45E2))∈Δ,ord(/u1D6FF)=/u1D457},whereord:Δ→Nis an
arbitrary injection (e.g.,anordering of thetransitions);
3Δ′:=Δ1∪Δ2;
4Σ′isthe set of allsymbolsappearingin Δ′;
5return/a\}bracke⊔le{⊔/u1D444,Σ′,Δ′,R/a\}bracke⊔ri}h⊔;
term2, and then combine them using binary operation ±to produce a TA recognizing the quan-
tum states of term1±term2. The TAsAterm1,Aterm2would be constructed using TA versions of
basic operationsintroduced laterin thissection.
For a TA accepting the trees {/u1D4471,/u1D4472}, a correct construction would produce a TA with the lan-
guage{/u1D447′
1±/u1D447′′
1,/u1D447′
2±/u1D447′′
2},for/u1D447′
/u1D456=term1[/u1D447/u\i∈1A6.e\dl→/u1D447/u1D456]and/u1D447′′
/u1D456=term2[/u1D447/u\i∈1A6.e\dl→/u1D447/u1D456], where[/u1D447/u\i∈1A6.e\dl→/u1D447/u1D456]is
a substitution deﬁned in the standard way.Obtaining this result is, however, not straightforward.
If we just performed the ±operation pairwise between all elements of /u1D447′
/u1D456and/u1D447′′
/u1D456, we would ob-
tain the language{/u1D447′
1±/u1D447′′
1,/u1D447′
2±/u1D447′′
2,/u1D447′
1±/u1D447′′
2,/u1D447′
2±/u1D447′′
1}, which is wrong, since we are losing the
information that /u1D447′
1and/u1D447′′
1are related (and so are /u1D447′
2and/u1D447′′
2).
In the rest of the section, we will describe implementation of t he necessary operations for the
composition-based approach.
6.1 Tree Tag
We introduce the concept of tree tags to keep track of the origins of trees. For any tree /u1D447, its
tag Tag(/u1D447)is the tree obtained from /u1D447by replacing all leafsymbolswith a specialsymbol /square.E.g.,
for the tree /u1D4471=/u1D4651(/u1D4652(1,0),/u1D4652(0,0)),its tag is Tag(/u1D4471)=/u1D4651(/u1D4652(/square,/square),/u1D4652(/square,/square)).Our construction
needs to maintain the following invariants: (1) each tree in a TA ha s a unique tag, (2) all derived
treesshouldhavethesametag,and(3)binaryoperationsovertw osetsoftreesrepresentedbyTAs
only combine trees with the same tag. When we say /u1D447′isderived from /u1D447, it means /u1D447′is obtained
byapplying basic tree operationson /u1D447.E.g.,the tree /u1D435/u1D4651·/u1D447/u1D4651is derived from /u1D447.
Example6.1. LetAbe a TAwith rootstates R={/u1D45E}andtransitions
/u1D45E/u1D4651(/u1D45E/u1D459,/u1D45E/u1D45F) /u1D45E/u1D459/u1D4652(/u1D45E1,/u1D45E0) /u1D45E00()
/u1D45E/u1D459/u1D4652(/u1D45E0,/u1D45E1) /u1D45E11()
/u1D45E/u1D45F/u1D4652(/u1D45E0,/u1D45E0)
ObservethatL(A)={/u1D4651(/u1D4652(1,0),/u1D4652(0,0)),/u1D4651(/u1D4652(0,1),/u1D4652(0,0))}.InDiracnotation,thisistheset
{|00/a\}bracke⊔ri}h⊔,|01/a\}bracke⊔ri}h⊔}.Thetagofbothtreesis /u1D4651(/u1D4652(/square,/square),/u1D4652(/square,/square)),whichviolates invariant (1)above. /square
In general, invariant (1) does not hold, as we can see from Example 6.1. Our solution to this
is introducing the taggingprocedure (cf. Algorithm 3). The idea of tagging is simple: for each
transition,weassigntoitsfunctionsymbolauniquenumber.Afte rtaggingaTA,everytransition
hasadiﬀerentsymbol.Let Untag(/u1D447)beafunctionthatremovesthenumber /u1D457(addedbythetagging
procedure)fromeachsymbol /u1D465/u1D457
/u1D458in/u1D447’slabels.An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Example 6.2. After taggingAfrom Example 6.1, we obtain the TA ATagwith the root state /u1D45E
and thefollowing transitions:
/u1D45E/u1D4651
1(/u1D45E/u1D459,/u1D45E/u1D45F) /u1D45E/u1D459/u1D4652
2(/u1D45E1,/u1D45E0) /u1D45E00()
/u1D45E/u1D459/u1D4653
2(/u1D45E0,/u1D45E1) /u1D45E11()
/u1D45E/u1D45F/u1D4654
2(/u1D45E0,/u1D45E0)
HereL(ATag)={/u1D4471,/u1D4472},where/u1D4471=/u1D4651
1(/u1D4652
2(1,0),/u1D4654
2(0,0))and/u1D4472=/u1D4651
1(/u1D4653
2(0,1),/u1D4654
2(0,0)).Thetwo
trees/u1D4471and/u1D4472have diﬀerent tagsnow. /square
L/e.sc/m.sc/m.sc/a.sc 6.3. All non-single-valuedtrees in ataggedTAhave diﬀerent tag s.
Deﬁnition 6.4 (Tag preservation). Given a tagged TA ATagand an operation /u1D448over binary
trees, a TA construction procedure /u1D442transformingATagto/u1D442(ATag)is calledtag-preserving if
there is a bijection /u1D446:L(ATag) → L( /u1D442(ATag))such that Tag(/u1D447)=Tag(/u1D446(/u1D447))for all/u1D447∈
L(ATag). In such a case, we write ATag≃Tag/u1D442(ATag). Further, if the above correspondence sat-
isﬁes/u1D448(Untag(/u1D447))=Untag(/u1D446(/u1D447))for each/u1D447, we say that the TA construction procedure /u1D442is
tag-preserving over /u1D448.
6.2 The Complete Picture ofthe /Q_uantum Gate ApplicationProc edure
Tagginga TAis theﬁrst step in applyingaquantumgate.Inthe sec ondstep,foreachtermin the
updateformulae(cf.Table 1),wemakeacopyofthetaggedTAandapplytheoperationsthatwe are
goingtointroduce (projection,restriction, and multiplicatio n) toconstructthe correspondingTA.
Noticethattheoperationsare tag-preserving ,i.e.,theywillkeepthetagofallacceptedtrees.Then
we use the binary operation to merge trees with the same tag and c omplete the update formula
compositionally.In the end,we remove theTA’stagto ﬁnish the q uantumgate application5.
Example6.5. FromTable 1,we have
/u1D44C1(/u1D447)=/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651−/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651.
Forapplying thegate /u1D44C1toa taggedTAAT,we performtheconstructionsshown in Fig. 3./square
6.2.1 RestrictionOperation:Constructing A/u1D435/u1D465/u1D461·/u1D447andA/u1D435/u1D465/u1D461·/u1D447fromA/u1D447.Observethatthetree /u1D435/u1D465/u1D461·/u1D447
can be obtained by changing all leaf labels of the /u1D465/u1D461-subtrees in /u1D447to(0,0,0,0,0). In Algorithm 4
we showtheprocedureforconstructingtherestriction operat ionbasedonthisobservation. Here
/u1D44F?/u1D4601:/u1D4602is a shorthand for “if /u1D44Fis true then /u1D4601else/u1D4602.” Intuitively, when encountering a
transition with variants of /u1D465/u1D461as its label,in case /u1D44F=true,we reconnectits zero (left) child to the
5Thisisadesignchoice.Anotherpossibility istokeepthetag untilﬁnishinga llgateoperations. Untaggingafterﬁnishing
a gate hastheadvantage that it allowsa more aggressive statesp ace reduction.
Tagging:
ATProjection:
A/u1D447/u1D4651
Projection:
A/u1D447/u1D4651Restriction:
A/u1D435/u1D4651·/u1D447/u1D4651
Restriction:
A/u1D435/u1D4651·/u1D447/u1D4651Multiplication:
A/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651
Multiplication:
A/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651Binary Operation:
A/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651−/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651Untagging:
A/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651−/u1D7142·/u1D435/u1D4651·/u1D447/u1D4651duplicate
duplicate
Fig. 3. Constructions performedwhen applying the gate /u1D44C1toATagYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
Algorithm 4: Restriction operation on /u1D465/u1D461,Res(A,/u1D465/u1D461,/u1D44F)
Input:A taggedTAA={/u1D444,Σ,Δ,R},
Output:AtaggedTAA′such thatL(A′)={/u1D44F?/u1D435/u1D465/u1D461·/u1D447:/u1D435/u1D465/u1D461·/u1D447|/u1D447∈L(A)}
1Δ′
/u1D456:={/u1D45E′
0/u1D465/u1D456
/u1D457(/u1D45E′
1,/u1D45E′
2)|/u1D45E0/u1D465/u1D456
/u1D457(/u1D45E1,/u1D45E2)∈Δ};
2Δ′
/u1D459:={/u1D45E′
00()|/u1D45E0(/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458)()∈Δ};
3Δ′:=Δ′
/u1D456∪Δ′
/u1D459;
4Δadd:=Δrm:=∅;
5foreach/u1D45E/u1D465/u1D456
/u1D461(/u1D45E/u1D459,/u1D45E/u1D45F)∈Δdo
6if/u1D44FthenΔadd:=Δadd∪{/u1D45E/u1D465/u1D456
/u1D461(/u1D45E′
/u1D459,/u1D45E/u1D45F)}elseΔadd:=Δadd∪{/u1D45E/u1D465/u1D456
/u1D461(/u1D45E/u1D459,/u1D45E′
/u1D45F)};
7Δrm:=Δrm∪{/u1D45E/u1D465/u1D456
/u1D461(/u1D45E/u1D459,/u1D45E/u1D45F)};
8return{/u1D444∪/u1D444′,Σ∪{0},((Δ∪Δ′)\Δrm)∪Δadd,R};
primed version (Line 6 of Algorithm 4), so the leaves of this subtree would be all zero. The case
when/u1D44F=falseis symmetric. Note that the structure of the original and the pr imed versions are
identical, so thismodiﬁcation will not changethe tagsofaccep tedtrees.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 6.6. LetAbe a tagged TA. Then it holds that Res(A,/u1D465/u1D461,/u1D44F) ≃TagAand, moreover,
L(Res(A,/u1D465/u1D461,/u1D44F))={/u1D44F?/u1D435/u1D465/u1D461·/u1D447:/u1D435/u1D465/u1D461·/u1D447|/u1D447∈L(A)} .
6.2.2 MultiplicationOperation:Constructing A/u1D463·/u1D447fromA/u1D447.Algorithm 5givesthemultiplication
operation that workson bothtaggedandnon-taggedversion.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 6.7. LetAbe a tagged TA. Then it holds that Mult(A,/u1D463) ≃TagAand, moreover,
L(Mult(A,/u1D463))={/u1D463·/u1D447|/u1D447∈L(A)} .
6.2.3 ProjectionOperation:Constructing A/u1D447/u1D465/u1D461andA/u1D447/u1D465/u1D461fromA/u1D447.Recallthat /u1D447/u1D465/u1D461isobtainedfrom
/u1D447by ﬁxing the /u1D461-th input bit to be 1, i.e., /u1D447/u1D465/u1D461(/u1D44F1.../u1D44F/u1D461.../u1D44F/u1D45B)=/u1D447(/u1D44F1...1.../u1D44F/u1D45B).Intuitively, the
construction ofA/u1D447/u1D465/u1D461fromA/u1D447canbe doneby copyingallright subtrees of /u1D465/u1D456
/u1D461(i.e., corresponding
to/u1D465/u1D456
/u1D461=1) to replace its left ( /u1D465/u1D456
/u1D461=0) subtrees. A seemingly correct construction can be found
in Algorithm 6. For short, we use s.copyt(A)to denote s.copy(A,/u1D465/u1D461,true)ands.copyt(A)to
denotes.copy(A,/u1D465/u1D461,false).
Algorithm 5: Multiplication operation, Mult(A,/u1D463)
Input:A taggedTAA={/u1D444,Σ,Δ,R}anda constant value /u1D463(either/u1D714or1√
2)
Output:AtaggedTAA′such thatL(A′)={/u1D463·/u1D447|/u1D447∈L(A)}
1Δadd:=Δrm:=∅;
2foreach/u1D45E(/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458)()∈Δdo
3if/u1D463=/u1D714then
4 Δadd:=Δadd∪{/u1D45E(−/u1D451,/u1D44E,/u1D44F,/u1D450,/u1D458)()};
5else///u1D463=1√
2
6 Δadd:=Δadd∪{/u1D45E(/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458+1)()};
7Δrm:=Δrm∪{/u1D45E(/u1D44E,/u1D44F,/u1D450,/u1D451,/u1D458)()};
8return{/u1D444,Σ,(Δ\Δrm)∪Δadd,R};An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Algorithm 6: Subtree copyingprocedure on /u1D465/u1D461,s.copy(A,/u1D465/u1D461,/u1D44F).
Input:AtaggedTAA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔,variable /u1D465/u1D461tocopy,andaBooleanvalue /u1D44Ftoindicate
whichbranchto copy
Output:ThetaggedTA/a\}bracke⊔le{⊔/u1D444,Σ,Δ′,R/a\}bracke⊔ri}h⊔
1Δrm:=Δadd:=∅;
2foreach/u1D45E/u1D465/u1D456
/u1D461(/u1D45E/u1D459,/u1D45E/u1D45F)∈Δdo
3if/u1D44Fthen/u1D45E/u1D450:=/u1D45E/u1D45Felse/u1D45E/u1D450:=/u1D45E/u1D459;
4Δadd:=Δadd∪{/u1D45E/u1D465/u1D456
/u1D461(/u1D45E/u1D450,/u1D45E/u1D450)};
5Δrm:=Δrm∪{/u1D45E/u1D465/u1D456
/u1D461(/u1D45E/u1D459,/u1D45E/u1D45F)};
6return/a\}bracke⊔le{⊔/u1D444,Σ,(Δ\Δrm)∪Δadd,R/a\}bracke⊔ri}h⊔;
However, this construction has two issues (1) it would change t he tag of accepting trees and
(2)whenthere are morethan onepossible subtrees below /u1D45E/u1D45F(or/u1D45E/u1D459),say,forexample, /u1D4471and/u1D4472,it
mighthappenthattheresulting TAacceptsatreesuchthatones ubtree belowthesymbol /u1D465/u1D456
/u1D461is/u1D4471
while anothersubtree is /u1D4472,i.e., they are still not equaland hencenot the result after copy ing.
Although the procedure is incorrect in general, it is correct w hen/u1D461=/u1D45B, i.e., the layer just
above the leaf. Notice that constant symbols are irrelevant to a tree’s tag (all constant symbols
will be replacedwith /squarein a tag).So copyingone subtree tothe other will not aﬀect the ta gat the
leaftransition. Moreover,recallthatfromTA’sdeﬁnition, all leaf transitions have uniquestarting
states. So it will notencounter the issue (2)mentioned above.
L/e.sc/m.sc/m.sc/a.sc 6.8. Subtree copying s.copytis tag-preserving over the tree projection operation /u1D447→/u1D447/u1D465/u1D461
ands.copytistag-preserving over /u1D447→/u1D447/u1D465/u1D461when/u1D461=/u1D45B.
Fromthelemmaabove,wegetthehintthatthecopysubtreeproc edureworksonlyatthelayer
directly above leaf transitions, i.e., when applied to /u1D465/u1D45B. However, if we can reorder the variable
withoutchangingthesetofquantumstatesencodedinaTA,thenth eprojectionprocedurecanbe
applied to any qubit. Below we will demonstrate a procedure for variable reordering (it is similar
to aBDD variable reorderingprocedure [ 40]),but with anadditional eﬀort to preserve tree tags.
Example6.9. Consider the followingtree with the variable order /u1D4651>/u1D4652
/u1D4651(/u1D4652(/u1D45000,c01),/u1D4652(c10,/u1D45011)),
here/u1D450/u1D456/u1D457is the amplitude of |/u1D456/u1D457/a\}bracke⊔ri}h⊔, which intuitively means /u1D4651takes value /u1D456and/u1D4652takes/u1D457. If we
swapthevariableorderofthetwovariables,onecanconstruct thetreebelowtocapturethesame
quantumstate
/u1D4652(/u1D4651(/u1D45000,c10),/u1D4651(c01,/u1D45011)).
Notice the main diﬀerence of the two trees is that the two leaf l abels/u1D45010and/u1D45001are swapped.
This is because the second tree ﬁrst picks the value of /u1D4652and then /u1D4651, so the 01 node should be
labeled/u1D45010,whichdenotes /u1D4651takesvalue 1and /u1D4652takesvalue 0. /square
Inspired by theexample,we canswap the order oftwo consecutiv e variables bymodifyingthe
transitions of a TA.One diﬃculty is that we want to keep trees’ tag s, so we introduce two proce-
duresforward variableorder swapping (Algorithm 7)andbackward variable orderswapping (Algo-
rithm8) tomodifya variable’s order while maintaining the trees’tag.
Algorithm 7swapsthevariableorderof /u1D465/u1D461anditssucceedingsymbol /u1D465/u1D459,assumingthevariable
orderis...>/u1D465/u1D461>/u1D465/u1D459>....Weassumethatbeforerunningforwardvariableswapping,allsy mbols
corresponding to qubits /u1D465/u1D461and/u1D465/u1D459are assigned unique numbers by the tagging procedure. AfterYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
Algorithm 7: Forward variable order swapping procedureon /u1D465/u1D461,f.swap/u1D461(A)
Input:A taggedTAA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔
Output:ThetaggedTA/a\}bracke⊔le{⊔/u1D444′,Σ′,Δ′,R/a\}bracke⊔ri}h⊔
1Δrm:=Δadd:=∅,/u1D444′:=/u1D444,Σ′:=Σ;
2foreach/u1D45E/u1D465ℎ
/u1D461(/u1D45E0,/u1D45E1),/u1D45E0/u1D465/u1D456
/u1D459(/u1D45E00,/u1D45E01),/u1D45E1/u1D465/u1D457
/u1D459(/u1D45E10,/u1D45E11)∈Δdo
3Δadd:=Δadd∪{/u1D45E/u1D465/u1D456,/u1D457
/u1D459(/u1D45E′
0,/u1D45E′
1),/u1D45E′
0/u1D465ℎ
/u1D461(/u1D45E00,q10),/u1D45E′
1/u1D465ℎ
/u1D461(q01,/u1D45E11)};
4Δrm:=Δrm∪{/u1D45E/u1D465ℎ
/u1D461(/u1D45E0,/u1D45E1),/u1D45E0/u1D465/u1D456
/u1D459(/u1D45E00,q01),/u1D45E1/u1D465/u1D457
/u1D459(q10,/u1D45E11)};
5/u1D444′:=/u1D444′∪{/u1D45E′
0,/u1D45E′
1};
6Σ′:=Σ′∪{/u1D465/u1D456,/u1D457
/u1D459};
7return/a\}bracke⊔le{⊔/u1D444′,Σ′,(Δ\Δrm)∪Δadd,R/a\}bracke⊔ri}h⊔;
running the forward swapping procedure, we remember the unique num bers of both succeeding
symbols/u1D465/u1D456
/u1D459and/u1D465/u1D457
/u1D459atthenewupperlayer’ssymbol /u1D465/u1D456,/u1D457
/u1D459(Line3).Sothetrees’tagcanberecovered
in the backwardvariable order swapping procedure(Line 3 ofAl gorithm8).
Then,the projectionis computedasfollows:
Prj(A,/u1D465/u1D461,/u1D44F)=b.swap/u1D45B−/u1D461
/u1D461(s.copy(f.swap/u1D45B−/u1D461
/u1D461(A),/u1D465/u1D461,/u1D44F)), (13)
where a superscript /u1D456denotes repetition of the procedure /u1D456times. Each time when the forward
swapping procedure is triggered, we move /u1D465ℎ
/u1D461one layer lower in all trees accepted by A. We
can move /u1D465ℎ
/u1D461to the layer above the leaf by repeatedly applying the forward swapping procedure,
whichfulﬁllstherequirementforexecutingthesubtreecopyi ngprocedure.Thenweusetheback-
ward swap procedure to return the variables to the original or der. This procedure is potentially
expensive, but TAminimization algorithms[ 3,4,32]can helpto signiﬁcantly reduce the cost.
Example 6.10. Here we demonstrate how the projection operations works with a concrete ex-
ample.We assume that Aisa taggedTAwith the rootstate /u1D45Eand thefollowing transitions:
/u1D45E/u1D4651
1(/u1D45E/u1D459,/u1D45E/u1D45F) /u1D45E/u1D459/u1D4652
2(/u1D45E1,/u1D45E0) /u1D45E00()
/u1D45E/u1D459/u1D4653
2(/u1D45E0,/u1D45E1) /u1D45E11()
/u1D45E/u1D45F/u1D4654
2(/u1D45E0,/u1D45E0)
Algorithm 8: Backwardvariable order swapping procedureon /u1D465/u1D461,b.swap/u1D461(A)
Input:A taggedTAA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ,R/a\}bracke⊔ri}h⊔
Output:ThetaggedTA/a\}bracke⊔le{⊔/u1D444′,Σ′,Δ′,R/a\}bracke⊔ri}h⊔
1Δrm:=Δadd:=∅,/u1D444′:=/u1D444,Σ′:=Σ;
2foreach/u1D45E/u1D465/u1D456,/u1D457
/u1D459(/u1D45E′
0,/u1D45E′
1),/u1D45E′
0/u1D465ℎ
/u1D461(/u1D45E00,/u1D45E10),/u1D45E′
1/u1D465ℎ
/u1D461(/u1D45E01,/u1D45E11)∈Δdo
3Δadd:=Δadd∪{/u1D45E/u1D465ℎ
/u1D461(/u1D45E′′
0,/u1D45E′′
1),/u1D45E′′
0/u1D465/u1D456
/u1D459(/u1D45E00,q01),/u1D45E′′
1/u1D465/u1D457
/u1D459(q10,/u1D45E11)};
4Δrm:=Δrm∪{/u1D45E/u1D465/u1D456,/u1D457
/u1D459(/u1D45E′
0,/u1D45E′
1),/u1D45E′
0/u1D465ℎ
/u1D461(/u1D45E00,q10),/u1D45E′
1/u1D465ℎ
/u1D461(q01,/u1D45E11)};
5/u1D444′:=/u1D444′∪{/u1D45E′′
0,/u1D45E′′
1};
6Σ′:=Σ′\{/u1D465/u1D456,/u1D457
/u1D459};
7return/a\}bracke⊔le{⊔/u1D444′,Σ′,(Δ\Δrm)∪Δadd,R/a\}bracke⊔ri}h⊔;An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Algorithm 9: Binary operation, Bin(A1,A2,±)
Input:Two taggedTAsA1=/a\}bracke⊔le{⊔/u1D4441,Σ,Δ1,{/u1D45E1}/a\}bracke⊔ri}h⊔andA2=/a\}bracke⊔le{⊔/u1D4442,Σ,Δ2,{/u1D45E2}/a\}bracke⊔ri}h⊔.
Output:ThetaggedTAA′suchthatL(A′)=/a\}bracke⊔le{⊔/u1D4471±/u1D4472|/u1D4471∈L(A 1)∧/u1D4472∈L(A 2/a\}bracke⊔ri}h⊔)
1Δ′
/u1D456:={(/u1D45E1,/u1D45E2)/u1D465/u1D456
/u1D457((/u1D45E1
/u1D459,/u1D45E2
/u1D459),(/u1D45E1
/u1D45F,/u1D45E2
/u1D45F))|/u1D45E1/u1D465/u1D456
/u1D457(/u1D45E1
/u1D459,/u1D45E1
/u1D45F)∈Δ1∧/u1D45E2/u1D465/u1D456
/u1D457(/u1D45E2
/u1D459,/u1D45E2
/u1D45F)∈Δ2};
2Δ′
/u1D459:={(/u1D45E1,/u1D45E2)(/u1D44E1±/u1D44E2,/u1D44F1±/u1D44F2,/u1D4501±/u1D4502,/u1D4511±/u1D4512,/u1D4581)()|/u1D45E1(/u1D44E1,/u1D44F1,/u1D4501,/u1D4511,/u1D4581)()∈
Δ1∧/u1D45E2(/u1D44E2,/u1D44F2,/u1D4502,/u1D4512,/u1D4582)()∈Δ2};
3return/a\}bracke⊔le{⊔/u1D4441×/u1D4442,Σ′,Δ′,{(/u1D45E1,/u1D45E2)}/a\}bracke⊔ri}h⊔;
Observe thatL(A)={/u1D4471,/u1D4472},where
/u1D4471=/u1D4651
1(/u1D4652
2(1,0),/u1D4654
2(0,0))and/u1D4472=/u1D4651
1(/u1D4653
2(0,1),/u1D4654
2(0,0)).
Thenf.swap/u1D458(A)producesa TAwith a single rootstate /u1D45Eand the followingtransitions
/u1D45E/u1D4652,4
2(/u1D45E2,/u1D45E3)/u1D45E2/u1D4651
1(/u1D45E1,/u1D45E0)/u1D45E4/u1D4651
1(/u1D45E0,/u1D45E0)/u1D45E00()
/u1D45E/u1D4653,4
2(/u1D45E4,/u1D45E5)/u1D45E3/u1D4651
1(/u1D45E0,/u1D45E0)/u1D45E5/u1D4651
1(/u1D45E1,/u1D45E0)/u1D45E11()
The languageL(f.swap/u1D458(A))is{/u1D447′
1,/u1D447′
2},where
/u1D447′
1=/u1D4652,4
2(/u1D4651
1(1,0),/u1D4651
1(0,0))and/u1D447′
2=/u1D4653,4
2(/u1D4651
1(0,0),/u1D4651
1(1,0)).
Notethat /u1D447′
1and/u1D447′
2representthesamequantumstatesas /u1D4471and/u1D4472above.Then s.copy1(f.swap1(A))
producesthefollowing TAwith the rootstate /u1D45E:
/u1D45E/u1D4652,4
2(/u1D45E2,/u1D45E3)/u1D45E2/u1D4651
1(/u1D45E0,/u1D45E0)/u1D45E4/u1D4651
1(/u1D45E0,/u1D45E0)/u1D45E00()
/u1D45E/u1D4653,4
2(/u1D45E4,/u1D45E5)/u1D45E3/u1D4651
1(/u1D45E0,/u1D45E0)/u1D45E5/u1D4651
1(/u1D45E0,/u1D45E0)/u1D45E11()
Next we apply the backward swapping procedure to obtain A/u1D447/u1D4651, the ﬁnal result of applying
projection onA. More concretely,A/u1D447/u1D4651=b.swap1(s.copy1(f.swap1(A))producesa TA with the
rootstate /u1D45Eand the followingtransitions:
/u1D45E/u1D4651
1(/u1D45E′
2,/u1D45E′
3)/u1D45E′
2/u1D4652
2(/u1D45E0,/u1D45E0)/u1D45E′
4/u1D4653
2(/u1D45E0,/u1D45E0)/u1D45E00()
/u1D45E/u1D4651
1(/u1D45E′
4,/u1D45E′
5)/u1D45E′
3/u1D4654
2(/u1D45E0,/u1D45E0)/u1D45E′
5/u1D4654
2(/u1D45E0,/u1D45E0)/u1D45E11()
Observe that the languageafterprojection is
L(A/u1D447/u1D4651)={/u1D4651(/u1D4652
2(0,0),/u1D4654
2(0,0)),/u1D4651(/u1D4653
2(0,0),/u1D4654
2(0,0))},
whichis theexpectedresult. /square
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 6.11. LetAbe a tagged TA. Then it holds that Prj(A,/u1D465/u1D461,/u1D44F) ≃TagAand, moreover,
L(Prj(A,/u1D465/u1D461,/u1D44F))={/u1D44F?/u1D447/u1D465/u1D461:/u1D447/u1D465/u1D461|/u1D447∈L(A)} .
6.2.4 BinaryOperation: A/u1D4471±/u1D4472.Binaryoperationcanbedonebyamodiﬁedproductconstruction
(cf. Algorithm 9). Notice that since we apply binary operations only over TAs deri ved from the
same sourceTA,i.e., initially theyhave the same /u1D458atthe leaftransitions, and theonly possibility
of changing the /u1D458part of a leaf symbol is the multiplication with1√
2, which is done only after all
binary operationsin Table 1,we can safelyassume without lossofgenerality that /u1D4581=/u1D4582.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 6.12. LetA/u1D4471andA/u1D4472be two tagged TAs. Then it holds that L(Bin(A1,A2,±))=
{/u1D4471±/u1D4472|/u1D4471∈L(A /u1D4471)∧/u1D4472∈L(A /u1D4472)∧Tag(/u1D4471)=Tag(/u1D4472)}.
C/o.sc/r.sc/o.sc/l.sc/l.sc/a.sc/r.sc/y.sc6.13. Thecomposition-based encodingof quantum gateoperations iscorrect.
P/r.sc/o.sc/o.sc/f.sc.FollowsbyTheorems 6.6,6.7,6.11and6.12. /squareYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
7 EXPERIMENTAL EVALUATION
WeimplementedtheproposedTA-basedalgorithmasaprototyp etoolnamed A/u.sc/t.sc/o.scQinC++.We
provide two settings: H/y.sc/b.sc/r.sc/i.sc/d.sc, which uses the permutation-based approach (Section 5) to handle
supportedgatesandswitchestothecomposition-basedapproa chfortheothergates,and C/o.sc/m.sc/p.sc/o.sc/hyphen.sc
/s.sc/i.sc/t.sc/i.sc/o.sc/n.sc, which handles all gates using the composition-based approach (Section6). For checking
language equivalence between the TA representing the set of reac hable conﬁgurations and the
TA for the post-condition, we use the V/a.sc/t.sc/a.sclibrary [53]. We use a lightweight simulation-based
reduction [ 21] afterﬁnishing the Y,Z,S,T,CNOT,CZ,andTofolligate operati onsto keeptheob-
tained TAssmall.6All experiments were conducted on a server with an AMD EPYC 7742 64-core
processor (1.5GHz),1,152GiB of RAM(24GiB for eachprocess ),and a 1TB SSD running Ubuntu
20.04.4LTS.Further details (pre- andpost-conditions, circu its, etc.) canbe foundin Appendix E.
Data sets. We use the following set ofbenchmarkswith quantumcircuits:
•BV:Bernstein-Vazirani’s algorithmwith one hidden string oflength /u1D45B[13],
•MCT/o.sc/f.sc/f.sc/o.sc/l.sc/i.sc :circuitsimplementingmulti-controlledToﬀoligatesofsize /u1D45Busingavariation
ofNielsen and Chuang’sdecomposition [ 61] with standard Toﬀoligates,
•G/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scS/i.sc/n.sc/g.sc andG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scA/l.sc/l.sc :implementationofGrover’ssearch[ 46]forasingleoracle
andforallpossibleoraclesoflength /u1D45B(weencodetheoracle’sanswertobetakenfromthe
input; cf.Appendix Dformore details),
•F/e.sc/y.sc/n.sc/m.sc/a.sc/n.scB/e.sc/n.sc/c.sc/h.sc :45benchmarksfrom thetool suite F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc [8],
•R/e.sc/v.scL/i.sc/b.sc:80benchmarksofreversible and quantum circuits[ 76],and
•R/a.sc/n.sc/d.sc/o.sc/m.sc:20randomlygeneratedquantumcircuits(10circuitswith35qu bitsand105gates
and 10circuits with 70qubitsand 210gates).
We note that the benchmarksdid not contain anyunsupported gates.
Other tools. Since no existing work follows the same approach as we do, we comp aredA/u.sc/t.sc/o.scQ
with representatives ofthe following approaches:
•Quantum circuit simulators : These computethe output ofaquantumcircuit foragiven in-
put quantum state. As a representative, we selected S/l.sc/i.scQS/i.sc/m.sc[70], a state-of-the-art quan-
tumcircuitsimulatorbasedondecisiondiagrams,whichals oworkswithaprecisealgebraic
representation of complex numbers. We also tried the simulato r fromQ/i.sc/s.sc/k.sc/i.sc/t.sc[10] (which
does not provide a precise representation of numbers), but it wa s slower than S/l.sc/i.scQS/i.sc/m.scso
we do not include it in the results.
•Quantum circuitequivalencecheckers :Weselectedthefollowingequivalencecheckers:the
veriﬁerfromthe F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc7toolsuite [ 8](basedonthepathsum)and Q/c.sc/e.sc/c.sc8[20](combin-
ing decision diagrams,the ZX-calculus[ 31],and randomstimuli generation [ 19]).
We evaluated A/u.sc/t.sc/o.scQin two use cases, describedin detail below.
7.1 Verification AgainstPre- andPost-Conditions
Intheﬁrst experiment,we comparedhowfast A/u.sc/t.sc/o.scQcomputestheset ofoutputquantumstates
and checks whether the set satisﬁes a given post-condition. We c ompared against the simulator
S/l.sc/i.scQS/i.sc/m.scinthesettingwhenweranitoverallstatesencodedinthepre-c onditionofthequantum
algorithmandaccumulatedthetimes.Wenotethatwedidnotinclu dethetimeforcomparingthe
6Our technique computes a non-maximum simulation by only checking wheth er states have the same successors. The
results are in many cases the same as if the maximum simulation were c omputed, but the performance is much better.
Furtherevaluation ofthis optimization of simulation isa future wor k.
7Git commit 56e5b771
8Version2.0.0An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Table2. Verification ofquantum algorithm. Here, /u1D45Bdenotesthe parametervaluefor thecircuit, #qdenotes
the number of qubits, #Gdenotes the number of gates in the circuit. For A /u.sc/t.sc/o.scQ, the columns beforeand
a/f_terhave the format “states (transitions)” denoting the number of states and transitions in TA in the pre-
condition andtheoutputofouranalysisrespectively.Thec olumnanalysis contains thetimeittook A/u.sc/t.sc/o.scQ
to derive the TA for the output states and =denotes the time it took V/a.sc/t.sc/a.scto test equivalence. The timeout
was12min. We usecolours todistinguish the bestresult in each row and timeouts .
A/u.sc/t.sc/o.scQ-H/y.sc/b.sc/r.sc/i.sc/d.sc A/u.sc/t.sc/o.scQ -C/o.sc/m.sc/p.sc/o.sc/s.sc/i.sc/t.sc/i.sc/o.sc/n.sc S/l.sc/i.scQS/i.sc/m.sc F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc
/u1D45B#q #G before after analysis =before after analysis =time verdict timeBV95 96 241 193 (193) 193 (193) 6.0s 0.0s 193 (193) 193 (193) 7.1s 0.0s 0.0s equal 0.5s
96 97 243 195 (195) 195 (195) 5.9s 0.0s 195 (195) 195 (195) 7.1s 0.0s 0.0s equal 0.5s
97 98 246 197 (197) 197 (197) 6.3s 0.0s 197 (197) 197 (197) 7.4s 0.0s 0.0s equal 0.6s
98 99 248 199 (199) 199 (199) 6.5s 0.0s 199 (199) 199 (199) 7.7s 0.0s 0.0s equal 0.6s
99 100 251 201 (201) 201 (201) 6.7s 0.0s 201 (201) 201 (201) 7.8 s 0.0s 0.0s equal 0.6sG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scS/i.sc/n.sc/g.sc12 24 5,215 49 (49) 71 (71) 11s 0.0s 49 (49) 71 (71) 49s 0.0s 2.8s timeout
14 28 12,217 57 (57) 83 (83) 31s 0.0s 57 (57) 83 (83) 2m26s 0.0s 18s timeout
16 32 28,159 65 (65) 95 (95) 1m29s0.0s 65 (65) 95 (95) 6m59s 0.0s 1m41s timeout
18 36 63,537 73 (73) 107 (107) 4m1s0.0s timeout 9m27s timeout
20 40 141,527 81 (81) 119 (119) 10m56s 0.0s timeout timeout timeoutMCT/o.sc/f.sc/f.sc/o.sc/l.sc/i.sc8 16 15 33 (42) 104 (149) 0.0s0.0s 33 (42) 404 (915) 2.8s 0.0s 1.6s equal 0.0s
10 20 19 41 (52) 150 (216) 0.0s0.0s 41 (52) 1,560 (3,607) 27s 0.0s 6.1s equal 0.1s
12 24 23 49 (62) 204 (295) 0.0s0.0s 49 (62) 6,172 (14,363) 6m48s 0.1s 25s equal 0.1s
14 28 27 57 (72) 266 (386) 0.1s0.0s timeout 1m40s equal 0.1s
16 32 31 65 (82) 336 (489) 0.2s0.0s timeout timeout equal 0.2sG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scA/l.sc/l.sc6 18 357 37 (43) 252 (315) 3.3s 0.0s 37 (43) 510 (573) 12s 0.0s 1.7s timeout
7 21 552 43 (50) 481 (608) 10s 0.0s 43 (50) 1,123 (1,250) 42s 0.0 s5.4s timeout
8 24 939 49 (57) 934 (1,189) 39s 0.1s 49 (57) 2,472 (2,727) 2m40 s 0.0s 26s timeout
9 27 1,492 55 (64) 1,835 (2,346) 2m17s 0.4s 55 (64) 5,421 (5,93 2) 10m13s 0.1s 2m5s timeout
10 30 2,433 61 (71) 3,632 (4,655) 9m48s2.1s timeout 11m31s timeout
resultofS/l.sc/i.scQS/i.sc/m.scagainstapost-conditionspeciﬁcationduetothefollowinglim itationofthetool:
itcanproducethestateafterexecutingthecircuitinthevec torform,butthisstepisnotoptimized
andisquitetime-consuming.Sincethestep ofaccumulatingtheob tainedstatescouldpossiblybe
done in a more eﬃcient way, avoiding transforming them ﬁrst into the vector form, we do not
include it in theruntime to not give S/l.sc/i.scQS/i.sc/m.scan unfair disadvantage. Thetimeout was12min.
Wealsoincludethetimetakenby F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc tochecktheequivalenceofthecircuitswiththem-
selves. Althoughcheckingequivalenceof quantumcircuits is a harder problemthan what we are
solving(sotheresultscannotbeusedfordirectcomparisonwit hA/u.sc/t.sc/o.scQ),weincludetheseresults
in order to give an idea about hardnessof thecircuits forpath -sum-based approaches.
We ran this experiment on the benchmarks where the semantics was known to us so that we
could construct TAs with pre- and post-conditions. These were th e following: BV,MCT/o.sc/f.sc/f.sc/o.sc/l.sc/i.sc ,
G/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scS/i.sc/n.sc/g.sc , andG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scA/l.sc/l.sc . We give the results in Table 2. BothBVandG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scS/i.sc/n.sc/g.sc work
with only one input state, which should be most favourable for si mulators. Surprisingly, for the
caseofG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scS/i.sc/n.sc/g.sc ,A/u.sc/t.sc/o.scQoutperforms S/l.sc/i.scQS/i.sc/m.sconlargecases(outofcuriosity,wetriedtorun
S/l.sc/i.scQS/i.sc/m.sconG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scS/i.sc/n.sc/g.sc (/u1D45B=20)without a timeout; the running time was 51m43s).We attribu te
the good performance of A/u.sc/t.sc/o.scQto the compactness of the TA representation of Grover’s state
space.On the otherhand,both MCT/o.sc/f.sc/f.sc/o.sc/l.sc/i.sc andG/r.sc/o.sc/v.sc/e.sc/r.sc/hyphen.scA/l.sc/l.sc consider 2/u1D45Binput states and we can
observe the exponential factor emerging; hence A/u.sc/t.sc/o.scQoutperforms S/l.sc/i.scQS/i.sc/m.scin large cases. All
toolsperformprettywellon BV,evencaseswith100qubitscanbeeasilyhandled.Wecanalsos ee
thatH/y.sc/b.sc/r.sc/i.sc/d.scis consistently faster than C/o.sc/m.sc/p.sc/o.sc/s.sc/i.sc/t.sc/i.sc/o.sc/n.sc .
7.2 FindingBugs
In the following experiment, we compared A/u.sc/t.sc/o.scQwith the equivalence checkers F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc and
Q/c.sc/e.sc/c.scandevaluatedtheabilityofthetoolstodeterminethattwoqua ntumcircuitsarenon-equivalent
(thisistosimulatetheusecaseofverifyingtheoutputofano ptimizer).WetookcircuitsfromtheYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
Table3. Resultsforbugfinding.Thenotationisthesameasi nTable2.Inaddition,thecolumn bug?indicates
if the tool caught the injected bug: T denotes that the bug was found,Fdenotes that the tool gave an
incorrect result, and —means unknown result (includes the tool reporting unknown,crash, or not enough
resources). A/u.sc/t.sc/o.scQfinds all bugs within the time limit, and we provide the numbe r of iterations needed to
catch the bug (column iter). The timeout was30min.
A/u.sc/t.sc/o.scQ F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc Q/c.sc/e.sc/c.sc A/u.sc/t.sc/o.scQ F/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc Q/c.sc/e.sc/c.sc
circuit #q #G time iter time bug? time bug? circuit #q #G time ite r time bug? time bug?F/e.sc/y.sc/n.sc/m.sc/a.sc/n.scB/e.sc/n.sc/c.sc/h.sccsum_mux_9 30 141 0.8s16.5s—44.0s F hwb10 16 31,765 1m42s 1 timeout 30.2s T
gf2^10_mult 30 348 2.0s10.6s—42.7s F hwb11 15 87,790 4m23s 1 timeout 35.9s T
gf2^16_mult 48 876 11s14.8s— 58.5s T hwb12 20 171,483 13m43s 1 timeout 1m3s T
gf2^32_mult 96 3,323 2m4s 1 48.1s—1m58s T hwb8 12 6,447 15s1timeout 23.4s T
ham15-high 20 1,799 8.0s13m51s — 30.2s T qcla_adder_10 36 182 2.8s11.3s—46.6s F
mod_adder_1024 28 1,436 10s19.2s— 31.9s T qcla_mod_7 26 295 2.6s11m24s —38.4s FR/a.sc/n.sc/d.sc/o.sc/m.sc35a 35 106 3.2s10.2s—45.7s F 70a 70 211 16s11.1s— 1m18s T
35b 35 106 1.4s 1 0.2sT47.8s F 70b 70 211 14s 1 0.8sT 1m11s T
35c 35 106 1.3s 1 0.2sT 47.5s T 70c 70 211 12s10.9s— 1m24s T
35d 35 106 1.3s 1 0.2sT 48.2s T 70d 70 211 29m29s 36 1.2sT 1m26s T
35e 35 106 1.3s10.1s— 50.6s T 70e 70 211 17s11.0s— 1m30s T
35f 35 106 2.4s 1 0.3sT49.7s F 70f 70 211 33s 1 0.9sT1m26s F
35g 35 106 4.0s30.2s— 55.3s T 70g 70 211 14m42s 44 1.2s—1m35s T
35h 35 106 1.0s10.2s—0.6s— 70h 70 211 13s11.2s— 1m36s T
35i 35 106 1.3s 1 0.2sT 54.8s T 70i 70 211 23s11.2s— 1m36s T
35j 35 106 1.8s10.2s—51.4s F 70j 70 211 2m5s 1 1.4s—1m34s TR/e.sc/v.scL/i.sc/b.scadd16_174 49 65 2.6s1timeout 1m8s T urf1_149 9 11,555 30s1timeout 35.8s T
add32_183 97 129 17s1timeout 2m4s T urf2_152 8 5,031 11s1 21m33s T 32.5s T
add64_184 193 257 1m55s 1timeout 0.6s— urf3_155 10 26,469 1m19s 1 timeout 33.0s T
avg8_325 320 1,758 21m18s 1timeout 0.5s— urf4_187 11 32,005 1m57s 1 timeout 31.4s T
bw_291 87 308 10s1 11.7s T 1m55s T urf5_158 9 10,277 27s 1 timeout 26.6s T
cycle10_293 39 79 0.5s 1 0.4sT 1m7s T urf6_160 15 10,741 1m6s 1 timeout 36.2s T
e64-bdd_295 195 388 36s1timeout 0.5s— hwb6_301 46 160 2.0s1 2.7s T 1m7s T
ex5p_296 206 648 1m52s 1 1m29s T0.4s— hwb7_302 73 282 8.3s1 10.9s T 1m38s T
ham15_298 45 154 0.6s10.6sT 1m14s T hwb8_303 112 450 27s1 37.9s T 2m22s T
mod5adder_306 32 97 0.5s1 0.7s T 1m1s T hwb9_304 170 700 1m33s 1 2m20s T 0.6s—
rd84_313 34 105 0.5s1 1.1s T 1m2s T
benchmarks F/e.sc/y.sc/n.sc/m.sc/a.sc/n.scB/e.sc/n.sc/c.sc/h.sc ,R/a.sc/n.sc/d.sc/o.sc/m.sc, andR/e.sc/v.scL/i.sc/b.sc, and for each circuit, we created a copy and
injected an artiﬁcial bug (one additional randomly selected gat e at a random location). Then we
ran the tools and let them check circuit equivalence; for A/u.sc/t.sc/o.scQ, we let it compute two TAs rep-
resenting sets of output states for both circuits for the given set of input states and then checked
their languageequivalencewith V/a.sc/t.sc/a.sc.
Ourstrategyforﬁndingbugswith A/u.sc/t.sc/o.scQ(weusedthe H/y.sc/b.sc/r.sc/i.sc/d.scsetting) wasthefollowing:We
started with a TA representing a single basis state, i.e., a TA wi th no top-down nondeterminism,
and gradually added more non-deterministic transitions (in each i teration one randomly chosen
transition) into theTA,makingit represent a largerset of states , running the analysis foreach of
theTAs,untilwefoundthebug.Thisprovedtobeasuccessfulst rategy,sincerunningtheanalysis
with an input TA representing, e.g., all possible basis states, might be too challenging (generally
speaking,thelargeris the TArepresenting the set ofstates, th e slower is the analysis).
We present the results in Table 3. We exclude trivial cases (all tools can ﬁnish within 5s) and
diﬃcult cases that no tool can handle within the timeout period (30min). We can see that many
of the cases were so tricky that equivalence checkers failed t o conclude anything, while A/u.sc/t.sc/o.scQ
succeeded in ﬁnding the bug with just the ﬁrst few TAs. For two ins tances from R/a.sc/n.sc/d.sc/o.sc/m.sc (70d
and70g),wefoundthebugaftertrying36TAsafter29m29sand44TA safter14m42s,respectively.
Fora few cases(e.g.,csum_mux_9), Q/c.sc/e.sc/c.scdid not ﬁnd the bugandreported thatthe circuitswere
equivalent (F)9, whileA/u.sc/t.sc/o.scQreported it (T). For these cases, we fed the witness produced b y
A/u.sc/t.sc/o.scQtoS/l.sc/i.scQS/i.sc/m.scand conﬁrmedthe two circuits are diﬀerent.
The results show that our approach to hunting for bugs in quantum circuits is beneﬁcial, par-
ticularly for larger circuits where equivalence checkers do not scale. For such cases, A/u.sc/t.sc/o.scQcan
still ﬁnd bugs using a weaker speciﬁcation. For instance, A/u.sc/t.sc/o.scQwas able to ﬁnd bugs in some
9Thisbug hasbeenconﬁrmed bythe Q/c.sc/e.sc/c.scteamandﬁxedlater,cf.[ 2].An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
large-scale instances from R/e.sc/v.scL/i.sc/b.scwith hundreds of qubits, e.g., add64_184and avg_8_325,while
bothF/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc andQ/c.sc/e.sc/c.scfail.
We note that the area of quantum circuit equivalence checking is r apidly advancing. When
preparing the ﬁnal version, we became aware of S/l.sc/i.scQEC[24,75], a recent tool that outperforms
the otherequivalence checkersthat we tried on thisbenchmark .
8 RELATED WORK
Circuitequivalencecheckers areoftenveryeﬃcientbutlessﬂexibleinspecifyingthedesir ed prop-
erty(onlyequivalence).Ourapproachcanswitch toalightwei ghtspeciﬁcation whenveriﬁcation
fails due to insuﬃcient resources and still ﬁnd bugs in the design. Often equivalence checking is
done by a reduction to normal form using a set of rewriting rules. Path-sum is a recent approach
proposedin[ 8],whoserewriterulescansolvetheequivalenceproblemofCl iﬀordgroupcircuitsin
polynomialtime.The ZX-calculus [31]isagraphicallanguagethatisparticularlyuseful incircu it
optimization and proving equivalence.Theworksof [ 49]ensures correctnessofthe rewrite rules
with a theorem prover. Quartz [ 79] is a circuit optimization framework consisting of an equiv-
alence checker based on some precomputed equivalence sets. We pickF/e.sc/y.sc/n.sc/m.sc/a.sc/n.sc [8], a state-of-
the-art equivalence checker based on path-sum, and Q/c.sc/e.sc/c.sc[20], based on decision diagrams and
ZX-calculus, as the baseline tools for comparison. Quantum circuit simulators , e.g.S/l.sc/i.scQS/i.sc/m.sc[70],
canbe used asequivalencecheckersfor aﬁnite number ofinputs by trying all basis states.
Quantumabstractinterpretation [65,88]isparticularlyeﬃcientinprocessinglarge-scalecircuits ,
but it over-approximates state space and cannot conclude anything when veriﬁcation fails. For
instance,theworkin[ 88]canonlydistinguishquantumstateswithzeroandnon-zeroprobab ility
(and cannot derive exact boundary probabilities). In contrast, o ur approach precisely represents
reachable states and can reveal bugs. One can consider our appro ach to be an instantiation of
classical abstract interpretation [ 34] that is precise, and our approach to non-equivalence testing
ascomparingoutput abstractcontextsoftwoprograms. Quantum modelchecking supportsa rich
speciﬁcation language (ﬂavors of temporal logic [ 44,57,78]). It can be seen as an extension of
probabilistic model checking [ 41,42,44,78,83–85] and is more suitable for verifying high-level
protocols due to the limited scalability [ 11]. Techniquesbased on quantum simulation [45,62,63,
66,70,73,74,90,91] allowonly oneinput quantumstate and thushave limited analyzing p ower.
Quantum Hoare logic [43,54,71,82,89]) allows veriﬁcation against complex correctness prop-
erties and rich program constructs such as branches and loops, bu t requires signiﬁcant manual
work. On the other hand, quantum incorrectness logic [81] is a dual of quantum Hoare logic that
allows showing the existence of a bug, but cannot prove its absence . TheQ/b.sc/r.sc/i.sc/c.sc/k.sc/s.sc [23] approach
alleviates the diﬃculty of proof search by combining state-of -the-art theorem provers with deci-
sion procedures,but,accordingtotheir experiments,still r equiresasigniﬁcant amountofhuman
intervention. For instance, their experiments show that it requir es 125 times intervention during
veriﬁcation of Grover’s searchw.r.t. an arbitrary numberof qubits.
9 CONCLUDINGREMARKS
Wehaveintroducedanewparadigmforquantumcircuitanalysisth atisexcitingfrombothpracti-
calandtheoreticallenses.Wedemonstratedoneofitspotentiala pplications—circuitnon-equivalence
checking,butwebelievetherecouldbemuchmore.Inourownex perienceofusingthemethodto
prepare thebenchmarks,itsroleissimilar to astatic assert ion checker(like software modelcheck-
ersfor classical programs[ 28,48]);it helpedus greatly to ﬁnd several problemswhile composi ng
the circuits. The connection to automata-based veriﬁcation i s also quite exciting. A series of ap-
proaches from the classical world should also be helpful in t he quantum case. For instance, the
idea of regular tree model checking could be leveraged to veri fy parameterized quantum circuitsYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
(w.r.t.anarbitrarynumberofqubits)[ 5,15].Forthis,onewouldneedtodealwithTAswithloops,
wheretaggingcannotbedoneanymoretoimposerelationsamongtrees (onewouldneedtousean
unboundednumberoftags)—newideasareneeded.Automata-learning canbeusedforautomatic
loopinvariant inference [ 27].Symbolicautomata [ 37]andregister automata[ 29]would allow us-
ing variables to describe amplitude (instead of a ﬁxed alphabe t as we use now). We believe there
are many othertechniquesfrom the automata world that couldbe used to extend our framework
and beapplied in the area of analysingquantum circuits.
ACKNOWLEDGMENTS
We thank the POPL’23 and PLDI’23 reviewers for their in-depth re marks that helped us improve
thequalityofthepaperandthePLDI’23artifactcommitteeme mbersfortheirhelpfulsuggestions
abouttheartifact.Thismaterialisbasedonaworksupporte dbytheCzechMinistryofEducation,
YouthandSportsprojectLL1908oftheERC.CZprogramme;theC zechScienceFoundationproject
GA23-07565S;theFITBUTinternalprojectFIT-S-23-8151;andt heNSTCQCprojectunderGrant
no.NSTC111-2119-M-001-004-.
DATA AVAILABILITY STATEMENT
Anenvironmentwiththetoolsanddatausedfortheexperimentalev aluationinthecurrentstudy
is available at [ 26].
REFERENCES
[1] 2022. GMP:TheGNU MultiplePrecision ArithmeticLibrary. https://gmplib.org/
[2] 2022. The Q/c.sc/e.sc/c.sc repository: Issue #200 (ZX-Checker produces invalid result).
https://github.com/cda-tum/qcec/issues/200
[3] ParoshAzizAbdulla,AhmedBouajjani,LukásHolík,LisaKaati, andTomásVojnar.2008.ComputingSimulationsover
Tree Automata. In Tools and Algorithms for the Construction and Analysis of Sy stems, 14th International Conference,
TACAS 2008, HeldasPart ofthe Joint European Conferenceson Theoryand PracticeofSoftware, ETAPS 2008, Budapest,
Hungary,March29-April6,2008.Proceedings(LectureNote sinComputerScience) ,C.R.RamakrishnanandJakobRehof
(Eds.),Vol. 4963.Springer, 93–108. https://doi.org/10.1007/978-3-540-78800-3_8
[4] Parosh Aziz Abdulla, Johanna Högberg, and Lisa Kaati. 2007. Bisim ulation Minimization of Tree Automata. Int. J.
Found. Comput.Sci. 18,4(2007),699–713. https://doi.org/10.1142/S0129054107004929
[5] Parosh Aziz Abdulla,Bengt Jonsson, PrithaMahata, andJuliend’ Orso.2002. Regular TreeModelChecking. In Com-
puter Aided Veriﬁcation, 14th International Conference,C AV 2002,Copenhagen, Denmark, July 27-31, 2002, Proceeding s
(Lecture Notes in Computer Science) , Ed Brinksma and Kim Guldstrand Larsen (Eds.), Vol. 2404. Springer, 555–568.
https://doi.org/10.1007/3-540-45657-0_47
[6] Dorit Aharonov. 2003. A Simple Proof that Toﬀoli and Hadamard are Quantum Universal.
https://doi.org/10.48550/arxiv.quant-ph/0301040
[7] Thorsten Altenkirch and Jonathan Grattage. 2005. A Functional Q uantum Programming Language. In 20th IEEE
Symposium onLogic in Computer Science (LICS 2005), 26-29 Ju ne 2005, Chicago, IL, USA, Proceedings . IEEE Computer
Society, 249–258. https://doi.org/10.1109/LICS.2005.1
[8] Matthew Amy. 2018. Towards large-scale functional veriﬁcat ion of universal quantum circuits. In Quantum Physics
and Logic .
[9] MatthewAmy. 2019. FormalMethods inQuantum Circuit Design . Ph.D.Dissertation.Universityof Waterloo.
[10] MD SAJID ANIS, Abby-Mitchell, Héctor Abraham, et al. 202 1. Qiskit: An Open-source Framework for Quantum
Computing. https://doi.org/10.5281/zenodo.2573505
[11] LindaAnticoli,CarlaPiazza,LeonardoTaglialegne,andPaoloZul iani.2016.TowardsQuantumProgramsVeriﬁcation:
FromQuipperCircuitstoQPMC.In ReversibleComputation-8thInternationalConference,RC 2016,Bologna,Italy,July
7-8, 2016, Proceedings (Lecture NotesinComputerScience) ,Simon J.Devittand IvanLanese(Eds.),Vol.9720.Springer,
213–219. https://doi.org/10.1007/978-3-319-40578-0_16
[12] Frank Arute,Kunal Arya,Ryan Babbush,Dave Bacon, Joseph C . Bardin, Rami Barends,Rupak Biswas, SergioBoixo,
FernandoG.S.L.Brandao,DavidA.Buell,BrianBurkett,YuChen,Zij unChen,BenChiaro,RobertoCollins,William
Courtney, Andrew Dunsworth, Edward Farhi, Brooks Foxen, Austin Fo wler, Craig Gidney, Marissa Giustina, Rob
Graﬀ, KeithGuerin, SteveHabegger,MatthewP.Harrigan, MichaelJ .Hartmann, Alan Ho, MarkusHoﬀmann, TrentAn Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Huang, Travis S. Humble, Sergei V. Isakov, Evan Jeﬀrey, Zhang Jia ng, Dvir Kafri, Kostyantyn Kechedzhi, Julian
Kelly, Paul V. Klimov, Sergey Knysh, Alexander Korotkov, Fedor Kostritsa, David Landhuis, Mike Lindmark, Erik
Lucero, Dmitry Lyakh, Salvatore Mandrà, Jarrod R. McClean, Mat thew McEwen, Anthony Megrant, Xiao Mi, Kris-
tel Michielsen, Masoud Mohseni, Josh Mutus, Ofer Naaman, Matthew N eeley, Charles Neill, Murphy Yuezhen Niu,
Eric Ostby, Andre Petukhov, John C. Platt, Chris Quintana, Eleanor G . Rieﬀel, Pedram Roushan, Nicholas C. Rubin,
Daniel Sank, Kevin J. Satzinger, Vadim Smelyanskiy, Kevin J. Sung, Matth ew D. Trevithick, Amit Vainsencher, Ben-
jamin Villalonga, Theodore White, Z. Jamie Yao, Ping Yeh, Adam Zalcm an, Hartmut Neven, and John M. Martinis.
2019. Quantumsupremacy using aprogrammable superconducting pro cessor.Nature574,7779(Oct.2019),505–510.
https://doi.org/10.1038/s41586-019-1666-5 Number:7779 Publisher:Nature PublishingGroup.
[13] EthanBernsteinandUmeshV.Vazirani.1993. Quantumcomplexity theory.In ProceedingsoftheTwenty-FifthAnnual
ACM Symposium on Theory of Computing, May 16-18, 1993, San Di ego, CA, USA , S. Rao Kosaraju, David S. Johnson,
and Alok Aggarwal (Eds.).ACM,11–20. https://doi.org/10.1145/167088.167097
[14] Jacob D.Biamonte,PeterWittek,NicolaPancotti,PatrickRebe ntrost,NathanWiebe,andSethLloyd.2017. Quantum
machine learning. Nature549,7671(2017),195–202. https://doi.org/10.1038/nature23474
[15] AhmedBouajjani,PeterHabermehl,AdamRogalewicz,andTom ášVojnar.2012. Abstractregular(tree)modelcheck-
ing.International JournalonSoftware ToolsforTechnologyTra nsfer14,2(2012),167–191.
[16] Ahmed Bouajjani, Bengt Jonsson, Marcus Nilsson, and Tayssir Touil i. 2000. Regular Model Checking. In Com-
puter Aided Veriﬁcation, 12th International Conference, C AV 2000, Chicago, IL, USA, July 15-19, 2000, Proceedings
(Lecture Notes in Computer Science) , E. Allen Emerson and A. Prasad Sistla (Eds.), Vol. 1855. Springe r, 403–418.
https://doi.org/10.1007/10722167_31
[17] P. Oscar Boykin, TalMor, MatthewPulver, Vwani P. Roychowd hury, and Farrokh Vatan. 2000. A newuniversal and
fault-tolerant quantum basis. Inf.Process. Lett. 75,3(2000),101–107. https://doi.org/10.1016/S0020-0190(00)00084-3
[18] Randal E. Bryant. 1986. Graph-Based Algorithms for Boolea n Function Manipulation. IEEE Trans. Computers 35, 8
(1986),677–691. https://doi.org/10.1109/TC.1986.1676819
[19] Lukas Burgholzer, Richard Kueng, and Robert Wille.2021. Ra ndom Stimuli Generation for theVeriﬁcation of Quan-
tumCircuits. In ASPDAC ’21: 26th Asia andSouthPaciﬁc DesignAutomationCon ference,Tokyo, Japan, January 18-21,
2021. ACM,767–772. https://doi.org/10.1145/3394885.3431590
[20] Lukas Burgholzer and Robert Wille. 2020. Advanced equivale nce checking for quantum circuits. IEEE Transactions
onComputer-Aided DesignofIntegratedCircuits and System s40,9 (2020),1810–1824.
[21] Doron Bustan and Orna Grumberg. 2003. Simulation-based minimaz ation.ACM Trans. Comput. Log. 4, 2 (2003),
181–206. https://doi.org/10.1145/635499.635502
[22] Yudong Cao, Jonathan Romero, Jonathan P. Olson, Matthias Deg roote, Peter D. Johnson, Mária Kieferová, Ian D.
Kivlichan, Tim Menke, Borja Peropadre, Nicolas P. D. Sawaya, Sukin S im, Libor Veis, and Alán Aspuru-Guzik.
2019. Quantum Chemistry in the Age of Quantum Computing. Chemical Reviews 119, 19 (2019), 10856–10915.
https://doi.org/10.1021/acs.chemrev.8b00803 arXiv:https://doi.org/10.1021/acs.chemrev.8b00803 PMID:31469277.
[23] Christophe Chareton, Sébastien Bardin, François Bobot, Valent in Perrelle,and Benoît Valiron. 2021. An Automated
Deductive Veriﬁcation Framework forCircuit-Building Quantum Progr ams. InESOP (Lecture Notesin ComputerSci-
ence),Nobuko Yoshida (Ed.),Vol.12648.Springer InternationalPublishing ,Cham,148–177.
[24] Tian-Fu Chen, Jie-Hong R. Jiang, and Min-Hsiu Hsieh. 2022. Partial Equ ivalence Checking of Quan-
tum Circuits. In 2022 IEEE International Conference on Quantum Computing an d Engineering (QCE) . 594–604.
https://doi.org/10.1109/QCE53715.2022.00082
[25] Yu-Fang Chen, Kai-Min Chung, Ondrej Lengál, Jyun-Ao Lin, Wei-Lun Ts ai, and Di-De Yen. 2023. An Automata-
Based Framework for Veriﬁcation and Bug Hunting in Quantum Circuits. Proc. ACM Program. Lang. 7, PLDI (2023),
1218–1243. https://doi.org/10.1145/3591270
[26] Yu-Fang Chen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei-LunTs ai,andDi-DeYen.2023. AnAutomata-based
Framework for Veriﬁcation and Bug Hunting in Quantum Circuits. https://doi.org/10.5281/zenodo.7811406
[27] Yu-Fang Chen,Chih-DuoHong, Anthony W Lin, and PhilippRümmer. 2017 . Learning to prove safety over parame-
terisedconcurrent systems.In 2017 FormalMethods inComputerAided Design(FMCAD) . IEEE,76–83.
[28] Yu-Fang Chen, Chiao Hsieh, Ondřej Lengál, Tsung-Ju Lii, Ming-Hsien T sai, Bow-Yaw Wang, and Farn Wang. 2016.
PAC learning-based veriﬁcation and model synthesis.In Proceedings ofthe 38th International ConferenceonSoftwa re
Engineering . 714–724.
[29] Yu-Fang Chen,OndřejLengál,TonyTan,andZhilinWu.2017. Registe rautomatawithlineararithmetic.In 201732nd
Annual ACM/IEEE Symposium onLogic inComputerScience(LIC S). IEEE,1–12.
[30] CarloCiliberto,MarkHerbster,AlessandroDavideIalongo, MassimilianoPontil,AndreaRocchetto, SimoneSeverini,
andLeonardWossnig.2018. QuantumMachineLearning:AClassicalPerspe ctive.ProceedingsoftheRoyalSocietyA:
Mathematical, Physical andEngineering Sciences 474,2209(January 2018).Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
[31] Bob Coecke and Ross Duncan. 2011. Interacting quantum observab les:categorical algebra and diagrammatics. New
Journal ofPhysics 13,4 (apr 2011),043016. https://doi.org/10.1088/1367-2630/13/4/043016
[32] Hubert Comon, Max Dauchet,Rémi Gilleron, Florent Jacquema rd, Denis Lugiez, ChristofLöding, Sophie Tison,and
Marc Tommasi. 2008. Treeautomata techniques and applications.
[33] D. Coppersmith. 2002. An approximate Fourier transform use ful in quantum factoring.
https://doi.org/10.48550/arxiv.quant-ph/0201067
[34] Patrick Cousot and Radhia Cousot. 1977. Abstract Interpret ation: A Uniﬁed Lattice Model for Static Analysis of
Programs by Construction or Approximation of Fixpoints. In Conference Record of the Fourth ACM Symposium on
PrinciplesofProgrammingLanguages,LosAngeles,Califor nia,USA,January1977 , RobertM.Graham,MichaelA.Har-
rison, andRavi Sethi (Eds.).ACM,238–252. https://doi.org/10.1145/512950.512973
[35] LorisD’Antoni,MargusVeanes,Benjamin Livshits,andDavidMolnar. 2015. Fast:ATransducer-BasedLanguage for
TreeManipulation. ACMTrans. Program.Lang. Syst. 38,1 (2015),1:1–1:32. https://doi.org/10.1145/2791292
[36] ChristopherMDawsonandMichaelANielsen.2005. TheSolovay -Kitaevalgorithm. arXivpreprintquant-ph/0505030
(2005).
[37] Loris D’AntoniandMargusVeanes.2017. Thepower ofsymbolica utomata andtransducers.In International Confer-
ence onComputerAided Veriﬁcation . Springer,47–67.
[38] MarkEttinger,PeterHøyer,andEmanuelKnill.2004.Thequantu mquerycomplexityofthehiddensubgroupproblem
is polynomial. Inf.Process. Lett. 91,1 (2004),43–48. https://doi.org/10.1016/j.ipl.2004.01.024
[39] Andrew Fagan and Ross Duncan. 2019. Optimising Cliﬀord Circuits with Quantomatic. Electronic Proceedings in
Theoretical ComputerScience 287(jan 2019),85–105. https://doi.org/10.4204/eptcs.287.5
[40] Eric Felt, Gary York, Robert K. Brayton, and Alberto L. Sangio vanni-Vincentelli. 1993. Dynamic variable re-
ordering for BDD minimization. In Proceedings of the European Design Automation Conference 1 993, EURO-
DAC ’93 with EURO-VHDL’93, Hamburg, Germany, September 20- 24, 1993. IEEE Computer Society, 130–135.
https://doi.org/10.1109/EURDAC.1993.410627
[41] Yuan Feng, Ernst Moritz Hahn, Andrea Turrini, and Shenggang Ying. 2017 . Model checking omega-regular prop-
erties for quantum Markov chains. In 28th International Conference on Concurrency Theory (CONC UR 2017). Schloss
Dagstuhl-Leibniz-ZentrumfuerInformatik.
[42] Yuan Feng, Ernst Moritz Hahn, Andrea Turrini, and Lijun Zhang. 2015. QPMC: A Model Checker for Quantum
Programs and Protocols. In International Symposium on Formal Methods , Nikolaj Bjørner and Frank de Boer (Eds.).
Springer InternationalPublishing,265–272.
[43] Yuan FengandMingshengYing.2021. QuantumHoarelogicwithclassic alvariables. ACMTransactionsonQuantum
Computing 2,4 (2021),1–43.
[44] Yuan Feng, Nengkun Yu, and Mingsheng Ying. 2013. Model checking qua ntum Markov chains. J. Comput. Syst. Sci.
79,7(2013),1181–1198. https://doi.org/10.1016/j.jcss.2013.04.002
[45] AlexanderS.Green,PeterLeFanuLumsdaine,NeilJ.Ross,Pete rSelinger,andBenoîtValiron.2013.Quipper:ascalable
quantum programming language. In ACM SIGPLAN Conference on Programming Language Design and I mplementa-
tion, PLDI ’13, Seattle, WA, USA, June 16-19, 2013 , Hans-Juergen Boehm and Cormac Flanagan (Eds.).ACM, 333–342.
https://doi.org/10.1145/2491956.2462177
[46] LovK.Grover.1996. AFastQuantumMechanicalAlgorithmfor DatabaseSearch.In ProceedingsoftheTwenty-Eighth
AnnualACMSymposiumontheTheoryofComputing,Philadelph ia,Pennsylvania,USA,May22-24,1996 ,GaryL.Miller
(Ed.).ACM,212–219. https://doi.org/10.1145/237814.237866
[47] Wakaki Hattori and Shigeru Yamashita. 2018. Quantum Circuit O ptimization by Changing the Gate Order for 2D
NearestNeighborArchitectures.In ReversibleComputation-10thInternationalConference,R C2018,Leicester,UK,Sep-
tember12-14, 2018, Proceedings (Lecture NotesinComputer Science),JarkkoKari andIrekUlidowski(Eds.),Vol.11106.
Springer, 228–243. https://doi.org/10.1007/978-3-319-99498-7_16
[48] Matthias Heizmann, Yu-Fang Chen, Daniel Dietsch, Marius Greitschu s, Jochen Hoenicke, Yong Li, Alexander Nutz,
Betim Musa, Christian Schilling, Tanja Schindler, et al. 2018. Ultimat e automizer and the search for perfect inter-
polants. In International Conference on Tools and Algorithms for the Co nstruction and Analysis of Systems . Springer,
447–451.
[49] KeshaHietala,RobertRand,Shih-HanHung,XiaodiWu,andMicha elHicks.2019.Veriﬁedoptimizationinaquantum
intermediate representation. arXiv preprint arXiv:1904.06319 (2019).
[50] ToshinariItoko,RudyRaymond,TakashiImamichi,andAtsushi Matsuo.2020. Optimizationofquantumcircuitmap-
ping using gate transformation and commutation. Integr.70(2020),43–50. https://doi.org/10.1016/j.vlsi.2019.10.004
[51] Dominik Janzing, Pawel Wocjan, and Thomas Beth. 2005. "Non-Identit y-Check" Is QMA-complete. International
Journal ofQuantum Information 03,03 (2005),463–473. https://doi.org/10.1142/S0219749905001067
[52] Iordanis Kerenidis and Anupam Prakash. 2016. Quantum Recommenda tion Systems.
https://doi.org/10.48550/arxiv.1603.08675An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
[53] OndřejLengál,JiříŠimáček,andTomášVojnar.2012. VATA:Alib raryforeﬃcientmanipulationofnon-deterministic
tree automata. In International Conference on Tools and Algorithms for the Co nstruction and Analysis of Systems .
Springer, 79–94.
[54] JunyiLiu,BohuaZhan,ShulingWang,ShenggangYing,TaoLiu,YangjiaL i,MingshengYing,andNaijunZhan.2019.
Formal veriﬁcationofquantumalgorithmsusingquantumHoare logic. InInternationalconferenceoncomputeraided
veriﬁcation . Springer,187–207.
[55] VsevolodLivinskii,DmitryBabokin,andJohnRegehr.2020. Random testingforCandC++compilerswithYARPGen.
Proc. ACMProgram.Lang. 4,OOPSLA(2020),196:1–196:25. https://doi.org/10.1145/3428264
[56] Paul Massey, John A. Clark, and Susan Stepney. 2005. Evolu tion of a human-competitive quantum fourier trans-
form algorithm using geneticprogramming. In Genetic and Evolutionary Computation Conference, GECCO 20 05, Pro-
ceedings, Washington DC, USA, June 25-29, 2005 , Hans-Georg Beyer and Una-May O’Reilly (Eds.). ACM, 1657–1663.
https://doi.org/10.1145/1068009.1068288
[57] Paulo Mateus, Jaime Ramos, Amílcar Sernadas, and Cristina Serna das. 2009. Temporal Logics for Reasoning about
Quantum Systems . CambridgeUniversityPress,389–413. https://doi.org/10.1017/CBO9781139193313.011
[58] Nikolaj Moll, Panagiotis Barkoutsos, Lev S Bishop, Jerry M Ch ow, Andrew Cross, Daniel J Egger, Stefan Filipp,
Andreas Fuhrer, Jay M Gambetta, Marc Ganzhorn, Abhinav Kandala, Ant onio Mezzacapo, Peter Müller, Walter
Riess, Gian Salis, John Smolin, Ivano Tavernelli, and Kristan Temme. 20 18. Quantum optimization using vari-
ational algorithms on near-term quantum devices. Quantum Science and Technology 3, 3 (jun 2018), 030503.
https://doi.org/10.1088/2058-9565/aab822
[59] Yunseong Nam, NeilJ.Ross, Yuan Su,AndrewM.Childs,and Dmitri Maslov.2018. Automated optimization of large
quantum circuits withcontinuous parameters. npj Quantum Information 4(2018).
[60] DanielNeiderandNilsJansen.2013. RegularModelCheckingUsingSo lverTechnologiesandAutomata Learning.In
NASA Formal Methods, 5th International Symposium, NFM 2013 , Moﬀett Field, CA, USA, May 14-16, 2013. Proceedings
(LectureNotesinComputerScience) ,GuillaumeBrat,NehaRungta,andArnaudVenet(Eds.),Vol.7871. Springer,16–31.
https://doi.org/10.1007/978-3-642-38088-4_2
[61] Michael A. Nielsen and Isaac L. Chuang. 2011. Quantum Computation and Quantum Information: 10th Anniver sary
Edition(10thed.). Cambridge UniversityPress,USA.
[62] PhilippNiemann, RobertWille,D.MichaelMiller,MitchellA.Tho rnton,andRolfDrechsler.2016. QMDDs:Eﬃcient
QuantumFunctionRepresentationandManipulation. IEEETrans.Comput.AidedDes.Integr.CircuitsSyst. 35,1(2016),
86–99.https://doi.org/10.1109/TCAD.2015.2459034
[63] Edwin Pednault, John A. Gunnels, Giacomo Nannicini, Lior Horesh, Tho mas Magerlein, Edgar Solomonik, Erik W.
Draeger, Eric T. Holland, and Robert Wisnieﬀ. 2017. Pareto-Eﬃcient Q uantum Circuit Simulation Using Tensor
Contraction Deferral. CoRRabs/1710.05867(2017). http://arxiv.org/abs/1710.05867
[64] Tom Peham, Lukas Burgholzer, and Robert Wille.2022. Equiv alence checking paradigms in quantum circuit design:
a case study. In DAC ’22: 59th ACM/IEEE Design Automation Conference, San Fr ancisco, California, USA, July 10 - 14,
2022, RobOshana (Ed.).ACM,517–522. https://doi.org/10.1145/3489517.3530480
[65] SimonPerdrix.2008.Quantumentanglementanalysisbasedonabs tractinterpretation.In InternationalStaticAnalysis
Symposium . Springer, 270–282.
[66] Vasilis Samoladas. 2008. Improved BDD Algorithms for the S imulation of Quantum Circuits. In Algo-
rithms - ESA 2008, 16th Annual European Symposium, Karlsruh e, Germany, September 15-17, 2008. Proceedings
(Lecture Notes in Computer Science) , Dan Halperin and Kurt Mehlhorn (Eds.), Vol. 5193. Springer, 720 –731.
https://doi.org/10.1007/978-3-540-87744-8_60
[67] Peter W. Shor. 1994. Algorithms for Quantum Computation: Dis crete Logarithms and Factoring. In 35th Annual
Symposium on Foundations of Computer Science, Santa Fe, New Mexico, USA, 20-22 November 1994 . IEEE Computer
Society, 124–134. https://doi.org/10.1109/SFCS.1994.365700
[68] Mathias Soeken, Robert Wille, Gerhard W. Dueck, and Rolf Dre chsler. 2010. Window optimization of re-
versible and quantum circuits. In 13th IEEE International Symposium on Design and Diagnostic s of Electronic
Circuits and Systems, DDECS 2010, Vienna, Austria, April 14 -16, 2010, Elena Gramatová, Zdenek Kotásek, An-
dreas Steininger, Heinrich Theodor Vierhaus, and Horst Zimmermann (Eds .). IEEE Computer Society, 341–345.
https://doi.org/10.1109/DDECS.2010.5491754
[69] Lee Spector. 2006. Automatic QuantumComputer Programming : A GeneticProgramming Approach. (2006).
[70] Yuan-Hung Tsai, Jie-Hong R. Jiang, and Chiao-Shan Jhang. 2021. Bit- Slicing the HilbertSpace: Scaling Up Accurate
Quantum Circuit Simulation. In 58th ACM/IEEE Design Automation Conference, DAC 2021, San F rancisco, CA, USA,
December5-9, 2021 . IEEE,439–444. https://doi.org/10.1109/DAC18074.2021.9586191
[71] Dominique Unruh. 2019. Quantum Hoare logic with ghost variables . In2019 34th Annual ACM/IEEE Symposium on
Logic inComputerScience (LICS) .IEEE,1–13.Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
[72] GeorgeF.Viamontes,IgorL.Markov,andJohnP.Hayes.2007 .Checkingequivalenceofquantumcircuitsandstates.In
2007InternationalConferenceonComputer-AidedDesign,I CCAD2007,SanJose,CA,USA,November5-8,2007 ,Georges
G. E.Gielen(Ed.).IEEE Computer Society, 69–74. https://doi.org/10.1109/ICCAD.2007.4397246
[73] George F. Viamontes, Igor L. Markov, and John P. Hayes. 2009 .Quantum Circuit Simulation . Springer.
https://doi.org/10.1007/978-90-481-3065-8
[74] Dave Wecker and Krysta M. Svore. 2014. LIQUi |>:A Software Design Architecture and Domain-Speciﬁc Language
for QuantumComputing. CoRRabs/1402.4467(2014). arXiv:1402.4467 http://arxiv.org/abs/1402.4467
[75] Chun-Yu Wei, Yuan-Hung Tsai, Chiao-Shan Jhang, and Jie-Hong R. Jiang . 2022. Accurate BDD-based uni-
tary operator manipulation for scalable and robust quantum circuit veriﬁcation. In DAC ’22: 59th ACM/IEEE De-
sign Automation Conference, San Francisco, California, US A, July 10 - 14, 2022 , Rob Oshana (Ed.). ACM, 523–528.
https://doi.org/10.1145/3489517.3530481
[76] R. Wille, D. Große, L. Teuber, G. W. Dueck, and R. Drechsler . 2008. RevLib: An Online Resource for Re-
versible Functions and Reversible Circuits. In Int’l Symp. on Multi-Valued Logic . 220–225. RevLib is available at
http://www.revlib.org.
[77] Robert Wille, Rod Van Meter, and Yehuda Naveh. 2019. IBM’s Qiskit Tool Chain: Working with and
Developing for Real Quantum Computers. In Design, Automation & Test in Europe Conference & Exhibi-
tion, DATE 2019, Florence, Italy, March 25-29, 2019 , Jürgen Teich and Franco Fummi (Eds.). IEEE, 1234–1240.
https://doi.org/10.23919/DATE.2019.8715261
[78] Ming Xu, Jianling Fu, Jingyi Mei, and Yuxin Deng. 2022. Model checking QC TL plus on quantum Markov chains.
Theor. Comput.Sci. 913(2022),43–72. https://doi.org/10.1016/j.tcs.2022.01.044
[79] MingkuanXu,ZikunLi,OdedPadon,SinaLin,JessicaPointing,AugusteH irth,HenryMa,JensPalsberg,AlexAiken,
Umut A Acar, et al. 2022. Quartz: superoptimization of Quantum cir cuits. InProceedings of the 43rd ACM SIGPLAN
International ConferenceonProgrammingLanguage Designa nd Implementation . 625–640.
[80] ShigeruYamashita andIgorL.Markov.2010. Fastequivalence -checking forquantumcircuits. QuantumInf.Comput.
10,9&10(2010),721–734. https://doi.org/10.26421/QIC10.9-10-1
[81] Peng Yan, Hanru Jiang, and Nengkun Yu. 2022. On incorrectness logic f or Quantum programs. Proceedings of the
ACMonProgramming Languages 6, OOPSLA1(2022),1–28.
[82] MingshengYing.2012. Floyd-Hoare logicforquantumprograms. ACMTransactionsonProgrammingLanguagesand
Systems (TOPLAS) 33,6(2012),1–49.
[83] MingshengYing. 2021. ModelChecking forVeriﬁcation ofQuantumCir cuits. InInternational Symposium onFormal
Methods. Springer,23–39.
[84] Mingsheng Ying and Yuan Feng. 2021. Model Checking Quantum Systems: Principles and Algorithms . Cambridge
University Press.
[85] Mingsheng Ying, Yangjia Li, Nengkun Yu, and Yuan Feng. 2014. Model-c hecking linear-time properties of quantum
systems. ACMTransactions onComputational Logic (TOCL) 15,3 (2014),1–31.
[86] Fang Yu, Tevﬁk Bultan, Marco Cova, and Oscar H Ibarra. 2008. Symbolic string veriﬁcation: An automata-based
approach. In International SPIN Workshop onModel Checking ofSoftware . Springer,306–324.
[87] Fang Yu, TevﬁkBultan,and Oscar H. Ibarra.2011. Relational S tring Veriﬁcation UsingMulti-Track Automata. Int.J.
Found. Comput.Sci. 22,8(2011),1909–1924. https://doi.org/10.1142/S0129054111009112
[88] Nengkun Yu and Jens Palsberg. 2021. Quantum abstract interpre tation. In Proceedings of the 42nd ACM SIGPLAN
International ConferenceonProgrammingLanguage Designa nd Implementation . 542–558.
[89] Li Zhou, Nengkun Yu, and Mingsheng Ying. 2019. An applied quantum H oare logic. In Proceedings of the 40th ACM
SIGPLAN ConferenceonProgrammingLanguage Designand Impl ementation . 1149–1162.
[90] Alwin Zulehner, Stefan Hillmich, and Robert Wille. 2019. How t o Eﬃciently Handle Complex Values? Im-
plementing Decision Diagrams for Quantum Computing. In Proceedings of the International Conference on
Computer-Aided Design, ICCAD 2019, Westminster, CO, USA, N ovember 4-7, 2019 , David Z. Pan (Ed.). ACM, 1–7.
https://doi.org/10.1109/ICCAD45719.2019.8942057
[91] AlwinZulehnerandRobertWille.2019. AdvancedSimulationofQ uantumComputations. IEEETrans.Comput.Aided
Des. Integr.CircuitsSyst. 38,5(2019),848–859. https://doi.org/10.1109/TCAD.2018.2834427An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
A STANDARD SEMANTICS OF CONSIDERED QUANTUM GATES
Gate Matrix Gate Matrix
/u1D44B/parenleftbigg0 1
1 0/parenrightbigg
Hadamard( /u1D43B)1√
2/parenleftbigg1 1
1−1/parenrightbigg
/u1D44C/parenleftbigg0−/u1D7142
/u1D71420/parenrightbigg
Rx(/u1D70B
2)1√
2/parenleftbigg1−/u1D7142
−/u1D71421/parenrightbigg
/u1D44D/parenleftbigg1 0
0−1/parenrightbigg
Ry(/u1D70B
2)1√
2/parenleftbigg1−1
1 1/parenrightbigg
/u1D446/parenleftbigg1 0
0/u1D7142/parenrightbiggControlledZ
(CZ)/parenlefttpA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA1 0 0 0
0 1 0 0
0 0 1 0
0 0 0−1/parenrighttpA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA
/u1D447/parenleftbigg1 0
0/u1D714/parenrightbiggControlledNOT
(CNOT)/parenlefttpA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0/parenrighttpA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA
Toﬀoli
(CCNOT)/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA
Fredkin/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 1/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA
B PROOFS FOR SECTION 5
In this section, we prove that the results of Algorithm 1and Algorithm 2are what we desire. For
instance, we show that the language L(A/u1D445)recognized by the output automaton A/u1D445of Algo-
rithm1on the input automaton Aand quantum gate U ∈{X/u1D461,Y/u1D461,Z/u1D461,S/u1D461,T/u1D461}(for some /u1D461∈[/u1D45B]) is
exactly the language {U(/u1D447)|/u1D447∈L(A)} . Intuitively,L(A/u1D445)={U(/u1D447)|/u1D447∈L(A)} if and only
if for each /u1D447/u1D445∈L(A/u1D445), we can ﬁnd /u1D447∈L(A) such that U(/u1D447)=/u1D447/u1D445and for each /u1D447∈L(A)
there is/u1D447/u1D445∈L(A/u1D445)such that /u1D447/u1D445=U(/u1D447). Instead of showing this directly, we prove that L(A)Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
andL(A/u1D445)areone-to-onecorrespondentbygivingaconstructiveproof,i.e. ,webuild abijective
mappingU/u1D461fromL(A)toL(A/u1D445),whereU/u1D461,indeed,maps /u1D447to/u1D447/u1D445.
L/e.sc/m.sc/m.sc/a.sc B.1 (C/o.sc/n.sc/s.sc/t.sc/a.sc/n.sc/t.sc S/c.sc/a.sc/l.sc/i.sc/n.sc/g.sc). Fix/u1D45B∈Nand letA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ=Δ/u1D456∪Δ/u1D459,R/a\}bracke⊔ri}h⊔be a TA rep-
resenting certain set of /u1D45B-qubit states. For any given /u1D461∈ [/u1D45B]and/u1D44E0,/u1D44E1such that/parenleftbigg/u1D44E00
0/u1D44E1/parenrightbigg
being
unitary, letA1=/a\}bracke⊔le{⊔/u1D444′,Σ,Δ1,R′/a\}bracke⊔ri}h⊔andA/u1D445=/a\}bracke⊔le{⊔/u1D444/u1D445,Σ/u1D445=Σ,Δ/u1D445,R/u1D445=R/a\}bracke⊔ri}h⊔betheresulting TAsunderthe
correspondingprocedurefrom line2 to line4 inthe Algorith m1, where
/u1D444′:={/u1D45E′|/u1D45E∈/u1D444},
R′:={/u1D45E′|/u1D45E∈R},
/u1D444/u1D445:=/u1D444∪/u1D444′
Δ1:=Δ′
/u1D456⊔{/u1D45E′/u1D44E1×/u1D450()|/u1D45E/u1D450()|Δ/u1D459}
={/u1D45E′/u1D465/u1D458(/u1D45E′
0,/u1D45E′
1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456}
⊔{/u1D45E′/u1D44E1×/u1D450()|/u1D45E/u1D450()|Δ/u1D459},
Δnew:={/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458≠/u1D461}
⊔{/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E′
1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458=/u1D461}
⊔{/u1D45E/u1D44E0×/u1D450()|/u1D45E/u1D450()∈Δ/u1D459}
Δ/u1D445:=Δnew∪Δ1.
Then,wehaveL(A/u1D445)={U/u1D461(/u1D447)|/u1D447∈L(A)} ,whereU/u1D461=Id⊗···Id⊗U⊗Id⊗···⊗Idwhose/u1D461-th
component U=/parenleftbigg/u1D44E00
0/u1D44E1/parenrightbigg
isunitary, and we denoteby U/u1D461(A)=A/u1D445.
P/r.sc/o.sc/o.sc/f.sc.We are goingto constructa map
U/u1D461:L(A)→L(A/u1D445)
/u1D447/u\i∈1A6.e\dl→U/u1D461(/u1D447)=:/u1D447/u1D445
such thatU/u1D461is a bijection. Given a /u1D447∈L(A)with its accepting run /u1D70C,sinceΣ/u1D445=Σ, we form a
tree/u1D447/u1D445with/u1D441/u1D447/u1D445=/u1D441/u1D447asfollows:foreachinternalnode /u1D462∈/u1D441/u1D447/u1D445weset/u1D43F/u1D447/u1D445(/u1D462)=/u1D43F/u1D447(/u1D462)∈Σ/u1D445=Σ.
Let/u1D70C/u1D445bethe run deﬁned as
(1)/u1D43F/u1D70C/u1D445(/u1D716)=/u1D43F/u1D70C(/u1D716);
(2) foreachinternal node /u1D462∈/u1D441/u1D447/u1D445with/u1D43F/u1D447(/u1D462)∈{/u1D4651,...,/u1D465/u1D461}, we set/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462);
(3) for nodes (including leaf ones) /u1D462=/u1D464.0.˜/u1D462,/u1D464∈{0,1}∗, with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D461, we set/u1D43F/u1D70C/u1D445(/u1D462)=
/u1D43F/u1D70C(/u1D462);
(4) for nodes (including leaf ones) /u1D462=/u1D464.1.˜/u1D462,/u1D464∈{0,1}∗, with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D461, we set/u1D43F/u1D70C/u1D445(/u1D462)=
/u1D43F/u1D70C(/u1D462)′;
(5) foreachleaf node /u1D462=0.˜/u1D462or/u1D462=1.˜/u1D462with an internal node ˜ /u1D462,
/u1D43F/u1D447/u1D445(/u1D462)=/braceleftBigg
/u1D44E0×/u1D43F/u1D447(/u1D462)if/u1D43F/u1D70C/u1D445(˜/u1D462)=/u1D43F/u1D70C(˜/u1D462)
/u1D44E1×/u1D43F/u1D447(/u1D462)if/u1D43F/u1D70C/u1D445(˜/u1D462)=/u1D43F/u1D70C(˜/u1D462)′.
Let/u1D462∈/u1D441/u1D447/u1D445be an internal node.Byconstruction,if /u1D43F/u1D447/u1D445(/u1D462)∈{/u1D4651,...,/u1D465/u1D461−1},the transition
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δnew⊂Δ/u1D445;
if/u1D43F/u1D447/u1D445(/u1D462)=/u1D465/u1D461,then
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462)′)∈Δnew⊂Δ/u1D445;An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
if/u1D462=/u1D464./u1D44E.˜/u1D462,/u1D464∈∪{0,1}∗and/u1D44E∈{0,1},with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D461,then either for /u1D44E=0
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δnew⊂Δ/u1D445
orfor/u1D44E=1
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)′/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462)′,/u1D43F/u1D70C(1./u1D462)′)∈Δ1⊂Δ/u1D445.
For eachleafnode /u1D462, we have either
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)()=/u1D43F/u1D70C(/u1D462)/u1D44E0×/u1D43F/u1D447(/u1D462)()∈Δnew⊂Δ/u1D445
or
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)()=/u1D43F/u1D70C(/u1D462)′/u1D44E1×/u1D43F/u1D447(/u1D462)()∈Δ1⊂Δ/u1D445.
Thus,themapU/u1D461iswell-deﬁned,i.e., /u1D447/u1D445togetherwiththerun /u1D70C/u1D445belongstoL(A/u1D445)andisclearly
one-to-one.
Claim1:ThemapU/u1D461issurjective.
Proof:For each/u1D447/u1D445∈L(A/u1D445)with the accepting run /u1D70C/u1D445, sinceΣ=Σ/u1D445, we can form a tree /u1D447such
that/u1D441/u1D447=/u1D441/u1D447/u1D445and/u1D43F/u1D447(/u1D462)=/u1D43F/u1D447/u1D445(/u1D462)∈Σfor each internal node /u1D462∈/u1D441/u1D447=/u1D441/u1D447/u1D445. Since/u1D444/u1D445=/u1D444∪/u1D444′,
foreachleaf node /u1D462we set
/u1D43F/u1D447(/u1D462)=/braceleftBigg
/u1D44E−1
0×/u1D43F/u1D447/u1D445(/u1D462)if/u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444
/u1D44E−1
1×/u1D43F/u1D447/u1D445(/u1D462)if/u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444′.
To construct the associated run /u1D70C, sinceR/u1D445=R ⊂/u1D444, we may set /u1D43F/u1D70C(/u1D716)=/u1D43F/u1D70C/u1D445(/u1D716). Moreover,
since/u1D444/u1D445=/u1D444∪/u1D444′and/u1D444′={/u1D45E′|/u1D45E∈/u1D444}is in one-to-one correspondence to /u1D444, we denote by
(/u1D45E′)/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451the corresponding /u1D45E∈/u1D444to/u1D45E′∈/u1D444′.Thenwe mayset
/u1D43F/u1D70C(/u1D462)=/braceleftBigg
/u1D43F/u1D70C/u1D445(/u1D462) if/u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444
/u1D43F/u1D70C/u1D445(/u1D462)/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451if/u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444′(14)
aswell.Sinceeachtransitionin Δ/u1D445correspondstoonein Δ,thetree/u1D447constructedabovetogether
with the run /u1D70CbelongstoL(A).
It remains to show that U/u1D461(/u1D447)=:/u1D447/u1D445=/u1D447/u1D445. Let/u1D70C/u1D445be the run associated to /u1D447/u1D445. By construction,
we have/u1D441/u1D447/u1D445=/u1D441/u1D447=/u1D441/u1D447/u1D445,/u1D43F/u1D447/u1D445(/u1D462)=/u1D43F/u1D447(/u1D462)=/u1D43F/u1D447/u1D445(/u1D462)for each internal node /u1D462,/u1D43F/u1D70C/u1D445(/u1D716)=/u1D43F/u1D70C(/u1D716)=
/u1D43F/u1D70C/u1D445(/u1D716)and/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C/u1D445(/u1D462)for internal nodes /u1D462with/u1D43F/u1D447(/u1D462)∈{/u1D4651,...,/u1D465/u1D461}. If/u1D43F/u1D447(/u1D462)=
/u1D465/u1D461=/u1D43F/u1D447/u1D445(/u1D462),then
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))∈Δ/u1D445
if and onlyif /u1D43F/u1D70C/u1D445(/u1D462),/u1D43F/u1D70C/u1D445(0./u1D462)∈/u1D444and/u1D43F/u1D70C/u1D445(1./u1D462)∈/u1D444′.Thus,by( 14),
/u1D43F/u1D70C/u1D445(0./u1D462)=/u1D43F/u1D70C(0./u1D462)=/u1D43F/u1D70C/u1D445(0./u1D462)
and
/u1D43F/u1D70C/u1D445(1./u1D462)=/u1D43F/u1D70C(1./u1D462)′=((/u1D43F/u1D70C/u1D445(1./u1D462))/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451)′=/u1D43F/u1D70C/u1D445(1./u1D462).
Similarly forthe rest internal nodes /u1D462,i.e., for/u1D462=/u1D44E.˜/u1D462,/u1D44E∈{0,1},suchthat /u1D43F/u1D447(˜/u1D462)∈{/u1D465/u1D461+1,...,/u1D465/u1D45B},
either both /u1D43F/u1D70C/u1D445(/u1D462),/u1D43F/u1D70C/u1D445(˜/u1D462)∈/u1D444or both/u1D43F/u1D70C/u1D445(/u1D462),/u1D43F/u1D70C/u1D445(˜/u1D462)∈/u1D444′.Inthe formercases,we have
/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C/u1D445(/u1D462)
and in the later
/u1D43F/u1D70C/u1D445(/u1D462)=(/u1D43F/u1D70C(/u1D462))′=(/u1D43F/u1D70C/u1D445(/u1D462)/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451)′=/u1D43F/u1D70C/u1D445(/u1D462).Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
Now,let/u1D462be a leafnode.If /u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444,then/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C/u1D445(/u1D462)and
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)()=/u1D43F/u1D70C(/u1D462)/u1D44E0×/u1D43F/u1D447(/u1D462)()
=/u1D43F/u1D70C/u1D445(/u1D462)/u1D44E0×/u1D44E−1
0×/u1D43F/u1D447/u1D445(/u1D462)()
=/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)().
Conversely,if /u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444′,then/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)′=(/u1D43F/u1D70C/u1D445(/u1D462)/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451)′=/u1D43F/u1D70C/u1D445(/u1D462)and
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)()=/u1D43F/u1D70C(/u1D462)′/u1D44E1×/u1D43F/u1D447(/u1D462)()
=/u1D43F/u1D70C/u1D445(/u1D462)/u1D44E1×/u1D44E−1
1×/u1D43F/u1D447/u1D445(/u1D462)()
=/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)().
Therefore /u1D447/u1D445=/u1D447/u1D445andhenceU/u1D461:L(A)→L(A/u1D445)is surjective. /squaresolid
Thuswe have shown that every /u1D447/u1D445∈L(A/u1D445)is ofthe formU/u1D461(/u1D447)forcertain /u1D447∈L(A).
It is obvious to see that U/u1D461(/u1D447)=U/u1D461(/u1D447)where U /u1D461=Id⊗···⊗U⊗Id⊗···⊗Id whose /u1D461-th
componentU =/parenleftbigg/u1D44E00
0/u1D44E1/parenrightbigg
.Forinstance,wemaywithoutlossofgeneralityassumethat /u1D461=/u1D45B.Then,
for/u1D447∈L(A)with
/u1D447=/summationdisplay.1
/u1D456∈{0,1}/u1D45B/u1D450/u1D456|/u1D456/a\}bracke⊔ri}h⊔,
we have
/u1D447/u1D445=/summationdisplay.1
/u1D464∈{0,1}/u1D45B−1/parenleftbigg
/u1D44E0×/u1D4500./u1D464|0./u1D464/a\}bracke⊔ri}h⊔+/u1D44E1×/u1D4501./u1D464|1./u1D464/a\}bracke⊔ri}h⊔/parenrightbigg
=U/u1D45B(/u1D447)
asdesired.
/square
L/e.sc/m.sc/m.sc/a.sc B.2 (S/w.sc/a.sc/p.sc/p.sc/i.sc/n.sc/g.sc /s.sc/u.sc/b.sc/t.sc/r.sc/e.sc/e.sc/s.sc). Fix/u1D45B∈Nand letA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ=Δ/u1D456∪Δ/u1D459,R/a\}bracke⊔ri}h⊔be a TA
representing certain set of /u1D45B-qubit states. For any given /u1D461∈[/u1D45B], letA/u1D445=/a\}bracke⊔le{⊔/u1D444/u1D445,Σ/u1D445=Σ,Δ/u1D445,R/u1D445=
R/a\}bracke⊔ri}h⊔=: X/u1D461(A), where/u1D444/u1D445=/u1D444and
Δ/u1D445={/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458≠/u1D461}
∪{/u1D45E/u1D465/u1D458(/u1D45E1,/u1D45E0)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458=/u1D461}
∪{/u1D45E/u1D450()|/u1D45E/u1D450()∈Δ/u1D459}.
Then,L(A/u1D445)={X/u1D461(/u1D447)|/u1D447∈L(A)} .
P/r.sc/o.sc/o.sc/f.sc.Asbefore,we are goingto constructa map
X/u1D461:L(A)→L(A/u1D445)
/u1D447/u\i∈1A6.e\dl→X/u1D461=:/u1D447/u1D445.
Given a/u1D447∈L(A)with its accepting run /u1D70C,we construct a tree /u1D447/u1D445of the same shape as follows:
sinceΣ/u1D445=Σ,weset/u1D43F/u1D447/u1D445(/u1D462)=/u1D43F/u1D447(/u1D462)foreachinternalnode /u1D462∈/u1D441/u1D447/u1D445=/u1D441/u1D447and/u1D43F/u1D70C/u1D445(/u1D716)=/u1D43F/u1D70C(/u1D716).For
thecasesthat /u1D43F/u1D447(/u1D462)∈{/u1D4651,...,/u1D465/u1D461},weset/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)aswell.Fortherest ofnodes(including
leaf nodes) /u1D462, we may write /u1D462=/u1D464.0.˜/u1D462or/u1D462=/u1D464.1.˜/u1D462for some (possibly empty) word /u1D464∈{0,1}∗
with/u1D43F/u1D447(/u1D462)=/u1D465/u1D461and we deﬁne
/u1D43F/u1D70C/u1D445(/u1D464.0.˜/u1D462)=/u1D43F/u1D70C(/u1D464.1.˜/u1D462)and/u1D43F/u1D70C/u1D445(/u1D464.1.˜/u1D462)=/u1D43F/u1D70C(/u1D464.0.˜/u1D462)An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
and forleafnodes /u1D462=˜/u1D464.0.˜/u1D462or/u1D462=˜/u1D464.1.˜/u1D462
/u1D43F/u1D447/u1D445(˜/u1D464.0.˜/u1D462)=/u1D43F/u1D447(˜/u1D464.1.˜/u1D462)and/u1D43F/u1D447/u1D445(˜/u1D464.1.˜/u1D462)=/u1D43F/u1D447(˜/u1D464.0.˜/u1D462).
Similar to the argument for constant scaling, it is clear that the constructed /u1D447/u1D445together with the
run/u1D70C/u1D445belongs toL(A/u1D445). Note that such a map X/u1D461is also well-deﬁned on applying to L(A/u1D445)
with destinationL(A), namely,X/u1D461(L(A/u1D445))⊆L(A) . Moreover, we have X/u1D461(X/u1D447(/u1D447))=/u1D447for all
/u1D447∈L(A). It followsthat every element /u1D447/u1D445∈L(A/u1D445)is of the formX/u1D461(/u1D447)forcertain /u1D447∈L(A)
and vice versa. Thefunctionality X/u1D461(/u1D447)=X/u1D461(/u1D447)holdsobviously. /square
L/e.sc/m.sc/m.sc/a.sc B.3. Fix/u1D45B∈Nand letA=/a\}bracke⊔le{⊔/u1D444,Σ,Δ=Δ/u1D456∪Δ/u1D459,R/a\}bracke⊔ri}h⊔be a TA representing certain set of
/u1D45B-qubit states. For any pair 0</u1D450</u1D461≤/u1D45B, letA1=/a\}bracke⊔le{⊔/u1D4441,Σ,Δ1,R/a\}bracke⊔ri}h⊔be eitherX/u1D461(A)orZ/u1D461(A)and
A′
1be the primed copy of A1. LetA/u1D445=/a\}bracke⊔le{⊔/u1D444/u1D445=/u1D444∪/u1D444′
1,Σ/u1D445=Σ,Δ/u1D445=Δnew∪Δ′
1,R/u1D445=R/a\}bracke⊔ri}h⊔be the
resulting TAunderthe procedurein the Line5of Algorithm 2, where
Δnew={/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458≠/u1D450}
⊔{/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E′
1)|/u1D45E/u1D465/u1D458(/u1D45E0,/u1D45E1)∈Δ/u1D456∧/u1D458=/u1D450}
⊔Δ/u1D459.
ThenL(A/u1D445)={U(/u1D447)|/u1D447∈A}forU=/braceleftBigg
CNOT/u1D450
/u1D461ifA1=X/u1D461(A)
CZ/u1D450
/u1D461ifA1=Z/u1D461(A).
P/r.sc/o.sc/o.sc/f.sc.Byabovelemmas,thereexistabijection V:L(A)→L(A 1).Forany/u1D447∈L(A)with
the accepting run /u1D70C, we denote byV(/u1D447)andV(/u1D70C)their corresponding image in L(A1)under
the bijective mapV. We also denote by V(/u1D444)⊂/u1D4441the subset of states in /u1D4441that appear in the
acceptedlanguagesin L(A1).ThusthemapV:/u1D444→V(/u1D444)is bijective.
Againwe are goingto constructa map
U:L(A)→L(A/u1D445)
/u1D447/u\i∈1A6.e\dl→U(/u1D447)=:/u1D447/u1D445
to prove the statement. Given a /u1D447∈L(A)with its accepting run /u1D70C,we form a tree /u1D447/u1D445such that
/u1D441/u1D447/u1D445=/u1D441/u1D447together with a run /u1D70C/u1D445asfollows: since Σ=Σ/u1D445,foreach internal node /u1D462∈/u1D441/u1D447/u1D445we set
/u1D43F/u1D447/u1D445(/u1D462)=/u1D43F/u1D447(/u1D462)∈Σand/u1D43F/u1D70C/u1D445(/u1D716)=/u1D43F/u1D70C(/u1D716)sinceR/u1D445=R. And
(1) foreachinternal node /u1D462∈/u1D441/u1D447/u1D445with/u1D43F/u1D447(/u1D462)∈{/u1D4651,...,/u1D465/u1D450},we simply let /u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462);
(2) for/u1D462such that /u1D43F/u1D447(/u1D462)=/u1D465/u1D450,we set/u1D43F/u1D70C/u1D445(0./u1D462)=/u1D43F/u1D70C(0./u1D462)and/u1D43F/u1D70C/u1D445(1./u1D462)=/u1D43F/u1D70C(1./u1D462)′;
(3) for/u1D462=/u1D464.0.˜/u1D462for/u1D464∈{0,1}∗and ˜/u1D462with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D450,we set/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462);
(4) similarly for /u1D462=/u1D464.1.˜/u1D462for some non-empty word /u1D464∈{0,1}∗and ˜/u1D462with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D450, set
/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43FV(/u1D70C)(/u1D462)′;
(5) forleaf node /u1D462=˜/u1D464.0.˜/u1D462(resp./u1D462=˜/u1D464.1.˜/u1D462),set/u1D43F/u1D447/u1D445(/u1D462)=/u1D43F/u1D447(/u1D462)(resp./u1D43F/u1D447/u1D445(/u1D462)=/u1D43FV(/u1D447)(/u1D462)).
Byconstruction,for eachinternal node /u1D462∈/u1D441/u1D447/u1D445,if/u1D43F/u1D447/u1D445(/u1D462)∈{/u1D4651,...,/u1D465/u1D450−1},then
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δnew⊂Δ/u1D445;
if/u1D43F/u1D447/u1D445(/u1D462)=/u1D465/u1D450,the transition
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462)′)∈Δnew⊂Δ/u1D445.
If/u1D462=/u1D464.0.˜/u1D462for/u1D464∈{0,1}∗and/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D450,we have
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δnew⊂Δ/u1D445.Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
For/u1D462=/u1D464.1.˜/u1D462with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D450,if/u1D464=/u1D716,since/u1D450</u1D461,/u1D43F/u1D70C(/u1D462)′=/u1D43FV(/u1D70C)(/u1D462)′and hence
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C(/u1D462)′/u1D43F/u1D447(/u1D462)(/u1D43FV(/u1D70C)(0./u1D462)′,/u1D43FV(/u1D70C)(1./u1D462)′)
=/u1D43FV(/u1D70C)(/u1D462)′/u1D43F/u1D447(/u1D462)(/u1D43FV(/u1D70C)(0./u1D462)′,/u1D43FV(/u1D70C)(1./u1D462)′)
∈Δ′
1⊂Δ/u1D445.
Finally,for thecase /u1D462=/u1D464.1.˜/u1D462with/u1D43F/u1D447(˜/u1D462)=/u1D465/u1D450and/u1D464∈{0,1}∗,we have
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43FV(/u1D70C)(/u1D462)′/u1D43F/u1D447(/u1D462)(/u1D43FV(/u1D70C)(0./u1D462)′,/u1D43FV(/u1D70C)(1./u1D462)′)
∈Δ′
1⊂Δ/u1D445.
ThusUiswell-deﬁned,i.e., /u1D447/u1D445togetherwith /u1D70C/u1D445belongstoL(A/u1D445),andisinjective.Itremainsto
prove the followingClaim:
Claim2:ThemapUissurjective.
Proof:For each/u1D447/u1D445∈L(A/u1D445)with its accepting run /u1D70C/u1D445, sinceΣ=Σ/u1D445, we can form a tree /u1D447such
that/u1D441/u1D447=/u1D441/u1D447/u1D445and/u1D43F/u1D447(/u1D462)=/u1D43F/u1D447/u1D445(/u1D462)for all internal nodes /u1D462∈/u1D441/u1D447. Moreover, sinceV(/u1D444)′⊂/u1D444′
1is
inone-to-onecorrespondenceto /u1D444,wedenoteby(V−1(/u1D45E′))/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451thecorresponding /u1D45E∈/u1D444to
V(/u1D45E)′∈/u1D444′
1.Thenwe mayset
/u1D43F/u1D70C(/u1D462)=/braceleftBigg
/u1D43F/u1D70C/u1D445(/u1D462) if/u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444
(V−1(/u1D43F/u1D70C/u1D445(/u1D462)))/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451if/u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444′
1
aswell.Sinceeachtransitionin Δ/u1D445correspondstoonein Δ,thetree/u1D447constructedabovetogether
with the run /u1D70CbelongstoL(A).
To show that /u1D447/u1D445:=U(/u1D447)=/u1D447/u1D445, let/u1D70C/u1D445be the run associated to /u1D447/u1D445. By construction, we have
/u1D441/u1D447/u1D445=/u1D441/u1D447=/u1D441/u1D447/u1D445,/u1D43F/u1D447/u1D445(/u1D462)=/u1D43F/u1D447(/u1D462)=/u1D43F/u1D447/u1D445(/u1D462)foreachinternal node /u1D462,/u1D43F/u1D70C/u1D445(/u1D716)=/u1D43F/u1D70C(/u1D716)=/u1D43F/u1D70C/u1D445(/u1D716)and
/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C/u1D445(/u1D462)for internal nodes /u1D462with/u1D43F/u1D447(/u1D462)∈{/u1D4651,...,/u1D465/u1D450}. If/u1D43F/u1D447(/u1D462)=/u1D465/u1D450=/u1D43F/u1D447/u1D445(/u1D462),
then
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)(/u1D43F/u1D70C/u1D445(0./u1D462),/u1D43F/u1D70C/u1D445(1./u1D462))∈Δ/u1D445
if and onlyif /u1D43F/u1D70C/u1D445(/u1D462),/u1D43F/u1D70C/u1D445(0./u1D462)∈/u1D444and/u1D43F/u1D70C/u1D445(1./u1D462)∈/u1D444′
1.Thus
/u1D43F/u1D70C/u1D445(0./u1D462)=/u1D43F/u1D70C(0./u1D462)=/u1D43F/u1D70C/u1D445(0./u1D462)
and since /u1D450</u1D461,
/u1D43F/u1D70C/u1D445(1./u1D462)=/u1D43F/u1D70C(1./u1D462)′=((V−1(/u1D43F/u1D70C/u1D445(1./u1D462)))/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451)′=V−1(/u1D43F/u1D70C/u1D445(1./u1D462))=/u1D43F/u1D70C/u1D445(1./u1D462).
Similarly forthe rest internal nodes /u1D462,i.e., for/u1D462=/u1D44E.˜/u1D462,/u1D44E∈{0,1},suchthat /u1D43F/u1D447(˜/u1D462)∈{/u1D465/u1D461+1,...,/u1D465/u1D45B},
either both /u1D43F/u1D70C/u1D445(/u1D462),/u1D43F/u1D70C/u1D445(˜/u1D462)∈/u1D444or both/u1D43F/u1D70C/u1D445(/u1D462),/u1D43F/u1D70C/u1D445(˜/u1D462)∈/u1D444′
1.In theformercases, we have always
/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C/u1D445(/u1D462)
and in the later
/u1D43F/u1D70C/u1D445(/u1D462)=(/u1D43FV(/u1D70C)(/u1D462))′=V(/u1D43F/u1D70C(/u1D462))′=V(((V−1(/u1D43F/u1D70C/u1D445(/u1D462)))/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451)′)=/u1D43F/u1D70C/u1D445(/u1D462).(15)
Now,let/u1D462be a leafnode.If /u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444,then/u1D43F/u1D70C/u1D445(/u1D462)=/u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C/u1D445(/u1D462)and
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)()=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)()
=/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)().An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
Conversely,if /u1D43F/u1D70C/u1D445(/u1D462)∈/u1D444′
1,then,similar to Eq.( 15),we have /u1D43F/u1D70C/u1D445(/u1D462)=/u1D43FV(/u1D70C)(/u1D462)′=/u1D43F/u1D70C/u1D445(/u1D462)and
/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)()=/u1D43FV(/u1D70C)(/u1D462)′/u1D43FV(/u1D447)(/u1D462)()
=/u1D43F/u1D70C/u1D445(/u1D462)/u1D43F/u1D447/u1D445(/u1D462)().
Therefore /u1D447/u1D445=/u1D447/u1D445andhenceU:L(A)→L(A/u1D445)issurjective. /squaresolid
Thefunctionality is obvious.
/square
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.scB.4(T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc5.1,5.2/a.sc/n.sc/d.sc 5.3). L(U(A))={U(/u1D447)|/u1D447∈L(A)} for
U∈{X/u1D461,Y/u1D461,Z/u1D461,S/u1D461,T/u1D461,CNOT/u1D450
/u1D461,CZ/u1D450
/u1D461,Toﬀoli/u1D450,/u1D450′
/u1D461}.
P/r.sc/o.sc/o.sc/f.sc.For U∈{Z/u1D461,S/u1D461,T/u1D461}, the statement follows from Lemma B.1, for U=X/u1D461, the statement
followsfromLemma B.2andforU =Y/u1D461itfollowsfromLemma B.1andLemma B.2combined.For
U∈{CNOT/u1D450
/u1D461,CZ/u1D450
/u1D461}it followsfromLemma B.3.
Finally, for U =Toﬀoli/u1D450,/u1D450′
/u1D461, we may setA1=CNOT/u1D450′
/u1D461(A). Since 0 </u1D450</u1D450′</u1D461≤/u1D45Band there
exists a bijectionV:L(A)→L( CNOT/u1D450′
/u1D461(A))by above. Following line by line in the proof of
LemmaB.3withA1=CNOT/u1D450′
/u1D461(A), we deducethe statement forU =Toﬀoli/u1D450,/u1D450′
/u1D461./square
C PROOFS FOR SECTION 6
Similar to the previous section, in this one we provide the proo fs for Theorems and Lemmas in
Section 6.
L/e.sc/m.sc/m.sc/a.sc C.1(L/e.sc/m.sc/m.sc/a.sc 6.3). All non-single-valued trees ina taggedTAhave diﬀerent tag s.
P/r.sc/o.sc/o.sc/f.sc.LetAbe a taggedTA.Suppose that /u1D4471,/u1D4472∈L(A)have the same tag,say
Tag(/u1D4471)=Tag(/u1D4472)=/u1D465/u1D4561
1(/u1D465/u1D4562
2(···(/u1D465/u1D456/u1D45A/u1D45B(/square,/square),/u1D465/u1D456/u1D459/u1D45B(/square,/square)),···))),
and let/u1D70C1(resp./u1D70C2) be the corresponding accepting run of /u1D4471(resp./u1D4472). Note that since Ais
deterministic, the acceptingrun isunique for /u1D4471and/u1D4472.Since every transition in a taggedTAhas
auniquesymbol, /u1D70C1and/u1D70C2havethesameinternalnodesintheunderlying(same)tree.Moreov er,
from our deﬁnition of TAs, every leaf transition has a unique par ent state. Hence /u1D70C1and/u1D70C2have
the sameleaf nodestoo.Thus,we have /u1D70C1=/u1D70C2andtherefore /u1D4471=/u1D4472. /square
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc C.2 (T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 6.6). The restriction procedure is tag preserving on the tree rest riction
operation that transforms /u1D447to/u1D435/u1D465·/u1D447.
P/r.sc/o.sc/o.sc/f.sc.Fix/u1D461∈[/u1D45B]. Since the restriction procedures for A/u1D435/u1D465/u1D461·/u1D447andA/u1D435/u1D465/u1D461·/u1D447are symmetric, we
will prove the caseof A/u1D435/u1D465/u1D461·/u1D447and the proofforthe latercase is similar.
ForagivenTAA=(/u1D444,Σ,Δ,R):=A/u1D447,letusdenotebyA/u1D435={/u1D444/u1D435=/u1D444∪/u1D444′,Σ/u1D435=Σ∪{/u1D4500},Δ/u1D435=
(Δ\Δrm)∪Δadd∪Δ′,R/u1D435=R}the TAA/u1D435/u1D465/u1D461·/u1D447constructed fromAvia our restriction procedure
Algorithm 4.We are going toconstruct a map
(·)/u1D435:L(A)→L(A /u1D435)
/u1D447/u\i∈1A6.e\dl→/u1D447/u1D435
asfollows:foreach /u1D447∈L(A)with anacceptingrun /u1D70C,sinceΣ⊆Σ/u1D435,we canformatree /u1D447/u1D435such
that/u1D461/u1D44E/u1D454(/u1D447/u1D435)=/u1D461/u1D44E/u1D454(/u1D447)with eachinternal node /u1D462∈/u1D441/u1D447/u1D435being such that /u1D43F/u1D447/u1D435(/u1D462)=/u1D43F/u1D447(/u1D462)∈Σ⊆Σ/u1D435.
Let/u1D70C/u1D435bethe run of /u1D447/u1D435deﬁned as
(1)/u1D43F/u1D70C/u1D435(/u1D716)=/u1D43F/u1D70C(/u1D716);Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
(2) foreachinternal node /u1D462∈/u1D441/u1D447/u1D435,
/u1D43F/u1D70C/u1D435(/u1D462)=/braceleftBigg
/u1D43F/u1D70C(/u1D462)if/u1D43F/u1D447(/u1D462)hasvariants in{/u1D4651,...,/u1D465/u1D461}asits label
/u1D43F/u1D70C(/u1D462)′otherwise;
(3) foreachleaf node /u1D462=0./u1D462′or/u1D462=1./u1D462′with aninternal node /u1D462′,
/u1D43F/u1D70C/u1D435(/u1D462)= 
/u1D43F/u1D70C(/u1D462)′if/u1D43F/u1D70C/u1D435(/u1D462′)=/u1D43F/u1D70C(/u1D462′)′
/u1D43F/u1D70C(/u1D462)′if/u1D462=0./u1D462′,/u1D43F/u1D70C/u1D435(/u1D462′)=/u1D43F/u1D70C(/u1D462′)and/u1D43F/u1D447(/u1D462′)hasvariants in /u1D465/u1D461aslabel
/u1D43F/u1D70C(/u1D462)otherwise.
Then,forevery internal node /u1D462∈/u1D441/u1D447/u1D435,we have
/u1D43F/u1D70C/u1D435(/u1D462)/u1D43F/u1D447/u1D435(/u1D462)(/u1D43F/u1D70C/u1D435(0./u1D462),/u1D43F/u1D70C/u1D435(1./u1D462))∈ 
Δ\Δrmif/u1D43F/u1D70C/u1D435(/u1D462),/u1D43F/u1D70C/u1D435(0./u1D462),/u1D43F/u1D70C/u1D435(1./u1D462)∈/u1D444
Δaddif/u1D43F/u1D70C/u1D435(/u1D462)∈/u1D444and/u1D43F/u1D70C/u1D435(0./u1D462),/u1D43F/u1D70C/u1D435(1./u1D462)∈/u1D444′
Δ′if/u1D43F/u1D70C/u1D435(/u1D462),/u1D43F/u1D70C/u1D435(0./u1D462),/u1D43F/u1D70C/u1D435(1./u1D462)∈/u1D444′
and hence
/u1D43F/u1D70C/u1D435(/u1D462)/u1D43F/u1D447/u1D435(/u1D462)(/u1D43F/u1D70C/u1D435(0./u1D462),/u1D43F/u1D70C/u1D435(1./u1D462))∈Δ/u1D435.
For eachleafnode /u1D462∈/u1D441/u1D447/u1D435,we set
/u1D43F/u1D447/u1D435(/u1D462)=/braceleftBigg
/u1D43F/u1D447(/u1D462)if/u1D43F/u1D70C/u1D435(/u1D462)∈/u1D444
/u1D4500if/u1D43F/u1D70C/u1D435(/u1D462)∈/u1D444′
and then
/u1D43F/u1D70C/u1D435(/u1D462)/u1D43F/u1D447/u1D435(/u1D462)()∈Δ/u1D435
for each leaf node /u1D462∈/u1D441/u1D447/u1D435. Moreover, /u1D43F/u1D70C/u1D435(/u1D716)=/u1D43F/u1D70C(/u1D716)∈R=R/u1D435. Thus/u1D445/u1D435is an accepting run of
L(A/u1D435)over/u1D447/u1D435andhence /u1D447/u1D435∈L(A /u1D435),i.e., themap(·)/u1D435is well-deﬁned.
By Lemma C.1, all diﬀerent trees /u1D447∈L(A) have diﬀerent tags and, since Tag (/u1D447/u1D435)=Tag(/u1D447)
for each/u1D447by the construction, we have that all /u1D447/u1D435’s are diﬀerent as well. It follows that the map
(·)/u1D435is injective with Tag (/u1D447)=Tag(/u1D447/u1D435).
Claim3:Themap(·)/u1D435issurjective.
Proof:For each/u1D447′∈L(A /u1D435)with an accepting run /u1D445′,sinceΣ/u1D435=Σ∪{/u1D4500}and/u1D4500correspondsto
the leaf transition only, we can form a tree /u1D447such that Tag(/u1D447)=Tag(/u1D447′)and, for each internal
node/u1D462∈/u1D441/u1D447,/u1D43F/u1D447(/u1D462)=/u1D43F/u1D447′(/u1D462)∈Σ/u1D435\{/u1D4500}=Σ. To construct an accepting run /u1D70Cof/u1D447such that
/u1D447∈ L(A), we ﬁrst note that the set of root states R/u1D435ofA/u1D435is identical to the one RofA.
Therefore /u1D43F/u1D70C′(/u1D716)∈R/u1D435=Randwemayset /u1D43F/u1D70C(/u1D716)=/u1D43F/u1D70C′(/u1D716).For eachinternal node /u1D462∈/u1D441/u1D447,weset
/u1D43F/u1D70C(/u1D462)=/braceleftBigg
/u1D43F/u1D70C′(/u1D462) if/u1D43F/u1D70C′(/u1D462)∈/u1D444
(/u1D43F/u1D70C′(/u1D462))/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451if/u1D43F/u1D70C′(/u1D462)∈/u1D444′
where,since /u1D444′isinone-to-onecorrespondenceto /u1D444,wedenoteby(/u1D45E′)/u1D462/u1D45B−/u1D45D/u1D45F/u1D456/u1D45A/u1D452/u1D451thecorrespond-
ing/u1D45E∈/u1D444to/u1D45E′∈/u1D444′.Byconstruction,allelementsin therangeof /u1D441/u1D435belongto /u1D444.Foraninternal
transition
/u1D43F/u1D70C′(/u1D462)/u1D43F/u1D447′(/u1D462)((/u1D43F/u1D70C′(0./u1D462),/u1D43F/u1D70C′(1./u1D462))∈Δ/u1D435,
if all/u1D43F/u1D70C′(/u1D462),/u1D43F/u1D70C′(0./u1D462),/u1D43F/u1D70C′(1./u1D462)∈/u1D444,then
/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)((/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δ.
Ifall/u1D43F/u1D70C′(/u1D462),/u1D43F/u1D70C′(0./u1D462),/u1D43F/u1D70C′(1./u1D462)∈/u1D444′,then
/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)((/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))∈ΔAn Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
toosince Δ′isinone-to-onecorrespondenceto Δ.Forthecases /u1D43F/u1D70C′(/u1D462)∈/u1D444and/u1D43F/u1D70C′(0./u1D462),/u1D43F/u1D70C′(1./u1D462)∈
/u1D444′,the transition /u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)((/u1D43F/u1D70C(0./u1D462),/u1D43F/u1D70C(1./u1D462))belongto Δas well by the add/remove step
inourprocedure.Theleaftransitionsfortheleafnodesareuniq uelydetermined bytheirstarting
states which have been deﬁned. Therefore such an /u1D70Cis an accepting run of /u1D447overA, namely,
/u1D447∈L(A).Thusthe claimfollows. /squaresolid
Finally,the functionality
UnTag(/u1D447/u1D435)=/u1D435/u1D465/u1D461·UnTag(/u1D447)
followsdirectlyfromthe construction of (·)/u1D435. /square
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.scC.3(T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc6.7). Themultiplication procedureover ataggedTAistag preserv ingon
the treemultiplication operation transforming /u1D447to/u1D463·/u1D447.
P/r.sc/o.sc/o.sc/f.sc.Thetheoremtriviallyholdsbecausethemultiplicationpro cedureonlychangestheleaf
symbols. /square
L/e.sc/m.sc/m.sc/a.sc C.4(L/e.sc/m.sc/m.sc/a.sc 6.8). Subtreecopying s.copynistag-preserving over thetreeprojectionopera-
tion/u1D447→/u1D447/u1D465/u1D45B.
P/r.sc/o.sc/o.sc/f.sc.LetA=(/u1D444,Σ,Δ,R)be ataggedTAand A′=(/u1D444′,Σ′,Δ′,R′):=s.copyn(A)be theTA
obtainedaftersubtreecopyingprocedureon /u1D465/u1D45B.Notethat,byconstruction, /u1D444′=/u1D444,Σ′=Σ,R′=R.
Let usconstruct amap
(·)/u1D465/u1D45B:L(A)→L(A′)
/u1D447/u\i∈1A6.e\dl→/u1D447/u1D465/u1D45B
as follows: for each /u1D447∈L(A)with its accepting run /u1D70C, we form a tree /u1D447/u1D465/u1D45Bsuch that Tag(/u1D447/u1D465/u1D45B)=
Tag(/u1D447)with eachinternal node /u1D462∈/u1D441/u1D447/u1D465/u1D45Bbeing suchthat /u1D43F/u1D447/u1D465/u1D45B(/u1D462)=/u1D43F/u1D447(/u1D462)∈Σ.Let/u1D70C/u1D465/u1D45Bbe the run
of/u1D447/u1D465/u1D45BonA′deﬁned as
(1)/u1D43F/u1D70C/u1D465/u1D45B(/u1D716)=/u1D43F/u1D70C(/u1D716);
(2)/u1D43F/u1D70C/u1D465/u1D45B(/u1D462)=/u1D43F/u1D70C(/u1D462)foreachinternal node /u1D462∈/u1D441/u1D447/u1D465/u1D45Bexcept those nodesin the /u1D465/u1D45B’slayer;
(3) and for the remaining internal nodes /u1D462′=0./u1D462and/u1D462′′=1./u1D462, we set/u1D43F/u1D70C/u1D465/u1D45B(0./u1D462)=/u1D43F/u1D70C(1./u1D462)
and/u1D43F/u1D70C/u1D465/u1D45B(1./u1D462)=/u1D43F/u1D70C(1./u1D462);
andfortheleafnodes /u1D462,/u1D43F/u1D70C/u1D465/u1D45B(/u1D462)and/u1D43F/u1D447/u1D465/u1D45B(/u1D462)arethenuniquelydeterminedbythestructureofthe
TAA′.By construction,we have,for /u1D462in the layerjust above the leafnodes,
/u1D43F/u1D70C/u1D465/u1D45B(/u1D462)/u1D43F/u1D447/u1D465/u1D45B(/u1D462)((/u1D43F/u1D70C/u1D465/u1D45B(0./u1D462),/u1D43F/u1D70C/u1D465/u1D45B(1./u1D462))=/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)((/u1D43F/u1D70C(1./u1D462),/u1D43F/u1D70C(1./u1D462))∈Δadd⊂Δ′.
For the other nodes, the corresponding transitions remain unchange d and hence belong to Δ\
Δrm⊂Δ′. Thus the map(·)/u1D465/u1D45Bis well-deﬁned. Moreover, since Tag (/u1D447)=Tag(/u1D447/u1D465/u1D45B)and each tree
hasits own unique tagby Lemma C.1,it followsthat(·)/u1D465/u1D45Bis injective.
Claim4:Themap(·)/u1D465/u1D45Bissurjective.
Proof:For each /u1D447′∈L(A′)with the accepting run /u1D70C′, again since Σ′=Σ, we can form a tree
/u1D447such that Tag(/u1D447)=Tag(/u1D447′), and, for each internal node /u1D462∈/u1D441/u1D447/u1D465/u1D45B,/u1D43F/u1D447(/u1D462)=/u1D43F/u1D447′(/u1D462) ∈Σ. To
construct an accepting run /u1D445of/u1D447, note that the set of root states R′ofA′is identical to the
one ofA. Therefore we may set /u1D43F/u1D70C(/u1D716)=/u1D43F/u1D70C′(/u1D716) ∈ R′=R. For each internal node /u1D462∈/u1D441/u1D447
other than in the /u1D465/u1D45B’s layer, we set /u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C′(/u1D462). For each internal node /u1D462in the/u1D465/u1D45B’s layer,
we set (1) /u1D43F/u1D70C(/u1D462)=/u1D43F/u1D70C′(/u1D462), (2)/u1D43F/u1D70C(1./u1D462)=/u1D43F/u1D70C′(1./u1D462), and (3)/u1D43F/u1D70C(0./u1D462)=/u1D45E/u1D459, where/u1D45E/u1D459is the left child
of the transition /u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D45E/u1D459,/u1D45E/u1D45F). Such a transition must exist since there is a one-to-one
correspondencebetween ΔandΔ′bys.copyalgorithm.Thetransition
/u1D43F/u1D70C(/u1D462)/u1D43F/u1D447(/u1D462)(/u1D45E/u1D459,/u1D45E/u1D45F)Yu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
is nothingbut the one correspondingto thetransition
/u1D43F/u1D70C′(/u1D462)/u1D43F/u1D447′(/u1D462)((/u1D43F/u1D70C′(0./u1D462),/u1D43F/u1D70C′(1./u1D462))
which,by assumption, belongsto Δ′. Those labelings of leaf nodesare then uniquely determined
bythestructureoftheTA.Thus,byconstruction, /u1D447∈L(A)andhencethemap (·)/u1D465/u1D45Bissurjective.
/squaresolid
Finally,UnTag(/u1D447/u1D465/u1D45B)=UnTag(/u1D447)/u1D465/u1D45Bfollowsdirectlyfrom theconstruction of (·)/u1D465/u1D45B./square
L/e.sc/m.sc/m.sc/a.sc C.5 (F/o.sc/r.sc/w.sc/a.sc/r.sc/d.sc /a.sc/n.sc/d.sc /b.sc/a.sc/c.sc/k.sc/w.sc/a.sc/r.sc/d.sc /s.sc/w.sc/a.sc/p.sc/p.sc/i.sc/n.sc/g.sc /p.sc/r.sc/e.sc/s.sc/e.sc/r.sc/v.sc/e.sc/s.sc /q.sc_u.sc/a.sc/n.sc/t.sc/u.sc/m.sc /s.sc /t.sc/a.sc/t.sc/e.sc/s.sc).Given a TAA
that encodes a set of quantum states, L(f.swap/u1D461(A)),L(A), andL(b.swap/u1D461(A))represent the
same setof quantum states.
P/r.sc/o.sc/o.sc/f.sc.Firstofall,thebinarytreerepresentationsofafunction /u1D447:{0,1}/u1D45B→Z5areparametrized
by the orders on the variables /u1D465/u1D456’s. Fix/u1D461∈[/u1D45B]. We denote by /u1D447also the binary tree representing
the function(asin this wholearticle) onthe standard ordering
/u1D4651>/u1D4652>···>/u1D465/u1D461>/u1D465/u1D461+1>···/u1D465/u1D45B (16)
and by/u1D447′the binary tree representing the samefunction but on theorder
/u1D4651>/u1D4652>···/u1D465/u1D461−1>/u1D465/u1D461+1>/u1D465/u1D461>/u1D465/u1D461+2>···/u1D465/u1D45B. (17)
Suchacorrespondencebetweenthesetofbinarytreeswithrespe cttostandardorderinginEq.( 16)
and the set of trees with respect to the ordering in Eq. ( 17) is clearly one-to-one. Let Abe the
taggedTAconsisting of /u1D447∈L(A)with respectto the standard order Eq.( 16).ByAlgorithm 7of
thef.swap/u1D461procedure,it is clearthat f.swap/u1D461(A)consists ofall the /u1D447′andvice versa.Thusthere
is a one-to-one correspondence f.swap/u1D461:L(A)→L( f.swap/u1D461(A)). Moreover, since /u1D447and its
corresponding /u1D447′are by deﬁnition representing the same function as well as the sam e state, we
have that the TAsAandf.swap/u1D461(A)represent the same set of quantumstates.
The proof of the case that Aandb.swap/u1D461(A)(ifb.swap/u1D461is applicable) represent the same set
ofquantum states isin thesame fashion. /square
By the above Lemma C.5, let us deﬁne the induced maps f/u1D458andb/u1D458on tags of trees, namely,
f/u1D458(Tag(/u1D447)):=Tag(/u1D447′)andb/u1D458(Tag(/u1D447′)):=Tag(/u1D447).It is easy tosee that
Tag(b.swap/u1D458(f.swap/u1D458(/u1D447)))=b/u1D458(Tag(f.swap/u1D458(/u1D447)))=b/u1D458(f/u1D458(Tag(/u1D447)))=Tag(/u1D447).(18)
We also introduce the notion A1≃/u1D460/u1D461/u1D44E/u1D461/u1D452A2between two TAsA1andA2if there is a bijection
/u1D446:L(A1)→L(A 2)andL(A1)andL(A2)represent the sameset ofquantum states.
Next, we prove an auxiliary lemma and use it to show that the pro jection procedure is tag
preserving.
L/e.sc/m.sc/m.sc/a.sc C.6. Given a TAA. For each /u1D461∈[/u1D45B]and for each TAA′withA′≃Tagf.swap/u1D461(A), we
haveb.swap/u1D461(A′)≃TagA.
P/r.sc/o.sc/o.sc/f.sc.Byassumption,thereisaone-to-onecorrespondencebetween L(A′)andL(f.swap/u1D461(A))
such that for each /u1D447′∈L(A′)and its corresponding /u1D447′′∈L(f.swap/u1D461(A)), we have Tag(/u1D447′)=
Tag(/u1D447′′)(andvice versa). We denote by /u1D446′(·):L(A′)→L(f.swap/u1D461(A))sucha bijection.
SinceA≃/u1D460/u1D461/u1D44E/u1D461/u1D452f.swap/u1D461(A)bytheaboveLemma C.5,thereexistsabijection f.swap/u1D461(·):L(A)→
L(f.swap/u1D461(A))and similarly there is a bijection b.swap/u1D461(·):L(A′)→L(b.swap/u1D461(A′)). Thus
we have the followingdiagram
L(A)L(f.swap/u1D461(A))
L(b.swap/u1D461(A′))L(A′)f.swap/u1D461
/u1D446 /u1D446′
b.swap/u1D461An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
and thecomposition map
/u1D446(·):=b.swap/u1D461(·)◦/u1D446′(·)◦f.swap/u1D461(·):L(A)→L( b.swap/u1D461(A′))
iswell-deﬁnedandisbijectivesinceallthethreemapsarebije ctive.Moreover,foreach /u1D447∈L(A),
Tag(/u1D446(/u1D447))=Tag(b.swap/u1D461(/u1D446′(f.swap/u1D461(/u1D447))) ByDef.of /u1D446
=b/u1D461(Tag(/u1D446′(f.swap/u1D461(/u1D447))) By Def.of b/u1D461
=b/u1D461(Tag(f.swap/u1D461(/u1D447)) By assumption of /u1D446′
=b/u1D461(f/u1D461(Tag(/u1D447))) By Def.of f/u1D461
=Tag(/u1D447) ByLemma C.5.
Thuswe have b.swap/u1D461(A′)≃TagA. /square
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.scC.7 (T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc6.11). The projection procedureis tag preserving with respect to t he tree
projection operationsthat transforms atree /u1D447to/u1D447/u1D465.
P/r.sc/o.sc/o.sc/f.sc.Byconstruction,we have the followingdiagram
L(A) L(A 1) L(A 2)···L(A/u1D459−1) L(A /u1D459)
L(A′)L(A′
1) L(A′
2)···L(A′
/u1D459−1) L(A′
/u1D459)f.swap/u1D461
/u1D446f.swap/u1D461
/u1D4461 /u1D4462f.swap/u1D461
/u1D446/u1D459−1s.copy/u1D461
b.swap/u1D461b.swap/u1D461 b.swap/u1D461
where themaps /u1D446/u1D456’s are deﬁned inductively as
(1)/u1D446/u1D459−1:=b.swap/u1D461◦s.copy/u1D461◦f.swap/u1D461,and
(2)/u1D446/u1D456:=b.swap/u1D461◦/u1D446/u1D456+1◦f.swap/u1D461for/u1D456=0,1,...,/u1D459−2 and/u1D446:=/u1D4460.
Since now /u1D465/u1D461’s are in the layer just above leaf transition, s.copy/u1D461is tag preserving by Lemma C.4,
we haveA/u1D459≃TagA′
/u1D459. Apply Lemma C.6inductively, we have A/u1D456≃TagA′
/u1D456for each/u1D456and hence
A≃TagA′.Moreover,since
A≃/u1D460/u1D461/u1D44E/u1D461/u1D452A1≃/u1D460/u1D461/u1D44E/u1D461/u1D452···≃/u1D460/u1D461/u1D44E/u1D461/u1D452A/u1D459andA′≃/u1D460/u1D461/u1D44E/u1D461/u1D452A′
1≃/u1D460/u1D461/u1D44E/u1D461/u1D452···≃/u1D460/u1D461/u1D44E/u1D461/u1D452A′
/u1D459,
the functionality followsfromthefunctionality of s.copy/u1D461. /square
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc C.8 (T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 6.12). Given two tagged TAs A/u1D4471andA/u1D4472as the input of the binary
operation, the resulting TA A/u1D4471±/u1D4472recognizes{/u1D4471±/u1D4472|/u1D4471∈L(A /u1D4471)∧/u1D4472∈L(A /u1D4472)∧Tag(/u1D4471)=
Tag(/u1D4472)}.
P/r.sc/o.sc/o.sc/f.sc.Itis similar to the proofofTheorem C.2that there exists a one-to-one correspondence
L(A/u1D4471)×L(A /u1D4472)→L(A /u1D4471±/u1D4472)
(/u1D4471,/u1D4472)/u\i∈1A6.e\dl→/braceleftBigg
/u1D4471±/u1D4472if Tag(/u1D4471)=Tag(/u1D4472)
∅ otherwise
and, by the binary operation algorithm, we have Tag (/u1D4471±/u1D4472)=Tag(/u1D4471)=Tag(/u1D4472)for any pair
(/u1D4471,/u1D4472)∈L(A /u1D4471)×L(A /u1D4472)withTag(/u1D4471)=Tag(/u1D4472).Thefunctionalityfollowsfromthealgorithm
ofleaf transitions (ofthe binary operation). /squareYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−− one Grover iteration −−−−−−−−−−−−−−−−−−−−−−−−−−−−−→|/u1D4601/a\}bracke⊔ri}h⊔/u1D44B /u1D44B
|/u1D4602/a\}bracke⊔ri}h⊔/u1D44B /u1D44B
|/u1D4603/a\}bracke⊔ri}h⊔/u1D44B /u1D44B
|0/a\}bracke⊔ri}h⊔/u1D43B/u1D44B /u1D44B/u1D43B/u1D44B /u1D44B/u1D43B
|0/a\}bracke⊔ri}h⊔/u1D43B /u1D44B /u1D44B /u1D43B/u1D44B /u1D44B/u1D43B
|0/a\}bracke⊔ri}h⊔/u1D43B /u1D44B /u1D44B /u1D43B/u1D44B/u1D44D/u1D44B/u1D43B
|1/a\}bracke⊔ri}h⊔/u1D43B
Fig.4. AnimplementationofGrover’ssearchalgorithm.Theb oxedareadenotesamulti-controlgate,which
can be implemented with Toﬀoli gates and two additional anci lla qubits. The area is the oracle circuit,
andthe parttothe right ofthe redseparatorisone Groverite ration.
D THE CIRCUITOF GROVER’S SEARCH ALGORITHM WITHALLPOSSIBLE
ORACLES
With the operations over the symbolic representation of quantu m states introduced in the main
text, we are able to perform all gate operations in Table 1. In the current section, we will use
Grover’s search algorithm [ 46] to demonstrate how to use these gate operations for automatic
veriﬁcation of thesafety properties ofquantum algorithms.
The Grover’s search algorithm assumes the existence of an oraclethat knows the problem of
interest and cananswer related questions.
DeﬁnitionD.1(PhaseOracle). Givenafunction /u1D453:{0,1}/u1D45B→{0,1},aphaseoracle /u1D442/u1D453transforms
a quantumstate|/u1D465/a\}bracke⊔ri}h⊔to(−1)/u1D453(/u1D465)|/u1D465/a\}bracke⊔ri}h⊔.
G/r.sc/o.sc/v.sc/e.sc/r.sc’/s.sc P/r.sc/o.sc/b.sc/l.sc/e.sc/m.sc
Input: A function /u1D453(/u1D465)that returns 1 if /u1D465=/u1D460for some unique secret string /u1D460∈{0,1}/u1D45Band 0
otherwise, and aphase oracle /u1D442/u1D453.
Output: Theunique secret string /u1D460.
InFig.4,weshowthecircuitimplementing3-qubitGrover’ssearchalg orithmtogetherwithits
oracle circuit. The oracle circuit takes as input qubits |/u1D4601/u1D4602/u1D4603/a\}bracke⊔ri}h⊔and uses them as the only solution
to/u1D453(/u1D465). For the analysis of the algorithm, we create a TA that accepts the set of quantum basis
states{|/u1D4601/u1D4602/u1D46030001/a\}bracke⊔ri}h⊔|/u1D4601/u1D4602/u1D4603∈{0,1}3}anduse it asthe initial TA.
Thecircuit totheright oftheredseparator in Fig. 4iscalleda Grover iteration , whosefunction
is to increase the probability amplitude of the basis |/u1D4601/u1D4602/u1D4603/u1D4601/u1D4602/u1D4603+/a\}bracke⊔ri}h⊔. The number of gates required
periteration islinear withourencodingand isexponentialwith an enumeration-basedapproach.
Intuitively,aGroveriterationincreasestheprobabilityth atthemeasuredoutcomeof /u1D4651/u1D4652/u1D4653equals
tothesolution /u1D4601/u1D4602/u1D4603.Itisexecutedrepeatedlyforroughly O(√
2/u1D45B)timesinordertoobtainahigh
enough probability that /u1D4651/u1D4652/u1D4653is measured to be /u1D4601/u1D4602/u1D4603(see [46] for more details). After that, we
checktheequivalence ofthe obtained TAagainst the reference ans wer.An Automata-basedFramework forVerificationand BugHunting in/Q_uantumCircuits
/u1D45E0/u1D43B /u1D43B
/u1D45E1/u1D43B /u1D43B
/u1D45E2/u1D43B /u1D43B
/u1D45E3/u1D43B/u1D44D
Fig.5. AnimplementationofBernstein-Vazirani’salgorith m.Themiddlepartbetweenthetworedseparators
is the quantum oracle correspondingto the hiddenstring /u1D4602/u1D4601/u1D4600=011.
E ADDITIONAL INFORMATION ABOUT THEEXPERIMENTS
The pre-conditions, circuits and post-conditions of each experi ment are described as follows. For
Bernstein-Vazirani’s algorithm, the parameter /u1D45Bis the length of the hidden string. Fig. 5is an
example circuit from the hidden string /u1D4602/u1D4601/u1D4600=011.For each /u1D460/u1D456=1,the correspondingqubit /u1D45E/u1D456is
attached to the control qubit of a CNOT gate whose target is loc ated at the bottom qubit. In this
algorithm, the initial state can only be |0/a\}bracke⊔ri}h⊔, and the output state has probability 100% at hidden
string’s basis state. Moreprecisely, when (/u1D45B=/u1D45A+1)
Pre:{|0/u1D45B/a\}bracke⊔ri}h⊔}
Post:{(10)(/u1D45A−1)/211} if/u1D45Ais odd
{(10)/u1D45A/21} if/u1D45Ais even.
Notice that for the sake of constructing the post condition, our i mplementation actually appends
one moreHgate at the targetqubit to theend ofthe circuit.
ForGrover’salgorithmwithoneoracle,theproblemsize /u1D45Bisalsothelengthofthehiddenstring.
The circuit can be easily modiﬁed from Fig. 4by hardwiring particular X gates from the unique
secretstringandthenremovingall |/u1D460/u1D456/a\}bracke⊔ri}h⊔qubits.Theinitial stateofthebottomqubitcanonlybe |1/a\}bracke⊔ri}h⊔
and those of other qubits can only be |0/a\}bracke⊔ri}h⊔. The output state has the highest probability at hidden
string’s basis state if the proper number of iterations is given. For Grover’s algorithm with all
possibleoracles,thereaderscanrefertoAppendix D.NoticethatwestillappendonemoreHgate
at the target qubit to the end of the circuit here for the sake of constructing the post condition.
Besides, the representation below does not assume an interleav ing of control qubits and workYu-FangChen,Kai-MinChung,OndřejLengál,Jyun-AoLin,Wei -LunTsai,and Di-DeYen
|/u1D4501/a\}bracke⊔ri}h⊔
|/u1D4502/a\}bracke⊔ri}h⊔
|0/a\}bracke⊔ri}h⊔
|/u1D4503/a\}bracke⊔ri}h⊔
|0/a\}bracke⊔ri}h⊔
|/u1D4504/a\}bracke⊔ri}h⊔
|0/a\}bracke⊔ri}h⊔
|/u1D4505/a\}bracke⊔ri}h⊔
|0/a\}bracke⊔ri}h⊔
/u1D44B
Fig. 6. Multi-controlled Toﬀoli of5control qubits
qubits.
Grover-Single(/u1D45B=2/u1D45A, /u1D45A≥3)
Pre:{|0/u1D45B/a\}bracke⊔ri}h⊔}
Post:{/u1D44Eℎ|/u1D4600/u1D45A−11/a\}bracke⊔ri}h⊔+/summationdisplay.1
/u1D456∈{0,1}/u1D45A,/u1D456≠/u1D460/u1D44E/u1D459|/u1D4560/u1D45A−11/a\}bracke⊔ri}h⊔|/u1D460=(01)(/u1D45A−1)/20}if/u1D45Ais odd
{/u1D44Eℎ|/u1D4600/u1D45A−11/a\}bracke⊔ri}h⊔+/summationdisplay.1
/u1D456∈{0,1}/u1D45A,/u1D456≠/u1D460/u1D44E/u1D459|/u1D4560/u1D45A−11/a\}bracke⊔ri}h⊔|/u1D460=(01)/u1D45A/2} if/u1D45Ais even.
Grover-All(/u1D45B=3/u1D45A, /u1D45A≥3)
Pre:{|/u1D4600/u1D45A0/u1D45A/a\}bracke⊔ri}h⊔|/u1D460∈{0,1}/u1D45A}
Post:{/u1D44Eℎ|/u1D460/u1D4600/u1D45A−11/a\}bracke⊔ri}h⊔+/summationdisplay.1
/u1D456∈{0,1}/u1D45A,/u1D456≠/u1D460/u1D44E/u1D459|/u1D460/u1D4560/u1D45A−11/a\}bracke⊔ri}h⊔|/u1D460={0,1}/u1D45A}
Formulti-controlledToﬀoligates,theproblemsize /u1D45Bisthenumberofcontrolqubits.Ourcircuit
ofmulti-controlledToﬀolicanbefoundinFig. 6and thetotalnumberofqubitsis2 /u1D45B.Wetest this
gatewiththeinitialautomatonconsistingofallbasisstatest hathavecontrolqubitsandthetarget
qubit 0 or 1 and work qubits only 0.In this case, the post-conditi on TA would be the same as the
pre-conditionTA.Therepresentationbelowdoesnotassumeani nterleavingofcontrolqubitsand
workqubits either.
MCToﬀoli(/u1D45B=2/u1D45A, /u1D45A≥3)
Pre:{|/u1D4500/u1D45A−1/u1D461/a\}bracke⊔ri}h⊔|/u1D450∈{0,1}/u1D45A∧/u1D461∈{0,1}}
Post:{|/u1D4500/u1D45A−1/u1D461/a\}bracke⊔ri}h⊔|/u1D450∈{0,1}/u1D45A∧/u1D461∈{0,1}}
Forrandomlygeneratedgates,theproblemsizeissimplythenum berofqubits.Following[ 70]’s
conﬁguration,theratioof#qubits:#gatesisﬁxedto1:3,andth ereare10circuitsforeachsize.The
gatesandthe applied qubitsare pickeduniformlyat random.The initial state consists ofonly |0/a\}bracke⊔ri}h⊔.
Understanding the Capabilities of Large Language
Models for Automated Planning
Vishal Pallagani
AIISC, University of South Carolina
vishalp@mailbox.sc.eduBharath Muppasani
AIISC, University of South Carolina
bharath@email.sc.edu
Keerthiram Murugesan
IBM T.J. Watson Research Center
keerthiram.murugesan@ibm.comFrancesca Rossi
IBM T.J. Watson Research Center
francesca.rossi2@ibm.com
Biplav Srivastava
AIISC, University of South Carolina
biplav.s@sc.eduLior Horesh
IBM T.J. Watson Research Center
lhoresh@us.ibm.com
Francesco Fabiano
University of Udine
francesco.fabiano@unipr.itAndrea Loreggia
University of Brescia
andrea.loreggia@gmail.com
Abstract
Automated planning is concerned with developing efficient algorithms to generate
plans or sequences of actions to achieve a specific goal in a given environment.
Emerging Large Language Models (LLMs) can answer questions, write high-
quality programming code, and predict protein folding, showcasing their versatility
in solving various tasks beyond language-based problems. In this paper, we aim
to explore how LLMs can also be used for automated planning. To do so, we
seek to answer four key questions. Firstly, we want to understand the extent to
which LLMs can be used for plan generation. Secondly, we aim to identify which
pre-training data is most effective in facilitating plan generation. Thirdly, we
investigate whether fine-tuning or prompting is a more effective approach for plan
generation. Finally, we explore whether LLMs are capable of plan generalization.
By answering these questions, the study seeks to shed light on the capabilities of
LLMs in solving complex planning problems and provide insights into the most
effective approaches for using LLMs in this context.
1 Introduction
Automated Planning [Ghallab et al., 2004] focuses on generating sequences of actions, called plans,
for an agent to navigate from an initial state to a desired goal state. We represent the planning
problems using the Planning Domain Definition Language (PDDL) [Aeronautiques et al., 1998], a
Lisp-inspired declarative language with the specifications for the (partial) transition model, initial &
goal states and constraints (such as preconditions and effects). Automated planners must follow these
specifications to generate optimal or near-optimal plans, without violating any constraints. Recently,
LLMs such as GPT-4 [OpenAI, 2023], have demonstrated the ability to generate a executable piece of
code in any programming language [Poldrack et al., 2023]. Both PDDL and programming languages
use a similar type of formal syntax and share common concepts such as variables, functions, and
Preprint. Under review.arXiv:2305.16151v1  [cs.AI]  25 May 2023control structures. This notion of resemblance motivates us to investigate the capabilities of LLMs in
plan generation.
LLMs are built using neural networks with millions/billions of learnable parameters, pretrained
with a large corpus of natural language data. LLMs such as GPT4 have been shown to generate
human-like, coherent, and diverse texts. There has been recent interest in exploring the capabilities
of LLMs beyond the applications in many natural language processing tasks [Li, 2022, Zhao et al.,
2023]. For example, in code generation [Wang et al., 2021, Feng et al., 2020, Chen et al., 2021],
protein folding [Unsal et al., 2022, Ferruz and Höcker, 2022], etc. However, one task that remains
elusive for LLMs is automated planning [Valmeekam et al., 2022], as it requires reasoning about the
effects of actions and finding optimal or near-optimal sequences of actions to achieve a desired goal.
Automated planning is crucial for many real-world applications, such as robotics, dialog systems,
game playing, and more. Therefore, it is important to understand if and how the recent progress in
LLMs can be leveraged for planning, including their limitations and opportunities for this task.
In this paper, we provide a comprehensive analysis of LLMs’ capabilities for automated planning.
Toward this goal, we address the following four research questions: (1)To what extent can LLMs solve
planning problems? (2)What pre-training data is effective for plan generation? (3)Does fine-tuning
and prompting improve LLM’s plan generation? (4)Are LLMs capable of plan generalization? To
answer these questions, we compare different LLMs on six classical planning domains using both
fine-tuning and prompting approaches. We propose a metric to measure plan generalization and
also introduce three new tasks to evaluate LLMs on plan generalization. Despite the inapt claims
on LLMs for automated planning [Valmeekam et al., 2022], we show favorable outcomes with
appropriate selection of LLM, data preparation, and fine-tuning. We claim that LLMs pre-trained on
code generation can benefit from further fine-tuning with problems from several automated planning
domains, although their generalization capabilities seem limited. We recommend further research in
LLM for better plan generalization.
Our key contributions in this paper are: (a)a diverse set of benchmark problems to evaluate LLMs
for automated planning (along with a publicly available codebase with model weights to drive future
research). (b)a metric to evaluate plan generalization and design new tasks to measure it. (c)a
thorough empirical analysis of LLMs on planning-related metrics and insights on an appropriate
selection of LLMs for automated planning.
2 Background and Related Work
This section reports a brief review of the pertinent literature regarding exploring the use LLMs for
planning. In Table 1, we summarize the planning-related terminology for a better understanding.
Besides being capable of generating natural language content, LLMs have demonstrated remarkable
abilities to generate high-quality programming code [Vaithilingam et al., 2022, Tian et al., 2023]
and perform reasoning tasks [Huang and Chang, 2022]. Also, some recent works have used LLMs
to guide embodied agents towards user-specified goals using prompting techniques [Huang et al.,
2022a,b, Ahn et al., 2022, Wang et al., 2023, Singh et al., 2022]. These studies evaluate LLMs on the
world knowledge already possessed by them and use repeated feedback to help the agents overcome
failures and perform actions in common-sense domains. In contrast, automated planning problems
require generating a plan by reasoning on the constraints specified in the domain file, which is a
different and more challenging task. Recently, some works have also explored the capabilities of
LLMs in automated planning. Valmeekam et al. [2022, 2023] proposed a suite of benchmark tests to
evaluate the planning capabilities of LLMs. They tested recent models such as GPT-3 [Brown et al.,
2020], Instruct-GPT [Ouyang et al., 2022], and BLOOM [Scao et al., 2022] on these benchmarks
and found that they performed poorly, with Instruct-GPT achieving only 5% valid plans on 500
Blocksworld problems. Silver et al. [2022] also prompted GPT-3.5 for plan generation and observed
similar results but noted that its performance varied across domains. Other works have used LLMs to
generate goals [Xie et al., 2023] or problem files given a domain as input [Liu et al., 2023] and then
used a traditional planner to create plans.
Despite these and other recent studies exploring the potential of LLMs in automated planning, there
is a lack of comprehensive information on the capabilities of LLMs for plan generation. Current
approaches only evaluate plan generation capabilities using prompting techniques. To address this
2Table 1: Definitions for the terms used in the paper.
Term Definition
Classical planning problem It is a 4-tuple ⟨S, s 0, A, G⟩where Srepresents the set of all possible states of the planning
problem, s0is the initial state, Ais the set of all possible actions that can be performed in the
planning problem, and Grepresents the set of all goal states that the agent is trying to reach.
PDDL A formal language used to describe classical planning problems. It requires a domain and
problem file.
Domain File Defines the set of actions, along with their preconditions and effects, objects and their
relations, and predicates that can be used to describe a planning problem within a specific
domain.
Problem File Define the initial state of a planning problem, along with the goal state(s) that needs to be
achieved.
Planner An algorithmic tool that generates a plan of actions to achieve a desired goal state, given the
domain and problem PDDL files. An example is the tool FastDownward [Helmert, 2006].
Plan A sequence of actions that transforms the initial state into one that respects the goal conditions.
Satisficing plan A plan that achieves the goal state.
Optimal plan A plan that achieves the goal state with the minimum possible cost (such as time or resources).
Plan Length A numerical value that represents the number of actions or steps required to achieve a given
goal.
Degree of Correctness It is the ratio of solved goals and the total number of goals.
Plan Verification Tool Determines whether a plan achieves the specified goals while satisfying any constraints and/or
requirements.
gap, this study aims to provide a detailed analysis of the capabilities of LLMs in plan generation and
evaluate their generalization capabilities.
3 Research Questions
In this study, we aim at exploring the capabilities of LLMs in solving planning problems. To do that,
we address the following four research questions (RQ):
•RQ1 - To what extent can LLMs solve planning problems? Automated planning requires
reasoning abilities to generate a plan, satisfying given constraints. Pretrained LLMs have
been shown to reason in recent works, specifically analogical reasoning [Agrawal, 2023], a
necessity for automated planning. To answer how well pre-trained (or vanilla ) LLMs can
generate plans, we test state-of-the-art OpenAI models with zero-shot prompting and the
others (T5, CodeT5, etc) without fine-tuning. Since most of these models are not familiar
with PDDL specifications during training, we expect them to perform poorly without
additional fine-tuning for domain adaptation. We employ a plan verification tool (i.e., V AL
[Howey and Long, 2003]) to verify LLM-generated plans and evaluate them on commonly
used, planning-related metrics such as satisficing, optimal, invalid plans, and the degree of
correctness.
•RQ2 - What pre-training data is effective for plan generation? We provide a set of
pre-training data from a diverse set of planning domains (with varying difficulty) to answer
this question. We compare the performance of models pre-trained exclusively on textual
corpora with those that incorporate both code and natural language during the pre-training
process. Our goal, in addressing this question, is to provide possible directions for future
researchers to select the appropriate LLMs for plan generation.
•RQ3 - Which approach between fine-tuning and prompting improves plan generation?
Our objective is to compare the effectiveness of fine-tuning and prompting approaches for
plan generation. Fine-tuning LLM updates the parameters of the model using a labeled
dataset from the target task. Prompting controls the input to an LLM using a template
or a cue to elicit the desired output. We want to assess whether updating model weights
through fine-tuning provides superior domain adaptation compared to prompting LLMs for
the desired outcome.
3Table 2: Difficulty of planning domains.
Planning Domain Difficulty State Space Branching Factor
Ferry Easy O(2n∗2∗m∗n!),nis no. of cars, mis no. of
locationsO(n+ 1)
Blocksworld Easy O(3n),nis no. of blocks O(4n/2 + 1)
Miconic Medium O(n(m+1)∗2m∗m!),nis no. of floors, mis
no. of passengersO(m+ 1)
Tower of Hanoi Medium O(3n),nis no. of disks O((k−1)k/2),kis no. of
pegs
Grippers Hard O(2n∗3nr),nis no. of balls, ris no. of robots O(3nr+r)
Driverlog Hard O(L(D+T+P)∗KP∗D∗T∗2T),Lis no.
of locations, Dis no. of drivers, Tis no. of trucks,
Pis no. of packagesO(L∗(D+T+P+DT+
TD))
•RQ4 - Are LLMs capable of plan generalization? To the best of our knowledge, the
current literature provides a limited understanding of the plan generalization capabilities of
LLMs [Valmeekam et al., 2023]. Only a handful of studies have studied and quantitatively
measured them. To better evaluate the generalization capabilities of LLMs within the scope
of automated planning, we think that the current definition of plan generalization needs to
be clarified due to its limited scope as it fails to account for all possible scenarios that may
arise when using LLMs to plan. Therefore, we propose three new tasks to quantify the plan
generalization capabilities of LLMs accurately. We believe that this new definition can be
then used to properly evaluate and categorize the various LLMs approaches.
4 Materials and Methods
In this section, we describe our planning dataset and discuss the difficulty classification of the
planning domains. We also provide an overview of the LLMs being evaluated and the experimental
setup for plan generation. In what follows, let the training dataset be Dtrain = (x1, y1), ...,(xn, yn)
where each xiis a planning problem and yiis the corresponding optimal plan for problem xi. Let the
testing dataset be Dtest= (xn+1, yn+1), ...,(xm, ym)where each xiis a previously unseen planning
problem and yiis the corresponding optimal plan for problem xi. Note that Dtrain andDtestconsist
of pairs of planning problems and their corresponding optimal plans, generated using FastDownward
[Helmert, 2006], a classical planning system based on heuristic search.
4.1 Planning Dataset
The International Planning Competition (IPC) [ICAPS, 2022] is a biennial event that evaluates
state-of-the-art automated planning and scheduling systems. A new set of planners and planning
domains are periodically released as part of the IPC. We consider six classical planning domains
represented in PDDL, released as a part of the IPC, to assess planning capabilities in LLMs. We use
problem generators that came with these domains [Seipp et al., 2022] to generate a planning dataset
with 18,000 problems for each domain. We use a random seed to generate the problems and further
enforced that there are no duplicate problems in the dataset. We generate the ground truth optimal
plans for these problems using the planner FastDownward, firstly presented by [Helmert, 2006], with
A*LM-Cut heuristics [Helmert and Domshlak, 2011]. Table 2 lists the planning domains considered
in this paper and classifies them into three difficulty classes. Note that this classification is based on
the complexity of the problem in terms of state space and branching factor. Other factors such as
observability of the states and concurrency of actions can also be considered but are not in the scope
of this paper as we aim to investigate the optimal plan generation capabilities of LLMs. Sections 1.3
in the main paper and 2.1 of the supplementary material present additional information on difficulty
classification.
4.1.1 Data Format for Fine-tuning
Due to the limitation in the amount of contextual information that LLMs take during fine-tuning, it
hinders the practical use of the PDDL domain and problem files as input sequences directly. With
the domain and problem specifications, it may not be expressive enough to provide the necessary
4(a) Token lengths for PDDL vs Compact Form
 (b) Plan length distribution of train and test sets
Figure 1: (a) Token length for the Ferry domain. Using the compact form achieves an average 40%
reduction in token length in comparison to PDDL. (b) Plan length distribution of both train and test
sets are carefully chosen to be similar and within the contextual limitation of the LLMs considered
in this paper. Token lengths are in the x-axis and number of problems/plans per token length are in
y-axis.
Table 3: LLM architectures used in our study.
Model-Parameters Pre-training Layers Heads Embed. Size Context Length
T5-base-220M NL 12 12 768 512
CodeT5-base-220M NL+code 12 12 768 512
Codegen-multi-350M NL+code 24 16 1024 1024
text-davinci-03 NL NA NA NA 8000
code-davinci-02 NL+code NA NA NA 8000
context for the model. To address this limitation, we consider an approach that transforms the PDDL
representation into a more compact format with reduced token length without compromising any
critical syntactic information. The compact form allows us to maintain the fidelity of the original
PDDL representation while making them suitable for fine-tuning LLMs with limitations in the length
of the context. Figure 1a illustrates the difference in token lengths between using PDDL and the
compact data format for the Ferry domain as an example. We use plans without any modifications
because their average token length for the dataset falls within the context length of LLMs as shown in
Figure 1b. To evaluate the plan generation capabilities of the LLMs, we initially use datasets with
identical distributions for training and testing. We also report an experiment with out-of-distribution
problems. Section 2.2 of the supplementary material contains the details of the compact representation
of the PDDL problem and domain files, code, and examples.
4.1.2 Data Format for Prompting
Prompting LLMs control the output plan generated using the input sequences. Unlike fine-tuning,
prompting allows detailed contextual information as a part of the input sequences. We directly use
problem and domain files in PDDL as input. We consider two prompting strategies: zero-shot, and
few-shot, to evaluate the planning capabilities in LLMs. In the zero-shot prompting approach, we
provide the domain and problem files as input, without any additional examples. In contrast, the
few-shot prompting approach provides a few samples from the same domain and its corresponding
plan, in addition to the problem and domain files. Section 2.3 of the supplementary material show the
example templates used for both prompting techniques.
4.2 Large Language Models: Overview and Considerations
Table 3 gives an overview of the language models (LLMs) employed in this study, including critical
design parameters such as the number of layers, heads, embedding size (head dimension), context
length, and data source (natural language (NL) and/or code). Our investigation in this paper involves
a combination of LLMs that have been pre-trained on natural language and/or code. Specifically, we
utilize two OpenAI models, namely text-davinci-03 and code-davinci-02 for prompting. We set the
temperature parameters in these models to 0.2 as increasing the temperature value result in being
more hallucinative and prone to taking risks. It is worth noting that both OpenAI models are derived
from GPT-3, thereby inheriting its underlying architecture. However, the exact specifications of these
models are unknown, and we write it as "not available" (NA) in our table. Our fine-tuning process
involves models such as T5, CodeT5, and Codegen trained on the planning dataset (from above)
5using regularization and weight decay to prevent overfitting. We conduct our experiments using 24
CPU cores, along with a single A100 40GB GPU and 1TB of RAM. On average, it takes less than
2.5 hours to fine-tune a model.
4.3 Plan Generalization
In this paper, we are interested in the ability of LLMs to generate plans that are close to optimal
plans for unseen, out-of-distribution problems from different planning domains. We need a metric
to measure the distance between a pair of plans. It is typical to measure the distance between plans
based on differences in actions, states, or causal structures [Srivastava et al., 2007]. In this paper, we
use an action-based criterion for LLM-generated plan vs optimal plan, i.e., the Hamming distance
between the order of actions in two plans, motivated by the recent literature [Katz and Sohrabi, 2020].
This metric measures how much LLMs deviate from the sequences of actions in the optimal plan.
More formally, the plan generalization error Epgis defined as:
Epg=1
|m−n|mX
i=n+1H(yi,ˆyi)
|A|(1)
where ˆyiis the generated plan for xi∈Dtest,H(·,·)is the Hamming distance between two plans,
and|A|is the total number of actions in the planning domain. A lower Epgmeans that LLM can
produce plans more similar to the optimal plans generated by a traditional planning system. An
LLM with Epgbelow a certain threshold (in this work, Epg≤0.5) is considered to have strong plan
generalization capabilities. To evaluate the plan generalization capabilities of LLMs and provide
insights to address RQ4, we propose the following three tasks:
•Task 1 - Plan Length Generalization: We evaluate the ability of LLMs to generalize to
plan lengths that are out of the distribution of the training set. Given a set of planning
domains in the training set D=D1, D2, ..., D n, we select a plan length lifor each domain
Dithat is outside the range of plan lengths considered in the training set. We then pose the
planning problem for each domain with the selected plan length to the LLM. Let ˆπdenote
the plan generated by the LLM, and let π∗denote the optimal plan for the planning problem.
We evaluate the plan ˆπon planning-related metrics mentioned in RQ1 (in addition to Epg).
•Task 2 - Object Name Randomization: We test the LLMs ability to generate plans using
randomized object names not present in the training set. We first create a set of randomized
object names for each planning domain in the dataset using the IPC problem generator. We
then replace the object names in the planning problems in each domain for the test set with
the randomized names. We pose the modified planning problems to the LLMs and evaluate
the generated plan ˆπusing the set of planning metrics mentioned in Task 1.
•Task 3 - Unseen Domain Generalization: We evaluate the LLMs ability to generalize to
planning problems from new domains not included in the training set. We select a set of
planning domains D′=D′
1, D′
2, ..., D′
mthat is different from the planning domains in the
training set. We pose the planning problems in each domain to the LLM and evaluate the
generated plan ˆπusing the planning metrics mentioned in Task 1.
Overall, we believe these tasks provide a comprehensive evaluation of the ability of LLMs to
generalize to different types of planning problems.
5 Experimental Results
In this section, we present the quantitative and qualitative results obtained using LLMs to generate
plans for classical planning domains of varying difficulty and generalize to unseen domains. All the
reported results in this paper are averaged over five independent runs. We evaluate the performance of
the considered LLMs on a test set with 3600 planning problems per domain classified into easy ( E),
medium ( M), and hard ( H) categories. The problems exhibit the same distribution of plan length as
the training set but consist of a distinct set of problem instances not encountered during the training
phase. We assess the generated plans using various planning-related metrics, including satisficing
plans ( Sat. Plans ), optimal plans ( Opt. Plans ), degree of correctness ( Deg. Corr. ), and inference time
(Inf. Time ). We can determine the number of invalid plans by subtracting the percentage of satisficing
plans from 100 percent.
6Table 4: Evaluation of plan generation capabilities of LLMs (both prompting pre-trained model
and fine-tuned model). For each model, we report the inference time (Inf. Time), the percentage
of satisficing plans (Sat. Plans), the percentage of optimal plans (Opt. Plans), and the degree of
correctness (Deg. Corr.).
.Models Type Inf. TimeSat. Plans (%) Opt. Plans (%) Deg. Corr.
E M H E M H E M H
T5Pre-trained 4.03s 0 0 0 0 0 0 0 0 0
Fine-tuned 1.59s 0.11 0 1.16 0.11 0 0.36 0.02 0 0.03
CodeT5Pre-trained 4.22s 2.70 0.6 0 1.73 0.6 0 0.07 0 0
Fine-tuned 1.50s 97.57 92.46 89.54 86.21 90.36 66.71 0.99 0.95 0.95
CodegenPre-trained 4.52s 1.70 0.16 0 0.17 0 0 0.01 0.01 0
Fine-tuned 1.93s 37.95 23.74 9.83 35.33 11.67 1.92 0.67 0.32 0.07
text-davinciZero-shot 3.89s 8.78 6.43 0 3.92 0 0 0.27 0.21 0
Few-shot 3.88s 10.82 6.90 3.31 7.23 2.84 1.21 0.32 0.17 0.04
code-davinciZero-shot 3.58s 17.42 11.77 4.38 8.23 6.11 1.84 0.38 0.27 0.21
Few-shot 3.51s 23.52 17.48 11.89 17.57 8.85 4.69 0.57 0.32 0.28
5.1 Results on Plan Generation
Table 4 indicates that code-davinci (zero-shot) performs better among the vanilla models. However,
we observe limited planning capabilities overall in pre-trained models , confirming the findings of
[Valmeekam et al., 2022].
Table 4 also shows that the fine-tuned CodeT5 model performs best across all considered domains,
with the least inference time. Overall, it has been observed that fine-tuned language models (LLMs)
are capable of generating outputs for planning problems at a rate four times faster than pre-trained
LLMs . This phenomenon can be attributed to the ability of fine-tuned LLMs to discern when to cease
output generation, a less developed capability in pre-trained LLMs, as illustrated in Figure 2. The
findings from Table 4 provide insightful observations that can aid in selecting the most appropriate
LLMs for near-optimal plan generation. Our evaluation metrics suggest that LLMs pre-trained on
programming code outperform those solely trained on the textual corpus . This addresses our
research question RQ2. However, although Codegen is a decoder-only model similar to GPT-2, our
evaluation indicates that it struggles to generate near-optimal plans after fine-tuning. This is due to
Codegen’s lack of a dedicated encoder, which may hinder its ability to understand and represent
the input prompt. In contrast, CodeT5 leverages both an encoder and a decoder, which allows for
better code understanding and generation tasks. Furthermore, CodeT5 incorporates code-specific
knowledge by proposing a novel masked identifier prediction task. This task masks all identifiers
present in the input prompt. It employs a sentinel token for all occurrences of a specific identifier,
allowing the model to better distinguish and recover identifiers in code, which are crucial for code
semantics and execution. In this paper, we consider the identifiers for planning domains such as
action names, predicates, and object names.
Pre-trained CodeT5 ( Inference Time: 4.12s)
b4 b3, put-down b4, unstack b2 b1, unstack x, not clear x, not handempty,
ontable, clear, holding x, not x, handempty, ontable x, stack x, not x, not
clear x,y, unstack b2 b3, put-down b ✗
Fine-tuned CodeT5 ( Inference Time: 1.01s)
unstack b4 b3, put-down b4 ✓
Figure 2: Incoherent generations from pre-trained models leading to longer inference time.
Prompting LLMs such as the OpenAI models have shown to perform better when they have coding-
related knowledge. However, they still perform worse than fine-tuning LLMs pre-trained on code.
Our observations indicate that fine-tuning is a superior approach to solving planning problems
with LLMs . This is attributed to fine-tuning allowing for more customization and adaptation of the
model to a specific task, while prompting relies on the general knowledge and competence of the
pre-trained models. However, in recent times, prompt engineering has become a widely researched
topic, and new techniques are being developed rapidly. Exploring other prompting approaches, such
7Table 5: Evaluating the capabilities of LLMs in handling randomized object names.
Object Names Model STSat. Plans (%) / Opt. Plan (%) Deg. Corr. Epg
E M H E M H E M H
Version 1CodeT5(FT)✗ 47.12% / 33.78% 42.74% / 38.68% 39.58% / 21.22% 0.57 0.51 0.51 0.82 0.84 0.84
✓ 97.52% / 86.21% 92.46% / 90.36% 89.12% / 66.71% 0.98 0.95 0.95 0.15 0.18 0.18
code-davinci(FS)✗ 23.52% / 17.57% 17.48% / 8.85% 11.89% / 4.69% 0.57 0.32 0.28 0.77 0.83 0.96
✓ 23.52%/ 17.57% 17.48% / 8.85% 11.89% / 4.69% 0.57 0.32 0.28 0.77 0.83 0.96
Version 2CodeT5(FT)✗ 66.01% / 64.72% 61.98% / 52.80% 55.17% / 37.5% 0.79 0.72 0.58 0.47 0.49 0.67
✓ 97.52%/86.21% 92.46%/90.36% 89.12%/66.71% 0.98 0.95 0.95 0.15 0.18 0.18
code-davinci(FS)✗ 23.52%/17.57% 17.48%/8.85% 11.89%/4.69% 0.57 0.32 0.28 0.77 0.83 0.96
✓ 23.52%/17.57% 17.48%/8.85% 11.89%/4.69% 0.57 0.32 0.28 0.77 0.83 0.96
Version 3CodeT5(FT)✗ 11.82% / 2.10% 4.92% / 1.47% 0.17% / 0% 0.24 0.04 0.01 0.87 0.95 1
✓ 97.52%/86.21% 92.46%/90.36% 89.12%/66.71% 0.98 0.95 0.95 0.15 0.18 0.18
code-davinci(FS)✗ 23.52%/17.57% 17.48%/8.85% 11.89%/4.69% 0.57 0.32 0.28 0.77 0.83 0.96
✓ 23.52%/17.57% 17.48%/8.85% 11.89%/4.69% 0.57 0.32 0.28 0.77 0.83 0.96
as prompt-tuning [Anil et al., 2022], would be interesting. Prompt-tuning learns continuous prompts
optimized end-to-end over a training dataset and is as effective as fine-tuning natural language
understanding tasks. Although our evaluation addresses RQ3,we believe there needs to be more
extensive research to be done in order to effectively answer this research question. The present
study commenced by conducting an initial analysis to explore the potential of LLMs for automated
planning. In order to address RQ4, we report the results for the the tasks described in Section 4.3.
5.2 Results on Plan Generalization
Task 1 - Plan Length Generalization. In the context of generalization experiments, we consider
the most proficient models obtained through fine-tuning and prompting methodologies. Specifically,
we employ the fine-tuned (FT) CodeT5 and few-shot (FS) prompting of code-davinci approaches.
We subject these models to an empirical evaluation by testing them on ten problems per difficulty
class. Notably, the ten problems selected are characterized by a plan length outside the distribution of
the training set. Figure 3 depicts the outcomes of the plan length generalization assessment across
the three different difficulty classes. Our findings demonstrate that the fine-tuned CodeT5 model
can generalize to plan lengths to some extent, while the few-shot prompting of code-davinci
generates only a single valid plan for a hard domain having a short plan. While neither model
produces optimal plans, we observe that the average correctness score of the plans generated by
the fine-tuned CodeT5 model is 0.46, while that of code-davinci is 0.04. With regard to Epg, the
fine-tuned CodeT5 model has an average score of 0.69, whereas code-davinci has an average score
of 1. Notably, neither model meets the Epgthreshold for generalization. In future work, we aim to
investigate recent approaches, such as scratchpad fine-tuning and prompting methodologies [Anil
et al., 2022], that have been shown to enhance the length generalization capabilities of LLMs.
Task 2 - Object Name Randomization. For object name randomization, we created three versions
of randomized variables to evaluate the plan generalization capabilities of LLMs. In version 1, we
used only single-digit numeric values as object names. In version 2, we used alphanumeric strings of
length 2 (similar to the convention followed by IPC generators), where the combinations of alphabets
and numerals used were unseen during training. Version 3 consisted of object names named after
three alphabets. For the few-shot prompting of code-davinci, we used an example from the training
set and posed a problem with randomized object names for which the plan needed to be generated.
We also implemented a symbol table that maps the randomized object names to the same vocabulary
as the training set to comprehensively evaluate the dependence of LLMs on the training data or the
prompting example for plan generation. Table 5 captures the performance of the models considered
for generalization, and it is observed that code-davinci’s performance is unaffected by object name
randomization and retains the same performance as seen in Table 4. However, code-davinci has a high
Epg, showing poor plan generalization capabilities. Fine-tuned CodeT5 has the best performance for
version 2 and better plan generalization capabilities than any other model (without a symbol table).
We observed a decrease in performance when the length of object names was increased, as in version
3, because the model confuses action names and object names. We further noticed an improvement
in plan generalization capabilities when a symbol table ( ST) was used to map the problem name with
randomized object names to the same vocabulary as the training set.
8Figure 3: Fine-tuned CodeT5 and code-davinci with few-shot prompting show poor plan length
generalization capabilities: Epgfor both models is higher than the threshold (0.5), but plans from
fine-tuned CodeT5 overall have a higher degree of correctness. The x-axis represents the plan length
and the y-axis represents the degree of correctness. The training plan lengths are highlighted in grey.
Ground Truth Plan - π∗(Domain: logistics )
load-airplane p2 a0 l1-0, fly-airplane a0 l1-0 l0-0, unload-airplane p2 a0 l0-0,
load-airplane p0 a0 l0-0, fly-airplane a0 l0-0 l1-0, unload-airplane p0 a0 l1-0
Fine-tuned CodeT5 ( Inference Time: 1.12s)
load-airplane driver0 l0, load-truck package3 truck0 s0, fly-airplane truck0
s0 s1 driver0, load-truck package2 truck0 s1, unload-airplane p0 a0 l1-0,
drive-truck truck0 s1 s0 driver0, unload-truck package2 truck0 s0 ✗
Few-shot prompting code-davinci ( Inference Time: 3.51s)
load-truck p0 t0 l0-0, load-truck p1 t1 l1-0, drive-truck t0 l0-0 l1-0 c1,
unload-truck p0 t0 l1-0, drive-truck t1 l1-0 l0-0 c0, unload-truck p1 t1 l0-0,
load-airplane p2 a0 l1-0 ✗
Figure 4: Example of an incorrect generations from LLMs for a problem from an unseen domain.
Task 3 - Unseen Domain Generalization We conducted a study to assess the efficacy of fine-tuned
CodeT5 and code-davinci with few-shot prompting in generating plans for domains not included in
the training set. Specifically, we selected three new classical planning domains, namely childsnack ,
depots , and satellite , and created ten problems per domain. We randomly chose an example
prompt and its corresponding plan from the six training domains for each problem. We report the
results averaged over five random seeds. Our findings reveal that both models failed to generate valid
plans in this task, resulting in an Epgof 1. We observed that fine-tuned CodeT5 often confused the
action and object names present in the test with those seen during training, showing no capabilities
in generalizing to unseen domains. On the other hand, code-davinci generated relevant actions but
incorrect plans for all test cases. To further illustrate our observations, we present in Figure 4 a
comparison between the ground truth plan generated by a planner for the logistics domain and
the output produced by the considered LLMs. This comparison highlights the incorrect combination
of action and object names. Our experimental results show that fine-tuning LLMs pre-trained on
code can significantly improve the generation of near-optimal plans for problems within the training
domains. We have also observed that these fine-tuned models exhibit some generalization capabilities,
such as handling plans of varying lengths and object names randomized during testing. However, we
have found that these models struggle to generate plans for unseen domains. While prompting LLMs
like code-davinci show some promising developments in planning capabilities, they currently fall
short in generating plans. We hope these experiments will be an essential reference for upcoming
researchers to refine their selection of LLMs for planning and explore avenues for improving their
plan generation capabilities. Such endeavors will ultimately enhance the potential for complex
problem-solving and reasoning capabilities.
6 Conclusion and Future Work
Our study in this paper explores the potential of LLMs in solving automated planning problems. To do
this, we defined four research questions and addressed them through a comprehensive experimental
analysis of several LLMs and a diverse set of planning domains. The study finds that: (1)Off-the-shelf,
pre-trained LLMs are not capable of effectively solving planning problems. (2)LLMs pre-trained
9on both natural language and programming code are more capable of plan generation than natural
language-only models. (3)Fine-tuning contributes to improved plan generation. (4)LLMs have
limited plan generalization abilities. Moreover, our research highlights that fine-tuning aids in partial
generalization to plan lengths not encountered during the training phase while maintaining a higher
level of correctness than prompting. Notably, when object names are randomized, fine-tuned models
exhibit satisfactory performance only when the randomized vocabulary aligns with the training set.
Both prompting and fine-tuning approaches prove ineffective when solving problems from unfamiliar
domains. In future work, we plan to investigate recent techniques, such as scratchpad fine-tuning and
prompting methodologies, that have been shown to enhance the length generalization capabilities of
LLMs. These methods could improve the planning capabilities of LLMs and open up new avenues
for their use in solving complex planning problems.
References
Constructions Aeronautiques, Adele Howe, Craig Knoblock, ISI Drew McDermott, Ashwin Ram,
Manuela Veloso, Daniel Weld, David Wilkins SRI, Anthony Barrett, Dave Christianson, et al.
PDDL – the planning domain definition language. Technical Report, Tech. Rep. , 1998.
Shrivats Agrawal. Are llms the master of all trades?: Exploring domain-agnostic reasoning skills of
llms. arXiv preprint arXiv:2303.12810 , 2023.
Michael Ahn, Anthony Brohan, Noah Brown, Yevgen Chebotar, Omar Cortes, Byron David, Chelsea
Finn, Keerthana Gopalakrishnan, Karol Hausman, Alex Herzog, et al. Do as i can, not as i say:
Grounding language in robotic affordances. arXiv preprint arXiv:2204.01691 , 2022.
Cem Anil, Yuhuai Wu, Anders Johan Andreassen, Aitor Lewkowycz, Vedant Misra, Vinay Venkatesh
Ramasesh, Ambrose Slone, Guy Gur-Ari, Ethan Dyer, and Behnam Neyshabur. Exploring length
generalization in large language models. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave,
and Kyunghyun Cho, editors, Advances in Neural Information Processing Systems , 2022. URL
https://openreview.net/forum?id=zSkYVeX7bC4 .
Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal,
Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are
few-shot learners. Advances in neural information processing systems , 33:1877–1901, 2020.
Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared
Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, et al. Evaluating large
language models trained on code. arXiv preprint arXiv:2107.03374 , 2021.
Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing
Qin, Ting Liu, Daxin Jiang, et al. Codebert: A pre-trained model for programming and natural
languages. In Findings of the Association for Computational Linguistics: EMNLP 2020 , pages
1536–1547, 2020.
Noelia Ferruz and Birte Höcker. Controllable protein design with language models. Nature Machine
Intelligence , pages 1–12, 2022.
Malik Ghallab, Dana Nau, and Paolo Traverso. Automated Planning: Theory and Practice . The Mor-
gan Kaufmann Series in Artificial Intelligence. Morgan Kaufmann, Amsterdam, 2004. ISBN 978-
1-55860-856-6. URL http://www.sciencedirect.com/science/book/9781558608566 .
Malte Helmert. The fast downward planning system. Journal of Artificial Intelligence Research , 26:
191–246, 2006.
Malte Helmert and Carmel Domshlak. Lm-cut: Optimal planning with the landmark-cut heuristic.
Seventh international planning competition (IPC 2011), deterministic part , pages 103–105, 2011.
R. Howey and D. Long. Val’s progress: The automatic validation tool for pddl2.1 used in the
international planning competition. In ICAPS 2003 workshop on "The Competition: Impact,
Organization, Evaluation, Benchmarks", Trento, Italy , 2003.
Jie Huang and Kevin Chen-Chuan Chang. Towards reasoning in large language models: A survey,
2022.
10Wenlong Huang, Pieter Abbeel, Deepak Pathak, and Igor Mordatch. Language models as zero-shot
planners: Extracting actionable knowledge for embodied agents. In International Conference on
Machine Learning , pages 9118–9147. PMLR, 2022a.
Wenlong Huang, Fei Xia, Ted Xiao, Harris Chan, Jacky Liang, Pete Florence, Andy Zeng, Jonathan
Tompson, Igor Mordatch, Yevgen Chebotar, et al. Inner monologue: Embodied reasoning through
planning with language models. arXiv preprint arXiv:2207.05608 , 2022b.
ICAPS. International planning competitions at international conference on automated planning and
scheduling (icaps). In https://www.icaps-conference.org/competitions/ , 2022.
Michael Katz and Shirin Sohrabi. Reshaping diverse planning. Proceedings of the AAAI Conference
on Artificial Intelligence , 34(06):9892–9899, Apr. 2020. doi: 10.1609/aaai.v34i06.6543. URL
https://ojs.aaai.org/index.php/AAAI/article/view/6543 .
Hang Li. Language models: Past, present, and future. Commun. ACM , 65(7):56–63, jun 2022. ISSN
0001-0782. doi: 10.1145/3490443. URL https://doi.org/10.1145/3490443 .
Bo Liu, Yuqian Jiang, Xiaohan Zhang, Qiang Liu, Shiqi Zhang, Joydeep Biswas, and Peter Stone.
Llm+ p: Empowering large language models with optimal planning proficiency. arXiv preprint
arXiv:2304.11477 , 2023.
OpenAI. Gpt-4 technical report, 2023.
Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll Wainwright, Pamela Mishkin, Chong
Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow
instructions with human feedback. Advances in Neural Information Processing Systems , 35:
27730–27744, 2022.
Russell A Poldrack, Thomas Lu, and Gašper Beguš. Ai-assisted coding: Experiments with gpt-4,
2023.
Teven Le Scao, Angela Fan, Christopher Akiki, Ellie Pavlick, Suzana Ili ´c, Daniel Hesslow, Roman
Castagné, Alexandra Sasha Luccioni, François Yvon, Matthias Gallé, et al. Bloom: A 176b-
parameter open-access multilingual language model. arXiv preprint arXiv:2211.05100 , 2022.
Jendrik Seipp, Álvaro Torralba, and Jörg Hoffmann. PDDL generators. https://doi.org/10.
5281/zenodo.6382173 , 2022.
Tom Silver, Varun Hariprasad, Reece S Shuttleworth, Nishanth Kumar, Tomás Lozano-Pérez, and
Leslie Pack Kaelbling. PDDL planning with pretrained large language models. In NeurIPS 2022
Foundation Models for Decision Making Workshop , 2022. URL https://openreview.net/
forum?id=1QMMUB4zfl .
Ishika Singh, Valts Blukis, Arsalan Mousavian, Ankit Goyal, Danfei Xu, Jonathan Tremblay, Dieter
Fox, Jesse Thomason, and Animesh Garg. Progprompt: Generating situated robot task plans using
large language models, 2022.
Biplav Srivastava, Tuan Anh Nguyen, Alfonso Gerevini, Subbarao Kambhampati, Minh Binh Do,
and Ivan Serina. Domain independent approaches for finding diverse plans. In Manuela M.
Veloso, editor, IJCAI 2007, Proceedings of the 20th International Joint Conference on Artificial
Intelligence, Hyderabad, India, January 6-12, 2007 , pages 2016–2022, 2007. URL http://
ijcai.org/Proceedings/07/Papers/325.pdf .
Haoye Tian, Weiqi Lu, Tsz On Li, Xunzhu Tang, Shing-Chi Cheung, Jacques Klein, and Tegawendé F
Bissyandé. Is chatgpt the ultimate programming assistant–how far is it? arXiv preprint
arXiv:2304.11938 , 2023.
Serbulent Unsal, Heval Atas, Muammer Albayrak, Kemal Turhan, Aybar C Acar, and Tunca Do ˘gan.
Learning functional properties of proteins with language models. Nature Machine Intelligence , 4
(3):227–245, 2022.
Priyan Vaithilingam, Tianyi Zhang, and Elena L Glassman. Expectation vs. experience: Evaluating
the usability of code generation tools powered by large language models. In Chi conference on
human factors in computing systems extended abstracts , pages 1–7, 2022.
11Karthik Valmeekam, Alberto Olmo, Sarath Sreedharan, and Subbarao Kambhampati. Large language
models still can’t plan (a benchmark for llms on planning and reasoning about change). arXiv
preprint arXiv:2206.10498 , 2022.
Karthik Valmeekam, Sarath Sreedharan, Matthew Marquez, Alberto Olmo, and Subbarao Kambham-
pati. On the planning abilities of large language models (a critical investigation with a proposed
benchmark). arXiv preprint arXiv:2302.06706 , 2023.
Yue Wang, Weishi Wang, Shafiq Joty, and Steven CH Hoi. Codet5: Identifier-aware unified pre-
trained encoder-decoder models for code understanding and generation. In Proceedings of the
2021 Conference on Empirical Methods in Natural Language Processing , pages 8696–8708, 2021.
Zihao Wang, Shaofei Cai, Anji Liu, Xiaojian Ma, and Yitao Liang. Describe, explain, plan and select:
Interactive planning with large language models enables open-world multi-task agents. arXiv
preprint arXiv:2302.01560 , 2023.
Yaqi Xie, Chen Yu, Tongyao Zhu, Jinbin Bai, Ze Gong, and Harold Soh. Translating natural language
to planning goals with large-language models. arXiv preprint arXiv:2302.05128 , 2023.
Wayne Xin Zhao, Kun Zhou, Junyi Li, Tianyi Tang, Xiaolei Wang, Yupeng Hou, Yingqian Min,
Beichen Zhang, Junjie Zhang, Zican Dong, Yifan Du, Chen Yang, Yushuo Chen, Zhipeng Chen,
Jinhao Jiang, Ruiyang Ren, Yifan Li, Xinyu Tang, Zikang Liu, Peiyu Liu, Jian-Yun Nie, and
Ji-Rong Wen. A survey of large language models, 2023.
12
Inﬂuence before Hiring: A Two-tired Incentive Compatible
Mechanism for IoT-based Crowdsourcing in Strategic Setting
Chattu Bhargavi *
 Vikash Kumar Singh†
Abstract
In crowdsourcing, a group of common people is asked to execute the tasks and in return will
receive some incentives (maybe monetary beneﬁts or getting social recognition). In this article, one
of the crowdsourcing scenarios with multiple heterogeneous tasks and multiple IoT devices (as task
executors) is studied as a two-tiered process.
In the ﬁrst tier of the proposed model, it is assumed that a substantial number of IoT devices are
not aware of the hiring process and are made aware by utilizing their social connections. Each of the
IoT devices is endowed with a cost ( private value ) that it will charge in return for its services. The
participating IoT devices are rational and strategic in nature. The objective of the ﬁrst tier is to select
the subset of IoT devices as initial notiﬁers (helps in spreading awareness among the IoT devices about
the task execution process) such that the total number of IoT devices notiﬁed is maximized with the
stopping condition that the total payment offered to the notiﬁers is less than or equals to the available
budget. For this purpose, an incentive compatible mechanism is proposed that also ensures the total
payment made to the initial notiﬁers is less than or equal to the budget. Once the substantial num-
ber of IoT devices got intimated about the hiring process, in the second tier, a subset of quality IoT
devices is determined by utilizing the idea of single-peaked preferences . Once the quality of IoT devices
is determined, the next objective of the second tier is to hire quality IoT devices for the ﬂoated tasks.
For this purpose, each of the quality IoT devices reports private valuation along with their favorite
bundle of tasks that they are interested in executing. In the second tier, it is assumed that the valua-
tion of the IoT devices satisﬁes gross substitute criteria and is private . For the second tier, the truthful
mechanisms are designed independently for determining the quality of IoT devices and for hiring
quality IoT devices and deciding their payment respectively.
Theoretical analysis is carried out for the two tiers independently. It is shown that the proposed
mechanisms are computationally efﬁcient ,truthful ,correct , and budget feasible (only in the case of the
mechanism proposed in the ﬁrst tier). Further, the probabilistic analysis is carried out to have an
estimate of the expected number of IoT devices got notiﬁed about the task execution process. The
simulation is done to measure the efﬁcacy of the proposed mechanisms with the benchmark mecha-
nisms based on truthfulness ,budget feasibility , and running time .
Index terms— Crowdsourcing, Internet of Things, Quality, Strategic, Budget feasible mechanism, Incen-
tive compatible
1 Introduction
Crowdsourcing is a process of completing the ﬂoated tasks by a group of common people through an
open call [LFW+22, VNTS+22, AD22, ASN22]. It mainly consists of players such as: (1) task requester(s) ,
(2)platform (orthird party ), and (3) crowd workers . The workﬂow of the crowdsourcing system is, ﬁrstly,
the task requester(s) will submit their tasks to some third party . On receiving the tasks from the task
requesters , the third party provides the tasks to the crowd workers that are present on the other side of
*School of Computer Science and Engineering, VIT-AP University, Amaravati, India. bhargavi.chattu506@gmail.com
†School of Computer Science and Engineering, VIT-AP University, Amaravati, India. vikash.singh@vitap.ac.in
1arXiv:2303.05062v2  [cs.GT]  3 Apr 2023the crowdsourcing market. The crowd workers execute the tasks and submit back the completed tasks
to the platform. The third party returns the executed tasks to the respective task requester(s) and the
crowd workers get some incentives (maybe monetary beneﬁts or some social recognition) in exchange
for their services (in this case executing the ﬂoated tasks). The above-discussed scenario is said to be
“crowdsourcing ” [EOS+23, CGV21, ASN22, SMXK20, SMXS20]. However, when crowdsourcing is done
using smart devices, it gives rise to a ﬁeld called “ mobile crowdsourcing ” (or mobile crowdsensing orpartic-
ipatory sensing (PS)) [MSPK22, SJSM22, JVLL12, KEJ22, Fuj20].
One of the challenging aspects of crowdsourcing and PS is to have a large number of common peo-
ple as the task executors in the system. Now, the question is: how to drag a large group of common people
into such systems ? One of the solutions could be to provide them with some incentives (maybe money or
some social recognition). In the past, the works have been carried out for designing the mechanisms (a.k.a
algorithms ) that will offer incentives to the crowd workers in return for their services, in strategic setting
[SJSM22, MSPK22, SMXK20, SMXS20, GNS14, XLG+22]. In [SJSM22] for the set-up with multiples task
requesters and task executors a truthful mechanism is discussed. Each task requester is endowed with
multiple homogeneous tasks and a bid. Both these quantities are private and are reported to the plat-
form. On the other hand, the IoT devices in the mobile crowdsourcing market report the ask and the
number of tasks they can execute, on the platform. The proposed truthful mechanism selects the sub-
set of quality IoT devices (as task executors) for the set of tasks. In [SMXK20] a quality-based truthful
mechanism is proposed for assigning a subset of tasks to the IoT devices in a mutually exclusive manner
such that the sum of the valuations of the IoT devices gets maximized. In [SMXS20] an effort has been
made to design a quality-adaptive budget feasible truthful mechanism for the set-up consisting of mul-
tiple task requesters and multiple task executors. Each task requester has a single task along with the
budget. On the other side, there are multiple IoT devices (as crowd workers) that report the bid values
(cost they will charge in exchange for their services). Further, the more realistic ﬂavor of the discussed
set-up is studied where the tasks are divisible in nature. For the extended version of the problem, a
non-truthful budget feasible mechanism is discussed. In [MSPK22], a mobile crowdsourcing scenario
with a single task requester and multiple IoT devices (as task executors) is investigated in strategic set-
ting. The task requester has the set of tasks and the budget associated with the tasks. The task executors
report a bid for executing the tasks and are private. In the proposed model, the overall budget is not
available apriori and is made available in an incremental manner in multiple rounds. For this set-up, a
truthful mechanism is proposed that also considers that the total payment made to the task executors is
within the budget. In [GNS14] an incentive-compatible mechanism is designed for one of the scenarios
in crowdsourcing with a single task requester and multiple task executors. The task requester is having
multiple tasks and a ﬁxed budget. The goal is to select a set of task executors for executing the set of
tasks such that the total payment offered to the selected task executors is less than or equal to the ﬁxed
budget. It is to be noted that, in the above-discussed scenarios, the task executors were already aware
of the task execution process, but it may not be the case always. It means that only fewer task executors
may be aware of the task execution process (or event). Now the question is, how to inform others about
the ongoing event? To address the above-discussed realistic scenario, some works have been carried out
in the past [XLG+22, XZC+21, WHW+21]. A two-tiered social crowdsourcing architecture is proposed
in [XLG+22] that allows the task executors to forward the ﬂoated tasks that are to be executed to their
neighbors in the social connections. In this setup, the tasks are having different end times. For this sce-
nario, the three different system models are discussed based on the arrival modes of the registered users
and social neighbors. For the three different models, a truthful mechanism is proposed. In [XZC+21] to
increase the crowd workers the ﬂoated tasks are diffused in the social network (representing the social
connections of the crowd workers). The objective is to diffuse the tasks to as many crowd workers as
possible with the constraint that the total payment made to the task diffusers is within the available
budget. For the discussed set-up a truthful budget feasible mechanism is developed that takes into ac-
count the enhanced classic independent cascade model . In [WHW+21] an effort has been made to design a
dynamic incentive mechanism that transfers information about the task execution process through the
22 m-1 mHeterogeneous T asksSocial connection
1. Reported cost
vector
1. Tasks
submitted
11. BudgetFirst T ier
of IoT  devices
. . .
k-1 kTask Execution
Notifiers Mechanism
(TENM)Platform
$1. Social connection 
submitted
Effective T ask
Executors Identification
Mechanism (ECT AI)Platform
Winner and Price
Determination (W iPD)2. Output of the first tier
3. Part of tasks given
for execution4. Part of tasks completed
and submitted
Quality IoT  devicesSecond T ier
5. Determined quality
IoT devicesNotified set of IoT  devices
6. Reports set
of tasks
and bid7. Tasks
assigned
8. Completed tasks
submitted9. Payment
madeFigure 1: A two-tiered framework for IoT-based crowdsourcing
social connections of the task executors.
Motivated by the above discussed crowdsourcing scenarios, in this paper, one of the scenarios of
IoT-based crowdsourcing is studied as a two-tiered process in strategic setting1as shown in Figure 1. In
the proposed model, we have multiple heterogeneous tasks and multiple task executors (as IoT devices ).
Firstly, the tasks are submitted to the platform for execution purposes. One of the assumptions is that
an insufﬁcient number of task executors are aware of the task execution process. So, on receiving the
tasks, one of the challenges of the platform is: how to inform the sufﬁcient number of task executors about the
task execution process? One of the solutions could be to utilize the social connections of the task executors
for notifying (or informing) the sufﬁcient number of task executors for the task execution process. Once
notiﬁed, the next objective is to hire quality task executors for each of the tasks. For the above-discussed
scenario, the discussed model is studied as a two-tier process. In the ﬁrst tier, the social connections
of the task executors are considered to inform the substantial number of task executors about the task
execution process. The input to the ﬁrst tier is the social connection of the task executors, the cost vec-
tor2, the set of tasks to be executed, and the available budget3. The cost for notifying the task execution
process to the task executors is private and the task executors can act strategically to gain. The objective
of the ﬁrst tier is to select the subset of task executors from the given social graph such that the number
of task executors that got notiﬁed is maximized with the constraint that the total payment made to the
notiﬁers is within the ﬁxed budget. Once the substantial number of task executors got notiﬁed about
the task execution process, in the second tier, the challenges are (1) to determine the quality task executors
among the notiﬁed task executors , and (2) to hire the quality task executors and decide their payment in exchange
for their services . In the second tier, the challenges mentioned in points 1 and 2 are taken care of. Firstly, to
have an idea about the quality of the task executors, an inﬁnitesimally small part of the tasks are given
to the task executors for execution purposes. Once the tasks get executed, the executed tasks are given
to the peers for estimating the quality of the completed tasks by the task executors ( i:e:the quality of the
task executors). Once the quality of the task executors is determined, the next objective is to handle the
challenge mentioned in point 2 above. For that purpose, each of the quality task executors will be asked
1By strategic, it is meant that the agents will try to manipulate the system by misreporting their private information.
2The maximum price the IoT devices will charge in exchange for their services.
3The money to be invested as the payment for the notiﬁers in return for their ‘ word of mouth ’ in their social network.
3for a set of tasks and the valuation that they will charge for executing the requested set of tasks. Given
the discussed setup, the output of the second tier is to allocate the tasks to the quality task executors and
decide their payment.
In this paper for the above-discussed set-up a Two-tiered Incentive COmpatible Mechanism (TICOM) is
proposed that consists of three components: (1) TaskExecution Notiﬁers Mechanism (TENM), (2) EffeCtive
TAsk executors Identiﬁcation mechanism (ECTAI), and (3) Winner and PriceDetermination (WiPD). In Sec-
tion 3 the above-discussed scenario is formulated using mechanism design.
1.1 Our Contributions
The contribution of this paper is:
1. The task execution process in crowdsourcing is studied as a two-tiered process. Firstly, a sufﬁcient
number of IoT devices are made aware of the hiring process (or task execution process) by utilizing
the social connections of the IoT devices (using Algorithm 1). Further, the IoT devices that helped
in spreading awareness about the task execution process in their social connections are paid such
that the total payment made to them is within the ﬁxed budget (using Algorithm 2).
2. Once a sufﬁcient number of IoT devices got notiﬁed about the task execution process, in the second
tier, (1) the quality of the IoT devices is determined (using Algorithm 3), and (2) for the ﬂoated
tasks the quality IoT devices are selected and their payments are decided (using Algorithm 4).
3. For the discussed set-up, TICOM is proposed that consists of the following components: (1) Task
Execution Notiﬁers Mechanism (TENM) (Algorithm 1 and Algorithm 2), (2) EffeCtive TAsk ex-
ecutors Identiﬁcation mechanism (ECTAI) (Algorithm 3), and (3) Winner and PriceDetermination
(WiPD) (Algorithm 4).
4. The theoretical analysis of the two tiers is carried out independently. Firstly, in the ﬁrst tier,
through theoretical analysis it is shown that TENM is computationally efﬁcient (Lemma 1) correct
(Lemma 2), truthful (Corollary 1), and budget feasible (Corollary 2). Further, in the ﬁrst tier, the
probabilistic analysis is carried out to have an estimate of the number of IoT devices that got no-
tiﬁed in expectation in a social graph. In the second tier, through theoretical analysis, it is shown
that ECTAI and WiPD are computationally efﬁcient (Lemma 4), correct (Lemmas 5 and 6), and truthful
(Lemmas 7 and 8).
5. The simulation for the two tiers is done independently. In the ﬁrst tier, TENM is compared with
two baseline mechanisms, namely, non-truthful budget feasible mechanism (NTBFM) and proportional
sharemechnaism (PSM) [Sin10]. The comparison is done based on (1) the utility of notiﬁers, (2)
budget feasibility, (3) the number of IoT devices selected as initial notiﬁers in the social network,
and (4) running time. In the second tier of the proposed framework, the experiments are carried
out to compare ECTAI and WiPD with the already existing mechanism average voting rule(AVR)
and greedy mechanism (outline of this mechanism is given in Subsection 6.2) respectively on the
ground of truthfulness ,individual rationality , and running time .
1.2 Paper Organization
The remainder of the paper is structured as follows. The works carried out in the ﬁelds of crowdsourcing
and mobile crowdsourcing is discussed in Section 2. Section 3 describes the notations and preliminaries
that are utilized throughout the paper. The proposed mechanisms are illustrated in section 4. In section
5 the game theoretic and probabilistic analysis of the proposed mechanisms for the two tiers is carried
out independently. The simulation and result analysis are carried out in Section 6. Finally, the paper is
concluded with the possible future directions in section 7.
42 Related Prior Works
In this section, the works carried out in crowdsourcing and PS in strategic setting are discussed. The
readers can go through [HKG22, KEJ22, CGV21, DKP+20, AEK+18, PL18] to get an idea of the recent
works carried out in crowdsourcing and PS.
In [DKP+20] a comprehensive review of different game theoretic solutions is done, that address the
following issues in PS such as sensing cost ,quality of data , and incentives . In the past several incentive
mechanisms are developed for different crowdsourcing and PS scenarios in strategic setting [QZH+22,
DTY+17, GNS14, YCS22, ML22, SJSM22]. In [QZH+22] an incentive-compatible proﬁt-oriented mech-
anism is designed for the setup with a single crowdsourcer and multiple workers. The workers will
submit the bids (the amount they will charge in return for their services). Along with truthfulness,
the proposed mechanism is individually rational and computationally efﬁcient . In [DTY+17] the incentive
mechanisms were designed for IoT-based mobile crowdsourcing systems (MCSs) for surveillance appli-
cations. In [GNS14] paper the setup consists of a set of heterogeneous tasks such that it requires certain
skills from the crowd workers to get completed. For this purpose, the crowd workers show interest
in the set of tasks that they can perform based on their skills. The goal is to design a mechanism that
along with truthfulness satisﬁes budget feasibility . In [YCS22] article the problem of allocating heteroge-
neous tasks with multiple skill requirements in crowdsourcing is tackled. The objective is to determine
the mutually exclusive, quality set of workers who can successfully complete the tasks within a given
deadline and budget . In [ML22] the goal is to crowdsource the small tasks such as image labeling and
voice recording that gives rise to several challenges: (1) crowd workers may have different capacities for
doing the works and may misreport it with their bid, (2) if the auction is running multiple times, then
there is a chance that some sufﬁcient number of workers may leave the market that reduces the com-
petition in the system. To tackle the above challenges a truthful mechanism is developed. In [XCX+17]
the vehicles choose their capability for sensing the tasks based on sensing and transmission cost and the
expected payment that will be received from the server. The Nash equilibrium (NE) of the static vehic-
ular crowdsensing game had been determined for the sensing task and gave the condition that leads to
the existence of NE. For the dynamic mobile crowdsensing game the solution is based on reinforcement
learning.
In [FSS+22], the crowdsourcing system is studied as a two-stage problem that consists of a task as-
signment stage and a truth discovery stage. Utilizing the prior knowledge about the domain of the
tasks, ﬁrstly, the tasks are classiﬁed based on the domain and then allocated to the respective expert
domains using a mechanism based on greedy algorithm. To identify the copiers, the Bayesian model is
utilized. Further for truth discovery, the iterative method is adopted. A two-tiered social crowdsourcing
architecture is proposed in [XLG+22] that allows the task executors to forward the ﬂoated tasks that are
to be executed to their neighbors in the social connections. In this setup, the tasks are having different
end times. For this scenario, the three different system models are discussed based on the arrival modes
of the registered users and social neighbors. For the three different models, a truthful mechanism is pro-
posed. In [XZC+21] to increase the crowd workers the ﬂoated tasks are diffused in the social network
(representing the social connections of the crowd workers). The objective is to diffuse the tasks to as
many crowd workers as possible with the constraint that the total payment made to the task diffusers is
within the available budget. For the discussed set-up a truthful budget feasible mechanism is developed
that takes into account the enhanced classic independent cascade model . In [WHW+21] an effort has been
made to design a dynamic incentive mechanism that transfers information about the task execution
process through the social connections of the task executors. [JNX+22] developed an incentive-based
mechanism for truth discovery, with the primary objective being minimizing the copiers.
Several quality-based incentive schemes are developed for different scenarios in crowdsourcing and
PS [MSPK22, SMXS20, SMXK20, GS20, SJSM22]. In [MSPK22] the setup consists of a single task re-
quester and multiple task executors, where a task requester is endowed with multiple tasks and the
budget. It is assumed that the overall budget is not available apriori and will be available in an in-
5cremental fashion. On the other side, we are having multiple task executors along with the charges
that they will ask in return for their services. The objective is to select the subset of quality task execu-
tors for the given tasks such that the total payment made to the task executors is within the budget.
In [SMXS20] the heterogeneous task assignment problem is investigated in strategic setting. The setup
consists of multiple task requesters, each having a single task and multiple IoT devices (as task execu-
tors). In this, there is a publicly known budget that will be utilized for payment to the task executors in
exchange for their services. The objective is to select the subset of quality task executors for each task
such that the total payment made to the task executors is within the budget. The setup with multiple
task requesters and multiple task executors, where each task requester is endowed with multiple tasks
is discussed in [SMXK20]. Here, each of the tasks has start and ﬁnish times associated with it. On the
other side, we have multiple task executors that ask for the set of tasks they are interested in executing
along with the cost they will charge. For the purpose of allocating the subset of task executors to each
task in a non-conﬂicting manner a truthful mechanism is proposed. Gong et al. [GS20] considered the
data quality and data accuracy, and proposed a truthful mechanism. In [SJSM22] there are multiple task
requesters and multiple IoT devices (as task executors ). Each task requester reports a set of homogeneous
tasks and the bids (the amount they are willing to pay to the task executors in exchange for completing
the tasks). On the other side, each of the available IoT devices reports the number of tasks it can execute
and the cost it will charge for imparting its services. The bids and asks of the task requesters and task
executors respectively are private information. For this scenario, a truthful mechanism is proposed for
allocating the quality IoT devices to the tasks carried by task requesters. Some other research works
[KOS11, LKLJ15, LL17, LLZ23] in crowdsourcing have focused on learning the data quality of crowd
workers.
From the above-discussed literature reviews that the scenario discussed in this paper, in IoT-based
crowdsourcing in strategic settings has not been considered in the past. In this paper, a truthful mech-
anism is proposed that ﬁrst provides awareness about the task execution process among its social con-
nections. After that, each task is assigned quality IoT devices and payment for the quality IoT devices is
decided.
3 Notation and Preliminaries
In this section, a crowdsourcing scenario discussed in this paper will be formulated using mechanism
design . There are mheterogeneous tasks and nIoT devices (as task executors ). Here,nm. The set of
tasks is given as t, wheret=ft1;t2;:::;tmg, andtirepresentsithtask. The set of IoT devices is given as
I, whereI=fI1;I2;:::;Ing, andIjrepresentsjthIoT device. Our proposed model is a two-tier model.
Let us see each of the tiers one by one.
First tier :In this model, it is assumed that a substantial number of IoT devices may not be aware of the
task execution event. For this reason, in the ﬁrst tier, the social connection of the IoT devices is utilized
to notify about the task execution event to other IoT devices. In our model, the social connections of the
IoT devices are depicted through a graph G(NT;RT), here, NTrepresents the set of IoT devices and
are acting as the nodes (or vertices) of the graph, and RTrepresents the set of edges between the IoT
devices in a graph G. We say thatIiandIjare socially connected, if and only if there exists an edge
(i; j)2RT, otherwise not. The notify function is given as h, and is represented as h: 2NT!<. Given
a setUNTthe valueh(U)represents the expected number of IoT devices getting notiﬁed about the
task execution event in the social graph G. It is considered that the function h: 2NT!<ismonotone
(non-decreasing) submodular function . By monotone , It is meant that, for any HJ ,h(H)h(J).
Deﬁnition 1. h: 2NT!<is submodular if h(H[fig) h(H)h(J[fig) h(J),8HJ .
Each IoT deviceIiin graphG(NT;RT)has a private bid(orcost) and is given as ci. It is the amount that
6anyithIoT device will charge for being an initial notiﬁer . By private cost, it is meant that the cost is only
known to it and not known to other IoT devices and the mechanism designer. It is assumed that the
IoT devices are strategic and rational . It means that they will try to manipulate their private information
(in this case, the cost) to gain. For example, the reported cost by any ithIoT device could be ^cisuch
that^ci=cior^ci6=ci.^ci=cirepresents the fact that the IoT device Iireport bid in a truthful manner.
The cost vector of the IoT devices is given as c=fc1;c2;:::;cng. For the purpose of notifying the IoT
devices, the coverage inﬂuence model in social networks is utilized. In the graph, say, if each IoT device
Iiis connected with the subset of IoT devices Zi, then the number of IoT devices notiﬁed about the
task execution event by the subset UI is given as h(U) =S
i2UZi. The payment vector of the initial
notiﬁers is given as , where =f1;2;:::;ngandiis the payment of any ithnotiﬁer. The utility of
anyithIoT device as notiﬁer is given as:
Ui(c;) =(
i ci;ifIiacts as initial notiﬁers.
0;otherwise(1)
Given the above-discussed scenario and the publicly known budget B, the objective is to select the subset
of IoT devices as the initial notiﬁer such that the total payment made to them is within the available
budgetB. The output of the ﬁrst tier is the subset of IoT devices as the initial notiﬁers , the subset of notiﬁed
IoT devices , and the payment vector that contains the payment of each of the IoT devices that are acting as
thenotiﬁers .
From the above discussion, it is clear that it is a single-parametric mechanism design problem, as
each IoT device has only a single private information i:e:cost. So, for designing a truthful mechanism for
the above-discussed set-up, a greedy technique-based mechanism is one of the viable solutions. It is due
to the reason that the greedy technique will be monotone when sorted according to marginal notiﬁcation
(see Deﬁnition 2) per cost.
Deﬁnition 2 (Marginal notiﬁcation [Sin12a] ).Marginal notiﬁcation of j given Si 1is:hjjSi 1=h(Si 1[
fjg) h(Si 1). In this,hjjSi 1andhIjjSi 1will be used interchangeably where ever required. Here, Si 1
represents the set of i 1IoT devices that are already selected using the same rule.
Deﬁnition 3. Marginal notiﬁcation of IoT device Iiat positionkishi;k=h(Tk 1[fIig) h(Tk 1)whereTk
denotes the subset of ﬁrst kIoT devices in the marginal notiﬁcation-per-cost sorting over the subset of IoT devices
I=fIig:
Given the above-discussed set-up, for the ﬁrst tier, a truthful mechanism is proposed that satisﬁes the
constraint that the total payment made to the initial notiﬁers is within the available budget.
Second Tier :Once a sufﬁcient number of IoT devices are made aware of the ﬂoated event, our next
primary objective is to have a set of quality IoT devices from among the available ones. For that purpose,
the idea of peer assessment is utilized. The general idea of the peer assessment is that the completed
work(s) (or in our case the completed task(s)) by the IoT devices are assessed by their peers and the
reports are submitted. Based on the submitted reports, the quality of IoT devices is determined. In the
proposed model, the peer assessment is implemented by utilizing the idea of single-peaked preference .
In this, ﬁrstly, the IoT devices that are to be ranked are placed on the scale of [0;1]randomly. After
that inﬁnitesimally small part of tasks are provided to these IoT devices for execution purposes. After
execution, the completed tasks of each of the IoT devices are given to some randomly selected IoT
devices (other than those present on the scale of [0;1]) for assessment purposes. As an assessment
process, each ithIoT device provides a peak value i2[0;1]that is private . The reported peak value
iof anyithIoT device will be the peak value at which its favorite IoT device is placed or closer to its
favorite IoT device. Let us take an example to understand it in a better way. For example, let us say,
7there are 4 IoT devices Ii 1,Ii,Ij, andIj+1that are placed at 0.34, 0.47, 0.52, and 0.65 respectively on
the scale of [0;1]as shown in Figure 2a. The peak values of the other 4 IoT devices i:e:Ik,Ik+1,Ii+1, and
Ij 1are given as 0.37, 0.34, 0.58, and 0.65 respectively as shown in Figure 2b. It means that Ii+1’s most
preferred IoT device is Ij,Ik+1’s most preferred IoT device is Ii 1and likewise. After getting the peak
values from the IoT devices, in this paper, the quality of IoT devices is determined using Algorithm 3
(see Subsection 4.2).
0 10.34 0.65
Ii−1 Ij+10.52
Ij0.47
Ii
(a) IoT devices placed on [0;1]scale
0 10.34 0.65
Ii−1 Ij+10.52
Ij0.47
Iiαk
αi+1αj−1 αk+1 (b) Peak values reported by Ik,Ik+1,Ii+1, andIj 1
Figure 2: Illustrating the meaning of peak values
After the determination of quality IoT devices, further challenges that need to be handled are:
1. Hire the subset of IoT devices from the available quality IoT devices.
2. Distribute the set of available tasks to the subset of quality IoT devices for execution purposes.
3. What pricing strategy is to be followed for deciding the payment of the winning quality IoT de-
vices?
The second step of the second tier of the proposed model takes care of the above-coined questions. It is
assumed that each IoT device requests for a bundle of tasks at a time instead of a single task. Each IoT
deviceIihas a private valuation vi(S)for each bundle SF of tasks that it might receive. The valuation
function utilized in this step of the second tier satisﬁes the monotonicity condition i.e., vi(S)vi(F)for
SF4. For an empty set of tasks, vi() = 0 . For the discussed setup for a mechanism to work, it is
assumed that the valuation function satisﬁes the gross-substitute condition (See Deﬁnition 4).
Deﬁnition 4 (Gross Substitute (GS) [Rou14, N.N07] ).For any IoT device Ii, the valuation visatisﬁes GS
condition if and only if for every price vector , some setS2Di()and for every price vector r,9Twith
(Sn)[
T2Di(r)
where=
j:r(j)>(j)
is the set of tasks whose prices have gone up, and Snis the set of tasks for which
the prices remains same and Iistill wants them. Di()is the supply of IoT device Iiat price vector .
For each IoT device Iithe utility at price vector is given as:
ui(S;) =8
<
:P
j2Si(j) vi(S);ifSis assigned to IoT device Ii.
0;otherwise(2)
Here,i(j)is the price paid to the IoT device Iifor executing its jthassigned task. The utility of IoT
deviceIiis 0 if it does not receive the requested set of tasks. The supply by any IoT device Iiat the
given price vector is given as:
Di() =argminX
j2Si(j) vi(S)
St(3)
4It means that more tasks can only be better.
8Table 1: Notations used
Symbols Descriptions
m Number of heterogeneous tasks
n Number of IoT devices
t t=ft1;t2;:::;tmg: Set of heterogeneous tasks.
ti ithtask.
I I=fI1;I2;:::;Ing: Set of available IoT devices.
Ij jthIoT device.
GG(NT;RT): Represents the social connection of IoT devices.
NTA set of IoT devices representing the nodes of a graph G.
RTA set of edges between the IoT devices in a graph G.
h h: 2NT!<: Represents a notify function.
Zi Set of IoT devices notiﬁed by ithIoT device.
ci True cost of ithIoT device.
^ci Reported cost of ithIoT device.
c c=fc1;c2;:::;cng: Cost vector of the IoT devices for
being the initial notiﬁers.
B Available budget.
 =f1;2;:::;ng: Payment vector of IoT devices that are competing
for being the initial notiﬁers.
i Represents the payment of any ithIoT device
as an initial notiﬁer.
Ui(c;) Utility of any ithIoT device given cost and payment vectors.
i i2[0;1]: Peak value of ithIoT device.
vi(S) Private valuation of ithIoT device for set of tasks S.
N It is the number of quality IoT devices.
A A=fA1;A2;:::;ANg: Allocation vector.
Ai Ai= (Si;Ii): Allocation made to ithIoT device.
=f1;2;:::;Ng: Payment vector of IoT devices selected
for executing the tasks.
i Represents the payment of any ithIoT device.
ui(S;) Utility ofithIoT device given the price vector .
Di() Supply by any ithIoT device given the price vector .
As the participating IoT devices are strategic in nature so they will try to maximize their utility by misre-
porting their private valuation (in this case the valuation vi(S)of IoT deviceIifor a set of tasksS). The
objective of the second tier is to design a mechanism in presence of strategic agents, such that, it returns
an allocation and payment vectors with high social welfare (see Deﬁnition 8). An allocation for the dis-
cussed set-up is allocation vector A=fA1;A2;:::;ANg, whereAi= (Si;Ii)and=f1;2;:::;Ng.
Here,Nis the number of quality IoT devices.
Given the above-discussed scenario of IoT-based crowdsourcing in a strategic setting, the goal is to
design a mechanism that takes care of the following: (1) determine the set of initial notiﬁers that will
notify the substantial number of task executors about the task execution process with the constraint that
the total payment made to the notiﬁers is within the budget. (2) Determine a set of quality task execu-
tors. (3) Allocating the set of tasks to the quality task executors for execution purposes and deciding
their payment.
In the upcoming section, each of the components of the proposed mechanism i:eTICOM is discussed
and presented in a detailed manner.
93.1 Additional Required Deﬁnitions
Deﬁnition 5 (Truthful or Incentive Compatible (IC) [N.N07] ).A mechanism is said to be truthful or IC if
for anyithIoT deviceUi(c;) =i cii ^ci=^Ui(^c;).
Deﬁnition 6 (Budget feasible [Sin12b, Sin10] ).A mechanism is said to be budget feasible, if the total payment
made to the winning initial notiﬁers is less than equal to the available budget Bi:e:X
i2IiB:
Deﬁnition 7 (Individual rationality [N.N07] ).A mechanism is said to be individually rational if, for every
participating IoT device in the crowdsourcing market, the utility is non-negative. In other words Ui(c;)0(for
ﬁrst tier) or ui(S;)0(for second tier).
Deﬁnition 8 (Social Welfare [N.N07] ).It is the sum of the valuations of the IoT devices for their preferred set
of tasks. Mathematically, it is given as:
NX
i=1vi(S)
where,Sis the requested set of task from each IoT device Ii2I.
Deﬁnition 9 (Computational Efﬁciency ).A mechanism (a.k.a algorithm) is said to be computationally efﬁcient
if each step of the mechanism takes polynomial time.
Social Graph G(NT,RT), Budget B, Taskst
h: 2NT→ℜ, Cost vector c, IoT devices I
Notiﬁers Allocation Mechanism Notiﬁers Pricing Mechanism
Task Execution Noti ﬁers Mechanism
Notiﬁed Set of IoT Devices ¯S
Set of noti ﬁersS, Price vector ¯ρ
Eﬀective Task Executors Identi ﬁcation Mechanism
Set of quality IoT devices
O={I1,I2...,Iˆk}
Winners and Price Determination Mechanism
Allocation vector A={A1,A2,...,AN}
Payment vector ρ={ρ1,ρ2,...,ρN}tFirst Tier
Second Tier
Figure 3: Work Flow of Two-tiered Incentive COmpatible Mechanism (TICOM)
104 T WO-TIERED INCENTIVE COMPATIBLE MECHANISM (TICOM)
In this section, TICOM is discussed in a detailed manner. The TICOM consists of:
•Task execution notiﬁers mechanism (TENM)  It is useful in determining the set of initial noti-
ﬁers that will notify a substantial number of IoT devices for the task execution event in the crowd-
sourcing market and decide their payment. The payment made to the initial notiﬁers is such that
the total payment made to them should be within the available budget.
•Effective task executors identiﬁcation mechanism (ECTAI)  It helps to determine the qual-
ity/effective task executors among the available task executors in the crowdsourcing market.
•Winners and price determination mechanism (WiPD)  Hires the quality IoT devices and decide
their payments.
The overall workﬂow of TICOM is depicted in Figure 3. In the upcoming subsections, each of the
components of TICOM is discussed step-by-step in a detailed manner.
4.1 T ASK EXECUTION NOTIFIERS MECHANISM
In this section, a truthful budget feasible mechanism is proposed that is used to ﬁgure out the task
executors in the given social graph that will propagate the event of task execution to the task executors
in their social connection. It will also determine their payment in return for acting as the initial notiﬁer.
The task execution notiﬁer mechanism consists of (1) notiﬁer allocation mechanism (NAM), and (2) notiﬁer
pricing mechanism (NPM). The two components are discussed below.
4.1.1 N OTIFIERS ALLOCATION MECHANISM (NAM)
The input to the NAM is the social graph G, budgetB, the cost vector of the task executors ^c, and the
set of task executors I. The output of NAM is the set of task executors as notiﬁers and the set of task
executors that got notiﬁed about the task execution event.
Algorithm 1 NOTIFIERS ALLOCATION MECHANISM (G,B,^c,I)
Output:S ,S 
1:foreachIi2Ido
2:hijSi 1=h(Si 1[fig) -h(Si 1)fMarginal notiﬁcation of ithIoT device, given the set Si 1.g
3:end for
4: 2fis initialized to 2. g
5:i argmaxIk2InS
hkjSk 1
ck
fSelects an IoT device with maximum marginal notiﬁcation per cost,
given setSk 1.g
6:whileciB

hIijSi 1
(h(Si 1)+hIijSi 1)
do
7:S S[fI igfS holds the set of IoT devices that satisﬁes the stopping condition in line 6. g
8: ~S ~S[fZigfSholds the set of IoT devices that got notiﬁed by the IoT devices in S.g
9:i argmaxIk2InS
hIkjSk 1
ck
fSelects an IoT device with maximum marginal notiﬁcation per
cost among the available ones, given set S.g
10:end while
11:returnS,SfReturns the set of task executors as notiﬁers and the notiﬁed set of task executors. g
11In Algorithm 1, lines 1-3 calculate the marginal notiﬁcation by each of the task executors Ii2I. In line 2
the marginal notiﬁcation of Iigiven an already selected set of task executors as notiﬁers Siis calculated.
In line 4 variable is initialized to 2. In line 5, the task executor with maximum marginal notiﬁcation
per cost is selected among the available ones. In lines 6-10, the idea of determining the task executors
as notiﬁers are presented. In line 6 the stopping condition checks if the cost of ithtask executor is less
than or equal toB
times the ratio of the marginal notiﬁcation of ithtask executor to the number of task
executors notiﬁed by the set of task executors in set S[fIig. If the stopping condition in line 6 is true,
then in line 7 the task executor Iiis held inS. In line 8 Sholds the set of IoT devices that got notiﬁed
by the IoT devices in S. For the next iteration, the task executor with the highest marginal notiﬁcation
per cost is selected among the available ones in line 9. Lines 6-10 iterate until the stopping condition in
line 6 is true. In line 11 the set of task executors as notiﬁers and the notiﬁed set of task executors are
returned.
4.1.2 N OTIFIERS PRICING MECHANISM (NPM)
The input to the NPM is the set initial notiﬁer S, budgetB, and cost vector ^c. The output of the NPM
is the price vector of the initial notiﬁers. In line 1 of Algorithm 2, S0is initialized to . In lines 2-19
the payment calculation for the initial notiﬁers in setSis done. In line 3, a set holds the set of all the
IoT devices except Ij2S. After that, the task executor with the highest marginal notiﬁcation per cost
is selected from and is stored in variable i, as shown in line 4. Lines 5-9 determine the set of initial
notiﬁers when task executor Ijis dragged out of the crowdsourcing market. Now, any ithIoT device
will be added in the set S0only when the stopping condition in line 5 is true. Once added, the selected
IoT deviceIiwill be removed from . For the next iteration, a task executor will be selected from the
available task executors and will be held in i. Lines 5-9 iterate until the stopping condition in line 5
is true. Once terminated, in lines 10-16, the two quantities are calculated rj;kandj;k. In line 11, the
quantity rj;kis calculated and is held in rjin line 12. The quantity j;kis calculated in line 13 and
is held injin line 14. In line 15, the minimum of two quantities is determined. Line 17 gives us the
maximum value present in 0
jand held in . Finally, in line 20 the payment vector is returned.
Example. Let us understand the task execution notiﬁer mechanism with the help of an example. As dis-
cussed earlier it consists of two components: (1) notiﬁer allocation mechanism , and (2) notiﬁer pricing mech-
anism . Both the components are elaborated in the order discussed above .The graph shown in Figure
4a represents the social connections of the task executors and will be helpful in notifying the substantial
number of task executors about the task execution event. The value inside the square box is the cost that
will be charged by IoT devices in exchange for notifying the IoT devices about the task execution event.
I1
I5 I2 I6I4
I32
5 23 4
2
(a) Graph Representing Social Connection of IoT
DevicesTask Executors I1I2I3I4I5I6
hijS 4 3 4 3 3 3
^c 2 4 2 5 3 2
hijS
^c20.75 20.60 11.50
(b) Calculation of Marginal notiﬁcation given S=, Cost vector, and
Marginal notiﬁcation per cost
Figure 4: Initial Set-up for Illustration of NAM
12Algorithm 2 NOTIFIER PRICING MECHANISM (S,B,^c)
Output:  
1:S0 
2:foreachIj2Sdo
3: InfI jgfRemovingIjfrom the market and storing rest of the task executors in .g
4:i arg max
Ik2
hIkjS0
^ck
fThekthtask executor with maximum marginal notiﬁcation to cost ratio is
determined from and is stored in i.g
5: while^ci
B
hIijS0
hIijS0+h(S0)
do
6:S0 S0[fIigfS0holds the set of IoT devices that satisﬁes the stopping condition in line 5. g
7: nfIigfIiremoved from .g
8:i arg max
Ik2
hIkjS0
ck
fSelects an IoT device with maximum marginal notiﬁcation per cost
among the available ones, given set S0.g
9: end while
10: fork 1tojS0j+ 1 do
11: rj;k hj;k
ck
h0
kjTk 1
fCost that any jthIoT device would have revealed when considered in
place of IoT device that is already present at any kthposition.g
12: rj rj[frj;kg
13:j;k B
hj;k
h(Tk 1[fIjg)
fThe fraction of budget that will be utilized as the payment of the jth
IoT device at some kthposition.g
14:j j[fj;kgfThe payment of any jthIoT device at position kis stored inj.g
15:0
j minfrj;jgfMinimum of rjandjis determined and is stored in 0
j.g
16: end for
17: j maxf0
jgfDetermining the maximum value from j= 1tojS0j+ 1and stored in j.g
18:  [fjgfPayment of each of the jthIoT device in winning set is determined and is stored in
g
19:end for
20:return fThe payment vector for the winning IoT devices is returned. g
From Figure 4a it is evident that the task executor I1has social connection with task executors I2,
I4,I5, andI6. In the similar way, task executor I2has social connection with I1,I3, andI5and so on.
Further calculations in the running example will be done by considering the available budget Bas 12.
•NOTIFIERS ALLOCATION MECHANISM : Applying Algorithm 1 to Figure 4a, the marginal notiﬁ-
cation of each of the task executors in the graph shown in Figure 4a are calculated given S=.
After that, the ratio hijSper cost is calculated using line 2 of Algorithm 1. The calculated values are
depicted in Figure 4b in tabular form. Following line 5, one of the two task executors I1andI3will
be considered as both have the highest value for marginal notiﬁcation per cost but are the same.
Let us sayI1is considered randomly. For task executor I1the stopping condition 2(12
2)4
4= 6in
line 6 is true and is selected. So, S=fI1g, and ~S=fI2;I4;I5;I6g. In the next iteration, the graph
conﬁguration shown in Figure 5a will be considered. In the second iteration, the marginal notiﬁ-
cation of each of the task executors is calculated given S=fI1gas shown in Figure 5b. After that,
the ratiohijSper cost is calculated. The calculated values are shown in Figure 5b. Following lines
6-10, a task executor I6will be considered as it is having the highest marginal notiﬁcation per cost
value among the available IoT devices. For task executor I6the stopping condition 2(12
2)2
6= 2
in line 6 is true and is selected. So, S=fI1;I6g, and ~S=fI1;I2;I3;I4;I5;I6g.
13I1
I5 I2 I6I4
I32
5 23 4
2(a) Graph Representing Social Connection of IoT
Devices and Selected IoT Device I1Task Executors I1I2I3I4I5I6
hijS 0 2 0 2 2 2
^c 2 4 2 5 3 2
hijS
^c00.5 00.40 0.66 1
(b) Calculation of Marginal notiﬁcation given S=fI1g, Cost vector, and
Marginal notiﬁcation per cost
Figure 5: Illustration of 2ndIteration of While Loop of NAM
For the next iteration the conﬁguration shown in Figure 6a will be considered. In the third iter-
ation, the marginal notiﬁcation of each of the task executors is calculated given S=fI1;I6gas
shown in Figure 6b. After that, the quantity hijSper cost is calculated. The calculated values are
shown in Figure 6b. Following lines 6-10, for none of the task executor the stopping condition in
line 6 will be satisﬁed as the marginal notiﬁcation per cost value for the available task executors
are 0. Hence, the while loop in lines 6-10 will terminate, and line 11 will return S=fI1;I6g, and
~S=fI1;I2;I3;I4;I5;I6g.
I1
I5 I2 I6I4
I32
5 23 4
2
(a) Graph Representing Social Connection of IoT
Devices and Selected IoT Device I1andI6Task Executors I1I2I3I4I5I6
hijS 0 0 0 0 0 0
^c 2 4 2 5 3 2
hijS
^c0 0 0 0 0 0
(b) Calculation of Marginal notiﬁcation given S=fI1;I6g, Cost vector,
and Marginal notiﬁcation per cost
Figure 6: Illustration of 3rdIteration of While Loop of NAM
•NOTIFIERS PRICING MECHANISM : Using Algorithm 2, the payment of IoT devices I1andI6
will be calculated. From the construction of Algorithm 2, to calculate payment of I1, the task
executorI1will be placed out of the social graph. After dragging out IoT device I1, the marginal
notiﬁcation of each of the task executors is calculated given nobody is selected i:e:S0=. After
that, the ratio hijS0per cost is calculated. The calculated values are shown in Figure 7b. Following
line 4, a task executor I3will be picked up as it is having the maximum marginal notiﬁcation per
cost value among the available IoT devices. The stopping condition 212(4
4)= 12 in line 5 is
satisﬁed. So,I3is selected .For the next iteration, the conﬁgurations shown in Figure 8a will be
considered. In the second iteration, the marginal notiﬁcation of each of the task executors given
S0=fI3gis calculated. After that, the ratio hijS0per cost is calculated. The calculated values are
shown in Figure 8b. Following line 4, a task executor I6will be considered as it is having the
maximum marginal notiﬁcation per cost value among the available IoT devices. For task executor
I6the stopping condition 212(1
5) = 2:4in line 5 is true and is selected.
14I1
I5 I2 I6I4
I32
5 23 4
2(a) Graph Representing Social Connection of IoT
Devices When I1is Out of the MarketTask Executors I2I3I4I5I6
hijS0 2 4 2 2 2
^c 4 2 5 3 2
hijS0
^c0.5 20.4 0.66 1
(b) Calculation of Marginal notiﬁcation given S0=, Cost vector, and
Marginal notiﬁcation per cost
Figure 7: Illustration of 1stIteration of NPM
In the third iteration, the conﬁguration shown in Figure 9b will be utilized. The marginal notiﬁca-
tion of each of the task executors given S0=fI3;I6gare calculated. After that, the ratio hijS0per
cost is calculated. The calculated values are shown in Figure 9b. For this conﬁguration, none of the
task executors will be selected as the marginal notiﬁcation of all the IoT devices given S0=fI3;I6g
is 0. So, whenI1is out of the market then S0=fI3;I6gwill be acting as the initial notiﬁers. As
two IoT devices are selected, so jS0jvalue is 2. In our running example, the ﬁrst loser can be any-
one out ofI2,I4, andI5. Let us sayI2. Now, following lines 10-16 of Algorithm 2, at each index
k2[1::jS0j+ 1] the maximal cost of I1and its payment is determined. The minimum of the two
quantities is taken and then the maximum of each of the points will be the payment made by the
I1. Let us sayI1is considered in place of I32S0.
I1
I5 I2 I6I4
I32
5 23 4
2
(a) Graph Representing Social Connection of IoT De-
vices When I1is Out of the Market and I3got SelectedTask Executors I2I3I4I5I6
hijS0 1 0 1 1 1
^c 4 2 5 3 2
hijS0
^c0.25 00.2 0.33 0.5
(b) Calculation of Marginal notiﬁcation given S0=fI3g, Cost vector, and
Marginal notiﬁcation per cost
Figure 8: Illustration of 2ndIteration of NPM
In such case, r1;1= 4(2
4) = 2 , and1;1= 12(4
4) = 12 . So,minf2;12g= 2. Next, ifI1is considered
in place ofI62S0givenS0=fI3g. In such case, r1;2= 0(2
4) = 0 , and1;2= 12(0
4) = 0 . So,
minf0;0g= 0. Finally,I1is considered in place of I2thenr1;3= 0(4
0) = 0 , and1;3= 12(0
4) = 0 .
So,minf0;0g= 0. Following line 17, we get maxf2;0;0g= 2. So, the payment of I1= 2. Similarly,
the payment ofI6can be calculated and is given as 3. So, =f2;3g. The total payment is
2 + 3 = 512.
15I1
I5 I2 I6I4
I32
5 23 4
2(a) Graph Representing Social Connection of IoT
Devices When I1is Out of the Market and I3
andI6got SelectedTask Executors I2I3I4I5I6
hijS0 0 0 0 0 0
^c 4 2 5 3 2
hijS0
^c0 0 0 0 0
(b) Calculation of Marginal notiﬁcation given S0=fI3;I6g, Cost vector,
and Marginal notiﬁcation per cost
Figure 9: Illustration of 3rdIteration of NPM
4.2 E FFECTIVE TASK EXECUTORS IDENTIFICATION MECHANISM (ECTAI)
Once the substantial number of IoT devices from the ﬁrst tier is obtained, in the second tier, the ﬁrst
objective is to determine effective (or quality) IoT devices from among the available IoT devices. For
this purpose, the idea of single-peaked preference [Rou16b, Mou80] is utilized. The general idea of the
proposed mechanism i:e:ECTAI is:
ECTAI
In each iteration of the while loop:
1. Firstly, some fnumber of IoT devices are selected randomly from the set of IoT devices and
are placed on the scale of [0;1].
2. After that, an inﬁnitesimally small part of tasks are given to those IoT devices that are placed
on the scale of [0;1].
3. The executed tasks of fnumber of IoT devices are reviewed by gnumber of other IoT devices
and based on that the peak values are reported by gnumber of IoT devices.
4. Calculate the median of the peak values reported by gnumber of IoT devices.
5. Determine the IoT device among the IoT devices that are placed on the scale of [0;1]whose
peak value lies closer to the median peak value. It will be considered a quality IoT device.
Steps 1-5 are continued until the ranking tasks of each of the task executors are not ranked. The detailing
of the above-discussed approach is presented in Algorithm 3. The input to algorithm 3 is: (1) the set of
IoT devices that are acting as the initial notiﬁers i:e:S, and (2) the set of IoT devices that got notiﬁed
i:e:S. In Algorithm 3, line 1 initializes I00andI0byS[S,Rto, and ^Rto 0. Lines 2-18 determine the
quality of task executors. Lines 2-18 iterate until the condition in line 2 is satisﬁed. In line 3, the ftask
executors that are to be ranked are randomly selected from the set I0and are held in . From setI00n,
some task executors are randomly selected and are held in . The task executors in rank the executed
tasks of the task executors in . For the ranking purpose, the idea of single peaked preference is utilized.
The executed tasks by the task executors in are placed on a scale of 0 to 1 randomly. Now, each task
executor in will provide a peak (or value) between 0 and 1. The peak of each of the task executors is
stored inR, as depicted in lines 5-8. In line 9 the peak value by each of the task executors in is sorted in
ascending order. In lines 10-14, the resultant peak value is determined. Here, the two cases can happen:
16Algorithm 3 EFFECTIVE TASK EXECUTORS IDENTIFICATION (S,S)
Output: O 
1:I00=I0=S[S;R ;^R 0
2:whileI06=do
3: RANDOM SELECTION (I0;f)fSelects ftask executors from I0that are to be ranked. g
4: RANDOM SELECTION (I00n; g)fSelectsgtask executors from I00nthat will provide ranking
over the completed tasks of task executors in .g
5: foreachIi2do
6:i RANDOM (0;1)fReturns a random number between 0 and 1. g
7:R R[figfGenerated random number is held in R.g
8: end for
9: sort (R)fSort the peak values present in R, in ascending order. g
10: if(jjmod 2)6= 0 then
11: ^R Rh
jj+1
2i
fWhen the number of peak values is odd then the median is calculated and is
stored in ^R.g
12: else
13: ^R  
Rh
jj
2i
+Rh
jj
2+1i
2!
fWhen the number of peak values is even then the median is calcu-
lated and is stored in ^R.g
14: end if
15:i arg min
Ii2ji ^Rjf Determines the nearest IoT device to the median peak value. g
16:O O[figfThe nearest IoT device to the median peak value is held in O.g
17:I0 I0nfRemoves the already ranked IoT devices from I0.g
18:end while
19:return OfReturns the set of quality IoT devices. g
(1)jjcould be even, in that case, the resultant peak is calculated by line 11 and is stored in ^R, (2)jj
could be odd, in that case, the resultant peak value is calculated by line 13 and is stored in ^R. In line 15,
the IoT device in closer to the resultant peak is returned and is stored in i. The closer the IoT device
into the resultant peak value of the IoT devices in better will be the quality of the IoT device Iiin.
On the other hand, the farther the resultant peak value from the peak value of the task executor Ij, the
poorer will be the quality of the task executor Ij. In line 16, the task executor Ii, with high quality is
placed in Oin each iteration. In line 17, the task executors that are already ranked are removed from the
setI0. The while loop in lines 2-18 will iterate until all the IoT devices got ranked. Line 19 returns the set
of quality IoT devices.
Example. Let us consider an example to understand Algorithm 3. Let us suppose that there are 12 IoT devices
I=fI1;I2;:::;I12gthat got notiﬁed about the task execution process by their social connection. Now, out of 12
IoT devices, the objective is to select the subset of quality IoT devices. For that purpose, let us apply Algorithm 3.
For simplicity purposes, we have considered f= 3, andg= 5.
In the ﬁrst iteration of while loop of Algorithm 3, =fI2;I4;I9gare considered that are to be ranked and
=fI1;I3;I7;I8;I11gare the IoT devices that will provide ranking on the set as shown in Figure 10a. The
peak values reported by the IoT devices in set are depicted in the table shown in Figure 10a. Following lines
10-14 of Algorithm 3, we get jj= 5. So, line 10 of Algorithm 3 is true. Using line 11, ^R Rh
5+1
2i
=
^R Rh
6
2i
=^R Rh
3i
=^R 0:50 =3. Using line 15, we get i I 4. So,O=fI4g. In the next iteration
ofwhile loop of Algorithm 3, =fI1;I3;I7gare considered that are to be ranked and =fI2;I4;I6;I8;I11g
17are the IoT devices that will provide ranking on the set as shown in Figure 10b. The peak values reported by
the IoT devices in set are depicted in the table shown in Figure 10b. Following lines 10-14 of Algorithm 3, we
getjj= 5. So, line 10 of Algorithm 3 is true. Using line 11, ^R Rh
5+1
2i
=^R Rh
6
2i
=^R Rh
3i
=^R 0:50 =2. Using line 15, we get i I 3. So,O=fI4;I3g. In the third iteration of while loop of
Algorithm 3, =fI6;I10;I12gare considered that are to be ranked and =fI2;I7;I9;I10;I11gare the IoT
devices that will provide ranking on the set as shown in Figure 10c. The peak values reported by the IoT devices
in setare depicted in the table shown in Figure 10c. Following lines 10-14 of Algorithm 3, we get jj= 5. So,
line 10 of Algorithm 3 is true. Using line 11, ^R Rh
5+1
2i
=^R Rh
6
2i
=^R Rh
3i
=^R 0:45 =2.
Using line 15, we get i I 10. So,O=fI3;I4;I10g. In the ﬁnal iteration of while loop of Algorithm 3,
=fI8;I11;I9gare considered that are to be ranked and =fI1;I5;I7;I9;I10gare the IoT devices that will
provide ranking on the set as shown in Figure 10d. The peak values reported by the IoT devices in set are
depicted in the table shown in Figure 10d. Following lines 10-14 of Algorithm 3, we get jj= 5. So, line 10 of
Algorithm 3 is true. Using line 11, ^R Rh
5+1
2i
=^R Rh
6
2i
=^R Rh
3i
=^R 0:35 =9. Using line
15, we geti I 8. So,O=fI3;I4;I8;I10g. As all the IoT devices in our running example are ranked, the
Algorithm 3 will terminate by returning the set of quality IoT devices O=fI3;I4;I8;I10g.
0 10.20 0.80
I2 I90.55
I4 α8α7
α3α1 α11
Peak
Peakα1α7α8α11
0.60ValuesVariablesα3
0.50 0.40 0.30 0.90ˆR
(a) IoT devices represented on [0;1]scale
0 10.10 0.75
I1 I70.40
I3α8 α4α11
Peak
Peakα2α6α8α11
0.50ValuesVariablesα4
0.65 0.20 0.30 0.95α2 α6ˆR (b) Peak values of IjandIk
0 10.05 0.70
I6 I120.25
I10α9 α10α11
Peak
Peakα2α9α10α11
0.45ValuesVariablesα7
0.15 0.35 0.80 0.95α2 α7ˆR
(c) Task executors represented on [0;1]scale
0 10.70
I110.25
I8α9 α10α1
Peak
Peakα1α7α9α10
0.95ValuesVariablesα5
0.05 0.15 0.35 0.80α7ˆR
I90.50
α5 (d) Task executors represented on [0;1]scale
Figure 10: Detailed Illustration of ECTAI
4.3 Winners and Price Determination (WiPD)
In subsection 4.2 using Algorithm 3, the quality of IoT devices is determined. In this section, it is dis-
cussed that: (1) how the tasks will be allocated to the quality IoT devices? and (2) what will be their payment?
The input to the Algorithm 4 is the set of quality IoT devices and the set of heterogeneous tasks. In line
1, the allocation and price vectors are set to . In lines 2-4, the prices for all the tasks are set to 0. Using
lines 5-7, the initial allocation and initial price for all the IoT devices are set to empty and 0 respectively.
18Inwhile loop in lines 8-25, it is asked from the IoT devices that given the tasks you already have at the given
Algorithm 4 WINNERS AND PRICE DETERMINATION (O,t)
1:A , fInitially, the allocation and price vectors are set to .g
2:foreachti2tdo
3:(i) 0fInitially, the price of all the tasks is set to 0. g
4:end for
5:foreachIi2Odo
6:Ai ,i 0fInitially, the allocation and payment vectors of any ithIoT device is set to and
0respectively.g
7:end for
8:while (True) do
9: foreachIi2Odo
10: Ask for the preferred set of tasks not assigned to it, given the tasks they already have and the
current prices an arbitrary setFiin
arg min
FitnSi(X
j2Si(j)+X
j2Fi((j) +)
-vi(Si[Fi))
11: ifFi=then
12:Ai SifAiholds the set of tasks assigned to ithIoT device.g
13:A A[fA igfA holds the selected tasks of the respective IoT device. g
14:i X
i2Si(i)fThe prices of all the tasks requested by IoT devices in Siare added and is
stored ini.g
15: [figfholds the payment of the winning IoT devices. g
16: else
17:Si Si[FifThe new set of tasks Fiis added toSiand is stored inSi.g
18:Sl SlnFi,8l6=ifFiset of tasks is removed from the requested set of other task executors. g
19:(j) (j) +,8j2FifThe prices of all the tasks held by IoT devices in Fiis increased by
.g
20:i X
i2Si(i)fThe prices of all the tasks requested by IoT devices in Siare added and is
stored ini.g
21:Ai Ai[SifAiholds the set of tasks assigned to IoT device Ii.g
22:A A[A iand [ifAandholds the set of assigned tasks of IoT devices and their
payments respectively. g
23: end if
24: end for
25:end while
26:returnA,fReturnsAandthat holds the set of assigned tasks of IoT devices and their payments
respectively.g
prices of the tasks, what set of tasks, in addition, would you want to bid on? Now, if with the increase in price,
it is seen that no IoT device is interested to modify its requested set of tasks then the while loop in lines
8-25 terminates and the current allocations and the current payment vectors are returned in line 26. In
line 10 on the other hand, it may happen that with the increase in price, some of the task executors may
be ready to show interest in an additional set of tasks. If that is the case, then lines 16-23 of Algorithm 4
will be activated. In line 17, the overall demand of ithtask executor is stored in Si. In line 18, the set of
tasksFithat got added in Siis removed from the demand set of other IoT devices except for the demand
set ofIi. The price of the tasks in Fiis increased by again and is stored in (j)in line 19. In line 20, the
19sum of the prices of tasks in Siis held ini. In line 21,Aiholds the set of tasks assigned to IoT device
Ii. In line 22, the tasks allocated to all the task executors are held in Aand the payment vector of all the
winning task executors is determined. Line 26 returns the ﬁnal allocation and the payment vector.
4.4 Illustrative Example
In this subsection, WiPD is elaborated in a detailed manner with the help of an example. Let us say there
are 8 heterogeneous tasks t=ft1;t2;t3;t4;t5;t6;t7;t8gand 3 quality IoT devices. Following lines 2-4
of Algorithm 4 the prices of the tasks in tare set to 0. In our running example, the value is taken as
1. Using lines 8-25 of Algorithm 4, ﬁrstly IoT device I1is asked that at price (i) = 0 , for alli= 1to8,
what are the tasks that you want to execute ? ForI1we havev1(S1) = 6 , whereS1=ft1;t2;t3g. Next,
the prices of tasks t1,t2, andt3are increased by = 1. So, at price (i) = 1 , fori= 1;2;and3, and
(i) = 0 , fori= 4;5;6;7and8, the preferred set of tasks by I2is asked. ForI2we havev2(S2) = 4 ,
whereS2=ft4;t6;t8g. So, in the second iteration the tasks t4,t6, andt8are given toI2. Next, the prices
of the taskst4,t6, andt8are increased by = 1and prices became 1 for these tasks. So, at price (i) = 1 ,
fori= 1;2;3;4;6;and8, and(i) = 0 , fori= 5;7, the preferred set of tasks by I3is asked. ForI3we
havev3(S3) = 3 , whereS3=ft5g. So, in the third iteration, the task t5is given toI3. Next, the price of
taskt5is increased by = 1and the price became 1 for task t5. After the ﬁrst iteration of the while loop,
the allocation vector A=f(ft1;t2;t3g;I1);(ft4;t6;t8g;I2);(ft5g;I3)gand payment vector =f3;3;1g.
IoT Devices vi(Si)Iterations of While Loop
1st2nd3rd4th
AiρiAiρiAiρiAiρi
I1
I2
I36
4
3{t1,t2,t3}
{t4,t6,t8}
{t5}3
3
1{t1,t2}
{t4,t6,t8}
{t3,t5,t7}2
3
6{t1,t2}
{t4,t6,t8}
{t3,t5,t7}2
5
10{t1,t2,t3}
{t4,t6,t8}
{t5,t7}8
7
6
Figure 11: Detailed Illustration of WiPD
Now, at the given price vector ,what are the additional task(s) you want ? The answer by IoT device
I1is:F1=ft7g. So,S1=ft1;t2;t3;t7g. Following line 19 of Algorithm 4, the price of task t7is
increased by 1 and it became (1) = 1 . Further, in the next iteration the IoT device I2is asked about
the additional task(s). I2requested for additional task t3. So,v2(S2) = 4 , whereS2=ft3;t4;t6;t8g.
AsF2=ft3g, so the price of task t3will be increased by 1 and it became 2. In the next iteration of
forloop, IoT device I3is asked about the additional task(s) and reported t3andt7. So,F3=ft3;t7g.
Hence,S3=ft3;t5;t7g. AsF3=ft3;t7g, so the prices of tasks t3andt7will be increased by 1 and
it became 3 and 2 respectively. After the second iteration of the while loop, the allocation vector is
A=f(ft1;t2g;I1);(ft4;t6;t8g;I2);(ft3;t5;t7g;I3)gand payment vector =f2;3;6g.
Now, at the given price vector ,what are the additional tasks you want ? The answer by I1IoT device
is:F1=ft3;t4;t6g. So,S1=ft1;t2;t3;t4;t6g. Following line 19 of Algorithm 4, the prices of tasks t3,
t4, andt6is increased by 1 and it became 4, 2, and 2 respectively. Further, in the next iteration the IoT
deviceI2is asked about the additional task(s). I2requested for additional task t7. So,v2(S2) = 4 , where
S2=ft4;t6;t7;t8g. AsF2=ft7g, so the price of task t7will be increased by 1 and it became 3. In the
next iteration of forloop, IoT deviceI3is asked about the additional task(s) and reported t3andt7. So,
F3=ft3;t7g. Hence,S3=ft3;t5;t7g. AsF3=ft3;t7g, so the prices of tasks t3andt7will be increased
by 1 and it became 5 and 4 respectively. After the third iteration of the while loop, the allocation vector
20isA=f(ft1;t2g;I1);(ft4;t6;t8g;I2);(ft3;t5;t7g;I3)gand payment vector =f2;5;10g.
Similarly, in the next iteration of while loop F1=ft3;t7;t8g,F2=ft8g, andF3=ft7g. After this
iteration, the allocation and price vectors are A=f(ft1;t2;t3g;I1);(ft4;t6;t8g;I2);(ft5;t7g;I3)gand
payment vector =f8;7;6g. In next iteration F1,F2, andF3are. So, the ﬁnal allocation vector is
A=f(ft1;t2;t3g;I1);(ft4;t6;t8g;I2);(ft5;t7g;I3)gand ﬁnal payment vector is =f8;7;6g. The utility
ofI1,I2, andI3isu1(S1;) = 8 6 = 2 ,u2(S2;) = 7 4 = 3 , andu3(S3;) = 6 3 = 3 respectively.
5 M ECHANISM ANALYSIS
In this section, the analysis of the proposed mechanisms for the two tiers is discussed independently one
by one. Firstly, in subsection 5.1 the analysis of TENM is carried out. Next, the analysis of the proposed
mechanisms for the second tier i:e:ECTAI and WiPD are discussed in subsection 5.2.
5.1 Analysis of First Tier
In this subsection, the analysis of the ﬁrst tier is depicted. In Lemma 1 it is proved that TENM runs in
polynomial time. The correctness of TENM has been discussed in Lemma 2. It shows that on termina-
tion, TENM gives the desired output. Using Proposition 1, Corollary 1 proves that IoT devices cannot
improve their utility by misreporting their private information. In other words, it shows that TENM is
truthful orincentive compatible . By taking the help of Proposition 2 in Corollary 2 it is shown that TENM
isbudget feasible .
In Theorem 1 we are proving that the number of IoT devices that got notiﬁed about the task execu-
tion process by any ithIoT device in expectation is given as E[Xi] =jZijp. Here,Xiis an indicator
random variable that captures the number of IoT devices that got notiﬁed about the task execution pro-
cess by any ithIoT device,jZijis the number of IoT devices that are socially connected to ithIoT device
andpis the probability with which the ithIoT device will notify to any of its peers. This theorem will
give us an estimate that the number of IoT devices notiﬁed by ithIoT device. Further, it is estimated
in Theorem 2 that the probability that any ithIoT device notiﬁes about the task execution process to at
least one IoT device out of jZijis given as 1 
1
exp(jZijdlnjZije)
. This theorem helps us to show with
what probability any ithIoT device will be notifying at least one IoT device among the available ones.
In a given social graph, the probability that at leastp
jZijlnjZijIoT devices got notiﬁed by any ithIoT
device is given asexpp
jZijlnjZij
p
jZijlnjZijp
jZijlnjZij. This theorem helps us to show that with what probability
anyithIoT device will be notiﬁed to at leastp
jZijlnjZijIoT devices.
Lemma 1. TENM is computationally efﬁcient.
Proof. The running time of TENM is the sum of the running time of Algorithm 1 and Algorithm 2. So,
let us determine the running time of each of the algorithms one by one.
Lines 1 3 in Algorithm 1 will execute for ntimes and is bounded above by O(n). Line 4 will take
O(1). Line 5 is determining the IoT device with maximum
hIkjSk 1
ck
and holding it in i. It will take
O(n)time. In the worst case, lines 6-10 may execute for ntimes (i:e:number of IoT devices). For each
iteration of while loop, lines 7 and 8 will take constant time. Line 9 will take O(n). So while loop is
bounded above by O(n2). Line 11 will take O(1). So, the running time of Algorithm 1 is O(n) +O(1) +
O(n2) =O(n2).
Line 1 of Algorithm 2 takes O(1)time. Lines 2-19 may run for ntimes in the worst case. For each
21iteration of lines 2-19, lines 3 and 4 of Algorithm 2 will take O(n)time. Lines 5-9 will take O(n2)as
discussed in Algorithm 1. Lines 10-16 will iterate for n-1 times in the worst case. For each iteration of for
loop in lines 10-16, lines 11-14 will take constant time i:e:O (1). Line 15 is bounded above by O(n). So,
lines 10-16 are bounded above by O(n2). Line 17 will take O(n). Line 18 is bounded above by O(1). So,
each iteration of forloop in lines 2-19 is bounded above by O(1)+O(n)+O(n2)+O(n2)+O(n) =O(n2).
Forniterations it will be O(n3). So, overall running time of Algorithm 2 is O(1)+O(n3)+O(1) =O(n3).
Combining the running time of Algorithm 1 and Algorithm 2 i:e:O (n2) +O(n3) =O(n3). TENM
takesO(n3)time and hence is computationally efﬁcient .
Lemma 2. TENM works correctly.
Proof. The proof of correctness of TENM is done using loop invariant technique [CLRS09]. To show that
TENM is correct, it is to be shown that all the subroutines associated with TENM are correct. Let us
prove that each of the subroutines of TENM is correct.
Proof of Correctness of Algorithm 1: To prove that Algorithm 1 is correct, the following loop invari-
ant is considered:
Loop invariant: In each iteration of while loop of lines 6-10, an IoT device is added into the output
arraySas a notiﬁer.
•Initialization: We can start by showing that loop invariant holds before the ﬁrst iteration of while
loopi:e:whenS=. The output set Shas no IoT devices acting as notiﬁers before the ﬁrst
iteration. So, the loop invariant holds.
•Maintenance: For the loop invariant to be true, it is to be shown that before any lthiteration of
while loop and after lthiteration of the while loop the loop invariant holds. Before lthiteration,i:e:
till(l 1)thiteration there will be (l 1)IoT devices in a set S. Afterlthiteration, the number of
IoT devices will belP
i=11 =linS. So, the loop invariant holds.
•Termination: From the construction of Algorithm 1, it is clear that the while loop will terminate
only when the condition in line 6 is not satisﬁed. It means that once while loop terminatesS
contains the IoT devices that will act as initial notiﬁers.
As Algorithm 1 returns the desired output, it is correct.
Proof of Correctness of Algorithm 2: To prove that Algorithm 2 is correct, the following loop invari-
ant is considered:
Loop invariant: In each iteration of forloop of lines 2-19, a price of a single IoT device from among
the IoT device in Sis determined and is added in .
•Initialization: We can start by showing that the loop invariant holds before the ﬁrst iteration of for
loop when =. The output set has no price value for notiﬁers before the ﬁrst iteration. So, the
loop invariant holds.
•Maintenance: For the loop invariant to be true, it is to be shown that before any lthiteration of
theforloop and after lthiteration of the forloop the loop invariant holds. Here, l <jSj. Beforelth
iteration,i:e:till(l 1)thiteration there will be (l 1)prices in a set . Afterlthiteration, the price
vector will contain the prices of lIoT devices. So, the loop invariant holds.
22•Termination: From the construction of Algorithm 2, it is clear that the forloop will terminate only
when the payment of all the IoT devices that acted as the initial notiﬁers are processed.
As, Algorithm 2 returns the desired output, it is correct.
As Algorithm 1 and Algorithm 2 are correct, so as the TENM.
Proposition 1. The mechanism discussed in [Sin12b, Sin10, Sin12a] is truthful.
Corollary 1. TENM is IC.
Proof. From the construction of TENM, it can be seen that TENM consists of notiﬁers allocation mechanism
and notiﬁers pricing mechanism . The notiﬁers allocation mechanism determines the set of IoT devices that
can act as the initial notiﬁers in the social graph. The notiﬁers pricing mechanism is used to determine
the payment of the IoT devices that are acting as the initial notiﬁers. The notiﬁers allocation mechanism
and notiﬁers pricing mechanism of TENM are based on the allocation rule and payment characterization
discussed in [Sin12b] respectively. So, following Proposition 1 it can be inferred that TENM is IC.
Proposition 2. The payment characterization (i.e. each winning IoT device as notiﬁer will be paid how much) is
discussed in [Sin10, Sin12a] is budget feasible.
Corollary 2. The total payment made to the notiﬁers using the notiﬁers pricing mechanism of TENM is within
the available budget.
Proof. The notiﬁers pricing mechanism is utilized to determine the payment of the winning IoT devices
(that are acting as the initial notiﬁers). The payment characterization of the notiﬁers pricing mechanism
is based on the payment characterization of [Sin10, Sin12a]. By Proposition 2, we can infer that TENM
is budget feasible.
Theorem 1. In the given social graph G(NT;RT), the expected number of IoT devices notiﬁed by any ithIoT
device for the task execution process is given as E[Xi]=jZijp. Here,Xiis the indicator random variable that
keeps track of a number of IoT devices that got notiﬁed by any ithIoT device, Ziis the set of IoT devices that
are socially connected to ithIoT device and pis the probability with which the ithIoT device will notify to its
connections.
Proof. In this theorem, we wish to determine that in expectations how many IoT devices will get notiﬁed by
anyithIoT device? The sample space for the event is represented as Uand is given as :
U=fithIoT devicenotifytojthIoT device| {z }
Y; ithIoT devicedonotnotifytojthIoT device| {z }
Yg
The probability that Y takes place is pand the probability that Y does not takes place is (1 p). LetXi
be the random variable whose value will be equal to the number of IoT devices notiﬁed by any ithIoT
device. We let Xj
ibe the indicator random variable associated with the event in which the jthIoT device
is notiﬁed by ithIoT device. Thus, Xj
i=IfYg
Xj
i=(
1;if Y happen.
0;otherwise
As it is known that the expected value of the indicator random variable capturing the event is equal to
the probability of that event [CLRS09]. So, we have
E[Xj
i] =prfYg (4)
23The indicator random variable that we are interested in is given as:
Xi=jZijX
j=1Xj
i
Taking expectations from both sides, we get
E[Xi] =E"jZijX
j=1Xj
i
By linearity of expectation, we have
E[Xi] =jZijX
j=1E[Xj
i] (5)
Substituting the value of equation 4 to equation 5, we have
E[Xi] =jZijX
j=1prfYg
=jZijX
j=1p
=jZijp
Hence proved.
Observation 1. Ifpvalue is considered as1
2, thenE[Xi]will bejZij
2. It means that in expectation half of the
socially connected IoT devices with ithIoT device will be notiﬁed by the ithIoT device. If we consider pvalue as1
9
thenjZij
9IoT devices got notiﬁed about the task execution process by ithIoT device. It means that the higher the p
value higher will be E[Xi]value.
Theorem 2. In TENM, the probability that any ithIoT device notiﬁes about the task execution process to at least
one IoT device is bounded above by 1 
1
exp(jZijdlnjZije)
. Mathematically,
pr(Xi>1)1 1
exp(jZijdlnjZije)
Proof. In this theorem, we are interested in determining what is the probability that any ithIoT device will
notify at least one of the IoT devices in its social connection ? For this purpose, the proof and results presented
in Theorem 1 will be utilized. Notifying jthIoT device by any ithIoT device is independent of notifying
the other IoT devices in Zi. The probability that the ithIoT device has not notiﬁed any of the IoT devices
inZiis:
pr(Xi<1) = (1 p)(1 p):::jZijtimes
= (1 p)jZij(6)
Utilizing the standard inequality 1+ jZijexp(jZij), equation 6 can be written as:
pr(Xi<1)exp ( jZijp)
24=1
exp(jZijp)(7)
Given equation 7 the probability that any ithIoT device will notify at least one IoT device is given as:
pr(Xi1)1 1
exp(jZijp)
(8)
Now if we take p=dlnjZijethen equation 8 will be
pr(Xi1)1 1
exp(jZijdlnjZije)
Hence proved.
Corollary 3. If the value ofjZijfor anyithIoT device is taken as say 5, then
pr(Xi1)1 1
exp(5dln 5e)
= 1 1
3125
= 0:99
From the above calculation, it can be inferred that the probability that one of the IoT devices will be notiﬁed among
jZij= 5is very high.
Proposition 3 (Chernoff Bounds [Rou16a]) .LetX1;X2;:::;Xnbe random variables that have the common
range [0, 1] and X=Pn
i=1Xi. Given the above set-up, for every >0, we have
Pr
X > (1 +)E[X]
<exp((1 +)E[X])
(1 +)(1+)E[X]
(9)
Proof. As the proof is standard, it is omitted from this paper.
Lemma 3. Given a social connection G(NT;RT), the probability that the number of IoT devices that are notiﬁed
by anyithIoT device is greater thanp
jZijlnjZijis given as:
Pr
Xi>p
jZijlnjZij
<expp
jZijlnjZij
p
jZijlnjZijp
jZijlnjZij
where,jZijis the set of IoT devices that are socially connected to ithIoT device.
Proof. To prove the result of Lemma 3, the Chernoff bounds [Rou16a] (Proposition 3) is utilized. Let us
say=p
jZijlnjZij 1, andE[Xi] = 1 . HerejZij>2. Substituting the value of andE[Xi]in
equation 9, we get
Pr
Xi>
1 +p
jZijlnjZij 1
1
=Pr
Xi>p
jZijlnjZij
<exp((1 +)E[X])
(1 +)(1+)E[X]
25=exp
1 +p
jZijlnjZij 1
1

1 +p
jZijlnjZij 1
1+p
jZijlnjZij 1
1
=expp
jZijlnjZij
p
jZijlnjZijp
jZijlnjZij
Hence proved.
Observation 2. If we havep
jZijlnjZij= 3then the probability that any ithIoT device is notifying to at least
3 IoT devices in its social connection is bounded above by is given as:
PrfXi>3g<expp
jZijlnjZij
p
jZijlnjZijp
jZijlnjZij
=exp(3)
(3)3
= 0:7438
Here, it can be seen that with probability at most 0.7438 the ithIoT device will notify about the task execution
process to at least 3 IoT devices in its social connection.
5.2 Analysis of Second Tier
In this, the analysis of the second tier is depicted. In Lemma 4, it is proved that ECTAI and WiPD
run in polynomial time . The correctness of ECTAI and WiPD are discussed in Lemma 5 and Lemma 6
respectively. It is shown that on termination, ECTAI and WiPD give the correct output. In Lemma 7
it is shown any ithIoT device cannot gain by misreporting its peak value i:e:ECTAI is truthful . By
misreporting the private valuation for the set of tasks, the IoT devices cannot gain i:e:WiPD is truthful
is shown in Lemma 8.
Lemma 4. ECTAI and WiPD are computationally efﬁcient.
Proof. The running time of ECTAI and WiPD is the running time of Algorithm 3 and Algorithm 4 re-
spectively. So, let us determine the running time of each of the algorithms one by one.
In line 1 of Algorithm 3, the initialization is done and will take O(1)time. For each iteration of while
loop in lines 2-18, line 3 will take O(n)time. Line 4 is bounded above by O(n). Lines 5-8 are bounded
above byO(g). Line 9 sorts the peak values of the IoT devices and takes O(glgg), wheregis the number
of IoT devices present in R. Lines 10-14 will take O(1)time. Line 15 will take O(f)time. Line 16 will
take constant time. For removing IoT devices from I0, it will take O(n)time. So, the time taken by lines
2-18 for each iteration of while loop is given as O(n) +O(g) +O(glgg) +O(f) +O(1) +O(n) =O(glgg),
ifgis a function of nthen it can be written as O(nlgn). As the while loop will iterate for ntimes, so lines
2-18 are bounded above by O(n2lgn). So, the running time of Algorithm 3 is O(1) +O(n2lgn) +O(1) =
O(n2lgn).
26In Algorithm 4, line 1 will take constant time. Lines 2-4 will iterate for mtimes and are bounded
above byO(m). Lines 5-7 will iterate for Ntimes and are bounded above by O(N), whereNis the
number of quality IoT devices in set O. Let us say the while loop in lines 8-25 iterates for times. For
each iteration of while loop, the forloop in lines 9-24 will iterate for Ntimes. Line 10 is bounded above
byN. Lines 11-17 will take O(1)time. Lines 18 and 19 are bounded above by O(n2). Lines 20-22 will
take constant time. So, lines 9-24 are bounded above by O(m)+O(N)+O(n2) =O(n2)for each iteration
ofwhile loop. So, while loop in lines 8-25 takes O(xn2). Ifxis a fraction of nthen it is rewritten as O(n3).
The time taken by Algorithm 4 is O(1) +O(m) +O(n) +O(n3) +O(1) =O(n3).
From above it can be seen that Algorithm 3 and Algorithm 4 are bounded above by O(n2lgn)and
O(n3). Hence, ECTAI and WiPD are computationally efﬁcient .
Lemma 5. ECTAI works correctly.
Proof. The proof of correctness of ECTAI is done using loop invariant technique [CLRS09].
Proof of Correctness of Algorithm 3: To prove that Algorithm 3 is correct, the following loop invari-
ant is considered:
Loop invariant: In each iteration of while loop of lines 2-18, a set of quality IoT devices is determined
and is added in O.
•Initialization: We can start by showing that loop invariant hold before the ﬁrst iteration of while
loop when O=. The output set Ohas no quality IoT devices before the ﬁrst iteration. So, the
loop invariant holds.
•Maintenance: For the loop invariant to be true, it is to be shown that before any lthiteration of the
while loop and after lthiteration of the while loop the loop invariant holds. Before lthiteration,i:e:
till(l 1)thiteration there will be (l 1)quality IoT devices in a set O. Afterlthiteration, the set
Owill contain lIoT devices. So, the loop invariant holds.
•Termination: From the construction of Algorithm 3, it is clear that the while loop will terminate
only when all the IoT devices are processed for determining the set of quality IoT devices.
Hence, Algorithm 3 is correct and so is the ECTAI.
Lemma 6. WiPD works correctly.
Proof. The proof of correctness of WiPD is done using loop invariant technique [CLRS09].
Proof of Correctness of Algorithm 4: To prove that Algorithm 4 is correct, the following loop invari-
ant is considered:
Loop invariant: In each iteration of while loop of lines 8-25, a set of IoT devices as winners for each
of the tasks are determined and the winner’s payment is decided.
•Initialization: We can start by showing that loop invariant holds before the ﬁrst iteration of while
loop, the setsA=and=. The output sets A=and=have no IoT devices as winners
and no payment. So, the loop invariant holds.
•Maintenance: For the loop invariant to be true, it is to be shown that before any lthiteration of the
while loop and after lthiteration of the while loop the loop invariant holds. Before lthiteration, say,
someksets of tasks of kIoT devices are held in A, andholds the payment of kIoT devices. After
lthiteration, the setAmay contain some (k+x)sets of tasks of (k+x)IoT devices, and the set 
contains the payment of k+xIoT devices. So, the loop invariant holds.
27•Termination: From the construction of Algorithm 4, it is clear that the while loop will terminate
only when the requested set of additional tasks i:e:Fifor allIi2Ois.
Hence, Algorithm 4 is correct, so as the WiPD
Proposition 4. The median voting rule [Rou16c ]is truthful.
Lemma 7. ECTAI is truthful.
Proof. To prove that ECTAI is truthful , it is sufﬁcient to prove that the participating IoT devices are not
gaining by misreporting their privately held peak value. Consider any ithIoT device. Let us say that the
reported peak value of ithIoT device lies to the left of the median ^Ron the scale of [0;1].^Ris obtained
between 0 and 1 on the scale of [0;1]when all the participating IoT devices are reporting their peak value
truthfully . AnyithIoT device can misreport its peak value in two different ways (considered as two cases
in the proof): (1) by reporting a lower peak value from its true peak value, and (2) by reporting a higher
peak value from its true peak value. Let us consider the two cases one by one.
•Case 1 (0
i< i):In this case, it is considered that any ithIoT device reports a lower peak value
from its true peak value. In the case when true peak value was reported, the utility of ithIoT device
is given asui=ji ^Rj. The pictorial representation of the true peak value scenario is depicted in
Figure 12a. Now, when ithIoT device lowers its peak value i:e:0
i<i, in such case the resultant
peak value will be the same as the resultant peak value when ithIoT device reports its peak value
in a truthful manner i:e:^R0=^R. If that is the case, then the utility of ithIoT device will be same as
the utility of ithIoT device when reported truthfully i:e:u0
i=ji ^R0j=ui.
0 1ˆR
αiui=|αi−ˆR|
(a)ithIoT device reporting true peak value
0 1
α′
iˆR=ˆR′
αiu′
i=|αi−ˆR′|=ui(b)ithIoT device misreporting peak value ( 0
i<i)
Figure 12: Pictorial representation of the case when ithIoT device reports true peak value and lower peak value from the true
peak value
•Case 2 (0
i> i):In this case, it is considered that any ithIoT device reports a higher peak value
from its true peak value. In the case when true peak value was reported, the utility of ithIoT device
is given as ui=ji ^Rj. The pictorial representation of the true peak value scenario is depicted
in Figure 12a. Now, when ithIoT device increases its peak value i:e:0
i> iagain the two cases
can occur. In the ﬁrst case, it may happen that the ithIoT device increases its peak value and the
increased peak value still lies on to the left of the resultant peak value obtained when reported
truthfully as depicted in Figure 13a. In such case, the resultant peak value will be the same as the
resultant peak value when the true peak value was reported by ithIoT devicei:e:^R0=^R. If that is
the case, then the utility of ithIoT device will be same as the utility of ithIoT device when reported
truthfullyi:e: u0
i=ji ^R0j=ui. Another case could be that when ithIoT device reported an
increased peak value i:e: 0
i> iand it crosses the resultant peak value obtained when all the
IoT devices were reporting truthfully as depicted in Figure 13b. In such case the resultant peak
value will be shifted to the right of the current resultant peak value as shown in Figure 13b and the
utility ofithIoT device will be u0
i=ji ^R0j> ui. It means that the resultant peak value moved
28away from the true peak value. Hence, it’s a loss. So, with the increase in peak value, the utility of
ithIoT device is remaining the same or is becoming worse.
0 1
αiˆR=ˆR′
α′
iu′
i=|αi−ˆR′|=ui
(a)ithIoT device misreporting peak value ( 0
i>i)
0 1
αiˆR
α′
iu′
i=|αi−ˆR′|> uiˆR′(b)ithIoT device misreporting peak value ( 0
i>i)
Figure 13: Pictorial representation of the case when ithIoT device reports a higher peak value from the true peak value.
From the above-discussed two cases, it can be seen that the participating IoT devices are not gaining by
misreporting their peak value. Hence, ECTAI is truthful .
Lemma 8. WiPD is truthful.
Proof. Fix an IoT device Ii. To prove that WiPD is truthful , the two cases are considered: (1) underbid ,
and (2) overbid . In the ﬁrst case, the ithIoT device decreases its bid value for a set of tasks Ssuch that
v0
i(S)< vi(S). In overbid case, theithIoT device increases its bid value for a set of tasks Ssuch that
v0
i(S)>vi(S). Let us illustrate the two cases.
•Underbid: Let us suppose that ithIoT device misreported his valuation for the set of tasks say
Ssuch thatv0
i(S)< vi(S). In such case two things can happen: (1) it may happen to be the last
iteration and for any ithIoT deviceFi=. It means that none of the IoT devices wants to have an
additional task. In this the ithIoT device is allocated its requested tasks at the priceP
j2S0
i(j)and
hence the utility isP
j2S0
i(j) vi(S)<P
j2Si(j) vi(S) =ui(S;). (2) Another case could be that
due to the lowering of bid value, the ithIoT device has not received any tasks and hence the loser.
In that case, the utility will be 0.
•Overbid: Let us suppose that ithIoT device misreported his valuation for the set of tasks Ssuch
thatv0
i(S)> vi(S). In this case, the two scenarios can occur: (1) if the current iteration is the last,
and after that mechanism terminates. In this case, the ithIoT device is the winner and its utility
will beu0
i(S;) =P
j2Si(j) vi(S) =ui(S;). (2) Another case could be with the increase in bid
values the IoT device fetched some additional sets of tasks but its tasks got fetched by other IoT
devices, so its utility will be 0.
From the above discussion, it can be inferred that IoT devices cannot gain by misreporting their private
value. Hence, WiPD is truthful.
6 Experimental Analysis
In this section, the simulation for the two tiers is carried out independently. For the ﬁrst tier of the
proposed framework, through simulation, TENM is compared with the already existing mechanisms,
namely, non-truthful budget feasible mechanism (NTBFM) and proportional sharemechnaism (PSM) [Sin10].
The comparison is done based on (1) truthfulness, (2) budget feasibility, (3) the number of IoT devices
selected as initial notiﬁers in the social network, and (4) running time. The evaluation metric mentioned
29in point 1 will help us to show that TENM and PSM are truthful and NTBFM is vulnerable to manip-
ulation. The budget feasibility metric mentioned in point 2 will help us to show that NTBFM, PSM,
and TENM are budget feasible. The estimate on the number of IoT devices getting selected as initial
notiﬁers in the case of TENM, PSM, and NTBFM is taken care of by the metric mentioned in point 3. The
evaluation metric mentioned in point 4 will help us to show that TENM is scalable.
In the second tier of the proposed framework, the experiments are carried out to compare ECTAI
and WiPD with the already existing mechanism average voting rule(AVR) and greedy mechanism re-
spectively on the ground of truthfulness . It will help us to show that both ECTAI and WiPD are truthful
as compared to the respective benchmark mechanism. The second metric that is considered for compar-
ing ECTAI and WiPD with the respective benchmark mechanism is the running time of the mechanisms.
It will help us to show that ECTAI and WiPD are scalable.
6.1 Simulation Setup
In this section, the simulation setup for the two independent tiers is discussed one by one. The simula-
tion is carried out by using the software and programming language mentioned in Table 2.
Table 2: Speciﬁcations of the software used in simulation
Software Version
Ubuntu 20.04.4 LTS
Python 3.8.10
Processor Intel Core™ i5-8250U CPU @ 1.60GHz × 8
Gnuplot 5.2
1.Simulation setup for ﬁrst tier - For the simulation purpose we use three real-world data sets by
considering the social connections of the users in Facebook [LK14a], Twitter [LK14b], and Google+
[LK14c], with statistics given in Table 3. It shows the number of nodes ,number of edges , and the cost
range utilized for three different social networks. Each of the three mechanisms is executed for 5
rounds (or iterations) on the data given in Table 3.
Table 3: Simulation parameters used in the ﬁrst tier
Social network name No. of nodes No. of edges Cost range (random distribution)
Facebook 4039 88234 [20;50]
Twitter 81306 1768149 [20;50]
Google+ 107614 13673453 [20;50]
Figure 14: Pictorial representation of users’ social connections on Facebook, Twitter, and Google+
30For comparison purposes, one parameter that is kept intact for the three distinct social networks is
the cost range of IoT devices. For each IoT device, a cost for notifying other IoT devices is picked up
randomly from the given cost range. The unit of cost is the dollar. The pictorial representation of
the social connections of the users in the three different social networking sites is depicted in Figure
14. The reason behind utilizing three different data sets is to strengthen the claim mentioned in the
theoretical analysis part. For comparing TENM, PSM, and NTBFM on the ground of truthfulness
it is considered that 30% of the IoT devices are misreporting their true cost in the case of NTBFM
and is represented as NTBFM-D in the simulation results. Here, misreporting the cost means that
the IoT devices will lower their cost by some ﬁxed amount so that their chance of getting selected
will increase.
2.Simulation setup for second tier - For simulation purposes, each time some 50 IoT devices are
selected randomly for providing ranking over 100 other randomly selected IoT devices that are
placed on the scale of [0;1]. To generate the peak value of the IoT devices we have utilized random
distribution and normal distribution . For the normal distribution, the mean value is taken as = 0:6
and standard deviation = 0:3as shown in Table 4. Similarly, for the second phase of the second
tier, the bid value range that is utilized for random and normal distributions is depicted in Table
4. The reason behind considering the two different probability distributions is to strengthen the
claim made in the theoretical analysis.
Table 4: Data set utilized for simulation in case of ECTAI mechanism
Parameters Values Description
f 100 Number of IoT devices that are to be ranked.
g 50 Number of IoT devices that provide a ranking.
i [0;1] Peak value selected randomly for random distribution.
i [= 0:6;= 0:3] Peak value determination for normal distribution.
vi(S) [30;45] True valuation range for random distribution.
vi(S) [= 37;= 8] True valuation range for normal distribution.
6.2 Baselines
In this section, the baselines that are used for comparing the proposed mechanisms in two tiers are
discussed.
1.Baseline for ﬁrst tier - For comparing the efﬁciency of TENM, we considered two baseline meth-
ods, namely, NTBFM and PSM [Sin10]. In this, NTBFM is non-truthful and PSM is truthful in
nature by their construction and is shown in the simulation results. Both the mechanisms are
budget feasible.
• NTBFM It consists of allocation and payment rules. In the allocation rule , ﬁrstly, the IoT
devices are sorted in descending order of marginal notiﬁcation per cost of IoT devices. From
the sorted ordering, each time an IoT device is picked up and a check is made that, whether,
the cost of the picked-up IoT device is less than or equal to the available budget or not. If it
satisﬁes this condition, then the IoT device is included in the winning set ( i:e:considered as
the initial notiﬁers), and the available budget is reduced by the amount equal to the cost of
the IoT device considered otherwise an allocation rule terminate. The above process continues
till the stopping condition in the allocation rule is satisﬁed. After that, coming to the payment
rule, each of the winning IoT devices is paid an amount equal to their respective reported
cost.
31• PSM [Sin10] The PSM consists of allocation and payment rules. In the allocation rule , the IoT
devices are sorted in descending order of their costs so that c1c2:::cn. Further in
sorted ordering, the largest index kis determined for which ckB
k. The payment of any
winning IoT device iis given as minfB
k;ck+1g.
2.Baseline for second tier - For comparing the efﬁciency of ECTAI, we consider a baseline method,
namely, AVR [Rou16c]. In this, AVR is non-truthful and the manipulative behavior of IoT devices
in the case of AVR is reﬂected in the simulation results. The idea of AVR is quite similar to that of
ECTAI. Steps 1-3 of AVR are exactly the same as for the ECTAI. ECTAI differs from AVR only in
steps 4 and 5. In step 4 of AVR, calculate the average of the peak values reported by gnumber of
IoT devices. In the next step determine the IoT device among the IoT devices that are placed on
the scale of [0;1]whose peak value lies closer to the average peak value. It will be considered a
quality IoT device. Repeat steps 1-5 of AVR until all the IoT devices are ranked.
For comparing the efﬁciency of WiPD, we consider the baseline method as a greedy mechanism
(in simulation graphs it is named GREEDY). It is to be noted that the proposed greedy mechanism
is non-truthful in nature. The idea of the greedy mechanism is: (1) IoT devices are sorted in
ascending order of the ratio of valuation to square root of the number of reported sets of tasks. (2)
Each time, an ithIoT device is picked-up from the sorted ordering, and a check is made whether
the intersection of tasks of the IoT devices present in the winning set and currently considered IoT
device requested set of task is or not. If it is thenithIoT device is considered in the winning
set, otherwise not. (3) The payment of the winning IoT devices will be their respective bid value.
6.3 Performance Analysis
In this section, the performance analysis of TENM, ECTAI, and WiPD is carried out based on the metrics
mentioned in Section 6 above. First, the performance analysis of TENM is presented and after that, the
performance analysis of ECTAI and WiPD is discussed.
1.Performance analysis of TENM on Facebook, Twitter, and Google+ data sets. The performance
of TENM is compared with the existing works (NTBFM and PSM) in the scenario discussed in the
ﬁrst tier of the proposed model. The discussion mainly circumvents around the metrics given in
Section 6 for the ﬁrst tier.
•Truthfulness - The simulation results shown in Figure 15 show the comparison of TENM with
the two benchmark mechanisms i:e:NTBFM and PSM on the ground of utility of notiﬁers.
The x-axis of the graphs represents the iteration (or round) number and the y-axis of the
graphs represents the utility of notiﬁers. Fixing the available budget Bto 15000$. It is evident
from Figure 15 that in the case of TENM, the utility of IoT devices is sometimes higher and
sometimes lower than in the case of PSM for all three data sets. This nature of the graphs is
appearing from the construction of mechanisms.
 0 10000 20000 30000 40000
1st2nd 3rd4th5thUtility of Notifiers
IterationFacebook dataset and B = 15,000$
TENM
PSM
NTBFM
NTBFM-D
 0 10000 20000 30000 40000
1st2nd 3rd4th5thUtility of Notifiers
IterationTwitter dataset and B = 15,000$
TENM
PSM
NTBFM
NTBFM-D
 0 10000 20000 30000 40000
1st2nd 3rd4th5thUtility of Notifiers
IterationGoogle+ dataset and B = 15,000$
TENM
PSM
NTBFM
NTBFM-D
Figure 15: Comparison of TENM, NTBFM, NTBFM-D, and PSM on Facebook, Twitter, and Google+ data in terms of the
utility of notiﬁers.
32For NTBFM, the IoT devices will have zero utility because the payment made to the winning
IoT devices is equal to the respective cost revealed by them as shown in Figure 15. However,
NTBFM is vulnerable to manipulation, which means that the IoT devices can gain by misre-
porting (in this case, 30% of the IoT devices are reporting their cost below the true cost by
some amount) their privately held cost. It can be easily seen in Figure 15 that for all three
data sets the IoT devices to have higher utility in the case of NTBFM when misreporting (it is
represented as NTBFM-D in the graphs) than the case when all the participating IoT devices
report truthfully. So, the participating IoT devices gain by misreporting their true value in
the case of NTBFM. From the simulation results, it can be inferred that TENM and PSM are
truthful and NTBFM is vulnerable to manipulation.
•Budget feasibility: The simulation results presented in Figure 16 shows the comparison of
TENM with the benchmark mechanisms i:e:NTBFM and PSM on the ground of budget feasi-
bility . The x-axis of the graphs represents the iteration number and the y-axis of the graphs
represent the total payment in dollars. In Figure 16 it can be seen that the total payment made
to the winning IoT devices in the case of PSM is sometimes higher and sometimes lower than
the total payment made to the IoT devices in the case of TENM. This nature of the graphs
is evident from the construction of the two mechanisms i:e:TENM and PSM. On the other
hand, NTBFM has the highest value for the total payment made to the IoT devices among
the three mechanisms. It is due to multiple reasons: (1) the full available budget is utilized
for deciding the winners, and (2) the available budget is draining out slowly which leads to a
larger number of IoT devices getting selected as initial notiﬁers. As the number of IoT devices
getting selected is higher in the case of NTBFM and so is the total payment. From the con-
struction of the three mechanisms it is clear that the total payment made to the IoT devices
will be below the available budget and is also depicted in Figure 16. So, TENM, PSM, and
NTBFM are budget feasible.
 15000 20000 25000 30000 35000
1st 2nd 3rd 4th 5thTotal Payment (in dollars)
IterationFacebook dataset
TENM
NTBFM
PSM
Available Budget
 15000 20000 25000 30000 35000
1st 2nd 3rd 4th 5thTotal Payment (in dollars)
IterationTwitter dataset
TENM
NTBFM
PSM
Available Budget
 15000 20000 25000 30000 35000
1st 2nd 3rd 4th 5thTotal Payment (in dollars)
IterationGoogle dataset
TENM
NTBFM
PSM
Available Budget
Figure 16: Comparison of TENM, NTBFM, NTBFM-D, and PSM on Facebook, Twitter, and Google+ data in terms of budget
feasibility.
•Number of IoT devices selected as initial notiﬁers in the social network: In Figure 17 the
comparison of TENM, NTBFM, and PSM is done on the ground of the number of IoT devices
got selected as initial notiﬁers. In Figure 17 the x-axis of the graphs represents the budget and
the y-axis of the graphs represents the number of notiﬁers selected. The comparison is carried
out for three different social networks i:eFacebook, Twitter, and Google+. From Figure 17,
it can be seen that the number of IoT devices selected as notiﬁers in the case of NTBFM is
more than the number of IoT devices selected as notiﬁers in the case of TENM and is more
than the number of IoT devices selected as notiﬁers in case of PSM for all the three data sets.
This nature is due to the fact that in the case of NTBFM, the overall budget is utilized in
the allocation rule and it is eaten away slowly than in the case of TENM where the budget
33allocation rule starts with half of the available budget and as the algorithm progresses the
budget drains out very fast and less number of IoT devices get selected. On the other hand,
in the case of PSM, the allocation rule starts with the full budget but in each iteration, the
available budget drains out faster than in the case of TENM and NTBFM. So, due to this
reason less number of IoT devices get selected. So, fewer IoT devices get notiﬁed about the
task execution process.
 0 100 200 300 400 500 600 700 800
5000 10000 15000 20000 25000No. of Notifiers Selected
Budget (in dollar)Facebook dataset
TENM
PSM
NTBFM
 0 100 200 300 400 500 600 700 800
5000 10000 15000 20000 25000No. of Notifiers Selected
Budget (in dollar)Twitter dataset
TENM
PSM
NTBFM
 0 100 200 300 400 500 600 700 800
5000 10000 15000 20000 25000No. of Notifiers Selected
Budget (in dollar)Google+ dataset
TENM
PSM
NTBFM
Figure 17: Comparison of TENM, NTBFM, and PSM on Facebook, Twitter, and Google+ data in terms of the number of IoT
devices selected as initial notiﬁers in the social network.
•Running time: In Figure 18 the execution time (or running time) of TENM is compared with
the execution time of NTBFM and PSM. The x-axis of the graph shown in Figure 18 represents
the budget in dollars and the y-axis represents running time in milliseconds. The simulation
results show that TENM takes more time than PSM and NTBFM for providing the desired
results. The reason behind the higher running time for TENM is both allocation and pricing
mechanisms. In the allocation rule of TENM, most of the time is killed up in calculating the
marginal notiﬁcation of each of the nodes in the social graph. Similar is the reason for the
pricing mechanism of TENM, in this, the IoT device for whom the payment is calculated is
dragged out of the crowdsourcing market and again the allocation rule is executed on the
remaining IoT devices. The process is repeated for all the winning IoT devices. In the case
of PSM, the payment is the minimum of the two quantitiesB
kandck+1. So, this payment
calculation takes time less than the payment calculation for TENM. On the other hand, in the
case of NTBFM, the payment is the reported cost of the IoT devices and so takes the lowest
time. From the above discussion, it can be inferred that TENM running time is the highest
among all the three mechanisms. From the simulation graphs, it can be seen that all three
mechanisms are scalable.
 0 10 20 30 40 50 60 70
0 5000 10000 15000 20000 25000Running time (in millisecond)
Budget (in Dollar)Facebook dataset
TENM
NTBFM
PSM
 0 10 20 30 40 50 60 70
0 5000 10000 15000 20000 25000Running time (in millisecond)
Budget (in Dollar)Twitter dataset
TENM
NTBFM
PSM
 0 10 20 30 40 50 60 70
0 5000 10000 15000 20000 25000Running time (in millisecond)
Budget (in Dollar)Google dataset
TENM
NTBFM
PSM
Figure 18: Comparison of TENM, NTBFM, NTBFM-D, and PSM on Facebook, Twitter, and Google+ data in terms of
execution time.
342.Performance analysis of ECTAI and WiPD. The performance of ECTAI and WiPD is compared
with AVR and GREEDY respectively. The discussion mainly circumvents around the metrics given
in Section 6 for the second tier.
•Truthfulness: The simulation results shown in Figure 19 show the comparison of ECTAI with
AVR on the ground of truthfulness for both random and normal distributions. The x-axis of
the graphs represents the number of IoT devices and the y-axis represents the utility of IoT
devices that are ranked. In the case of ECTAI, the resultant peak value will be sometimes
lower and sometimes higher than in the case of AVR, and so as the utility of the IoT devices
as shown in Figure 19. This nature of the graphs is from the construction of the mechanisms.
In the case of ECTAI and AVR, the higher the utility value lower will be the quality of the
IoT devices, and the lower the utility value higher will be the quality of IoT devices. Further,
in the graphs of Figure 19 the manipulative behavior of IoT devices can be seen in the case
of AVR. If 30% of the IoT devices misreport (reporting the peak value closer to its favorite
IoT device) their peak value then the total utility of the IoT devices will drop down and
will be sometime less as compared to the case when all the IoT devices are reporting their
true peak value. This manipulative nature of AVR can be seen for both random and normal
distributions in Figure 19. From the above discussion, one can say that AVR is vulnerable to
manipulation but ECTAI is not.
 0 2 4 6 8 10
513 717 813 946 1017Utility of IoT devcies
#IoT devicesRondom distribution of peak value in [0,1]
ICTAI
AVR
AVR-D
 0 2 4 6 8 10
513 717 813 946 1017Utility of IoT devcies
#IoT devicesNormal distribution of peak value in [0,1]
ICTAI
AVR
AVR-D
Figure 19: Comparison of ECTAI, AVR, and AVR-D in terms of the utility of IoT devices in random and normal distribution
cases.
 0 100 200 300 400 500 600
500 1000 1500 2000 2500Utility of IoT devices
#IoT devicesRD bid value range [30, 45]
WiPD
GREEDY
GREEDY-D
 0 100 200 300 400 500 600
500 1000 1500 2000 2500Utility of IoT devices
#IoT devicesND bid value range [30, 45], mean = 37, SD = 8
WiPD
GREEDY
GREEDY-D
Figure 20: Comparison of WiPD, GREEDY, GREEDY-D in terms of the utility of IoT devices in random and normal
distribution cases.
35The simulation results shown in Figure 20 show the comparison of WiPD with GREEDY on
the ground of truthfulness for both random and normal distributions. The x-axis of the graphs
represents the number of IoT devices and the y-axis represents the utility of IoT devices. In
this case, the utility of IoT devices is calculated by utilizing the formula given in equation 2. It
can be seen from Figure 20 that the utility of IoT devices in the case of WiPD is higher than in
the case of GREEDY. It is zero in the case of GREEDY. It is due to the reason that in the case of
GREEDY, the payment made to the IoT devices is their reported bid value and so the utility is
0. Further, in the graphs of Figure 20 the manipulative behavior of IoT devices can be seen in
the case of the greedy mechanism (named GREEDY-D in the graphs of Figure 20). If 30% of
the IoT devices misreport (reporting the bid value higher than their true valuation) their true
valuation then the total utility of the IoT devices will go up and will be more as compared
to the case when all the IoT devices were reporting their true bid value. This manipulative
nature of GREEDY can be seen in both random and normal distributions. Hence, GREEDY is
vulnerable to manipulation and WiPD is not vulnerable to manipulation.
•Running time: In Figure 21a the execution time (or running time) of ECTAI is compared with
the execution time of AVR. The x-axis of the graph shown in Figure 21a represents the number
of IoT devices and the y-axis represents running time in milliseconds. The simulation results
show that ECTAI and AVR take almost the same time for providing the desired results. The
reason is that in both the mechanism a simple arithmetic operation takes place and it takes
constant time as mentioned in Lemma 4. The above-discussed scenario is depicted in Figure
21a. From the simulation graphs, it can be seen that both ECTAI and AVR are scalable.
 0 1 2 3 4 5
0 513 717 813 946 1017Running time (in millisecond)
#IoT DevicesECTAI
AVR
(a) Running time analysis of ECTAI and AVR
 0 2 4 6 8 10
0 500 1000 1500 2000 2500Running time (in millisecond)
#IoT DevicesWiPD
GREEDY (b) Running time analysis of WiPD and GREEDY
Figure 21: Comparison of ECTAI and AVR, WiPD and GREEDY in terms of execution time.
In the case of WiPD and GREEDY, the comparison based on running time is shown in Figure 21b.
The x-axis of the graph shown in Figure 21b represents the number of IoT devices and the y-axis
represents running time in milliseconds. The simulation results show that WiPD takes more time
than GREEDY. The reason is that in the case of WiPD deciding the set of tasks to be assigned to
the IoT devices and the payment to be made to them takes more time. In the case of GREEDY the
allocation rule takes time but the payment rule is simple and takes less time. The above-discussed
scenario is depicted in Figure 21b. From the simulation graphs, it can be seen that both WiPD and
GREEDY are scalable.
7 Conclusion and Future Works
In this paper, one of the crowdsourcing scenarios is studied as a two-tiered process in strategic setting.
In the ﬁrst tier of the proposed framework, the social connections of the IoT devices are utilized to make
36other IoT devices aware of the task execution event. For this purpose a truthful mechanism namely
TENM is proposed for identifying the initial notiﬁers such that the total payment made to the initial
notiﬁers for their services is within the available budget. Once a substantial number of IoT devices got
notiﬁed about the task execution process, in the second tier, the truthful mechanisms namely ECTAI and
WiPD are proposed that determine the quality of IoT devices and assign a subset of tasks to each of
the quality IoT devices respectively. For the second tier of the proposed model, we assumed that the
valuation function is gross substitute .
Through theoretical analysis, it is shown that the proposed mechanisms are correct ,computationally
efﬁcient , and truthful . Further, through probabilistic analysis, the estimate is done on the number of task
executors that get notiﬁed about the task execution process. The simulation result shows that in the ﬁrst
tier, in the case of NTBFM the IoT devices are gaining by misreporting their costs, whereas in the case
of TENM and PSM the IoT devices can maximize their utility only by reporting a true cost. The reason
is that NTBFM is vulnerable to manipulation and TENM is not vulnerable to manipulation. Further, the
results show that TENM, NTBFM, and PSM are budget feasible. With the increase in budget, the num-
ber of IoT devices selected as initial notiﬁers in a social network is increasing for all three mechanisms
i.e. TENM, PSM, and NTBFM. Further, the comparison is done in terms of execution time, and found
that TENM, NTBFM, and PSM are scalable. In the second tier, ECTAI and WiPD are compared to their
respective benchmark mechanism on the ground of truthfulness and running time. In the case of ECTAI
the IoT devices can maximize their utility only by reporting their true peak value. On the other hand
in the case of AVR, the IoT devices gain by misreporting their true peak value. It is due to the reason
that AVR is vulnerable to manipulation. In terms of running time, both ECTAI and AVR take almost
the same time. In the case of WiPD the IoT devices can maximize their utility only by reporting their
valuation. On the other hand in the case of GREEDY, the IoT devices gain by misreporting their true
valuation. It is because of this reason that GREEDY is vulnerable to manipulation. In terms of running
time, GREEDY outperforms WiPD but both are scalable.
In the future it will be interesting to see if the above-discussed set-up can be extended to the case
where IoT devices have general valuations (not GS). It poses the challenge of designing a truthful mech-
anism (right now the truthful mechanism is guaranteed only when the IoT devices have GS valuations).
Another direction could be, say, in addition to the above set-up each of the tasks has a start time and
ﬁnish time associated with it. In such cases designing a time-bound truthful mechanism will be a chal-
lenging task. In our upcoming work, the focus will be on designing a truthful mechanism for the above-
mentioned scenario that also takes care of the quality of the IoT devices and the completion of tasks
within the given start and ﬁnish times.
The results, the code, the real-world data, and the synthetic data that are utilized in the paper are
made available at https://github.com/chbhargavi/IoT_Elseiver .
Acknowledgment
The authors would like to thank the Centre of Excellence for the Internet of Things (CoE-IoT) of VIT-AP
University, Amaravati, India for providing valuable suggestions and support.
References
[AD22] Lamine Amour and Abdulhalim Dandoush. Crowdsourcing based performance analysis
of mobile user heterogeneous services. Electronics , 11(7):1011, 2022.
[AEK+18] Khalid Abualsaud, Tarek M Elfouly, Tamer Khattab, Elias Yaacoub, Loay Sabry Ismail, Mo-
hamed Hossam Ahmed, and Mohsen Guizani. A survey on mobile crowd-sensing and its
applications in the iot era. Ieee access , 7:3855–3881, 2018.
37[ASN22] Kenneth Li Minn Ang, Jasmine Kah Phooi Seng, and Ericmoore Ngharamike. Towards
crowdsourcing internet of things (crowd-iot): Architectures, security and applications. Fu-
ture Internet , 14(2):49, 2022.
[CGV21] Livio Cricelli, Michele Grimaldi, and Silvia Vermicelli. Crowdsourcing and open innova-
tion: a systematic literature review, an integrated framework and a research agenda. Review
of Managerial Science , pages 1–42, 2021.
[CLRS09] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to algorithms . MIT
press, 2009.
[DKP+20] V . S. Dasari, B. Kantarci, M. Pouryazdan, L. Foschini, and M. Girolami. Game theory in
mobile crowdsensing: A comprehensive survey. Sensors , 20(7), 2020.
[DTY+17] Z. Duan, L. Tian, M. Yan, Z. Cai, Q. Han, and G. Yin. Practical incentive mechanisms for
iot-based mobile crowdsensing systems. IEEE Access , 5:20383–20392, 2017.
[EOS+23] Nada Elsokkary, Hadi Otrok, Shakti Singh, Rabeb Mizouni, Hassan Barada, and Mo-
hammed Omar. Crowdsourced last mile delivery: Collaborative workforce assignment.
Internet of Things , page 100692, 2023.
[FSS+22] Xiu Fang, Suxin Si, Guohao Sun, Quan Z Sheng, Wenjun Wu, Kang Wang, and Hang Lv.
Selecting workers wisely for crowdsourcing when copiers and domain experts co-exist.
Future Internet , 14(2):37, 2022.
[Fuj20] Akihiro Fujihara. Powap: Proof of work at proximity for a crowdsensing system for collab-
orative trafﬁc information gathering. Internet Things , 10:100046, 2020.
[GNS14] G. Goel, A. Nikzad, and A. Singla. Mechanism design for crowdsourcing markets with
heterogeneous tasks. In Proceedings of the Second AAAI Conference on Human Computation
and Crowdsourcing, HCOMP 2014, November 2-4, 2014, Pittsburgh, Pennsylvania, USA , 2014.
[GS20] Xiaowen Gong and Ness B. Shroff. Truthful data quality elicitation for quality-aware data
crowdsourcing. IEEE Transactions on Control of Network Systems , 7(1):326–337, 2020.
[HKG22] Danula Hettiachchi, Vassilis Kostakos, and Jorge Goncalves. A survey on task assignment
in crowdsourcing. ACM Comput. Surv. , 55(3), feb 2022.
[JNX+22] Lingyun Jiang, Xiaofu Niu, Jia Xu, Dejun Yang, and Lijie Xu. Incentive mechanism design
for truth discovery in crowdsourcing with copiers. IEEE Transactions on Services Computing ,
15(5):2838–2853, 2022.
[JVLL12] Luis G Jaimes, Idalides Vergara-Laurens, and Miguel A Labrador. A location-based incen-
tive mechanism for participatory sensing systems with budget constraints. In 2012 IEEE
International Conference on Pervasive Computing and Communications , pages 103–108. IEEE,
2012.
[KEJ22] Jong Wook Kim, Kennedy Edemacu, and Beakcheol Jang. Privacy-preserving mechanisms
for location privacy in mobile crowdsensing: A survey. Journal of Network and Computer
Applications , page 103315, 2022.
[KOS11] David R. Karger, Sewoong Oh, and Devavrat Shah. Budget-optimal crowdsourcing using
low-rank matrix approximations. In 2011 49th Annual Allerton Conference on Communication,
Control, and Computing (Allerton) , pages 284–291, 2011.
38[LFW+22] Xiang Liu, Chenchen Fu, Weiwei Wu, Minming Li, Wanyuan Wang, Vincent Chau, and Jun-
zhou Luo. Budget-feasible mechanisms in two-sided crowdsensing markets: Truthfulness,
fairness, and efﬁciency. IEEE Transactions on Mobile Computing , 2022.
[LK14a] Jure Leskovec and Andrej Krevl. SNAP Datasets: Stanford large network dataset collection.
http://snap.stanford.edu/data/ego-Facebook.html , June 2014.
[LK14b] Jure Leskovec and Andrej Krevl. SNAP Datasets: Stanford large network dataset collection.
http://snap.stanford.edu/data/ego-Twitter.html , June 2014.
[LK14c] Jure Leskovec and Andrej Krevl. SNAP Datasets: Stanford large network dataset collection.
http://snap.stanford.edu/data/ego-Gplus.html , June 2014.
[LKLJ15] Donghyeon Lee, Joonyoung Kim, Hyunmin Lee, and Kyomin Jung. Reliable multiple-
choice iterative algorithm for crowdsourcing systems. SIGMETRICS Perform. Eval. Rev. ,
43(1):205–216, jun 2015.
[LL17] Yang Liu and Mingyan Liu. An online learning approach to improving the quality of
crowd-sourcing. IEEE/ACM Transactions on Networking , 25(4):2166–2179, 2017.
[LLZ23] Zhuo Li, Zecheng Li, and Wei Zhang. Quality-aware task allocation for mobile crowd
sensing based on edge computing. Electronics , 12(4), 2023.
[ML22] T. S. H. Mak and A. Y. S. Lam. Two-stage auction mechanism for long-term participation in
crowdsourcing. Transactions on Computational Social Systems , pages 1–14, 2022.
[Mou80] H. Moulin. On strategy-proofness and single peakedness. Public Choice , 35(4):437–455, 1980.
[MSPK22] Jaya Mukhopadhyay, Vikash Kumar Singh, Anita Pal, and Abhishek Kumar. A truthful
budget feasible mechanism for iot-based participatory sensing with incremental arrival of
budget. Journal of Ambient Intelligence and Humanized Computing , 13:1107–1124, Feb 2022.
[N.N07] N.Nisan. Algorithmic Game Theory , chapter Introduction to Mechanism Design, pages 209–
242. Cambridge University Press, New York, 2007.
[PL18] Jurairat Phuttharak and Seng W Loke. A review of mobile crowdsourcing architectures and
challenges: Toward crowd-empowered internet-of-things. Ieee access , 7:304–324, 2018.
[QZH+22] Yu Qiao, Jie Zhang, Qiangqiang He, Yi Gu, Jun Wu, Lei Zhang, and Chongjun Wang. Truth-
ful proﬁt maximization mechanisms for mobile crowdsourcing. Wireless Communications
and Mobile Computing , 2022, 2022.
[Rou14] T. Roughgarden. CS364B: Frontiers in mechanism design, (Stanford University Course),
Lecture #5: he gross substitutes condition, January 2014.
[Rou16a] T. Roughgarden. CS261: A second course in algorithms (Stanford University course), 2016.
Lecture #18: Five Essential Tools for the Analysis of Randomized Algorithms.
[Rou16b] T. Roughgarden. CS269I: Incentives in computer science (Stanford University course), 2016.
Lecture 3: Strategic Voting.
[Rou16c] T. Roughgarden. Cs269i: Incentives in computer science (stanford university lecture notes),
2016. Lecture 3: Strategic Voting.
[Sin10] Y. Singer. Budget feasible mechanisms. In Proceedings of the 2010 IEEE 51stAnnual Sympo-
sium on Foundations of Computer Science , FOCS ’10, pages 765–774, Washington, DC, USA,
2010. IEEE Computer Society.
39[Sin12a] Y. Singer. How to win friends and inﬂuence people, truthfully: Inﬂuence maximization
mechanisms for social networks. In Proceedings of the 5thInternational Conference on Web
Search and Data Mining , WSDM ’12, pages 733–742, New York, NY, USA, 2012. ACM.
[Sin12b] Yaron Singer. How to win friends and inﬂuence people, truthfully: inﬂuence maximization
mechanisms for social networks. In Proceedings of the ﬁfth ACM international conference on
Web search and data mining , pages 733–742, 2012.
[SJSM22] Vikash Kumar Singh, Anjani Samhitha Jasti, Sunil Kumar Singh, and Sanket Mishra. Quad:
A quality aware multi-unit double auction framework for iot-based mobile crowdsensing
in strategic setting. arXiv preprint arXiv:2203.06647 , 2022.
[SMXK20] V . K. Singh, S. Mukhopadhyay, F. Xhafa, and P . Krause. A quality-assuring, combinatorial
auction based mechanism for IoT-based crowdsourcing. In Advances in Edge Computing:
Massive Parallel Processing and Applications , volume 35, pages 148–177. IOS Press, 2020.
[SMXS20] Vikash Kumar Singh, Sajal Mukhopadhyay, Fatos Xhafa, and Aniruddh Sharma. A budget
feasible peer graded mechanism for iot-based crowdsourcing. Journal of Ambient Intelligence
and Humanized Computing , 11(4):1531–1551, Jan 2020.
[VNTS+22] Hamed Vahdat-Nejad, Tahereh Tamadon, Fatemeh Salmani, Sajedeh Abbasi, Fateme-Sadat
Seyyedi, et al. A survey on crowdsourcing applications in smart cities. arXiv preprint
arXiv:2204.05421 , 2022.
[WHW+21] Zhibo Wang, Yuting Huang, Xinkai Wang, Ju Ren, Qian Wang, and Libing Wu. Socialre-
cruiter: Dynamic incentive mechanism for mobile crowdsourcing worker recruitment with
social networks. IEEE Transactions on Mobile Computing , 20(5):2055–2066, 2021.
[XCX+17] Liang Xiao, Tianhua Chen, Caixia Xie, Huaiyu Dai, and H Vincent Poor. Mobile crowdsens-
ing games in vehicular networks. IEEE Transactions on Vehicular Technology , 67(2):1535–1545,
2017.
[XLG+22] Jia Xu, Zhuangye Luo, Chengcheng Guan, Dejun Yang, Linfeng Liu, and Yan Zhang. Hir-
ing a team from social network: Incentive mechanism design for two-tiered social mobile
crowdsourcing. IEEE Transactions on Mobile Computing , pages 1–1, 2022.
[XZC+21] Jia Xu, Yuanhang Zhou, Gongyu Chen, Yuqing Ding, Dejun Yang, and Linfeng Liu. Topic-
aware incentive mechanism for task diffusion in mobile crowdsourcing through social net-
work. ACM Trans. Internet Technol. , 22(1), dec 2021.
[YCS22] Akash Yadav, Joydeep Chandra, and Ashok Singh Sairam. A budget and deadline aware
task assignment scheme for crowdsourcing environment. IEEE Transactions on Emerging
Topics in Computing , 10(2):1020–1034, 2022.
40
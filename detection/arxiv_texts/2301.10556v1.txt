Synthesis with Explicit Dependencies?
Priyanka Golia1;2, Subhajit Roy1, and Kuldeep S. Meel2
1Indian Institute of Technology Kanpur, India
2National University of Singapore, Singapore
Abstract. Quantied Boolean Formulas (QBF) extend propositional
logic with quantication 8;9. In QBF, an existentially quantied vari-
able is allowed to depend on all universally quantied variables in its
scope. Dependency Quantied Boolean Formulas (DQBF) restrict the
dependencies of existentially quantied variables. In DQBF, existentially
quantied variables have explicit dependencies on a subset of universally
quantied variables, called Henkin dependencies. Given a Boolean spec-
ication between the set of inputs and outputs, the problem of Henkin
synthesis is to synthesize each output variable as a function of its Henkin
dependencies such that the specication is met. Henkin synthesis has
wide-ranging applications, including verication of partial circuits, con-
troller synthesis, and circuit realizability.
This work proposes a data-driven approach for Henkin synthesis called
Manthan3. On an extensive evaluation of over 563 instances arising from
past DQBF solving competitions, we demonstrate that Manthan3 is com-
petitive with state-of-the-art tools. Furthermore, Manthan3 could syn-
thesize Henkin functions for 26 benchmarks for which none of the state-
of-the-art techniques could synthesize.
1 Introduction
Quantied Boolean Formulas (QBF) equip the propositional logic with universal
(8) and existential quantiers ( 9) for propositional variables. In QBF, an exis-
tentially quantied variable is allowed to depend on all universally quantied
variables within its scope. On the other hand, Henkin quantiers, often called
Branching quantiers, generalize the standard quantication and allow explicit
declarations of dependencies [30]. Propositional logic is equipped with Henkin
quantiers, resulting in the so-called Dependency Quantied Boolean Formulas
(DQBFs). In DQBF, an existentially quantied variable is allowed to depend on
a pre-dened subset of universally quantied variables, called Henkin dependen-
cies. For example, :8x1;x29x1y1:'(x1;x2;y1) is a DQBF formula, where 'is
some quantier-free Boolean formula and existentially quantied variable y1is
only allowed to depend on x1, which is the Henkin dependency corresponding to
y1. The dependency specication quantication is called Henkin quantier [30].
?To be appeared at DATE 2023. Manthan3 is available open-sourced at https://
github.com/meelgroup/manthan .arXiv:2301.10556v1  [cs.LO]  25 Jan 20232 Golia, Roy, and Meel
These explicit dependencies provide more succinct descriptive power to DQBF
than QBF. However, DQBF is shown to be in the complexity class of NEXPTIME-
complete [35], whereas QBF is only PSPACE-complete [15]. The payos asso-
ciated with an increase in the computational complexity are the wide-ranging
applications of DQBF, such as engineering change of order [28], topologically
constrained synthesis [6], equivalence checking of partial functions [16], nding
strategies for incomplete games [35], controller synthesis [9], circuit realizabil-
ity [6], and synthesis of fragments of linear-time temporal logic [10].
The DQBF satisability is a decision problem that looks for an answer to the
question: Does there exist a function corresponding to each existentially quanti-
ed variable, in terms of its Henkin dependencies, such that the formula substi-
tuted with the function in places of existentially quantied variables is a tautol-
ogy? Owing to wide variety of applications that can be represented as DQBF,
recent years have seen a surge of interest in DQBF solving [16,14,40,43,44]. In
many cases, a mere True/False answer is not sucient as one is often interested
in determining the denitions corresponding to those functions. For instance, in
the context of engineering change of order (ECO), in addition to just knowing
whether the given circuit could be rectied to meet the golden specication, one
would also be interested in deriving corresponding patch functions [28]. Owing to
the naming of dependencies, we call such patch functions to be Henkin functions.
Recent years have witnessed an increased interest in the problem of Henkin
function synthesis. The state-of-the-art techniques, HQS2 [44] and Pedant [40]
can synthesize Henkin functions for True DQBF in addition to DQBF solv-
ing. HQS2 [45] applies a sequence of transformations to eliminate quantiers
in DQBF instances to synthesize Henkin functions for True instances, whereas
Pedant [40] uses interpolation-based denition extraction and various SAT or-
acle calls to synthesize Henkin functions. Despite the signicant progress over
the years, many real-world instances are beyond the reach of Henkin function
synthesis engines.
In this work, we take a step to push the envelope of Henkin synthesis. To
this end, we propose a novel framework for Henkin function synthesis, called
Manthan3. Manthan3 takes an orthogonal approach to the existing techniques
by combining advances in machine learning with automated reasoning. In par-
ticular, Manthan3 uses constrained sampling to generate the data, which is later
fed to a machine-learning algorithm to learn the candidate functions in accor-
dance with the Henkin dependencies for each existentially quantied variable.
Then, Manthan3 employs a SAT solver to check the correctness of the syn-
thesized candidates. If the candidate verication checks fail, Manthan3 does
a counterexample-driven candidate repair. Furthermore, Manthan3 utilizes a
MaxSAT solver-based method to nd the candidates that need to undergo repair
and uses a proof-guided strategy to construct a good repair.
To demonstrate the practical eciency of Manthan3, we perform an extensive
comparison with the prior state-of-the-art techniques, HQS2 and Pedant, over a
benchmark suite of 563 instances. Our empirical evaluation demonstrates that
Manthan3 shows competitive performance and signicantly contributes to theSynthesis with Explicit Dependencies 3
portfolio of Henkin synthesizers. Manthan3 achieves the shortest synthesizing
time on 42 of the 204 benchmarks solved by at least one tool. Furthermore,
Manthan3 is able to synthesize Henkin functions for 26 instances that none of
the state-of-the-art function synthesis engines could synthesize.
2 Preliminaries
We use a lower case letter to represent a propositional variable and an upper case
letter to represent a set of variables. A literal is either a variable or its negation,
and a clause is considered as a disjunction of literals. A formula 'represented as
conjunction of clauses is considered in Conjunctive Normal Form (CNF). Vars (')
represents the set of variables appearing in '. A satisfying assignment( ) of the
formula'maps Vars (') tof0;1gsuch that'evaluates to True under . We
usej='to represent as a satisfying assignment of '. For a set of variables
V, we used[V] to denote the restriction of toV. If'evaluates to True for
all possible valuation of Vars ('),'is considered as tautology.
A uniform sampler samples the required number of satisfying assignments
uniformly at random from the solution space of the formula. We use UnsatCore
to represents an unsatisable core , which is a subset of clauses of 'for which
there does not exists a satisfying assignment. For a CNF formula in which a
set of clauses is considered as hard constraints and remaining clauses as soft
constraints, a MaxSAT solver tries to nd a satisfying assignment that satises
all hard constraints and maximizes the number of satised soft constraints.
A formulais DQBF if it can be represented as :8x1:::x n9H1y1:::9Hmym
'(X;Y ) whereX=fx1;:::;x ng,Y=fy1;:::;y mgandHiXrepresents the
dependency set of yi, that is, variable yican only depend on Hi. EachHiis called
Henkin dependency and each quantier 9Hiis called Henkin quantier [22].
A DQBFis considered to be True, if there exists a function fi:f0;1gjHij7!
f0;1gfor each existentially quantied variable yi, such that'(X;f 1(H1);:::;f m(Hm)),
obtained by substitution of each yiby its corresponding function fi, is a tau-
tology. Given a DQBF , the problem of DQBF satisability, is to determine
whether a given DQBF is True or False.
Problem Statement: Given a True DQBF 8x1:::x n9H1y1:::9Hmym'(x1;:::
;xn;y1;:::;y m) wherex1;:::;x n2X,y1;:::;y m2Y,HiX, the problem of
Henkin Synthesis is to synthesize a function vector f:hf1;:::;f misuch that
'(X;f 1(H1); :::;f m(Hm)) is a tautology.
fis called Henkin function vector and each fiis a Henkin function. We used
8X9H1y1:::9Hmym'(x1;:::;x n;y1;:::;y m) and8X9HY'(X;Y ) interchange-
ably.
Henkin synthesis generalizes Skolem synthesis in which H1=:::=Hm=
X. In such a case, one omits the usage of Hiand simply represents as
8X9Y'(X;Y ). In such a case, fis called Skolem function vector, such that
8X(9Y'(X;Y )$'(X;f)).4 Golia, Roy, and Meel
3 Related Work
There has been a lot of work in the area of QBF solving [26,25,32,33,37,38,39],
and the recent years have seen signicant interest in DQBF solving as well
[14,16,17,42,40,43,44]. The rst DPLL-based approach to solve DQBF satisa-
bility was proposed by Frohlich et al. [13]. In a similar direction, recently, Tentrup
and Rabe [43] introduced the idea of using clausal abstraction for DQBF solving.
Gitina et al. [16] proposed the idea of solving a DQBF instance using a basic
variable elimination strategy which is about transforming a DQBF instance to a
QBF by eliminating a set of variables that causes non-linear dependencies. The
strategy is further improved by several optimization in [17]. A similar approach
was proposed by Frohlich et al. [14] in which a DQBF instance is transformed
into an SAT instance by a local universal expansion on each clause.
Wimmer et al. [44] proposed a method for obtaining Henkin functions from
DQBF solvers that are based on variable elimination-based DQBF solving tech-
niques [17,14]. Elimination-based DQBF solvers execute a sequence of transfor-
mation of eliminating quantiers on a DQBF instance to obtain an SAT instance;
in this process, they obtain a sequence of equisatisable formulas '1;'2;:::;' k,
where'iformula is a result of a transformation of 'i 1. They showed that for
a True DQBF instances, Henkin function for 'i 1can be obtained from 'i.
Recently, Reichl, Slivovsky, and Szeider [40] proposed a dierent approach for
DQBF solving using interpolation-based denition extraction. They introduce
arbiter variables that represents the value of an existential variable for all the
assignments of its dependency sets for which the variable is not uniquely dened.
And, then it extracts the denition for existential variables in terms of their
dependency sets and those arbiter variables. The proposed method is certifying
by design and returns Henkin functions.
The earliest work in the context of DQBF focused on the special case of 2-
QBF for both decision and functional synthesis problems. The problem of func-
tional synthesis in the context of 2-QBF is known as Skolem synthesis. The ear-
liest works on Skolem synthesis were limited to the case when the given 2-QBF
formula was True [7,23,27]; the subsequent work expanded to handle general
2-QBFs, and consequently, a multitude of wide-ranging techniques have been
proposed, such as CEGAR-based methods [3,4,12], factorization-based tech-
niques [5,29], incremental determinization [37].
Recently, a new data-driven approach for Skolem synthesis was implemented
inManthan [18,19]. Manthan uses advances in constraint sampling, machine
learning, and formal methods for ecient Skolem synthesis. Manthan uniformly
samples from the solutions of '. Using these samples as data, it learns a candi-
date vector for Skolem functions as a decision tree classier for each existentially
quantied variable. Manthan , then, veries whether the learned candidate vector
is a Skolem vector. If the candidate vector passes the verication check, Manthan
returns the Skolem vector. Otherwise, Manthan uses the counterexample to per-
form an UnsatCore guided repair and relies on a MaxSAT solver to minimize
the number of candidates to repair in each counterexample.Synthesis with Explicit Dependencies 5
4 Overview
This section provides a high-level overview of Manthan3 framework. While Man-
than3 shares high-level similarity with Manthan , the recently proposed Skolem
function synthesis engine [18][19], in its usage of machine learning techniques
and SAT/MaxSAT solvers, the two techniques dier crucially due to the require-
ments imposed by Henkin dependencies. It is worth remarking that handling
Henkin dependencies is not trivial, perhaps best highlighted by the fact that
2-QBF isP
2-complete while DQBF is NEXPTIME-complete [35].
As shown in Figure 1, Manthan3 rst uses advances in constrained sampling
to generate the data, then use the data to learn a candidate vector fusing
a machine learning-based approach. Then, Manthan3 attempts to verify if the
candidate vector fis a Henkin function vector. If the candidates pass the formal
verication check, Manthan3 returns the candidates as a valid Henkin vector.
Otherwise, the candidate vector is repaired to satisfy the counterexample, and
the verication check is repeated. Note that Manthan3 needs to take care of
restrictions imposed by Henkin dependencies while learning and repairing the
candidates.
We now present high-level overview of the dierent components of Manthan3:
Data GenerationInput
'(X;Y )Learn Candidate
Functions
Verify Repair
Output fNo
Yes
Fig. 1: Overview of Manthan3
Data Generation: As the rst step, Manthan3 uses constrained samplers [20,21]
to sample the satisfying assignments of specication 'uniformly at random from
the solution space of specication. The sampled satisfying assignments are con-
sidered data to feed the learning algorithms to learn candidate functions in the
next stage.
Candidate Learning: Manthan3 learns a binary decision tree classier for
each existentially quantied variable yito learn the candidate function ficor-
responding to it. The valuations of yiin the generated samples are considered
labels, and the valuations of corresponding Henkin dependencies Hiare consid-
ered the feature set to learn a decision tree. A Henkin function ficorresponding
toyiis computed as a disjunction of labels along all the paths from the root
node to leaf nodes with label 1in the learned decision tree.6 Golia, Roy, and Meel
Due to the Henkin dependencies, the feature set for yimust be restricted
only toHi. However, in order to learn a good decision tree, we can include all
theyjin the set of features for which HjHi. The function fjcan be simply
expanded within fiso thatfiis only expressed in terms of Hi. For the cases
whenHj=Hi, such use of the Yvariables is allowed as long it does not cause
the cyclic dependencies; that is, if yjappears in the learned candidate fi, then
yiis not allowed as a feature to learn candidate fj. Ifyjappears in fi, then
we sayyidepends on yj, denoted as yidyj. Manthan3 discovers requisite
variable ordering constraints among such Yvariables on the y as the candidate
functions are learned.
A function vector fin whichyjappears in fiis a valid vector if yidoes
not appear in fj. Iffis a valid function vector, there exists a partial order d
overfy1;:::;y mg. Once, we have a candidate vector, Manthan3 obtains a valid
linear extension total order, say denoted as Order , from the partial dependencies
learned in candidate learning overYvariables.
Verication: The learned candidate vector may not always be a valid Henkin
vector. Therefore, the candidate functions must be veried. fis a Henkin func-
tion vector only if '(X;f 1(H1); :::;f m(Hm)) is a tautology. Manthan3 rst,
make a SAT oracle query on the formula E(X;Y0) =:'(X;Y0)^(Y0$f)
If formula E(X;Y0) is UNSAT, Manthan3 returns the function vector f
as a Henkin function vector. If formula E(X;Y0) is SAT and is a satisfying
assignment of E(X;Y0), Manthan3 needs to nd out whether '(X;Y ) has a
propositional model extending assignment of X. Therefore, Manthan3 performs
another satisability check on formula '(X;Y )^(X$[X]). If satisability
checks return UNSAT, the corresponding DQBF formula is False, and there
does not exist a Henkin function vector; therefore, Manthan3 terminates. Fur-
thermore, if '(X;Y )^(X$[X]) is SAT, and is a satisfying assignment and
we need to repair the candidate function vector. Note that [X] is same as [X],
and[Y] is a possible extending assignment of X, and[Y0] presents the output
of candidate function vector with [X]. Now, we have a counterexample as
[X] +[Y] +[Y0].
Candidate Repair: We apply a counterexample driven repair approach for
candidate functions. As Manthan3 attempts to x the counterexample , it rst
needs to nd which candidates to repair out of f1tofmcandidates. Manthan3
takes help of MaxSAT solver to nd out the repair candidates, and makes a
MaxSAT query with '(X;Y )^(X$[X]) as hard constraints and ( Y$[Y0])
as soft constraints. It selects a function fifor repair if the corresponding soft
constraintyi$[y0
i] is falsied in the solution returned by the MaxSAT solver.
Once, we have candidates to repair, Manthan3 employs unsatisability cores
obtained from the infeasibility proofs capturing the reason for candidates to not
meet the specication to construct a repair.
Let us now assume that Manthan3 selects ficorresponding to variable yias
a potential candidate. Manthan3 constructs another formula Gi(X;Y ) (FormulaSynthesis with Explicit Dependencies 7
1) to nd the repair:
Gi(X;Y ) :'(X;Y )^(Hi[^Y$[Hi[^Y])^(yi$[y0
i])
where ^YYsuch that8yj2^Y:HjHi
andfOrder [index (yj)]>Order [index (yi)]g(1)
Informally, in order to determine whether fineeds to be repaired, we con-
junct the specication '(X;Y ) with the conjunction of unit clauses that set the
valuation of yito the current output of fiand the valuation of all the dependen-
cies as per the counter-example. We describe the intuition behind construction
ofGi(X;Y ). The formula Gi(X;Y ) is constructed to answer the following ques-
tion: Whether is it possible for yito be set to the output of figiven the valuation
of its Henkin dependencies? .
The answer to the above question depends on whether Gi(X;Y ) is UNSAT
or SAT.Gi(X;Y ) being UNSAT indicates that it is not possible for yito be
set to the output of fiand the UnsatCore of Gi(X;Y ) captures the reason.
Accordingly, Manthan3 uses the UnsatCore of Gi(X;Y ) to repair the candidate
functionfi. In particular, Manthan3 uses all the variables corresponding to unit
clauses in UnsatCore of Gi(X;Y ) to construct a repair formula , and depending
on the valuation of y0
iin the counter example ,is used to strengthen or weaken
the candidate fito satisfy the counterexample.
On the other hand, if Gi(X;Y ) is SAT, Manthan3 attempts to nd alterna-
tive candidate functions to repair. Gi(X;Y ) being SAT indicates that with the
current valuation to Henkin dependencies, yicould take a value as per the output
of candidate fi; however, to x the counterexample , we need to repair another
candidate function. To this end, let be a satisfying assignment of Gi(X;Y ),
then allyjvariables for which [yj] is not the same as [y0
j] are added to the
queue of potential candidates to repair.
The repair loop continues until either E(X;Y0) is UNSAT or '(X;Y )^(X$
[X]) is UNSAT, where is a satisfying assignment of E(X;Y0) . IfE(X;Y0)
is UNSAT, we have a Henkin function vector f, and if'(X;Y )^(X$[X])
is UNSAT, then the given DQBF instance is False and there does not exist a
Henkin function vector.
5 Algorithmic Details
Manthan3 (Algorithm 1) takes a DQBF instance 8X9H1y1:::9Hmym'(X;Y )
as input and outputs a Henkin function vector f:=hf1;:::;f mi.
Algorithm 1 assumes access to the following subroutines:
1.GetSamples : It takes a specication as input and calls an oracle to produce
samplesof specications. Each sample in is a satisfying assignment of
specications.8 Golia, Roy, and Meel
Algorithm 1 Manthan3(8X9HY:'(X;Y ))
1: GetSamples ('(X;Y ))
2:D fd1=;:::;d jYj=;g
3:forhHi;Hjido
4:ifHjHithen
5:dj dj[yi
6:foryi2Ydo
7:fi;D CandidateHkF (;'(X;Y );yi;D)
8:Order FindOrder (D)
9:repeat
10:E(X;Y0) :'(X;Y0)^(Y0$f)
11:ret; CheckSat (E(X;Y0))
12: ifret = SAT then
13:res; CheckSat ('(X;Y )^(X$[X]))
14: ifres = UNSAT then
15: return8X9HY:'(X;Y ) is False.
16: [X] +[Y] +[Y0] fis a counterexample g
17: f RepairHkF ('(X;Y );f;;Order )
18:until ret = UNSAT
19:f Substitute ('(X;Y );f;Order )
20:return f
2.CandidateHkF : This subroutine generates the candidate function correspond-
ing to an existential variable. It takes a specication ', generated samples ,
existential variable yicorresponding to which we want to learn a candidate
function and a vector Dthat keeps track of dependencies among Yvari-
ables as input. CandidateHkF returns a candidate function ficorresponding
toyi, and updates the dependencies in Dforyi. We discussed CandidateHkF
routine in detail in Algorithm 2.
3.FindOrder : It takes a set Dcollection of di, where each diis the list of Y
variables, which can depend on yi.FindOrder obtains a valid linear extension,
Order , from the partial dependencies in D.
4.CheckSat : It takes a specication as input and makes a SAT oracle call
to do a satisability check on the specication. It returns the outcome of
satisability check as SAT or UNSAT. In the case of SAT, it also returns a
satisable assignment of the specication.
5.RepairHkF : This subroutine repairs the current candidate function vector to
x the counterexample. It takes the specication, candidate function vector,
a counterexample, and Order , a linear extension of dependencies among Y
variables as input, and returns a repaired candidate function vector. Algo-
rithm 3 discusses RepairHkF subroutine in detail.
Algorithm 1 starts with generating samples by calling GetSamples sub-
routine at line 1. Next, Algorithm 1 initializes the set D(line 2), which is a
collection of di, wheredirepresents the set of Yvariables that depends on yi.
Lines 3-5 introduce variable ordering constraints based on the subset relations inSynthesis with Explicit Dependencies 9
eachhHi;Hjipair, that is, if HjHi, thenyican depend on yj. Line 7 calls the
subroutine CandidateHkF for everyyivariable to learn the candidate function
fi. Next, at line 8, Manthan3 calls FindOrder to compute Order , a topological
ordering among the Yvariables that satisfy all the ordering constraints in D.
In line 11, CheckSat checks the satisability of the formula E(X;Y0) described
at line 10. If E(X;Y0) is SAT, then Manthan3 at line 13 performs another satis-
ability check to ensure that propositional model to Xcan be extended to Y. If
CheckSat at line 13 is UNSAT, then Algorithm 1 terminates at line 15 as there
does not exists a Henkin function vector, otherwise Manthan3 has a counterex-
ampleto x. The candidate vector fgoes into a repair iteration (line 17) based
on the counterexample , that is, the subroutine RepairHkF repairs the current
function vector fsuch thatnow gets xed. Manthan3 returns a function vector
fonly ifE(X;Y0) is UNSAT.
Algorithm 2 CandidateHkF (;'(X;Y );yi;D)
1:featset Hi
2:foryj2Ydo
3:if(HjHi)^(yj=2(di[yi))then
4:featset featset[yj
5:feat;lbl #featset;#yi
6:t CreateDecisionTree (feat;lbl )
7:forn2LeafNodes(t) do
8:ifLabel (n) = 1 then
9: Path(t;root;n )fA path from root to node nin treetg
10:fi fi_
11:foryk2fido
12:dk dk[yi[di
13:returnfi;D
We now discuss the subroutines CandidateHkF andRepairHkF in detail.
Algorithm 2 shows the CandidateHkF subroutine. CandidateHkF assumes ac-
cess to CreateDecisionTree that constructs a decision tree tfrom labeled data on
a set of features featset . It uses the ID3 algorithm [36] and we used the Gini
Index [36] as the impurity measure.
In Algorithm 2, line 1 includes the feature set, featset , foryiin the depen-
dency setHi. Further, line 3 extends the features to include all the yjvariables
that have the dependency set Hjas a subset of Hi, andyjdoes not depend on
yito allow the decision tree to learn over such yjas well. Line 5 selects valua-
tions of feature set and label from samples , and learns a decision tree. Then,
Lines 7-10 constructs a logical formula as a representation of the decision tree
by constructing a disjunction over all paths in the tree that lead to class label
1. In line 12, set dkis updated for variable ykthat appears as a node in decision
treetforyi.10 Golia, Roy, and Meel
Algorithm 3 RepairHkF ('(X;Y );f;;Order )
1:H '(X;Y )^(X$[X]);S (Y$[Y0])
2:Ind FindCandi (H;S)
3:foryk2Inddo
4: ^Y ;
5:foryj2Ydo
6: ifHjHk^Order [index (yj)]>Order [index (yk)]then
7: ^Y ^Y[yj
8:Gk (yk$[y0
k])^'(X;Y )^(Hk$[Hk])^(^Y$[^Y])
9:ret; CheckSat (Gk)
10: ifret=UNSAT then
11:C FindCore (Gk)
12: V
l2Cite(([l] = 1);l;:l)
13:fk ite(([y0
k] = 1);fk^:;fk_)
14: else
15: foryt2Yn^Ydo
16: if[yt]6=[y0
t]then
17: Ind Ind:Append (yt)
18:[yk] [y0
k]
19:return f
Algorithm 3 represents the RepairHkF subroutine. RepairHkF assumes access
to the following subroutines:
1.FindCandi : It takes hard constraints and soft constraints as input. It makes
a MaxSAT solver call on a specication containing hard and soft constraints
and returns a set of variables corresponding to which the soft constraints are
dropped by MaxSAT solver in order to satisfy the specication.
2.FindCore : It takes a UNSAT formula as an input and returns unsatisable
core (UnsatCore) of the formula.
Algorithm 3 rst attempts to nd the potential candidates to repair using
FindCandi . At line 2, FindCandi subroutine essentially calls a MaxSAT solver with
'(X;Y )^(X$[X]) as hard-constraints and ( Y$[Y]) as soft-constraints
to nd the potential candidates to repair, it returns a list ( Ind) ofYvariables
such that candidates corresponding to each of the variables appearing in ( Ind)
are potential candidates to repair. For each of the yk2Ind, line 6 computes ^Y,
which is a set of yjvariable that appears after ykinOrder and corresponding
Hjis a subset of Hk.
Next, Algorithm 3 checks the satisability of the Gkformula at line 9. If Gkis
UNSAT, line 11 attempts to nd the UnsatCore of Gkusing subroutine FindCore ,
and line 12 constructs a repair formula , using the literals corresponding to unit
clauses in UnsatCore. Depending on the value of [y0
k],is used to strengthen
or weakenfkat line 13. If Gkis SAT and j=Gk, lines 15-18 look for other
potential candidates to repair, and add all ytvariables for which [yt] is not
same as[y0
t] to the list Ind.Synthesis with Explicit Dependencies 11
Note that in line 8, we add a constraint ^Y$[^Y] inGi(X;Y ) where ^Yis a
set ofYvariables such that for all yjof^Y,HjHi. Fixing valuations for such yj
variables helps Manthan3 to synthesize a better repair for candidate fi. Consider
the following example. Let 8X9H19H2'(X;Y ), where'(X;Y ) : (y1$x1y2),
H1=fx1gandH2=fx1g. Let us assume that we need to repair the candidate
f1, andG1(X;Y ) = (y1$[y0
1])^'(X;Y )^(x1$[x1]). AsG1(X;Y ) does
not include the current value of y2that led to the counterexample, it misses out
on drivingf1in a direction that would ensure y1$x1y2. In fact, in this case
repair formula would be empty, thereby failing to repair.
Let us consider an example to discuss Manthan3 working in detail. We now
x1x2x3y1y2y3
0 0 0 1 1 0
0 0 1 1 1 1
1 1 0 0 0 1
Fig. 2: Samples of
'(X;Y )x1
0 11 0
Fig. 3: Decision
tree fory1y1
1 01 0
Fig. 4: Decision
tree fory2
x3
x2 1
0 10 1
0 1
Fig. 5: Decision tree for y3
illustrate Algorithm 1 through an example.
Example 1. LetX=fx1;x2;x3g,Y=fy1;y2;y3gin8X9H1y19H2y29H3y3'(X;Y )
where'(X;Y ) is (x1_y1)^(y2$(y1_:x2))^(y3$(x2_x3)), andH1=
fx1g;H2=fx1;x2g, andH3=fx2;x3g.
Data Generation : Manthan3 generates training data through adaptive
sampling. Let us assume the sampler generates data as shown in Figure 2.
Candidate Learning : AsH1H2, Manthan3 adds a dependency con-
straint that y1can not depend on y2. Manthan3 now attempts to learn candi-
dates and calls CandidateHkF for eachyi. AsH36H1,y1can not depend on
y3, the feature set for y1only includes H1. The decision tree construction uses
the samples offx1gas features and samples of fy1gas labels. The candidate
functionf1is constructed by taking a disjunction over all the paths that end in
leaf nodes with label 1. As shown in Figure 3, f1is:x1.
AsH1H2, the feature set for y2includesH2andy1, however it can not
includey3asH36H2. So, the decision tree construction uses the samples of12 Golia, Roy, and Meel
fx1;x2;y1gas features and samples of fy2gas labels. The candidate function f1
is constructed by taking a disjunction over all paths that end in leaf nodes with
label 1: as shown in Figure 4, f2is synthesized as y1. Similarity, for y3, the feature
set isH3, and a decision tree is constructed as shown in Figure 5 with samples
ofx2;x3as features and samples of y3as label. We get f3:=x3_(:x3^x2). At
the end of CandidateHkF , we havef1:=:x1; f2:=y1; f3:=x3_(:x3^x2) .
Let us assume the total order returned by FindOrder isOrder =fy3;y2;y1g.
Verication : We construct E(X;Y0) =:'(X;Y0)^(Y0$f), which turns
out to be SAT, and let =hx1$1,x2$0,x3$0,y0
1$0,y0
2$0,y0
3$0ibe
a satisfying assignment of E(X;Y0). Next, Manthan3 checks if the Xvalaution
can be extended to Yin order to satisfy the specication. It checks satisability
of'(X;Y )^(x1$[x1])^(x2$[x2])^(x3$[x3]), which turns out to be
SAT, letbe the satisfying assignment, =hx1$1,x2$0,x3$0,y1$1,
y2$1,y3$0i. Let=hx1$1,x2$0,x3$0,y1$1,y2$1,y3$0,
y0
1$0,y0
2$0,y0
3$0ibe a counterexample to x.
Candidate Repair : In order to nd the candidates to repair, MaxSAT solver
is called with '(X;Y )^(x1$[x1])^(x2$[x2])^(x3$[x3]) as hard
constraints and ( y1$[y0
1])^(y2$[y0
2])^(y3$[y0
3]) as soft constraints in
FindCandi . Let FindCandi returnsind=fy2g.
Repair synthesis commences for f2with a satisability check of G2='(X;Y )^
(x1$[x1])^(x2$[x2])^(y1$[y0
1])^(y2$[y0
2]). Notice, here we can
constrainG2withy1asH1H2. The formula is unsatisable, and Manthan3
calls FindCore , which returns variable :x2, since the constraints ( x2$[x2])
and (y2$[y0
2]) are not jointly satisable in G2. As the output of candidate f2
for the assignment must change from 0 to 1, f2is repaired by disjoining with
:x2, and we get f2:=y1_:x2as the new candidate.
The updated candidate vector f:hf1:=:x1; f2:=y1_:x2; f3:=x3_
(:x3^x2)ipasses the verication check, that is, the formula E(X;Y0) is UNSAT.
Thus, Manthan3 returns fas a Henkin function vector.
By denition of Henkin functions, we know that the following lemma holds:
Lemma 1. fis a Henkin function vector if and only if :'(X;Y )^(Y$f)is
UNSAT.
Manthan3 returns a function vector only when E(X;Y0) ::'(X;Y0)^(Y0$
f) is UNSAT, and each function fifollows Henkin dependencies by construction.
Therefore Manthan3 is sound, and returned function vector is a Henkin function
vector.
Limitations: There are instances for which Manthan3 might not be able to
repair a candidate vector, and consequently is not complete. The limitation is
that the formula G(X;Y ) (Formula 1) is not aware of Henkin dependencies.
Let us consider an example, :8X9H1y19H2y2'(X;Y ) whereX=fx1;x2;x3g;
Y=fy1;y2g,'(X;Y ) :=:(y1y2),H1=fx1;x2g, andH2=fx2;x3g. Note
thatis True and Henkin functions are f:=hf1(x1;x2) :x2;f2(x2;x3) :Synthesis with Explicit Dependencies 13
x2i. Let us assume the candidates learned by Manthan3 is f:=hf1(x1;x2) :
x2; f 2(x2;x3) ::x2i. The learned candidates are not Henkin functions as
E(X;Y0) is SAT. Let the counterexample to repair is ishx1$0,x2$0,
x3$0,y1$0,y2$0,y0
1$0,y0
2$1i.
Let the candidate to repair is y2, and corresponding G2formula isG2:=
'(X;Y )^(x2$0)^(x3$0)^(y2$1). AsH16H2, the formula G2is not
allowed to constrain on y1.G2turns out SAT, suggesting that we should try to
repairy1instead ofy2, but asy1is also not allowed to depend on y2, the formula
G1would also be SAT. Therefore, Manthan3 is unable to repair candidate fto
x counterexample the . Manthan3 would not be able to synthesize Henkin
functions for such a case. Hence, Manthan3 is not complete.
6 Experimental Results
We implemented Manthan33using Python, and it employs Open-WBO [34] for
MaxSAT queries, PicoSAT [8] to nd UNSAT cores, ABC [31] to represent and
manipulate Boolean functions, CMSGen to generate the required samples [20],
UNIQUE [41] to extract denition for uniquely dened variables, and Scikit-
Learn [2] to learn the decision trees.
Instances: We performed an extensive comparison on 563 instances consist-
ing of a union of instances from the DQBF track of QBFEval18, 19, and 20 [1],
which encompass equivalence checking problems, controller synthesis, and suc-
cinct DQBF representations of propositional satisability problems.
Test hardware: All our experiments were conducted on a high-performance
computer cluster with each node consisting of a E5-2690 v3 CPU with 24 cores
and 96GB of RAM, with a memory limit set to 4GB per core. All tools were run
in a single core with a timeout of 7200 seconds for each benchmark.
Tools compared with: We performed a comparison vis-a-vis the prior state-
of-the-art techniques, HQS2 [17] and Pedant [40]. Note that we compared Man-
than3 with the tools that can synthesize Henkin functions for True DQBF; the
rest all the DQBF solvers, including DepQBF [32], DQBDD [42] do not synthe-
size such functions. The DQBF preprocessor HQSpre [45] is invoked implicitly by
HQS2. We found that the performance of Pedant degrades with the preproces-
sor HQSPre; therefore, we consider the results of Pedant without preprocessing.
Manthan3 is used without HQSpre.
Evaluation objective: It is well-known that dierent techniques are sit-
uated dierently for dierent classes of instances in the context of NP-hard
problems. The practical adoption often employs a portfolio approach [11,24,46].
Therefore, in practice, one is generally interested in evaluating the impact of a
new technique on the portfolio of existing state-of-the-art tools. Hence, to eval-
uate the impact of our algorithm on the instances that the current algorithms
cannot handle, we focus on the Virtual Best Synthesizer (VBS), which is the
portfolio of the best of the currently known algorithms. If at least one tool in the
3Manthan3 is available at https://github.com/meelgroup/manthan14 Golia, Roy, and Meel
portfolio could synthesize Henkin functions for a given instance, it is considered
to be synthesized by VBS; that is, VBS is at least as powerful as each tool in the
portfolio. The time taken to synthesize Henkin functions for the given instance
by VBS is the minimum of the time taken by any tool to synthesize a function
for that instance.
Results: Figure 6 represents the cactus plot for VBS of HQS2 and Pedant
vis-a-vis with VBS of HQS2, Pedant, and Manthan3. We observe that the VBS
with Manthan3 synthesizes functions for 204 instances while VBS without Man-
than3 synthesizes functions for only 178 instances; that is, the VBS improves
by 26 instances with Manthan3. Of 563 instances, for 204 instances, Henkin
functions are synthesized by at least one of three tools. Manthan3 achieves the
smallest synthesizing time on 42 instances, including 26 instances for which none
of the other tools could synthesize Henkin functions.
0 25 50 75 100 125 150 175 200
Benchmarks01000200030004000500060007000Runtime
VBS+Manthan3
VBS
Fig. 6: Virtual Best Synthesizing Henkin functions with/without Manthan3. VBS in
the plot represents VBS of HQS2 and Pedant. A point hx;yiimplies that a tool took
less than or equal to yseconds to synthesize a Henkin function vector for xmany
instances on a total of 563 instances.
Figure 7 highlights that the performance of Manthan3 is orthogonal to ex-
isting tools. Furthermore, as shown in green area of Figure 7, for 47 instances
Manthan3 took less than or equal to additional 10 seconds to synthesize Henkin
functions than by the VBS with HQS2 and Pedant.
Figure 9 (resp. Figure 8) represents scatter plot for Manthan3 vis-a-vis
with HQS2 (resp. Pedant). The distribution of the instances for which functions
are synthesized shows that all three tools are incomparable. There are many
instances where only one of these tools succeeds, and others fail.
In total there are 148, 138 and 116 instances for which HQS2, Pedant and
Manthan3 could synthesize Henkin functions respectively. Moreover, there are 40
instances for which Manthan3 could synthesize Henkin functions, whereas HQS2Synthesis with Explicit Dependencies 15
10−1100101102103
VBS(HQS+Pedant)(s)10−1100101102103Manthan3(s)Timeout
Timeout
Fig. 7: Manthan3 vs
VBS(HQS2+Pedant).
10−1100101102103
Pedant(s)10−1100101102103Manthan3(s)Timeout
Timeout
Fig. 8: Manthan3 vs. Pedant
10−1100101102103
HQS(s)10−1100101102103Manthan3(s)Timeout
Timeout
Fig. 9: Manthan3 vs. HQS2.
10−1100101102103
HQS(s)10−1100101102103Pedant(s)Timeout
Timeout
 Fig. 10: Pedant vs. HQS2.
A pointhx;yiimplies that the synthesizer on hxiaxis tookxsec. while the synthesizer
onhyiaxis tooksysec. to synthesize Henkin functions for an instance.
could not. Similarly, there are 37 instances for which Pedant could not synthesize
Henkin functions and Manthan3 synthesized. There are in total 88 instances for
which Manthan3 was not able to synthesize functions, however, either Pedant or
HQS2 could synthesize Henkin functions. Due to incompleteness of Manthan3,
it could not handle 49 out of those 88 instances and for remaining instances it
timed out.
Figure 10 shows that there is no best tool even amongst the existing tools,
Pedant and HQS2. Although both tools could synthesize functions for (almost)
the same number of instances, the instances belong to dierent classes.
The results show that dierent approaches are suited for dierent classes of
instances, and Manthan3 pushes the envelope in Henkin synthesis by handling
instances for which none of the state-of-the-art tools could synthesize Henkin
functions.16 Golia, Roy, and Meel
7 Conclusion
Henkin synthesis has wide-ranging applications, including circuit repair, par-
tial equivalence checking, and controller synthesis. In this work, we proposed a
Henkin synthesizer, Manthan3, building on advances in machine learning and au-
tomated reasoning. Manthan3 is orthogonal to existing approaches for Henkin
function synthesis that hints that the machine learning-based algorithm em-
ployed by Manthan3 is fundamentally dierent from that used by the current
Henkin synthesizers. We are interested in understanding these points of deviation
better.
Acknowledgements. This work was supported in part by National Research
Foundation Singapore under its Campus for Research Excellence and Techno-
logical Enterprise (CREATE) programme, NRF Fellowship Programme [NRF-
NRFFAI1-2019-0004], Ministry of Education Singapore Tier 2 grant [MOE-
T2EP20121-0011], and Ministry of Education Singapore Tier 1 Grant [R-252-
000-B59-114 ]. The computational work was performed on resources of the Na-
tional Supercomputing Centre, Singapore https://www.nscc.sg .
References
1. QBF solver evaluation portal 2020 (2020), http://www.qbflib.org/qbfeval20.
php
2. sklearn.tree.decisiontreeclassier (2021), https://scikit-learn.org/stable/
modules/generated/sklearn.tree.DecisionTreeClassifier.html
3. Akshay, S., Arora, J., Chakraborty, S., Krishna, S., Raghunathan, D., Shah, S.:
Knowledge compilation for boolean functional synthesis. In: Proc. of FMCAD
(2019)
4. Akshay, S., Chakraborty, S., Goel, S., Kulal, S., Shah, S.: What's hard about
boolean functional synthesis? In: Proc. of CAV (2018)
5. Akshay, S., Chakraborty, S., John, A.K., Shah, S.: Towards parallel boolean func-
tional synthesis. In: Proc. of TACAS (2017)
6. Balabanov, V., Chiang, H.J.K., Jiang, J.H.R.: Henkin quantiers and boolean for-
mulae: A certication perspective of dqbf. Proc. of Theoretical Computer Science
(2014)
7. Balabanov, V., Jiang, J.H.R.: Resolution proofs and skolem functions in QBF
evaluation and applications. In: Proc. of CAV (2011)
8. Biere, A.: PicoSAT essentials. Proc. of JSAT (2008)
9. Bloem, R., K onighofer, R., Seidl, M.: Sat-based synthesis methods for safety specs.
In: Proc. of VMCAI (2014)
10. Chatterjee, K., Henzinger, T.A., Otop, J., Pavlogiannis, A.: Distributed synthesis
for ltl fragments. In: Proc. of FMCAD (2013)
11. Dudek, J.M., Phan, V.H.N., Vardi, M.Y.: ProCount: Weighted projected model
counting with graded project-join trees. In: Proc. of SAT (2021)
12. Fried, D., Tabajara, L.M., Vardi, M.Y.: BDD-based boolean functional synthesis.
In: Proc. of CAV (2016)
13. Fr ohlich, A., Kov asznai, G., Biere, A.: A dpll algorithm for solving dqbf. Proc.
POS (2012)Synthesis with Explicit Dependencies 17
14. Fr ohlich, A., Kov asznai, G., Biere, A., Veith, H.: idq: Instantiation-based DQBF
solving. In: Proc. of SAT (2014)
15. Garey, M.R.: A guide to the theory of np-completeness. Computers and intractabil-
ity (1979)
16. Gitina, K., Reimer, S., Sauer, M., Wimmer, R., Scholl, C., Becker, B.: Equivalence
checking of partial designs using dependency quantied boolean formulae. In: Proc.
of ICCD (2013)
17. Gitina, K., Wimmer, R., Reimer, S., Sauer, M., Scholl, C., Becker, B.: Solving dqbf
through quantier elimination. In: Proc. of DATE (2015)
18. Golia, P., Roy, S., Meel, K.S.: Manthan: A data-driven approach for Boolean func-
tion synthesis. In: Proc. of CAV (2020)
19. Golia, P., Slivovsky, F., Roy, S., Meel, K.S.: Engineering an ecient boolean func-
tional synthesis engine. In: Proceedings of International Conference On Computer
Aided Design (ICCAD) (2021)
20. Golia, P., Soos, M., Chakraborty, S., Meel, K.S.: Designing samplers is easy: The
boon of testers. In: Proc. of FMCAD (2021)
21. Gupta, R., Sharma, S., Roy, S., Meel, K.S.: WAPS: Weighted and projected sam-
pling. In: Proc. of TACAS (2019)
22. Henkin, L.: Some remarks on innitely long formulas, innitistic methods (1959)
23. Heule, M.J., Seidl, M., Biere, A.: Ecient extraction of skolem functions from
QRAT proofs. In: Proc. of FMCAD (2014)
24. Hoos, H.H., Peitl, T., Slivovsky, F., Szeider, S.: Portfolio-based algorithm selection
for circuit qbfs. In: Proc. of CP (2018)
25. Janota, M.: Circuit-based search space pruning in qbf. In: Proc. of SAT. Springer
(2018)
26. Janota, M.: Towards generalization in qbf solving via machine learning. In: Proc.
of the AAAI (2018)
27. Jiang, J.H.R.: Quantier elimination via functional composition. In: Proc. of CAV
(2009)
28. Jiang, J.H.R., Kravets, V.N., Lee, N.Z.: Engineering change order for combinational
and sequential design rectication. In: Proc. of DATE (2020)
29. John, A.K., Shah, S., Chakraborty, S., Trivedi, A., Akshay, S.: Skolem functions
for factored formulas. In: Proc. of FMCAD (2015)
30. Krynicki, M., Mostowski, M.: Henkin quantiers. In: Quantiers: logics, models
and computation (1995)
31. Logic, B., Group, V.: ABC: A system for sequential synthesis and verication
(2021), http://www.eecs.berkeley.edu/ ~alanmi/abc/
32. Lonsing, F., Biere, A.: DepQBF: A dependency-aware QBF solver. Proc. of JSAT
(2010)
33. Lonsing, F., Egly, U.: Depqbf 6.0: A search-based QBF solver beyond traditional
QCDCL. In: Proc. of CADE (2017)
34. Martins, R., Manquinho, V., Lynce, I.: Open-WBO: A modular MaxSAT solver.
In: Proc. of SAT (2014)
35. Peterson, G., Reif, J., Azhar, S.: Lower bounds for multiplayer noncooperative
games of incomplete information. Computers & Mathematics with Applications
(2001)
36. Quinlan, J.R.: Induction of decision trees. Proc. of Machine learning (1986)
37. Rabe, M.N.: Incremental determinization for quantier elimination and functional
synthesis. In: Proc. of CAV (2019)
38. Rabe, M.N., Tentrup, L.: CAQE: A certifying QBF solver. In: Proc. of FMCAD
(2015)18 Golia, Roy, and Meel
39. Rabe, M.N., Tentrup, L., Rasmussen, C., Seshia, S.A.: Understanding and extend-
ing incremental determinization for 2QBF. In: Proc. of CAV (2018)
40. Reichl, F.X., Slivovsky, F., Szeider, S.: Certied DQBF solving by denition ex-
traction. In: Proc. of SAT (2021)
41. Slivovsky, F.: Interpolation-based semantic gate extraction and its applications to
QBF preprocessing. In: Proc. of CAV (2020)
42. S  c, J., Strej cek, J.: DQBDD: an ecient BDD-based DQBF solver. In: Proc. of
SAT (2021)
43. Tentrup, L., Rabe, M.N.: Clausal abstraction for DQBF. In: Proc. of SAT (2019)
44. Wimmer, K., Wimmer, R., Scholl, C., Becker, B.: Skolem functions for QBF. In:
Proc. of ATVA (2016)
45. Wimmer, R., Reimer, S., Marin, P., Becker, B.: Hqspre{an eective preprocessor
for QBF and DQBF. In: Proc. of TACAS (2017)
46. Xu, L., Hutter, F., Hoos, H.H., Leyton-Brown, K.: Satzilla: portfolio-based algo-
rithm selection for SAT. Proc. of JAIR (2008)
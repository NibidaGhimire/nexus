arXiv:2301.04591v1  [cs.CR]  11 Jan 2023MV AM: Multi-variant Attacks on Memory for IoT Trust Computi ng
Arup Kumar Sarker∗, Md Khairul Islam†, Yuan Tian‡
∗†University of Virginia, Charlottesville, VA 22904, USA, {djy8hg, mi3se }@virginia.edu
‡University of California, Los Angeles, CA 90095-1405, USA yuant@ ucla.edu
Abstract —With the signiﬁcant development of the Internet
of Things and low-cost cloud services, the sensory and data
processing requirements of IoT systems are continually goi ng
up. TrustZone is a hardware-protected Trusted Execution En -
vironment (TEE) for ARM processors speciﬁcally designed fo r
IoT handheld systems. It provides memory isolation techniq ues
to protect the trusted application data from being exploite d by
malicious entities. In this work, we focus on identifying di ffer-
ent vulnerabilities of the TrustZone extension of ARM Corte x-
M processors. Then design and implement a threat model to
execute those attacks. We have found that the TrustZone is
vulnerable to buffer overﬂow based attacks. We have used thi s
to create an attack called MOFlow and successfully leaked
the data of another trusted app. This is done by intentionall y
overﬂowing the memory of one app to access the encrypted
memory of other apps inside the secure world. We have also
found that, by not validating the input parameters in the
entry function, TrustZone has exposed a security weakness. We
call this Achilles’ heel and present an attack model showing
how to exploit this weakness too. Our proposed novel attacks
are implemented and successfully tested on two recent ARM
Cortex-M processors available on the market (M23 and M33).
Index Terms —Trust Computing, IoT, TrustZone, Cortex-M,
vulnerability, Instruction TCM(ITCM), Data TCM(DTCM)
1. Introduction
ARM TrustZone is an embedded security system for
ARM Cortex processors. Recently, ARM included Trust-
Zone into IoT computing with cortex-m processors. The
beneﬁt of TrustZone is its compact and lightweight nature,
allowing for both worlds (Figure 1) to operate on a single
processor core. Because of this secure operating system,
ARM micro-controllers can store all system-essential li-
braries and applications in a secure area [1]. The defense
mechanism in TrustZone is to protect memory (physical and
cache) and process. For example, memory in both worlds is
isolated with a security attribute Unit (SAU), even the same
app with different signatures running in two different worlds
has to go with a robust veriﬁcation process and execute in
isolation. Work stretching across different applications, both
secure and not secure, can do so through a software-basedFigure 1. TrustZone Core Virtualization
secure monitor which mediates between the two security
worlds. This software-based secure monitor is executed on
the same core as all the other processes, and thus consumes
less power than the traditional approaches detailed above.
Even with this, there are malicious attacks by observing
entry and exit onto the address of cache, compromising the
messaging channel between a non-secure process and secure
process [2]. To target this problem, some research papers
are used isolated cache protection design to narrow down
the access space.
Due to limited or not availability of cache, accessin memory inside Trusted Execution Environment(TEE) is
shared and not bound to speciﬁc secure kernel process. So,
the TEE delineates speciﬁc memory addresses in accor-
dance with their world. There is no tightly coupled memory
dedicated to a speciﬁc app in the secure zone. A trusted
execution environment can be easily exploited by leaking
memory within the shared space. Without authorization
or access to protected enclaves, the attacks can be quite
effective at collecting the users’ private and secure data.
This allows sensitive information to be stored out of reach
for applications operating outside of the secure world.
With the use of ARM TrustZone in the IoT ecosystem,
memory access in these devices have a signiﬁcant research
focus within single and cloud with multiple connected smart
devices. The goal of our study is to research and develop
security exploit encrypted information to gather sensitive
user information into the normal world. Although the secu-
rity attribute Unit (SAU) ensures the security, certain input
parameters might expose the access of secure memory if the
developer forgets to check memory-bound checking non-
secure callable zone. The system should have an automatic
guard to validate the memory-bound checking. Poor imple-
mentation at the nonsecure callable side might expose the
potential loophole. This will create multiple openings for
external attacks. A secure framework should not have APIs
to get non-accessible data from the user level. TrustZone
does not have any automatic internal memory management
like with a high-level programming language. Moreover,
security design and protection work differently in x86. Most
of the low-level APIs are primitive and do not have any
metrics to benchmark the security level. We have not found
the API security validation from the ARM platform. A
developer has to perform extensive operations for allocating
memory and clearing them. Any intentional or unintentional
memory leakage might expose the sensitive data even from
the secure TrustZone memory.
The proposed threat model of MOFlow is based on the
experimental results and found memory leaks during the
access to out-of-bound data even in the TrustZone secure
world. We also ﬁnd, using invalid parameters in the Entry
function, it is possible to inﬁltrate the secure world. We
call this an Achilles’ heel for the TrustZone security. These
successful attacks will highlight security vulnerabilities in
the current ARM Cortex-M processors which need to be
addressed to ensure the safety of the IoT systems. This
will also help us understand potential risks associated with
TrustZone and improve the security of IoT trust computing.
In short our contributions in this work are:
•We have done a robust exploration of the security
vulnerabilities during the communication in between
normal and secure world in the ARM TrustZone
Cortext-M processor and deﬁned open scopes of
possible compromise of the system.
•We propose a threat model to exploit memory over-
ﬂow with intentional or unintentional fraudulent
communication, encapsulated with security attribute
unit along with mechanism for creating Achilles’sheel.
•We also expose the APIs limitations and the implica-
tion of a low-level framework that creates a possible
loophole for the intruder.
•We provide best practices for the defense improve-
ment inside TrustZone based on the experimental
results and analysis that includes an additional layer
of veriﬁcation.
•Finally, we propose a trust model with TrustZone ex-
tension APIs and veriﬁer along with communication
ﬂows.
Paper Organizations . The rest of the paper is organized
as follows. Section 2 presents the backgrounds on TrustZone
and its architecture. Section 3 explains the motivation behind
the attacks and what was the expected outcome. Section
3.4 has the design of the threat model. Then Section 3.5
shows how we planned to apply it to ARM TrustZone.
Section 4 presents the experimental setup. In Section 5
we list the different types of attacks we performed on the
TrustZone and its results. Discussions on the implications
of our ﬁndings, possible mitigation plans against the attacks
and future works are added in Section 6. Section 7 lists
the related works. Section 8 contains the limitations of our
work. And ﬁnally, Section 9 has the conclusion.
2. Background
There are multi-variety of designs in ARM TrustZone
to ensure security. ARM Cortex M23 [3] and M33 [4] do
not have any in-built cache because of the compact design
and priority on security features. In ARM Cortex-M35P, the
process cache is the primary element of in-memory design
to create a bridge between the processor execution and the
relatively slower memory access. In the TrustZone-M design
both instruction and data, a memory is expanded with an
additional feature called an NS ﬂag which helps to identify
the security domain. This ﬂag bit will be used to isolate
the memory. These lines are not accessible from the normal
world directly. But it is common for both worlds, during
the execution of the processor. So the normal and secure
world will try to use this memory line to support its running
application.
The main reason for this design is to maximize the
utilization of the memory and improve system performance.
ARM sets speciﬁc hardware to secure the access of memory
by any world application. But the access pattern is not secure
in simple designed cortex M33 or M23 where only a single
memory unit is available. Moreover, M55 [5] has a robust
memory with instruction and data. These will communi-
cate with customs-designed newly introduced instruction
and data Tightly-Coupled Memory (TCM). Access patterns
between TCM to cache can be easily monitored by an
attacker process, leaving TrustZone vulnerable for the cache
access side-channel attacks. From the beginning of trust
computing, there is a vast number of studies on Intel-based
SGX secure container [6], [7], but very few studies are done
on TrustZone [8], running on mobile platforms. A graphic
overview of the cache-based attack is seen in Figure 2.Figure 2. A standard communication by using shared resource s
This security probing involved reading literature regard-
ing the TrustZone-M architecture, control ﬂow, and compo-
nents. After re-framing the approach, the team began look-
ing into previous effective cyber-attacks and the fundamental
principles behind them. Though TrustZone-M provides a lot
of new obstacles for attackers to overcome, we believed that
certain attack models could be modiﬁed and applied to this
security architecture. Throughout our literature exploration,
we came across the MOFlow bug [9].
The MOFlow bug relies on a TEE/Non-secure commu-
nication with the standard API of TrustZone. A nonsecure
app sends a short message to a secure app to check if the
app is active in the background. When a secure UI/service
app falls out of responses with another due to inactivity or
being killed or crashed, it is needed to be able to check
if they are still alive. There will be data inconsistencies
due to interaction by the user or server or any connected
apps in the IoT system. That encrypted piece of data is sent
from another node to check its status or availability. When
the crashed or killed secure node receives this request, it
responds with the same piece of encrypted data to prove
to the nonsecure app that the secure app is still in place.
This is where the vulnerability lies. The request message
also includes information about its length. Below, we will
draw out a scenario of how communication can be used to
extract information from a secure app [10].
A normal world app is a malicious user and wants to
extract sensitive information from the secure world app.
So communication from Non-secure will go to secure for
checking the availability of the service. The request consistsof an encrypted message (e.g, 16KB lengths), but the normal
world app intentionally lies about the length of the encrypted
message and says that it is 128KB long (the maximum
request length). The secure app receives this request and
allocates a 128KB memory buffer to contain the encrypted
message it is supposed to send back to the malicious app
in Non-secure. The secure world then stores the 16KB
encrypted message on the 128KB memory buffer and sends
it back to the Non-secure. This is where the vulnerability
lies. Security attributes in secure zone do not verify that
the encrypted message length is equal to the length value
provided. This tricks the secure world app into sending over
112KB of possibly sensitive information.
The lack of this safeguard on secure zone allowed
malicious users to use the MOFlow vulnerability to extract
data from unsuspecting secure world apps. In this work, we
intend to perform the MOFlow attack to target an ARM
TrustZone-enabled micro-controller. This attack requires an
important assumption which we will make for this experi-
ment: the malicious user has planted a buggy application on
the secure world. This is an important assumption because,
without a buggy application within the secure world, there
is no avenue for the attacker to interface with the secure
world. While this obstacle seems difﬁcult to overcome, we
believe that it is a plausible scenario. With the onset of
IoT systems, particularly smart homes, the user is free to
download and use third-party applications that provide ad-
ditional features. This app store provides an avenue through
which a malicious user could plant a seemingly innocuous
application that contains a bug enabling MOFlow attacks.
Any user that downloads this malicious application opens
the door for attackers to execute the MOFlow attack on a
TrustZone-enabled device. In Section 5.6, we have discussed
the attack model tailoring MOFlow to TrustZone-enabled
micro-controllers.
3. Overview of Approach
3.1. A Motivating Use Case
To provide a motivating example, suppose there exists
an IoT smart home device that is powered by a TrustZone-
M enabled micro-controller. This smart home device can
be connected to sensors such as a user’s smartwatch device,
house lights, front door, and many other miscellaneous smart
household IoT devices. The smart device can also interact
with multiple cloud servers for each app that provides users
the functionality to make purchases, check health statuses,
and send messages and emails. If the MOFlow attack is
proven to work within TrustZone-M devices it could lead
to serious violations in the integrity of TrustZone’s secu-
rity measures. Speciﬁcally for the described TrustZone-M
powered IoT device, an attacker can publish a malicious
application with memory leakage to the device’s afﬁliated
marketplace and disguise the application as a seemingly
innocent service that a user could end up downloading
(similar to utterance checking) into their smart device’ssecure zone. TrustZone applications can retrieve sensitive in-
formation from the server to get access to a sensor and save
it to the memory. From there, the malicious application is
among different other legitimate applications for sensors that
could have the functionality to retrieve sensitive information
from a using shared memory space. The attacker could
then invoke this compromised secure-world application by
overﬂowing the secure memory space. If another sensor’s
data is saved on the device, the attacker could gather the
user’s device identiﬁers, device authentication key, and other
data from the memory.
3.2. Expected Robustness Properties
Let’s deﬁne communication properties between Non−
secure andTEE with a set of blocks instructions
X{x1,x2,x3,...,xn} ⇔Y{y1,y2,y3,...,yn}. If△mis the
leakage memory, then the response of Xfrom the TEE is,
RX=OY+△m
whereOY, is the the expected allocated memory.
The model tries to perform the maximum number of
attacks on TEE and increase the number of successful
attacksSN. Target is to maximize the amount of leaked
memory, Fmwith the generator function L. So,
lim
△m→Fmf(△m) =L
So for all instructions X{x1,x2,x3,...,xn}, output re-
sponse is generated with multiple equations as follows,
Rx1=△mx1+Ox1
Rx2=△mx2+Ox2
Rx3=△mx3+Ox3
···
Rxn=△mxn+Oxn
To verify the robustness properties of TEE secure com-
munications, △mshould be 0, e.g.,
△m=△mx1+△mx2+△mx3+...+△mxn= 0 (1)
In this paper, by performing a set of attacks, we will
invalidate the robustness properties of TEE .
3.3. Aligning Problems on ARM TrustZone
We have done a robust study on normal-world user and
kernel space and have learned of vulnerabilities allowing
attackers to gain full control of the normal-world kernel
space. It is possible to discern physical addresses from
virtual information. Address translations play a vital role in
allocating memory and are thus a prime area for an attack.
By design, the whole memory is divided into multiple parts.
Our ﬁrst target is to ﬁnd a path to access the secure memory.
Moreover, the cycle counter can be used as a precision
timer that is accessed by only super users. In addition, anon-privileged app can access information without super-
user permissions and with no virtual to physical address
translation or cycle count.
This creates an opportunity for prime and probe attacks.
To do that, there can be multiple scenarios. When a normal
world app tries to access securely by not following the
standard protocol, on the framework side, there should be
some security measures to protect any kind of illegal access.
Security Attribute Unit(SAU) and Implementation Deﬁned
Attribution Unit(IDAU) will raise kernel fault in response.
What if the developer made the mistake of adding memory
boundary checking in the non-secure callable? A normal
world app will have access to the whole memory of a secure
world. Many high-level programming languages have inbuilt
garbage collectors to free allocated memory and handle
memory leaks. If a system does not have a built-in garbage
collector, it should have support at the framework level to
handle memory leakage internally.
ARM TrustZone is based on low-level language, As-
sembly, and C. In these languages, developers have to
manage every allocated memory checking. One of the major
limitations in the ARM TrustZone framework is, it does
not have any in-built memory management support, even
for secure zones. This opens the door for the overﬂow
of the memory in a secure zone and possible leakage of
valuable data. In Figure 2, communication line C3 is the
main way between normal world user and kernel space.
With C3 superuser access, a non-privileged app gets access
information without cycle count and address translation. C3
is executed with a TrustZone daemon or library which needs
an extensive authentication process for the execution in a
secure world. But C3 has access to a nonsecure callable.
Intentional memory accessible is possible with bad coding
and generates Achilles’ heels. An attacker can get overﬂow
memory data by using standard TrustZone API. No other
apps, including TrustZone itself, will have a single idea
about the theft of the information.
3.4. Threat Model Design
Based on the design by ARM, all cryptographic oper-
ations are executed in an isolated environment [11], [12].
That means API execution in a process of a cryptographic
library like SSL is isolated in the secure world. We have
designed our threat model based on the assumptions that
there must be a channel of handshaking between the normal
world and secure world data or instruction transmission.
If those operations happen either on the SMC interface
or TZ manager, then the attacker can easily get data by
using standard protocol from a secure world and extracting
necessary information to get the AES key. Because Zhang et
al. [13] demonstrates a way of recovering the full AES128
key using the application level attack in a shorter time.
Now the main idea is to get data from the memory
by overﬂowing the assigned data structure. All apps in the
secure world use shared resources. Assigning memory to
an app is a loosely coupled operation at the processor. If a
malicious app overﬂows its memory scope, it can easily getdata that was not assigned. Although the data is encrypted, it
can be easily decrypted by using a T-table-based decryption
mechanism. Moreover, input parameters play an important
part in getting the level of access to a secure world. There
is no standard system in the TrustZone framework to handle
any fuzzy attacks. Developers might not check all the corner
cases of access memory in non-secure callable parts. SAU
and IDAU do not guarantee parameter level veriﬁcation at
non-secure callable regions. Here comes the Achilles heel.
With that attacker can compromise the non-secure callable
and get full access to secure world memory.
The proposed threat model will work from the appli-
cation level with user privilege, which does not have any
assumption to break the hardware-enabled trust execution
environment. So executing the code from normal world
user space to kernel space does not need any API call or
permission from the TZ library or TZ manager in kernel
space. A malicious process in a secure space can run and
infect any operation and remain intact inside an app. This
process might have access to memory data with the back-
door leakage. Based on this analogy, this threat model is
more resilient in the IoT system and does not need any
dependencies on the TrustZone speciﬁc platform. Based on
this threat model, suppose, an attacker has both a secure and
non-secure app, running on an IoT device, and he wants to
steal information from other vendors’ apps running on the
same device.
Figure 3. The Proposed Threat Model
In Figure 3, A2 is the malicious app that memory leaks.
In ARM TrustZone, there is no support for handling mali-
cious memory overﬂow, inside a secure zone. So, A2 will
read data from the DRAM which was assigned to any other
app, and send it back to the normal world by following the
APIs of non-secure callable. Because in TrustZone memory,
there is no tightly coupled memory bound to a speciﬁc app.
As a result, even the TrustZone framework and no other appwill detect the theft of information. For the simplicity of the
threat model, we have excluded the decryption mechanism
of secure data from the project scopes.
Figure 4. ARM Cortext-M micro-controller modes
3.5. Apply Threat Model to ARM TrustZone
ARM Cortext-m is designed as a component of IoT
ecosystem. As it is low power, TrustZone security extension
is optional. That means, chipset vendor has the ﬂexibity
to design chip. For example, NXPLPC55S28 is based on
Cortex-M33, but this board does not have TrustZone security
extension. As it is low powered micro-controller, proces-
sor works differently than ARM cortex-A. ARM Cortex-M
processor works in two different modes in Figure-4. When
running application software, the CPU is in Thread mode,
and for handling exceptions, it is in Handler mode. When the
processor exits reset, it enters Thread mode and exits Thread
mode when all exceptions have been processed. Execution
can be privileged or unprivileged in Thread mode. Execution
is Privileged in Handler mode. Memory maps are used to
divide the Secure and Normal worlds, and transitions are
handled automatically in exception handling routines.That’s
why multiple secure function entry points are supported by
Armv8-M [14].
Because of that, all access to different memory might be
on multiple in parallel. Although SAU and IDAU protect the
memory access with NS bit, what is transmitting from the
secure zone does not have any control. Moreover, in both
thread and handler mode, within the region of secure mem-
ory, data access is performed based on the programming
logic of secure memory. Attribute units are independent
and do not have any inﬂuence on application features. This
design opens research questions about the security ﬂaws
inside secure and non-secure callable and that’s how our
proposed thread model has implications on the secure zone.
4. Experimental Setup
Multiple vendors develop board based on ARM Cortex-
M along with development environment. Our primary anal-ysis for feasibility test, was started with QEMU emulator
for RPI3 kernel in linux [15]–[17]. But we were unable
to replicate the deﬁned problem in target domain. Because,
it doesn’t have TrustZone framework and the architecture
is not comply the current state of the arts. NXP and
Nuvoton released R&D board based on ARM cortex-M
and we have used NXPLPC55S69 [18] and [19] Nuvoton
M2351. Nuvoton-M2351 has a single core M23 processor
and NXPLPC55S69 has a dual-core M33 processor with
DRAM. Both of them have support for TrustZone instruc-
tions. Our initial plan was to use the Cortex-M35P and
M55 processors. Because they have the latest TrustZone
implementation. Cortex-M55 has additional instruction and
data tightly coupled memory. These are conﬁgurable to the
speciﬁc app for the ﬁxed memory location. Unfortunately,
we couldn’t get either of them publicly available on the
market. Or even if they were available, there were substantial
amount of time delay for the delivery due to chip shortage.
So, we chose the M23 and M33-based boards. We have
also received an NXPLPC55S28 board, developed with a
single ARM cortex M33 processor. But it does not have any
support of TrustZone, so it couldn’t be used in this work.
5. Attacks on ARM Cortex-M
We have performed multiple attacks on Cortex M pro-
cessors. Some attacks are failed due to security properties
by ARM. Failed attacks are an Invalid transition from secure
to the normal world, the invalid entry point from normal to
secure world, and invalid data access from the normal world.
We do have some success. Success attacks are Invalid input
parameters in the entry function, we call it Achilles’ heel and
steal Memory data inside a secure world, we call it Heart
Bleed. In the next subsections, we will describe in detail
all attacks. Source codes for all of the attacks are publicly
available on https://github.com/arupcsedu/MVAM .
5.1. Memory Map
Before going into details about our experiments, let’s
check the run-time memory attribute map of ARM Cortex-
M in Figure 5. We have exported this memory snapshot
from the LPCNXP55S69 board, during running the program.
We see the NS Program ﬂash base is 0x0001 0000. The
Secure Program ﬂash base is 0x1000 0000. A Non-secure
Callable, here with NXP, we call a Veneer Table, the entry
point to secure area base is 0x1000 FE000. A combination
of SAU (Secure Attribute unit) and IDAU (Implementation
Deﬁned Attribution Unit) ensures the separation of each
memory footprint with security. Here SAU is internal with
a processor and IDAU is external units, normally designed
by chipset vendors, for example, NXP has that ﬂexibility to
design IDAU.
Figure 5. Memory map of Secure, Non-Secure and Non-Secure Ca llable
5.2. Invalid Transition From Secure to Normal
World
In this attack, a direct address to non-secure RESET is
used to jump into the normal world. There are two issues
related to this approach in Listing-1. First , all core registers
are not clear so there is a potential data leak. Second , the
most LSB of address into the normal world has to be cleared.
We have not performed those and the requirement is not met
for the transition to the normal world. As a result, a secure
fault is generated by SAU.
#define CODE_START_NS 0x00010000
#define AHB_LAYERS_COUNT 12U
#define NON_SECURE_START CODE_START_NS
if(testCaseNumber ==
FAULT_INV_S_TO_NS_TRANS)
{
funcptr_ns ResetHandler_ns;
/*Non-secure main stack address */
__TZ_set_MSP_NS( *((uint32_t*)(NON_SECURE_START)));
/*Initialize the non-secure vector table
*/
SCB_NS->VTOR = NON_SECURE_START;
/*Function pointer for the Non-secure
reset handler */
ResetHandler_ns =
(funcptr_ns)( *((uint32_t
*)((NON_SECURE_START) + 4U)));
/*Invalid switch to non secure */
__asm("BXNS %0" : :"r"(ResetHandler_ns));
}
Listing 1. Attack with Invalid Transition From Secure to Nor mal World
Both issues can be solved by using the
cmse nonsecure call keyword attribute. If this attribute
is used for a function call to a normal world, the compiler
will do three things. First , clear all used registers to avoid
potential data leak. Second , clear LSB address bit. Third ,
jump to address using BXNS instruction. The BXNS
instruction causes a branch to an address and instruction
set speciﬁed by a register and causes a transition from
the Secure to the Non-secure domain. This variant of
the instruction must only be used when additional steps
required to make such a transition safe are taken [20].
5.3. Invalid Entry From Normal to Secure World
In Listing-2, a function pointer, PRINTF NSE is in-
tentionally increased by 4. It is deﬁned with a non-secure
callable function DbgConsole Printf NSE in the veneer ta-
ble. By this the Secure Gateway(SG) instruction is skipped,
when a function is called. This causes an illegal entry point
into a secure world and a secure fault is generated. The
correct entry point into the secure world is ensured by using
cmse nonsecure entry keyword attribute for every entry
function so that it clears the register value and LSB address
bit. Then the linker creates a veneer table for all entry
functions with SG instructions.
#define SEC_ADDRESS 0x10000000
#define NONSEC_ADDRESS 0x20130000
typedef void (*funcptr_t)( char const *s);
#define PRINTF_NSE DbgConsole_Printf_NSE
if(testCaseNumber == FAULT_INV_S_ENTRY)
{
func_ptr =
(funcptr_t)((uint32_t)&PRINTF_NSE +
4);
func_ptr( "Invalid Test Case\r\n" );
}
/*Non-secure callable (entry) function */
TZM_IS_NOSECURE_ENTRY void
DbgConsole_Printf_NSE( char const *s)
{size_t string_length;
/*Access to non-secure memory from
secure world has to be properly
validated */
/*Check whether string is properly
terminated */
string_length = strnlen(s,
MAX_STRING_LENGTH);
if((string_length == MAX_STRING_LENGTH)
&& (s[string_length] != ’\0’))
{
PRINTF("Input data error: String too
long or invalid string
termination!\r\n" );
abort();
}
PRINTF(s);
}
Listing 2. Attack with Invalid Transition From REE to TEE
5.4. Invalid Data Access From Normal World
In Listing - 3, the pointer is set to the address deﬁned
by NONSEC ADDRESS. This address has a non-secure
attribute in SAU but it has a secure attribute in AHB secure
controller. If data is read from this address, the data bus
error is generated. Compared to attacks for accessing the
memory address, SEC ADDRESS where the secure fault
is generated, this error is caught by AHB secure controller,
not by SAU. Because in the SAU this address is non-secure.
So the access from the normal world is correct from SAU’s
perspective. In the normal world, the application does not
have access to secure memory.
#define SEC_ADDRESS 0x10000000
#define NONSEC_ADDRESS 0x20130000
typedef void (*funcptr_t)( char const *s);
#define PRINTF_NSE DbgConsole_Printf_NSE
if(testCaseNumber ==
FAULT_INV_NS_DATA_ACCESS)
{
test_ptr = (uint32_t *)(SEC_ADDRESS);
test_value = *test_ptr;
}
Listing 3. Attack with Invalid data access to TEE
5.5. Achilles’ Heel - Invalid Parameters in Entry
Function
In this attack, the input parameter is set to address
0x10000000 in Listing-4. This address has a secure attribute
(see SAU settings in the memory map picture). This secure
violation is not detected by secure fault, since the input
parameter is used by the secure function in a secure mode.
So this function has access to the whole memory. However,
every entry function should check the source of all inputdata to avoid potential data leaks from secure memory. The
correctness of input data cannot be checked automatically.
So, this function is an Achilles’ heel, which can be used to
enter the secure world by using a valid secure location as an
input parameter. This has to be checked by software, using
TT instruction by publisher vendors to protect Achilles’ heel
if the developer forgot to set a check in the NSC layer.
#define SEC_ADDRESS 0x10000000
#define NONSEC_ADDRESS 0x20130000
typedef void (*funcptr_t)( char const *s);
#define PRINTF_NSE DbgConsole_Printf_NSE
if(testCaseNumber == FAULT_INV_S_ENTRY)
{
func_ptr =
(funcptr_t)((uint32_t)&PRINTF_NSE +
4);
func_ptr( "Invalid Test Case\r\n" );
}
/*Non-secure callable (entry) function */
TZM_IS_NOSECURE_ENTRY void
DbgConsole_Printf_NSE( char const *s)
{
size_t string_length;
/*Access to non-secure memory from
secure world has to be properly
validated */
/*Check whether string is properly
terminated */
string_length = strnlen(s,
MAX_STRING_LENGTH);
if((string_length == MAX_STRING_LENGTH)
&& (s[string_length] != ’\0’))
{
PRINTF("Input data error: String too
long or invalid string
termination!\r\n" );
abort();
}
/*Check whether string is located in
non-secure memory */
#if(__GNUC__ != 10)
if(cmse_check_address_range(( void*)s,
string_length, CMSE_NONSECURE |
CMSE_MPU_READ) == NULL)
{
PRINTF("Achilles’ Heel exception:
String is not located in normal
world!\r\n" );
abort();
}
#endif
PRINTF(s);
}
Listing 4. Achilles’ Heel Attack during access TEE with inva lid input
parameters5.6. MOFlow - Steal Memory Data Inside Secure
World
Along with the Achilles’ heel, we have implemented
our threat model, MOFlow. In the MOFlow attacks, men-
tioned in Listing-5 a secure attacker app(A2) with memory
overﬂow is running on the secure zone. Here, moﬂow()
function is implemented in the secure app which memory
leaks. There are three other test apps(A1/A3/A5) running on
the TrustZone memory which does not have any leakage.
Because of memory overﬂow in A2, it is getting more en-
crypted unassigned data from the memory which is allocated
to other apps. A2 returns all data to the normal world by
following the proper standard of TrustZone. Application,
A1/A3/A5 and even TrustZone itself does not have a single
idea about this stealing, as it is happening in a speciﬁc
program space. With a T-table-based mechanism, it can be
decrypted to actual data. Like in the MOFlow attacks, a
secure zone is acting as a server and returning sensitive
information to the normal world.
#define FAULT_HEART_BLEED 0
#define FAULT_INV_S_TO_NS_TRANS 1
#define FAULT_INV_S_ENTRY 2
#define FAULT_INV_NS_DATA_ACCESS 3
#define FAULT_INV_INPUT_PARAMS 4
#define FAULT_INV_NS_DATA2_ACCESS 5
#define MAX_SMEM_SIZE 4e+9
TZM_IS_NOSECURE_ENTRY char*
GetDRAMData_NSE( void)
{
charleakData[MAX_SMEM_SIZE];
char*lDataPtr = GetDRAMData();
PRINTF("Read from Veneer Table:\n" );
for(inti = 0; i < MAX_SMEM_SIZE; i++)
{
leakData[i] = lDataPtr[i];
printf("%c",leakData[i]);
}
leakData[MAX_SMEM_SIZE] = ’\0’;
//strcpy(leakData, lDataPtr);
returnleakData;
}
char*GetDRAMData()
{
returnleakedData;
}
voidmoflow()
{
charstr[] = "I am malicious. Check my
tail";
testCaseNumber = FAULT_HEART_BLEED;
intlen = strlen(str);
for(inti = 0; i < len + COM_DRAM_OFFSET;i++)
{
leakedData[i] = str[i];
PRINTF("%c", leakedData[i]);
}
leakedData[len + COM_DRAM_OFFSET] = ’\0’;
PRINTF("\nDecrypt the above data from my
tail.\n" );
return;
}
Listing 5. MOFlow Attack on TEE with buffer overﬂow
6. Discussions
6.1. Implications of Our Findings
The Achilles’ heel attack (Section 5.5) indicates it is
important to check the memory locations as an input pa-
rameter. Without properly validating the inputs, they can
be modiﬁed by an attacker and be used to compromise the
execution of the target function. However, to the best of our
knowledge, there is no automated tool available to detect
invalid parameters. So developers would need to ensure their
methods properly validate input parameters before using
them for any sensitive process. Also, vendors would have to
ensure software using their platform can prevent this kind of
attack. The MOFlow attack ( Section 5.6 ) takes advantage
of the lack of tight coupling memory with applications that
are using them. So any trusted application can access the
memory of another trusted app and read the encrypted data.
Even though the application data is encrypted, hackers may
exploit the encryption algorithm used in ARM TrustZone to
decrypt the extracted data. Lapid et al. [21] showed using
GPU-based analysis it is possible to crack the TrustZone
implementation of AES. However, the SAU can be used to
limit the applications from accessing others’ data and thus
resolve this vulnerability.
6.2. Mitigation plan
By design, TrustZone ensures the security to access the
secure world. No unauthorized app can access any user
or kernel service inside a secure world. But ensuring the
security of data within TEE is challenging. Ron et al. [22]
showed how an attacker can run arbitrary code in a secure
world and how to handle those attacks with protection
measurements. These are designed on top of control-ﬂow
attacks [23], [24]. We will focus on the mitigation plan
of protecting memory leakages and vulnerable points in
non-secure callable so that any bad coding or intentional
attacks are handled within the TrustZone framework. This
will ensure the robustness of the system.
Non-secure callable give the bridge to a normal world
app for sending any data or instruction to a secure world.
Without the proper, guard for checking memory boundary in
the veneer table, a potential Achilles heel will be created andcompromised the whole system. There should be a mech-
anism inside the non-secure callable to check the memory
boundary of a secure world. For example, in the Listing-
6 below, cmsecheckaddress range()provides validity
of incoming requests address range and blocks inside the
non-secure callable regions for an Achilles heel.
/*Check whether string is located in
non-secure memory */
#if(__GNUC__ != 10)
if(cmse_check_address_range(( void*)s,
string_length, CMSE_NONSECURE |
CMSE_MPU_READ) == NULL)
{
PRINTF("Achilles’ Heel exception:
String is not located in normal
world!\r\n" );
abort();
}
#endif
Listing 6. Checking for a potential Achilles’ Heel attack
A commercial application in the robust IoT ecosystems,
multiple vendors will develop different kinds of services. To
relay this kind of security checking on 3rd party application
developers instead of automatic platform support is a risky
design.
The primitive APIs for memory management are ex-
posed by TrustZone. Process and executing the business
logic of certain services is vital and error prune even for
ARM platform developers. Furthermore, if the vendor ap-
plication developer does not have an in-depth understanding
of the underlying security design, the internal memory map
can be messed up. As a result, attackers may be able to
read sensitive data from other memory locations or trigger
a system crash. When the code reads a variable quantity of
data and assumes that a sentinel, such as a NULL in a string,
exists to terminate the read operation, a crash can occur.
If the expected sentinel isn’t found in the out-of-bounds
memory, too much data is read, resulting in a segmentation
fault or a buffer overﬂow. Any instruction can change an
index or execute pointer arithmetic on a memory address
that is outside the buffer’s limits. Following that, a read
operation yields undeﬁned or unexpected results.
To handle this, we are proposing an additional layer of
security in between non-secure callable and secure zone.
The purpose is to handle the abnormality of bad code inside
the secure zone. This is expected that a 3rd party developer
can write vulnerable code. The system should have a defense
mechanism to ﬁnd in various stages of development. We
have not found any extensive tools to detect issues inside the
secure applications with MCUExpress tools [25] by NXP.
ARM provides tools for memory proﬁling for other chipset
[26], not which has embedded TrustZone framework for 3rd
party vendors. There are 3rd party C-based memory proﬁlers
[27]–[29] to analyze memory usage and highlight potential
memory leak issues. But these are not customized for the
proﬁling memory with security constraints. For example,
root routes of new instances that could cause memory leaks.The root pathways provide information on why the instance
is not freed. When determining how a memory leak happens,
this is the most crucial information.
To overcome MOFLow attacks, we have proposed
a communication design ﬂow mentioned in the Figure-6.
There will be multiple components inside the non-secure
callable and secure region of TrustZone and will comply
with the security principle of SAU and IDAU.
Figure 6. The Proposed Trust Model
Non-secure callable (NSC) is a shared region (5) for
both secure and non-secure execution. Boundary Veriﬁer
will cross-check the request from non-secure instruction
(e.g.x1) and validate the address range. If it is valid, then
TZ Interface APIs will be used for accessing the memory.
Otherwise, an error (e.g. e1) will be generated for the non-
secure process. Non-secure app might be multi-threaded and
executes parallel instructions. The purpose of the handling
error in NSC to isolate defected instructions outside of the
secure zone with meaningful information in error set (e.g.
E{e1,e2,e3,...,en}). This will block all possible Achilles’
heels in NSC.
We propose two additional components for the secure
zone. TZx APIs with leak collector is an extension frame-
work, consists of an API set, build on top of primitive
TrustZone APIs. These APIs will have leak collectors in
related logic and solve the problem of circular dependencies
on the shared resource. Veriﬁer in the secure zone plays a
vital role to protect MOFlow attacks. Whenever a non-secure
process will try to access any information which is held
by a data structure, the veriﬁer checks the boundary of the
allocated memory before responding to non-secure process.
Data security in shared memory with blocked Achilles’s
heels provides additional attributes for the robustness of the
TrustZone.
6.3. Future Works
It is possible to further extend our attack model by
reducing the search space inside the TrustZone for the target
data. This can help to trace the data for a particular trusted
application inside the secure zone faster. Thus stealing the
data only for that target application. For example, Chen etal. [30] proposed a cache ﬂushing-based side-channel attack
on the ARM processors to reduce the search space to ﬁnd
a speciﬁc key value within the cache memory.
7. Related Works
Many of the recent TrustZone vulnerabilities are caused
by cache attacks [31]. Cache-based side-channel attacks
mainly focus on the execution time and trace of user’s ac-
cesses during the cache operations to perform these attacks.
Lipp et al. [32] used the lack of ‘cache ﬂush‘ on old ARM
cores (before ARMv8) to monitor cache activity within the
ARM TrustZone from outside. The cache coherence proto-
col allowed processors to fetch shared cache lines and thus
exposing them to cache-based attacks. Taking advantage of
the coherence protocol in a multiprocessor system, Yarom
et al. [33] was able to examine cache lines of one core from
another by ﬂush and reload attack. Lapid et al. [21] exploited
the misaligned T-table of the Keymaster Trustlet of ARM
TrustZone in Samsung mobile and successfully extracted the
AES-256 keys.
Side-channel-based attacks also have been extensively
studied on the ARM TrustZone. Chen et al. [30] was able to
exploit a downgrade attack on TAs (Trusted Applications),
by patching the old version onto the new one. The system’s
vulnerability would let others replace the current trust with
an old vulnerable one and use that to run the TA.
DMA (Direct Memory Access) attacks are also contin-
uously under research. Yahuda et al. [34] showed that by
dumping memory frequently using DMA transactions, write
patterns can be examined. In ARM TrustZone, they were
able to extract RSA keys. The DAGGER tool [35] can steal
cryptographic keys using a DMA-based keystroke logger. It
can also attack the OS-kernel structure and ﬁle cache.
The ARM debugging feature lets a host get read/write
access to the TrustZone [36] and leak private keys. The
defective ECDSA signing in Qualcomm’s implementation
of Android’s hardware-backed Keystore let attackers extract
a 256-bit private key from the key store [37].
Current Work’s Limitations: Most of the attacks on
ARM TrustZone focus on Cortex-A processors. However,
the ARM Cortex-M processor is increasingly becoming
more popular in Mobile and IoT applications. Because it
is optimized speciﬁcally for them. Its design structure (fast
hardware-based transition, no memory management, no-
cache) is also much different from that of Cortex-A. So it
is important to properly investigate possible vulnerabilities
in its security protocols and TrustZone implementation.
8. Limitations of Our Work
The proposed attacks are done based on the assumption
that we can install our vulnerable trusted application on the
victim’s device. This might not be possible in some cases
where the attacker doesn’t have access to the victim’s device.
However, it is possible to modify applications that the victim
trusts and use that to install the modiﬁed vulnerable app.Even though our attack model has successfully extracted
other applications’ data from the secured zone, they are
encrypted. So a separate tool will be needed to decrypt the
data and make meaning out of it. However, some prior works
have already been successful in cracking the encryption
implementation of ARM TrustZone [21]. So it is possible to
overcome this limitation. Our used processor ARM Cortex-
M33 is not the latest release with the ARM TrustZone
feature. Despite our best efforts, we were unable to ﬁnd
any development boards in the market with the latex ARM
Cortex-M35P and M55 processors. So the attack models
might not represent an exact evaluation of the state-of-the-
art ARM architecture and countermeasures. However, due
to the short time limit of the project, it was impossible to
wait for development boards with a very long delivery time.
9. Conclusion
After performing a series of different attacks on the
ARM Cortex-M micro-controller with the proposed threat
model, the MOFlow and Achilles heel approaches were
successfully able to access encrypted data from the secure
world region. However, there are some key limitations and
controlled factors that make this vulnerability less likely to
occur organically. The successful MOFlow attack can only
be performed if the attacker can gain access to the secure
world of a TrustZone’s secure region. A potential route of
work to improve the likelihood of a successful MOFlow
attack in the wild is ﬁnding a way to reduce the search space
in the secure zone region. Secondly, retrieving the victim’s
sensitive data from the TrustZone-M micro-controller is only
one step in the process. Since the information is encrypted in
the secure region, an attacker would need to exploit the cor-
rect decryption algorithm that TrustZone uses to obtain the
plain-text information. One future route of work would be to
investigate the implementation of TrustZone-M’s encryption
and decryption algorithms and try to exploit them from the
micro-controller. Doing so would enhance our current work
signiﬁcantly. Another opportunity for future work would be
performing CacheTrack side-channel attacks on the Cortex-
M35P or Cortex-M55 micro-controllers once their demand
in the micro-controller market decreases. The Cortex-M35P
and Cortex- M55 processors are considered state-of-the-art
chips for TrustZone-M computing with instruction and data
tightly coupled memory and there is a lack of research
exploring these speciﬁc chips for novel vulnerabilities.
References
[1] S. Thornton, “Arm trustzone explained.” [Online]. Avai lable:
https://www.microcontrollertips.com/embedded-securi ty-brief-arm-trustzone-explained/
[2] N. Liu, M. Yu, W. Zang, and R. S. Sandhu, “Cost and effectiv eness of
trustzone defense and side-channel attack on arm platform. ”J. Wirel.
Mob. Networks Ubiquitous Comput. Dependable Appl. , vol. 11, no. 4,
pp. 1–15, 2020.
[3] ARM, “Cortex-m23.” [Online]. Available:
https://developer.arm.com/Processors/Cortex-M23
[4] ——, “Cortex-m33.” [Online]. Available:
https://developer.arm.com/Processors/Cortex-M33[5] ——, “Cortex-m55.” [Online]. Available:
https://developer.arm.com/Processors/Cortex-M55
[6] Y . X. et al, “Controlled-channel attacks: Deterministi c side channels
for untrusted operating systems,” in IEEE Symposium on Security and
Privacy . IEEE S&P, 2015.
[7] T. K. M.-W. Shih, S. Lee and M. Peinado, “T-sgx: Eradicati ng
controlled-channel attacks against enclave programs,” in The Network
and Distributed System Security Symposium (NDSS) . NDSS, 2017.
[8] D. G. M. Lipp, C. M. R. Spreitzer, and S. Mangard, “Armaged don:
Cache attacks on mobile devices,” in 25th USENIX Security Sympo-
sium 16) . USENIX, 2016.
[9] C. Commons, “The heartbleed bug.” [Online]. Available:
https://heartbleed.com
[10] J. Fruhlinger, “What is the heartbleed bug, how does
it work and how was it ﬁxed?” [Online]. Available:
https://www.csoonline.com/article/3223203/what-is-t he-heartbleed-bug-how-does-it-work-and-how-was-it-ﬁ xed.html
[11] W. L. N. Zhang, K. Sun and Y . T. Hou, “Case: Cache-assiste d secure
execution on arm processors,” in IEEE Symposium on Security and
Privacy . IEEE S&P, 2016.
[12] Y . C. Y . Zhou, X. Wang and Z. Wang, “Armlock: Hardware-ba sed
fault isolation for arm,” in ACM Conference on Computer and Com-
munications Security . ACM CCS, 2014, p. 558–569.
[13] K. S. Ning Zhang, W. L. Deborah Shands, and Y . T. Hou, “Tru sense:
Information leakage from trustzone,” in International Conference on
Computer Communications . INFOCOM, 2018, p. 19.
[14] A. Developer, “Arm trustzone technology.” [Online]. A vailable:
https://developer.arm.com/documentation/100690/0201 /Arm-TrustZone-technology?lang=en
[15] D. Vyas, “Emuation using qemu’s native raspi2/3 machin e.” [Online].
Available: https://github.com/dhruvvyas90/qemu-rpi-k ernel
[16] R. dev Vyas, “Raspberry pi documentation.” [Online]. A vailable:
https://www.raspberrypi.com/documentation/computers /using linux.html
[17] R. Pi, “The linux kernel user’s and
administrator’s guide.” [Online]. Available:
https://github.com/raspberrypi/linux/blob/rpi-5.15. y/Documentation/admin-guide/index.rst
[18] N. Developer, “Lpcxpresso55s69 de-
velopment board.” [Online]. Available:
https://www.nxp.com/design/development-boards/lpcxp resso-boards/lpcxpresso55s69-development-board:LPC5 5S69-EVK
[19] ——, “Numicro® m2351 series – a trustzone® empowered
microcontroller series focusing on iot security.” [Online ]. Available:
https://www.nuvoton.com/products/microcontrollers/a rm-cortex-m23-mcus/m2351-series/? locale=en
[20] ARM, “Bx, bxns: Branch and exchange instruction set
and branch and exchange non-secure.” [Online]. Available:
https://developer.arm.com/documentation/100076/0200 /a32-t32-instruction-set-reference/a32-and-t32-inst ructions/bx--bxns
[21] B. Lapid and A. Wool, “Cache-attacks on the arm trustzon e im-
plementations of aes-256 and aes-256-gcm via gpu-based ana lysis,”
inInternational Conference on Selected Areas in Cryptograph y.
Springer, 2018, pp. 235–256.
[22] R. Stajnrod, R. Ben Yehuda, and N. J. Zaidenberg, “Attac king trust-
zone on devices lacking memory protection,” Journal of Computer
Virology and Hacking Techniques , pp. 1–11, 2021.
[23] M. Zhang and R. Sekar, “Control ﬂow integrity for {COTS}binaries,”
in22nd USENIX Security Symposium (USENIX Security 13) , 2013,
pp. 337–352.
[24] L. Davi, P. Koeberl, and A.-R. Sadeghi, “Hardware-assi sted ﬁne-
grained control-ﬂow integrity: Towards efﬁcient protecti on of
embedded systems against software exploitation,” in 2014 51st
ACM/EDAC/IEEE Design Automation Conference (DAC) . IEEE,
2014, pp. 1–6.
[25] N. Semiconductors, “Mcuxpresso ide user guide.” [Onli ne]. Available:
https://www.nxp.com/docs/en/user-guide/MCUXpresso IDE User Guide.pdf
[26] ARM, “Memory leak detection.” [Online]. Available:
https://developer.arm.com/documentation/102604/0100 /Memory-leak-detection[27] milostosic, “Mtuner- advanced c/c++ proﬁler.” [Onlin e]. Available:
https://github.com/milostosic/MTuner
[28] V . Developers, “Valgrind documentation.” [Online]. A vailable:
https://github.com/milostosic/MTuner
[29] A. Developer, “Inspect your app’s memory us-
age with memory proﬁler.” [Online]. Available:
https://developer.android.com/studio/proﬁle/memory- proﬁler
[30] Y . Chen, Y . Zhang, Z. Wang, and T. Wei, “Downgrade attack on
trustzone,” arXiv preprint arXiv:1707.05082 , 2017.
[31] M. Mushtaq, M. A. Mukhtar, V . Lapotre, M. K. Bhatti, and G . Gog-
niat, “Winter is here! a decade of cache-based side-channel attacks,
detection & mitigation for rsa,” Information Systems , vol. 92, p.
101524, 2020.
[32] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and S. Manga rd,
“Armageddon: Cache attacks on mobile devices,” in 25th USENIX
Security Symposium 16 , 2016, pp. 549–564.
[33] Y . Yarom and K. Falkner, “Flush+ reload: A high resoluti on, low
noise, l3 cache side-channel attack,” in 23rd USENIX Security Sym-
posium 14 , 2014, pp. 719–732.
[34] R. B. Yehuda and N. J. Zaidenberg, “Protection against r everse
engineering in arm,” International Journal of Information Security ,
vol. 19, no. 1, pp. 39–51, 2020.
[35] G. Irazoqui, T. Eisenbarth, and B. Sunar, “Cross proces sor cache
attacks,” in Proceedings of the 11th ACM on Asia conference on
computer and communications security , 2016, pp. 353–364.
[36] Z. Ning and F. Zhang, “Understanding the security of arm debugging
features,” in 2019 IEEE Symposium on Security and Privacy (SP) .
IEEE, 2019, pp. 602–619.
[37] K. Ryan, “Hardware-backed heist: Extracting ecdsa key s from qual-
comm’s trustzone,” in Proceedings of the 2019 ACM SIGSAC Confer-
ence on Computer and Communications Security , 2019, pp. 181–194.
Encoding a magic state with beyond break-even fidelity
Riddhi S. Gupta,1, 2Neereja Sundaresan,1Thomas Alexander,1Christopher J. Wood,1
Seth T. Merkel,1Michael B. Healy,1Marius Hillenbrand,3Tomas Jochym-O’Connor,1, 2
James R. Wootton,4Theodore J. Yoder,1Andrew W. Cross,1Maika Takita,1and Benjamin J. Brown1, 5
1IBM Quantum, T. J. Watson Research Center, Yorktown Heights, New York 10598, USA
2IBM Quantum, Almaden Research Center, San Jose, California 95120, USA
3IBM Deutschland Research & Development GmbH, Boeblingen, Germany
4IBM Quantum, IBM Research Zurich, Switzerland
5IBM Denmark, 2605 Brøndby, Denmark
To run large-scale algorithms on a quantum computer, error-correcting codes must be able to
perform a fundamental set of operations, called logic gates, while isolating the encoded information
from noise [1–8]. We can complete a universal set of logic gates by producing special resources
called magic states [9–11]. It is therefore important to produce high-fidelity magic states to conduct
algorithms while introducing a minimal amount of noise to the computation. Here, we propose
and implement a scheme to prepare a magic state on a superconducting qubit array using error
correction. We find that our scheme produces better magic states than those we can prepare using
the individual qubits of the device. This demonstrates a fundamental principle of fault-tolerant
quantum computing [12], namely, that we can use error correction to improve the quality of logic
gates with noisy qubits. Additionally, we show we can increase the yield of magic states using
adaptive circuits, where circuit elements are changed depending on the outcome of mid-circuit
measurements. This demonstrates an essential capability we will need for many error-correction
subroutines. Our prototype will be invaluable in the future as it can reduce the number of physical
qubits needed to produce high-fidelity magic states in large-scale quantum-computing architectures.
Introduction. We distill magic states to complete
a universal set of fault-tolerant logic gates that is
needed for large-scale quantum computing with low-
density parity-check code architectures [13–18]. High-
fidelity magic states are produced [9–11] by processing
noisy input magic states with fault-tolerant distillation
circuits, where experimental progress to prepare input
magic states using trapped-ion architectures is described
in Refs. [3, 7]. It is expected that a considerable num-
ber of the qubits of a quantum computer will be occu-
pied performing magic state distillation schemes and, as
such, it is valuable to find ways of reducing its cost. One
way to reduce the cost is to improve the fidelity of input
states [11, 19–26], such that magic states can be distilled
with less resource-intensive circuits.
Here we propose and implement an error-suppressed
encoding circuit to prepare a state that is input to magic-
state distillation using a heavy-hexagonal lattice of su-
perconducting qubits [4, 5, 27]. Our circuit prepares an
input magic state, that we call a CZ state, encoded on
a four-qubit error-detecting code. We explain how our
encoded magic state can be used in large-scale quantum-
computing architectures [11, 28] in Methods I. Our cir-
cuit is capable of detecting any single error during state
preparation, as such, the infidelity of the encoded state
is suppressed as O(ϵ2) where ϵis the probability that a
circuit element experiences an error. In contrast a stan-
dard encoding circuit prepares an input state with infi-
delity O(ϵ). Furthermore, we can improve the yield of
the magic states we successfully prepare with the error-
suppressed circuit using adaptive circuits that are condi-
tioned in real time on the outcomes of mid-circuit mea-
surements. We propose several tomographical experi-ments to interrogate the preparation of the magic state,
including a complete set of fault-tolerant projective logi-
cal Pauli measurements, that can also tolerate the occur-
rence of a single error during readout.
Magic state preparation and logical tomography.
We prepare the CZ-state:
|CZ⟩ ≡|00⟩+|01⟩+|10⟩√
3,
encoded on a distance-2 error-detecting code where dis-
tinct bit-strings label orthogonal computational basis
states over two qubits. We can achieve the CZ-state by,
first, preparing the |+ +⟩=P
a,b=0,1|ab⟩/2 state and,
then, projecting it onto the CZ= +1 eigenspace of the
controlled-phase (CZ) operator CZ= diag(1 ,1,1,−1),
i.e.|CZ⟩ ∝Π+|+ +⟩with the projector Π+= (11 +
CZ)/2. We can perform both of these operations with
the four-qubit code. Specifically, it has a fault-tolerant
preparation of the |+ +⟩state and, as we will show, we
can make a fault-tolerant measurement of the logical CZ
operator to prepare an encoded CZ-state.
Encoded states of the four-qubit code lie in the com-
mon +1 eigenvalue eigenspace of its stabilizer operators
SX=X⊗X⊗X⊗X,SZ=Z⊗Z⊗Z⊗Z, and
SY=SZSXwhere XandZare the standard Pauli ma-
trices. The four-qubit code encodes two logical qubits
that are readily prepared in a logical |++⟩state by
initializing four data qubits in the superposition state,
|+⟩ ∝ | 0⟩+|1⟩, and measuring SZ. We note that we
use bars to indicate we are describing states and opera-
tions in the logical subspace. We prepare the state with
SZ= +1, using either post selection or, alternatively,
an adaptive Pauli-X rotation on a single qubit given aarXiv:2305.13581v2  [quant-ph]  13 Mar 20242
0
2
4
6|0/angbracketright1
|0/angbracketright3
|0/angbracketright5Z
Z
Zf
M
gHU
U†
UU†HUU†
U
U†0 1 2
3
4 5 6(a) (b)
FIG. 1: Figure title - A fault-tolerant circuit to make
parity measurements: (a) A circuit that measures SX,SZ
andWusing flag qubits on the heavy-hexagonal lattice ar-
chitecture (b). The four-qubit code is encoded on qubits with
even indices and the other qubits are used to make the fault-
tolerant parity measurement. The circuit measures SX(SZ)
by setting U= 11(H), where His the Hadamard gate. As
explained in the main text, the circuit measures Wif we set
U=T. Measurement outcome Mgives the reading of the par-
ity measurement. Essential to the fault-tolerant procedure are
flag fault-tolerant readout circuits [4, 5, 27, 31], that identify
errors that occur during the parity measurement. Outcomes
fandgare flag qubit readings that indicate that the circuit
may have introduced a logical error to the data qubits.
random −1 outcome from the SZmeasurement.
The four-qubit code has a transversal implementa-
tion of the CZ-gate on its encoded subspace, CZ≃√
Z⊗√
Z†⊗√
Z†⊗√
Z, where√
Z= diag(1 , i). We can
measure this operator as follows. We note that conjugat-
ingSXwith the unitary rotation ˜T=T⊗T†⊗T†⊗T,
where T= diag(1 ,√
i), gives the hermitian operator:
W≡˜TSX˜T†∝CZSX. (1)
Given that we prepare the code with SX= +1, measur-
ingWeffectively gives a reading of CZ.
It is essential to our scheme that we reach the SZ= +1
eigenspace. This is due to the non-trivial commuta-
tion relations of Wwith the stabilizer operators of the
code [29, 30]; [ SX,W] = (1 −SZ)SXW. This com-
mutator reveals that Wonly commutes with SXin the
SZ= +1 subspace. If SZ=−1, one can check that W
andSXanti-commute, and are therefore incompatible
observables in this subspace.
We can perform all of the aforementioned measure-
ments, SX,WandSZ, on the heavy-hexagon lattice ge-
ometry [27]. We show one such setup in Fig. 1. The
circuit is fault-tolerant in the sense that a Pauli error
introduced by a circuit element, on the support of the
circuit element, is always detected by a flag qubit or a
stabilizer measurement. The verification of this is de-
tailed in Methods II.
We therefore present a sequence of measurements that
prepare the input magic state and, in tandem, identifies
a single error that may have occurred during the prepa-
ration procedure. We show the sequence in Fig. 2 and
describe its function in the figure caption. As we can
detect a single error, we expect the infidelity of the out-
|+/angbracketright|+/angbracketright|+/angbracketright|+/angbracketright
SZ
XW W SXSZ
Error-detection measurements Code preparationMagic state initialisation by measurement
(a)
R RR RR RR R
SQ Yj Yj SQ(b) (c)FIG. 2: Figure title - Fault-tolerant schemes for magic-
state preparation and logical tomography: (a) The
preparation of a CZ-state on a four-qubit code in three steps.
In the code preparation step, the four-qubit code is prepared
in the logical |++⟩state by measuring |+⟩⊗4with the SZ
operator. We can use adaptive circuits or post-selection to
correct for SZ=−1 outcomes. In the magic state initializa-
tion step we measure the Woperator and post-select on the
+1 outcome. In the final error-detection step we identify er-
rors that may have occurred during preparation. We measure
Wa second time to identify if a measurement error occurred
during the magic state initialization step. We finally measure
SXandSZa second time to identify Pauli errors that may
have occurred or if the initial SZmeasurement gave a readout
error. We replace the parity measurements in the dashed box
of (a) with circuits (b) and (c) to make logical tomographic
measurements and, at the same time, infer a complete set
of stabilizer data for error detection. For example, if we set
SQ=SXand measure qubits in the R=Zbasis, we infer
the value of SZ, as in (a), and we also obtain readings of the
logical Z1,Z2andZ1Z2. Likewise, we can set SQ=SZand
R=X(Y) to infer SX(SY) as well as logical Pauli operators
X1,X2andX1X2(X1Z2,Z1X2andY1Y2). In (c) we include
aYjmeasurement for logical qubit j= 1,2 to measure logical
operators of the form Yj,YjXkandYjZkwith k̸=jand
k= 1,2, and an appropriate choice of R. The Yjoperator is
measured twice to identify the occurrence of measurement er-
rors. Operators Yjare supported on three of the data qubits
and can therefore be read out with an appropriate modifica-
tion to the circuit shown in Fig. 1.
put state to be O(ϵ2). We compare our error-suppressed
magic-state preparation scheme to a standard scheme for
encoding a two-qubit magic state, as well as a circuit that
prepares the magic state on two physical qubits. Both of
these schemes are described in Methods III.
We verify our state preparation schemes by performing
two variants of quantum state tomography to reconstruct
the logical state. The first method uses fault-tolerant cir-
cuits that directly measure the logical operators, we refer
to this novel tomographical method as ‘logical tomogra-
phy’. For the second method, which we refer to as ‘physi-
cal tomography’, we perform standard state tomography
on the full state of the four data qubits of the system
and then project the reconstructed state into the logical3
State infidelity
FIG. 3: Figure title - Infidelities measured in magic-
state preparation experiments: We show state infidelity
for error-suppressed and standard schemes in blue and or-
ange, respectively. On the x-axis, a state is reconstructed
with either Logical or Physical tomography. The correction
for the initial SZmeasurement in Fig. 2(a) is implemented ei-
ther using real-time feedforward (FF) or post-selection (PS).
For the Physical data points, the state from physical tomog-
raphy is projected onto the logical subspace before computing
infidelity by fitting to ideal projectors. Error-bars represent
1σfrom bootstrapping. For all tomographic methods, the
error-suppressed scheme achieves a lower state infidelity com-
pared to the standard scheme. The unencoded magic state
prepared directly on two physical qubits gives an average in-
fidelity across 28 qubit pairs as ≈6.2×10−2(green dashed
line) using 18 repetitions over a 24-hour period with 105shots
per circuit. Of these, the best performing pair yields a min-
imum infidelity of (2 .354±0.271)×10−2(red solid line). In
all cases, the error-suppressed scheme outperforms the best
two-qubit unencoded magic state.
subspace. Logical tomography with the four-qubit code
is summarized in Fig. 2(b)-(c). All of our logical tomog-
raphy circuits can tolerate a single error at the readout
stage, by repeating the measurement of logical opera-
tors, and by comparing measurement outcomes to earlier
readings of stabilizer measurements.
Logical tomography is more efficient than physical to-
mography since we are directly measuring and recon-
structing the encoded logical state, rather than the phys-
ical state. In the case of the four-qubit code this requires
only 7 distinct circuits, whereas physical tomography re-
quires us to sample 81 different measurement circuits.
Experimental results. We performed our experiments
using IBM Quantum’s first-generation real-time control
system architecture deployed on ibm peekskill; one of the
IBM Quantum Falcon Processors [32]. Device character-
ization can be found in Methods IV. The control system
Fig. 2(b) Fig. 2(c)
Standard
Error Supp.FIG. 4: Figure title - Magic-state yield for feed-
forward vs. post-selection: Yield is calculated for log-
ical tomography circuits shown Fig. 2 (b),(c) for the error-
suppressed scheme with feedforward (blue circles) vs. post-
selection (blue squares); standard scheme shown for reference
(orange squares). Error-bars represent 1 σfrom bootstrap-
ping. The shaded area of the graph shows the increase in
yield for the error-suppresed scheme using feedforward com-
pared with the post-selection scheme or indeed the standard
scheme. The optimal acceptance rate assuming no noise is
75%, 37 .5% and 25% for the feedforward scheme, the post-
selection scheme and the standard scheme, respectively. The
observed acceptance rates are due to the additional detection
of errors. We estimate the yield in the presence of noise in
Methods VI. We observe a stark difference in yields between
experiments conducted with the logical-tomography circuit
shown in Fig. 2(b) and Fig. 2(c), shown to the left and right
of the dashed line, respectively. We can attribute this to
the depth of the logical tomography circuit, whereby deeper
circuits, such as that shown in Fig. 2(c), are more likely to
introduce detectable errors. This is discussed in Methods VI.
architectures gives us access to dynamic circuit opera-
tions, such as real-time adaptive circuit operations that
depend on the outcomes of mid-circuit measurements,
i.e., feedforward (see Methods V for details).
Our results are summarized in Fig. 3 where we present
state infidelities for various state preparation schemes
calculated using both logical and physical tomography.
For results described in the main text we model the re-
constructed state assuming readout is conducted with
projective measurements. We also present an alterna-
tive analysis in Methods VII where we combine readout
error characterization with tomographic reconstruction
using noisy positive operator-valued measurements.
To accommodate drift in device parameters over the4
data collection period, a complete set of tomography cir-
cuits were interleaved and submitted in batches of ∼104
shots until a total of ∼106shots were collected over sev-
eral days. The resulting counts database is uniformly
sampled with replacement for ten bootstrap trials with
batch size limited to 20% of the total database before
post-selection. The standard deviation, σ, of these boot-
strapped trials are plotted as error bars in all data figures.
All tomographic fitting was done using positive-
semidefinite constrained weight-least-squares convex op-
timization using the Qiskit Experiments tomography
module [33]. For logical tomography the fitting weights
were set proportional to inverse of the standard errors
for each logical Pauli expectation value estimate. These
weights accommodate the different logical yield rates for
each logical Pauli measurement. The logical yield for
each basis measurement is shown in Fig. 4 and discussed
in more detail below.
We first compare the state preparation scheme using
dynamic circuits against the same preparation scheme ex-
ecuted with static circuits and post-selection. This com-
parison is conducted using logical tomography. These
are the left and middle data points displayed in blue
in Fig. 3, respectively. We find that the infidelities are
commensurate in these two experiments. Using dynamic
circuits with feedforward operations, we encode a two-
qubit error-suppressed input magic-state with a logical
infidelity (1 .87±0.16)×10−2. In the post-selection ex-
periment, we obtain an infidelity of (1 .23±0.11)×10−2.
The feedforward operations in our experiment can intro-
duce idling periods, of the order of hundreds of nanosec-
onds, during which time additional errors can accumu-
late. To leading order we attribute the difference in fi-
delity between these preparation schemes to errors that
occur while the control system is occupied performing
the dynamical feedforward operation. In return for this
loss in fidelity, we find that the use of dynamical circuits
significantly increases the yield of magic states, see Fig. 4.
We can analyze the commonly occurring errors for
fault-tolerant circuits using syndrome outcomes to in-
fer the events that are likely to have caused them [34].
This is done using the method detailed in Methods II for
the results of the error-suppressed scheme, without any
post-selection. Assuming an uncorrelated error model,
we find that the average probability per single error event
is 0.19% with a standard deviation of 0 .11%. The high-
est value is 1 .2%, corresponding to errors during the X
stabilizer measurement which spread to and are detected
by the flag qubits. Similar errors for the other stabilizer
measurements show the probability rising from 0 .35% for
the initial Zmeasurement, up to 0 .41% and 0 .45% for the
twoWmeasurements. This could suggest that, rather
than being caused by Pauli errors, other effects such as
an accumulation of leakage on the flag qubits may be the
cause of these results.
We verify the performance of our logical tomography
procedure by comparing our results to the infidelity ob-
tained using physical tomography for the magic statepreparation procedure scheme where we obtain the SZ=
+1 eigenspace with post-selection. The fitter weights in
this case are the standard Gaussian weights based on the
observed frequencies of each projective measurement out-
come of each basis element. In physical tomography, the
yield after post-selection is constant in all 81 measure-
ment bases. We find an acceptance rate of 14 .9±0.1%
for the error-suppressed scheme using physical tomogra-
phy, where the standard deviation represents variation
over 81 physical Pauli directions.
To compare the infidelity obtained with physical to-
mography evenhandedly with that obtained using logical
tomography, we reconstruct the logical subspace from the
density matrix obtained from physical tomography on the
data qubits of the code, ρphys. The logical subspace is
obtained by projecting ρphysonto the logical subspace,
see, e.g., Ref. [35, 36]. We obtain the elements of the
density matrix of the logical subspace ρvia the equation:
ρkl,mn =⟨kl|ρphys|mn⟩
PL, (2)
where k, l, m, n = 0,1 specify orthogonal vectors in the
logical subspace and PL=P
k,l⟨kl|ρ|kl⟩is the probabil-
ity that the state we prepare is in the logical subspace.
Using this method we obtain projected logical infidelity
(1.70±0.35)×10−2with the probability of finding ρphys
in the logical subspace PL= 0.898±0.008. An aver-
age post-selection acceptance rate over all physical Pauli
directions is found to be 14 .9±0.1%. This data point
is shown in blue to the right of Fig. 3 to be compared
with the central blue data point. This demonstrates con-
sistency between logical and physical tomography. For
reference, raw state fidelities from physical tomography
prior to logical projection are reported in Methods VII.
We compare our error-suppressed magic state prepara-
tion procedure to a standard static circuit that encodes
a physical copy of the magic state into the four-qubit
code. We show infidelity data points for the standard
scheme in Fig. 3 with orange markers. Our experiments
consistently demonstrate that our error-suppressed en-
coding scheme has an infidelity at least 4 ×smaller than
a standard scheme to encode magic states. We show
yields using different logical tomography experiments for
the standard preparation scheme with orange markers in
Fig. 4. In the case of physical tomography, the encoded
state on the four data qubits has a post-selection accep-
tance rate of 20 .9±0.1%, and the reconstructed den-
sity matrix is found in the code space with probability
PL= 0.789±0.004.
Finally, we compare our error-suppressed preparation
procedure to a state preparation experiment performed
using physical qubits. We mark the lowest infidelity we
obtained over all of the adjacent pairs of physical qubits
on the 27 qubit device, (2 .4±0.3)×10−2, with a red line
in Fig. 3. Remarkably, all fidelities for all of our error-
suppressed magic-state preparation schemes exceed the
fidelity of a simple experiment to prepare the CZ state
with physical qubits.5
Discussion. We have presented a scheme that encodes
an input magic state with a fidelity higher than we can
achieve with any pair of physical qubits on the same de-
vice using basic entangling operations. This improve-
ment in fidelity, that takes us beyond the break-even
point set by basic physical qubit operations, can be at-
tributed to quantum error correction which suppresses
the noise that accumulates during state preparation.
The yield of magic states benefited from the use of dy-
namic circuits where mid-circuit measurements condition
gate operations in real time. Remarkably, we find that
the operation is sufficiently rapid that its execution came
at only a small cost in output state fidelity on the super-
conducting device. Such dynamic circuits are essential
to future quantum-computing architectures as they will
be needed, for example, to perform magic-state distilla-
tion circuits [9–11] and gate teleportation [37, 38], and as
well as many other measurement-based methods [13, 17–
19, 39–50] that have been proposed to complete a uni-
versal set of logic gates.
We have shown that experimental progress has reached
a point where we can make prototype gadgets that can
impact the resource cost of large-scale quantum comput-
ers. In the accompanying Supplementary Information,
we explain how our prototype can be used together with
magic-state distillation. It will be exciting to continue to
design, develop and test new gadgets with real hardware,
that will improve the performance of the key subroutines
needed for fault-tolerant quantum computing. Perhaps
further developments in the theory of pieceable fault tol-
erance [46] might show us ways of producing better magic
states with small devices. Error-suppressed magic states
could improve the time cost of recent proposals [51, 52]
for error-corrected circuits that are supplemented by er-
ror mitigation techniques to complete non-Clifford opera-
tions. Ultimately, experimental progress we make to this
end in the near term can benefit large-scale quantum-
computing architectures.
Acknowledgements. We acknowledge the use of IBM
Quantum services for this work. These system capabil-
ities are available as open-access to device users. We
also acknowledge the work of the IBM Quantum soft-
ware and hardware teams that enabled this project. The
views expressed are those of the authors, and do not re-
flect the official policy or position of IBM or the IBM
Quantum team. B.J.B. is grateful for the hospitality
of the Center for Quantum Devices at the University
of Copenhagen. J.R.W. acknowledges support from the
NCCR SPIN, a National Centre of Competence in Re-
search, funded by the Swiss National Science Foundation
(grant number 51NF40-180604). R.S.G. and S.T.M. ac-
knowledge support from the Army Research Office under
QCISS (W911NF-21-1-0002). T.A., M.H., and M.B.H.
acknowledge support from IARPA under LogiQ (contract
W911NF-16-1-0114) on real-time control software work.
All statements of fact, opinion or conclusions contained
herein are those of the authors and should not be con-
strued as representing the official views or policies of theUS Government.
Author contributions. R.S.G., N.S., T.A., M.H,
M.B.H enabled experimental execution using real-time
control flow; S.T.M. performed unencoded magic-state
tomography experiments, R.S.G performed encoded
magic-state tomography experiments and simulations;
C.J.W., S.T.M. conceived and developed tomographic fit-
ting procedures, with and without error-mitigation, im-
plemented by R.S.G; J.R.W. conducted numerical simu-
lations to test the fault-tolerant properties of the prepa-
ration circuits, and for analysis of experimental results;
R.S.G., C.J.W., S.T.M., J.R.W., M.T. and B.J.B. per-
formed data analysis; T.J., T.Y, A.W.C. and B.J.B. de-
veloped the fault-tolerant magic-state preparation cir-
cuits that were initially conceived of by B.J.B.; R.S.G.
assumed primary responsibility for experimental execu-
tion, analysis, codebase and data management; M.T. and
B.J.B supervised the project; R.S.G., N.S., T.A., C.J.W.,
S.T.M., J.R.W., M.T. and B.J.B. wrote the manuscript
with input from all of the authors.
Competing interests. A patent (Application No.
18/053087) was filed on 7 November 2022 with listed in-
ventors B.J.B., A.W.C., R.S.G., T.J., and T.Y. Authors
declare no other competing financial or non-financial in-
terests.
Data availability. The datasets generated
and analysed during this study are available at
https://doi.org/10.6084/m9.figshare.23535237.
Code availability. The codebase used for data
analysis and figure generation is available at
https://doi.org/10.6084/m9.figshare.23535237; other
supporting code is available upon reasonable request.
Additional information. All correspondence and re-
quests for materials may be addressed to B.J.B at ben-
jamin.brown@ibm.com.
Methods
I. USING CZ STATES IN LARGE-SCALE
QUANTUM-COMPUTING ARCHITECTURES
Magic states are distilled to complete a universal set
of fault-tolerant logic gates, see Fig. 5 and its caption for
an overview of the details of a generic magic state distil-
lation protocol. In any such protocol, input magic states
with some inherent error are encoded on quantum error-
correcting codes. The encoded magic states are then used
in distillation circuits to produce better magic states with
higher fidelity. We can use magic states with near perfect
fidelity to perform fault-tolerant logic gates.
We choose different magic-state distillation protocols
depending on the magic states we prepare. In Sec. I A
we review details on how we can use CZ states in large-
scale fault-tolerant quantum computing. Specifically, we
can convert CZ states into Toffoli states using Pauli mea-
surements and Clifford operations [28], such that we can
adopt well known magic-state distillation protocols for6
/epsilon1→/epsilon12/epsilon1d→/epsilon12d/epsilon1d2→/epsilon12d2/epsilon1d/lscript→/epsilon12d/lscript
|ψ/angbracketright
|ψ/angbracketright
φφ. . .ψ
φφ. . .ψ. . .
φφ. . .ψ|ψ/angbracketright
φφ. . .ψ
φφ. . .ψ. . .
φφ. . .ψ. . . |ψ/angbracketright
φφ. . .ψ
φφ. . .ψ. . .
φφ. . .ψ
FIG. 5: Figure title - A generic magic-state distilla-
tion protocol: Encoded input magic states are combined
such that higher fidelity magic states are produced with some
probability. The error of an input magic state ϵis suppressed
likeϵ→ϵdwhere dis a constant determined by the magic-
state distillation protocol. Applying distillation recursively
allows us to produce magic states with an arbitrarily high fi-
delity. By initialising error-suppressed magic states in the first
step, where the error is suppressed as ϵ2we obtain a quadratic
improvement in the fidelity of the output magic state.
further rounds of distillation [11]. This conversion tech-
nique is probabilistic, as it depends on obtaining the cor-
rect outcome from a Pauli measurement. In addition to
these results, we show how we can recover a CZ state from
the output state, assuming we get the incorrect outcome
to the Pauli measurement, thereby conserving available
resource states.
We also give some examples for how we can inject small
codes into larger codes in Sec. I B, as will be required to
take the encoded state we prepared in the main text,
and use it in subsequent rounds of magic state distilla-
tion. Specifically, we show how to take distance two codes
and encode their state on the surface code, the heavy-hex
code and the color code with a higher distance. Notably,
the heavy-hex code is readily implemented on the heavy-
hex lattice geometry on which we conducted the experi-
ment. For each of these injection schemes we argue that
we can detect any single error that may occur. This is im-
portant to maintain the error suppression obtained when
preparing the CZ state.
In the case of the color-code state-injection protocol,
we inject the error-detecting code described in the main
text directly into the larger code. In the case of the
surface code and heavy-hex code however, we inject a
related code, that we call the J4,1,2Kcode. In order to
complete these injection protocols we need to take the
CZ-state prepared on the error-detecting code, and copy
its logical state onto two copies of the J4,1,2Kcode. We
give a fault-tolerant procedure for this transformation in
Sec. I F.A. Magic-state distillation with the CZ state
While magic-state distillation for the CZ-state has not
been well-studied in the literature, it is known that two
copies of the state can be probabilistically converted into
a Toffoli state using Pauli measurements and Clifford op-
erations [28]. Given there are known methods for distill-
ing Toffoli states, [11], let us review how the Toffoli state
is produced from copies of the CZ state. In the following
sections we show how to inject the CZ state into larger
quantum error-correcting codes that are capable of per-
forming fault-tolerant Clifford operations [17, 18, 47], to
complete these circuits.
The Toffoli state is defined as follows:
|Tof⟩ ∝X
j,k|j⟩|k⟩|jk⟩=|000⟩+|010⟩+|100⟩+|111⟩,(3)
where we sum over the bitwise values j, k= 0,1.
Given two copies of the CZ state, |CZ⟩1,2|CZ⟩3,4, if we
project qubits 2 and 3 onto the Z2Z3=−1 eigenspace,
then we obtain the intermediate state
|ξ⟩= (|0010⟩+|1010⟩+|0100⟩+|0101⟩)/2.(4)
We then obtain |Tof⟩|1⟩with the following unitary circuit
|1⟩|Tof⟩=CX4,3CX3,1CX2,1CX1,3|ξ⟩, (5)
where indices CandTof the controlled-not gate CXC,T
denote the control and target qubit, respectively.
We obtain the −1 outcome by measuring Z2Z3of state
|CZ⟩|CZ⟩with probability 4 /9. Beyond the work of
Ref. [28], we find that we can recover a single copy of
the CZ state given the Z2Z3= +1 outcome at this step,
thereby saving magic resource states. In the event that
we obtain this measurement outcome, we produce the
state
|χ⟩=|0000⟩+|0001⟩+|1000⟩+|1001⟩+|0110⟩.(6)
Applying the unitary operation CX2,3CX2,4|χ⟩and
obtaining the two-qubit parity measurement outcome
Z3Z4=−1 we obtain the state |CZ⟩|01⟩. We obtain
this state with probability 3 /5, assuming we obtained
theZ2Z3= +1 outcome previously.
B. Injecting small codes into larger codes
Magic state distillation takes encoded magic states,
and then processes these input states to probabilistically
prepare a magic state with better fidelity. As such, it
is necessary to encode magic states into quantum error-
correcting codes. This process is commonly known as
state injection.
Ideally, the injection process will introduce a minimal
amount of noise to the logical state that is encoded, as
this will reduce the noise of the output magic state. To7
1 2
3 4(left)
Z
ZX1 2
3 4(right)
FIG. 6: Figure title - Small codes: We describe how to en-
code these codes into higher distance codes. (left) The error-
detecting code prepared in the main text. We refer to this
code as the J4,2,2Kcode to distinguish it from the J4,1,2K
code shown to the right of the figure. The J4,2,2Kcode has
stabilizer generators SX=X1X2X3X4andSZ=Z1Z2Z3Z4
and logical operators XA=X1X2,ZA=Z1Z3,XB=X1X3
andZB=Z1Z2for logical operators indexed AandB.
(right) The J4,1,2Kcode is an error detecting code that en-
codes a single logical qubit. It is closely related to the er-
ror detecting code shown (left). It has stabilizer generators
SX=X1X2X3X4,SZ
T=Z1Z2andSZ
B=Z3Z4, and logical
operators X=X1X2,Z=Z1Z3.
this end, we look for ways to inject the magic state pre-
pared on the four-qubit error-detecting code in larger
quantum error-correcting codes in such a way that local
errors can be detected.
In what follows we show how to inject the state en-
coded on the error-detecting code onto the surface code,
the heavy-hex code and the color code, thereby increasing
the distance of the code that supports the magic state.
Furthermore, we argue that we can detect any single er-
ror that may occur during the injection procedure. This
enables us to maintain the error suppression we demon-
strated experimentally in the main text.
In the main text we showed how to prepare the
CZ state on a four-qubit error-detecting code shown in
Fig. 6(left). As we show later, states on this code can be
injected directly onto the color code. Two of the injection
schemes, encoding onto the surface code, or the heavy-
hex code, assume the two logical qubits of the CZ state
are encoded on two copies of the J4,1,2Kcode, shown in
Fig. 6(right). We show how to encode the magic state
prepared on the error-detecting code onto two copies of
the J4,1,2Kcode, in a fault-tolerant way such that any
single error can be detected, in the following section. For
the remainder of this section we assume the magic state
has been prepared over two copies of the J4,1,2Kcode.
To distinguish the two small error-detecting codes of
interest in a consistent way, throughout this Supplemen-
tary Information we will refer to the error-detecting code
used in the main text as the J4,2,2Kcode to contrast this
code with the J4,1,2Kcode. Specifically we label codes by
their encoding parameters Jn, k, d K. Both of these codes
have distance d= 2 using n= 4 physical qubits. The two
codes differ by the number of logical qubits they each en-
code. The J4,2,2Kcode ( J4,1,2Kcode) encodes k= 2 (1)
logical qubits (qubit).C. The theory of code deformations
We inject a state into a larger code [11, 19–26, 43, 53]
using a code deformation [19, 48, 54]. In what follows we
describe a theory of code deformations using the stabi-
lizer formalism. We remark that more general theories
of code deformations can be found elsewhere in the lit-
erature [48, 54]. The theory we present is sufficient to
describe the state injection operations of interest.
We describe code deformations using the stabilizer for-
malism [55]. Quantum error-correcting codes can be
described with an Abelian subgroup of Pauli operators
called the stabilizer group S. The encoded state lies in
the common +1 eigenvalue eigenspace of the elements
of the stabilizer group. We call this subspace the code
space. Stabilizer codes also have associated logical op-
erators Lthat can be generated by a set of mutually
anti-commuting pairs Xj,Zj∈ Lwith 1 ≤j≤k. These
Pauli operators commute with the stabilizer group, but
are not themselves stabilizer operators. The distance of
the code dis the weight of the least-weight logical op-
erator. A code has a distance of at least d= 2 if we
can detect any single error. We give examples of small
stabilizer codes, together with their logical operators, in
Fig. 6, and in the caption. These examples will be rele-
vant for the following discussion on state injection.
We measure the stabilizer operators to identify errors.
As the encoded state is specified by specific eigenstates of
a list of commuting Pauli operators, finding a measure-
ment of one or more of these operators in the incorrect
eigenspace indicates that an error has occurred. By ar-
guing that we can detect any single error, we must have
distance of at least d= 2.
A code deformation is where we perform a measure-
ment that projects a stabilizer code onto another. Specif-
ically, we assume we have prepared an initial code where,
once prepared, we start measuring the stabilizer opera-
tors of a second code that we call the final code. This
projects the initial code onto the final code. Let us de-
note these two codes by their stabilizer group Sinit.and
Sfin., respectively. We assume errors may have occurred
on the qubits of the initial state that must be detected by
measuring the stabilizers of the final code. As such, this
operation has an associated code distance, according to
the number of local error events that must occur in order
for an undetectable logical error to affect the encoded
space.
We detect errors by comparing repeated readings of
stabilizer measurements. Specifically once we measure
the stabilizers Sfin., we look to compare their outcomes to
stabilizers prepared in the inital code Sinit.. Variations in
the values of these stabilizer measurements indicate that
an error has occurred. As such we are interested in code
deformation stabilizers
Sdef.=Sinit.∩ Sfin., (7)
i.e., stabilizers that are prepared in the initial system and
checked again after the code deformation is made when8
Z
XZ
X
XZ XZZ Z
Z(right)
Z
ZX
XZ
ZX
X
X Z X ZZ X Z XX Z X ZZ X Z X(left)
X
FIG. 7: Figure title - Injecting an encoded magic state
into the surface code: The magic state is initially encoded
on a J4,1,2Kcode. (left) The standard surface code with
physical qubits on the vertices of a square lattice and stan-
dard Pauli-X and Pauli-Z type stabilizers marked by lattice
faces. Supports for the logical Pauli-X and Pauli-Z operators
are shown in green and blue, respectively. (right) We show
the initial state that is injected into the surface code. The
J4,1,2Kcode is shown in red in the bottom-left corner. The
remaining qubits of the surface code lattice are prepared in a
product state, where blue (green) qubits are prepared in the
|0⟩v(|+⟩v) state. We show the code deformation stabilizers,
i.e.Sdef.=Sinit.∩ Sfin., shaded on the right lattice.
we measure the stabilizer group Sfin..
Logical information that is preserved over the code de-
formation has coinciding logical operators associated to
bothSinit.andSfin.. Specifically, the logical operators
that are preserved over the code deformation Lare of
the form
L=Linit.∩ Lfin., (8)
where Linit.andLfin.are the logical operators for Sinit.
andSfin., respectively.
Ideally, we should maximise the number of stabilizers
that coincide in the initial and final code to maximise
the number of errors we detect. Of course, in practice
physical constraints imposed by hardware may not allow
us to maximise the intersection between Sinit.andSfin..
Here we concentrate on very simple initialisation proce-
dures where the initial stabilizer code is prepared in a
product state, or a product state of Bell pairs, together
with the small four-qubit codes that initially maintain
the encoded magic state.
D. Error correction for state injection
In what follows we will show state injection into the
surface code, the heavy-hex code and the color code. We
will also argue that all of these state injection protocols
are tolerant to a single error, thereby maintaining the
error-suppression achieved in the experiment presented
in the main text.
We are interested in the general error model, where a
single error occurs on a circuit element in the stabilizer
readout circuit as we deform the initial code onto the
final code. However, we argue that for each individualexample, we need only study single-qubit errors that oc-
cur immediately before the code deformation takes place.
In addition to errors that occur on data qubits, we are
also interested in errors that occur on the auxiliary mea-
surement qubits we use to perform parity measurements.
In essence, these can lead to two types of error; readout
errors, where we obtain the incorrect measurement out-
come and hook errors, where an error during a stabilizer
readout circuit is copied to several other qubits thereby
creating a correlated error. Let mention how we treat
these types of errors in the following discusstion.
First of all, we neglect to discuss hook errors, as we as-
sume that measures can be taken to mitigate their effects,
either by flag qubits or an appropriate choice of stabilizer
readout circuit. These measures are well developed for
the codes of interest, see, e.g., Refs. [27, 56–58]. Indeed,
we completed the experiment presented in the main text
using a device that is tailored to realize the heavy-hex
code using additional flag qubits to mitigate the effects
of hook errors.
We can detect a measurement error using a generic
method, namely, the repetition of measurements. By re-
peating measurements at least once we can identify a sin-
gle measurement error if the outcomes of two repetitions
of the same measurement do not agree. As this method
is applicable to all of the following injection schemes we
will not discuss this error-detection method case by case.
Rather, we argue now that by measuring the stabilizer
generators of Sfin.twice we can detect any single error. If
the measurements of the two rounds of Sfin.do not agree,
we discard the state we have prepared and repeat the
state preparation procedure. Otherwise, assuming the
two rounds of measurement for Sfin.do agree, we check
the outcomes to determine if any Pauli errors occurred
during the preparation of Sinit., or, immediately before
theSfin.stabilizer generators are measured. Assuming no
error is detected, we continue to conduct standard error
correction with the final code.
1. Surface code
Let us start by discussing the example of the surface
code [59], see Fig. 7. The stabilizers of the code are
shown by the faces in Fig. 7(left) where the light (dark)
faces mark the support of Pauli-X (Pauli-Z) type stabi-
lizers. We also show the support of a Pauli-X (Pauli-Z)
logical operator in green (blue). In the theory for code
deformation given above, this is the stabilizer group for
Sfin..
In Fig. 7(right) we show Sinit.. The figure shows the
J4,1,2Kcode outlined in red in the bottom-left corner of
the lattice. The remaining qubits are prepared in a prod-
uct state, such that the blue (green) qubits are initialised
in the |0⟩(|+⟩) state. These disentangled qubits can be
regarded as being in the stabilizer state Zv(Xv). The
logical operator of the initial state can be supported en-
tirely on the J4,1,2Kcode. However, we find the initial9
Z Z
Z ZZ Z
Z
ZX(right)
X
Z(left)
FIG. 8: Figure title - Injecting an encoded state into
the heavy-hex code: The injected state is initially encoded
on the J4,1,2Kcode. (left) A lattice with qubits on the ver-
tices. We show the support of a single Pauli-Z gauge check
and a Pauli-X stabilizer operator. The support of the Pauli-Z
gauge check is shown in dark gray. The Pauli-X stabilizer
operator is shaded grey towards the top of the lattice. We
also show the support of a Pauli-X and Pauli-Z type stabi-
lizer in green and blue, respectively. (right) The stabilizer
group for Sinit.. The J4,1,2Kcode is outlined in red in the
bottom-left corner of the lattice. The other qubits are ini-
tialised in a product state with blue (green) qubits initialised
in the |0⟩(|+⟩) state. Stabilizer operators Sdef.=Sinit.∩Sfin.
are shaded in the figure.
code shares the logical operators of the final code if we
multiply the logical operators of the J4,1,2Kcode by the
product state stabilizers.
Importantly, all the qubits support at least one sta-
bilizer operator of Sdef.such that a single error can be
detected. We note that the qubits that are initialised in
a product state need only detect one type of error, since
the other type of error acts trivially on the initial state.
For example, a Pauli-X (Pauli-Z) error acts trivially on a
green (blue) qubit, whereas a Pauli-Z (Pauli-X) error on
the same qubit will be detected by a stabilizer of Sdef..
Lastly, all qubits of the J4,1,2Kcode support one of each
type of stabilizer of Sdef.and as such can also detect both
types of Pauli errors. By inspection then, we see that we
can detect any single qubit error that occurs at the ini-
tialisation step.
2. Heavy-hex code
We can also inject the J4,1,2Kcode into the heavy-hex
code. This is particularly relevant with respect to the
experiment presented in the main text, as the experiment
is implemented on hardware that is tailored to realise the
heavy-hex code. The heavy-hex code is a subsystem code
closely related to the surface code. However, as the code
is a subsystem code, stabilizers are not measured directly.
Rather, we have a group of check operators, known as the
gauge group, that we measure to infer the values of the
stabilizer operators. Nevertheless, we find the arguments
given above are sufficient to argue that a state can be
injected while detecting a single error.
To review, the gauge group of the heavy-hex code
FIG. 9: Figure title - Injecting an encoded two-qubit
state into the color code: The state is initially encoded
with the J4,2,2Kcode. A qubit is supported on each of the
vertices of the lattice. We initialise the system Sinit.such that
the J4,2,2Kcode, shaded in red, is supported on a weight-four
face in the bottom left corner of the lattice. The other qubits
are prepared in Bell pairs on the highlighted blue and green
edge terms. As such, we shade the faces of Sdef.where both a
Pauli-X and Pauli-Z stabilizer is supported. The support of
the logical operators on the left and bottom boundaries are
highlighted in blue and green, respectively.
includes weight-two Pauli-Z terms on adjacent pairs of
qubits that share a row. We show one such term in
Fig. 8(left). The code also has Pauli-X type checks.
These are identical to the Pauli-X type stabilizer opera-
tors of the surface code, shown in Fig. 7. These checks
are used to infer Pauli-X and Pauli-Z type stabilizer op-
erators. The Pauli-X type stabilizer operators are the
product of Pauli-X terms on all of the qubits on two
adjacent rows, see Fig. 8(left). The Pauli-Z stabilizer op-
erators are the same as those of the surface code, again,
see Fig. 7. We also show the support of a logical Pauli-
X and Pauli-Z stabilizer operator in Fig. 8(left) in green
and blue, respectively. Once again, this stabilizer group
can be regarded as Sfin.with respect to the simplified
code-deformation theory we have presented. While we
infer their values from measuring the gauge checks, the
basic theory of state injection holds for our discussion on
error correction.
We show Sinit.for the heavy-hex code in Fig. 8(right)
where the J4,1,2Kcode, highlighted in red, is prepared
on qubits in the bottom-left corner of the lattice, and the
green (blue) qubits are prepared in the |+⟩v(|0⟩v) state.
These qubits have an associated stabilizer Xv(Zv). Once
again, like with the surface code case, the logical opera-
tors that are completely supported on the J4,1,2Kcode,
can be multiplied by elements of the stabilizer group of
Sinit.such that they are equivalent to those of Sfin.shown
in Fig. 8(left). As such, the encoded logical information
is preserved over the state injection procedure, as these
logical operators are members of Ldef..
As with the case of the surface code, we argue that we
can tolerate any single qubit error during the injection
procedure. Every single green (blue) qubit supports at
least one Pauli-X (Pauli-Z) type stabilizer of Sdef.. As
such, we can detect a single Pauli-Z (Pauli-X) error on
the green (blue) qubits that occurs up to the point the10
1. Prepare
|CZ /angbracketrightA,B |+/angbracketrightC0 2
11 134 6
15 172. Transport
2 4
13 156 8
17 19
3. Logical parity measurement
XBZCX
XZ
Z4. Logical measurement
ZBZ
ZZ
Z
FIG. 10: Figure title - Preparing a CZ state over two
J4,1,2K-codes: At step 1 the codes are prepared. The J4,2,2K
code that encodes the two-qubit CZ-state is represented by
the red square where its four qubits lie at the vertices of the
square. This preparation is described in the main text. The
code is prepared adjacent to a J4,1,2K-code that is initialised
in an eigenstate of the |+⟩state. The qubits in the figure
are indexed according to the qubit-map shown in Fig. 11. At
step 2 the qubits are transported in order to perform a logi-
cal parity measurement in step 3 using the heavy-hex lattice
geometry. Note that the qubit indices have changed. This
step can be performed with swaps, for instance, as shown in
Fig. 11(top). At step 3 a logical parity measurement is made.
It can be performed in a fault-tolerant manner using qubits 5,
10, and 16, as shown in the green box in Fig. 11(bottom). We
complete the operation by measuring the logical operator Z2
in step 4. This weight-two measurement can be repeated in
two locations on the J4,2,2Kcode such that a single measure-
ment error can be detected. This final measurement projects
the J4,2,2Kcode onto the J4,1,2K-code by reassigning the ZB
logical operators as stabilizers of the system.
code deformation takes place. We are not concerned with
Pauli-X (Pauli-Z) errors acting on the green (blue) qubits
as these errors act trivially on the initial state. Finally, all
of the qubits of the J4,1,2Kcode support both a Pauli-
X and a Pauli-Z type stabilizer of Sdef., and as such,
they can all detect both types of error. This accounts
for single-qubit errors occurring on all of the qubits of
the system during the state injection process with the
heavy-hex code.
3. Color code
Let us finally discuss the color code [60]. This is a
particularly interesting example as the J4,2,2Kcode can
be injected directly into the color code. We show the
color-code lattice in Fig. 9. For Sfin.each lattice face
supports both a Pauli-X and Pauli-Z type stabilizer. The
code supports two logical operators where XA(ZA) is the
product of Pauli-X (Pauil-Z) terms supported on all the
qubits along the bottom (left) boundary of the lattice.
Likewise XB(ZB) is the product of Pauli-X (Pauil-Z)
terms supported on all the qubits along the left (bottom)
boundary of the lattice. We highlight the support of thelogical operators on the left and bottom boundaries in
blue and green, respectively, in Fig. 9.
We define the stabilizer group for Sinit.in the caption
of Fig. 9 where the J4,2,2Kcode is placed on a four-qubit
face of the lattice, and all of the other qubits are prepared
in Bell pairs, with stabilizer operators XaXbandZaZb,
marked by highlighted edges in the figure. We colour
the edges either blue or green according to the colouring
convention for edges used in Ref. [60]. Nevertheless all
highlighted edges, of both colours, support the same Bell
pair.
We can multiply the logical operators of the J4,2,2K
code by elements of Sinit.such that we obtain the logical
operators of Sfin.. As such, the logical qubits encoded
on the error detecting code are preserved over the state
injection process.
We finally argue that we can detect any single-qubit
error during the state injection process. Fig. 9 high-
lights the support of the stabilizer operators of Sdef.with
coloured faces. Specifically, there is both a Pauli-X and
Pauli-Z type stabilizer on each of the coloured faces. By
inspection, we see that every qubit supports at least one
coloured face and, therefore, supports both a Pauli-X
anda Pauli-Z type stabilizer. We note also that the error
detecting code also supports both a Pauli-X and a Pauli-
Z type stabilizer on its respective face. As such, we can
detect any single-qubit error over the state injection pro-
cess.
E. Some remarks on state injection procedures
We have presented state injection protocols for sev-
eral different codes for the error-suppressed magic state
we discussed in the main text. We argued that we can
detect a single error that may occur in any of these pro-
tocols, such that we maintain the error suppression we
have demonstrated in our experiment. Let us remark
that the injection protocols we have presented can be
improved by combining them with other methods pre-
sented in the literature to improve the performance and
yield of state injection. For instance, in Refs. [20, 24],
two step preparation procedures are proposed, where a
magic state is injected onto an intermediate-sized code
using error detection is used to suppress errors, before
injecting the intermediate-sized code onto a larger code.
This method is compatible with the injection protocol we
have presented here. We might also adopt the method
presented in Ref. [25] where the authors propose estimat-
ing the logical error on the injected state in the decoding
step of state injection.
It is worth remarking that these error-detection proto-
cols can be improved by increasing the fraction of error
events that can be detected. We might, for example,
consider better choices of Sinit.that can be prepared be-
fore the state injection procedure begins. In the case of
subsystem codes, we might also look for additional error-
detection checks that can be made between intermediate11
9 100 1 2 3 4 5 6 7 8
11 12 13 14 15 16 17 18 199 100 1 2 3 4 5 6 7 8
11 12 13 14 15 16 17 18 19(top)
9 100 1 2 3 4 5 6 7 8
11 12 13 14 15 16 17 18 19(bottom)
FIG. 11: Figure title - Mapping the encoding onto
the heavy-hexagonal lattice geometry: We encode the
CZ-state onto two copies of the J4,1,2K-code. (top) We pre-
pare the encoded CZ-state as defined in the main text using
the qubits outlined in the purple box. We additionally pre-
pare a J4,1,2K-code in the logical |+⟩state using the qubits
outlined in the orange box. To perform step 3, as shown in
Fig. 10, we first move the codes, as in step 2. This can be
performed using swap gates between adjacent qubits. Swap
gates are performed, first, between pairs of qubits marked by
a blue arrow, and then between pairs of qubits marked with
green arrows. Each set of swap gates, the blue set and the
green set, can be performed in parallel. Completing the swap
operations moves the codes over the qubit map. We show
the locations of the codes after the swap operations by out-
lining their supporting qubits with a purple and orange box,
respectively, in the bottom figure. In their new locations, the
logical parity measurement of step 3 can be performed using
ancillary qubits 5,10 and 16, outlined in the green box in the
bottom figure. At the final step we facilitate the measurement
ofZ4Z6andZ15Z17using ancillary qubits 5 and 16, respec-
tively.
gauge measurements we make to infer the values of the
stabilizers, and the stabilizers of the initial code, during
the preparation procedure.
F. Encoding the CZ state on two J4,1,2K-codes
using the heavy-hex lattice geometry
Two of our state injection protocols described above
require that the CZ state is encoded on copies of the
J4,1,2Kcode. Here we show how to transform the en-
coded CZ-state prepared on the J4,2,2Kcode as we have
described in the main text onto two copies of the J4,1,2K-
code. This transformation is made using measurements.
In this sense it can be understood as a code deformation
similar to those discussed in the previous section. We
argue that we can detect any one single error over the
code deformation process, thereby maintaining the error
suppression obtained in the main text. We also show
how this process can be mapped onto the heavy-hex lat-
tice geometry. The protocol is outlined in Fig. 10, andwe show how the outline is mapped onto the heavy-hex
geometry in Fig. 11.
Before discussing the transformation, we first briefly
review the ideas behind state teleportation abstractly.
One can view the transformation as a small instance of a
lattice surgery operation [40] where gates are performed
between logical qubits by measuring appropriate logical
degrees of freedom. As an aside, in this particular in-
stance, we can view the operation as a lattice surgery
operation between a small color code and a small sur-
face code [50, 61, 62], where we interpret the J4,2,2K
code ( J4,1,2Kcode) as a small color code (surface code)
respectively. After performing a logical parity measure-
ment between the two codes, the transformation is com-
pleted with a partial condensation operation of the small
color code, as described in Ref. [50].
To elucidate the operation, we consider the evolution
of the stabilizers and logical operators of the code at each
step of the measurement pattern shown in Fig. 10 inde-
pendently from the implementation of the code. We have
three logical qubits indexed A,BandCwhere, initially,
AandBare encoded on the J4,2,2Kcode and Cis en-
coded on the J4,1,2Kcode. In essence, the operation
teleports the logical state encoded on qubit Bonto qubit
C, up to a Clifford operation. Logical qubit Ais not in-
volved in the operation, so we concentrate on qubits B
andC.
The teleportation operation proceeds as follows:
1. Prepare |+⟩C,
2. Measure XBZC,
3. Measure ZB,
4. Apply Pauli correction.
The operation functions with AandBcan be prepared
in some arbitrary logical state, but to illustrate the op-
eration we assume they are in a product state with
|ψ⟩B=a|+⟩B+b|−⟩B. We omit qubit Afrom the dis-
cussion, as it is unchanged by the transformation, and we
leave it as an exercise to the reader to verify the general
case.
Initially, an arbitrary state in the Bsubsystem along
with a logical |+⟩state on the Csubsystem can be de-
scribed by the following vector state: ( a|+⟩+b|−⟩)B⊗
|+⟩C, where we have chosen a convenient basis for the
vectors on B. Upon measuring the joint logical oper-
ator XBZCand obtaining measurement outcome m2,
the resulting state of the joint system is: a|+⟩B|m2⟩C+
b|−⟩B|1⊕m2⟩C. Finally, upon measuring ZBand ob-
taining the measurement outcome m3, the resulting state
is:|m3⟩B⊗(a|m2⟩C+ (−1)m3b|1⊕m2⟩C. An appro-
priate Pauli correction depending on the measurement
outcomes m2andm3allows us to recover the state
|0⟩B⊗(a|0⟩C+b|1⟩C). As such, we see the logical infor-
mation that was originally encoded on the Bsubsystem
in the form of the coefficients aandbnow lies entirely on12
theCsubsystem. Lastly, we note that, with this opera-
tion, the basis of the logical information has been rotated
by a Hadaamard operation. This can be corrected at a
later step. Fig. 10 explains details on how this trans-
formation is conducted between an encoded qubit of the
J4,2,2Kcode and the logical qubit of the J4,1,2Kcode by
performing logical measurements.
We now discuss how to implement the described state
teleportation on a heavy-hex lattice, as outlined in
Fig. 11. We begin by preparing the encoded CZ-state
as explained in the main text, together with an encoded
J4,1,2K-code. The J4,1,2K-code is prepared in the logical
state|+⟩. We can prepare this state using qubits outlined
in the orange box shown in Fig. 11(top), where the four
qubits, 4, 6, 15, and 17 are the data qubits of the code
and qubits 5, 10 and 16 are used to perform weight-four
parity checks with qubits 5 and 16 used as flag qubits.
The J4,1,2Kcode is prepared in a fault-tolerant manner
by initialising the data qubits in the |+⟩state and then
measuring each of the Pauli-Z type stabilizer operators
Z4Z6andZ15Z17. These measurements can be facilitated
with the ancillary qubits 5 and 16, respectively. Each of
these operators are measured twice such that we can de-
tect a single measurement error during preparation. See
also [4].
We transfer a single logical qubit of the J4,2,2Kcode
onto the J4,1,2K-code using logical measurements. In
step 3 we perform a weight-four measurement, that mea-
sures the parity of two logical qubits over the two codes.
In order to do this using the heavy-hexagonal lattice ge-
ometry we first transport the codes, this can be per-
formed in two rounds of swap gates or teleportation oper-
ations, as illustrated by arrows in Fig. 11(top), where the
blue arrows are performed first, in parallel, and the green
arrows are performed in parallel afterwards. It should
be noted that these rounds of parallel swap gates are
fault-tolerant since all individual swap operations involve
a single data qubit as well as an ancillary qubit, thus
any potential two-qubit gate error is effectively a single-
qubit error on the code that would be detected. After
the swap operation, we facilitate the logical parity mea-
surement with qubits 5, 10 and 16, shown in the green
box in Fig. 11. The logical measurement is performed
twice to identify a measurement error that may occur in
this step. The outcomes of both of these measurements
should agree. An odd parity in measurement outcomes
indicates that a measurement error has occurred.
Finally, we measure the logical operator ZBto com-
plete the teleportation operation. We measure this op-
erator on both of its two-qubit supports. Specifically,
these are ZB=Z2Z4andSZZB=Z13Z15, where
SZ=Z2Z4Z13Z15is the weight-four Pauli-Z stabilizer
of the J4,2,2Kcode. Measuring both of these weight-
two logical operators enables us to detect a single error,
as their parity should agree with the value of the Pauli-Z
stabilizer SZ. This final measurement completes the tele-
portation operation and, moreover, projects the error de-
tecting code onto a second copy of the J4,1,2K-code. Fi-nally, we remark that projecting ZBinto a known eigen-
state allows us to regard this logical operator as a weight-
two stabilizer. As such, we can now regard the J4,2,2K-
code that we prepared initially as a J4,1,2K-code. We
therefore have the state 11⊗H|CZ⟩encoded on the log-
ical space of two J4,1,2K-codes shown in the purple and
orange boxes shown in Fig. 11(bottom).
II. ANALYSIS IN TERMS OF SINGLE GATE
ERRORS
All circuits considered, both for magic state prepa-
ration and logical tomography, contain redundancy re-
quired to detect the occurrence of errors. For the mid-
circuit syndrome measurements, performed with the cir-
cuit shown in Fig. 1, this redundancy comes in the form
of the two flag qubits. These yield an outcome of 0 unless
an error has occurred. Such outcomes are therefore error
sensitive events, allowing errors to be detected.
Additional error sensitive events come from the results
of the syndrome measurements themselves. For the cir-
cuit shown in Fig. 2 (b), these are as follows:
•The results of the two Wmeasurements should
agree.
•SXshould yield 0, since the system is prepared in
a +1 eigenstate of this operator;
•Though the first SZwill yield a random outcome,
the following feedforward means that the resulting
state is in the +1 eigenspace of SZ. This will then
be the expected outcome for the value of final SZ
measurement.
For concreteness we will consider the measurement of log-
icalZZ, for which the final SZmeasuement is achieved
through the final measurement of data qubits. The cir-
cuit then has eight flag results in addition to the above
three conditions for syndrome measurements. This gives
eleven error sensitive events in all. To analyze how errors
in the circuit are detected, we consider all the possible
ways that a Pauli errors can be inserted around each
gate. Specifically, we consider the insertion of X,Yand
Zprior to any single qubit gate, and all possible single-
and two-qubit Paulis prior to any two-qubit gate, on the
qubits that support the gate. We then simulate each of
these circuits to determine how the error is detected.
This analysis has two important uses. Firstly, it can
be used to verify the fault-tolerance of the scheme, by
confirming that all Pauli errors with non-trivial effect
are in some way detected by the error sensitive events.
Secondly, it can be used to determine the specific combi-
nation of error sensitive events, s, that detect each error.
This information can then be used to infer the corre-
sponding probabilities ϵsthat such errors occurred, by
looking at how often the corresponding error signature
occurs within the outcomes measured.13
After performing this analysis, it was found that the
circuit is indeed fault-tolerant. The only cases in which
an error was not detected are where the error acted on
an eigenstate of the error operator, or where its applica-
tion was immediately followed by a measurement in an
eigenbasis of the Pauli error. In both of these cases the
error will have a trivial effect on the circuit output.
When calculating the ϵs, it is important to note that
the error signatures, s, are not necessarily unique for each
type of error. For example, XandYPaulis inserted im-
mediately before any measurement will yield the identical
effect of a measurement error. We therefore also deter-
mine the degeneracy, Nsfor each error signature. This
is the number of unique errors that give rise to the same
error signature. With this information we can then an-
alyze the syndrome outcomes from experimental data,
looking for these signatures and determining the proba-
bilities with which they occur [34]
Due to the limited number of error sensitive events
used in this experiment, these probabilities can be calcu-
lated directly. The combined probability, ϵs, for all forms
of error that lead to a particular signature is determined
using the number of shots for which that signature oc-
curs, ns, and the number of shots for which no error is
detected n0. The ratio of these numbers of shots will be
the ratio of the probability that the error occurs with the
probability that it does not
ns
n0≈ϵs
1−ϵs. (9)
Simply rearranging this relation then gives us the value
ofϵs[63]. We then use the degeneracy to obtain the
average probability for each possible single qubit Pauli
error with this signature: ϵs/Ns.
III. STANDARD MAGIC-STATE
PREPARATION CIRCUITS
Here we describe magic-state preparation circuits with
no error suppression, that we compare to our error-
suppressed scheme described in the main text.
In Fig. 12(a) we show a circuit that prepares an en-
coded CZ-state by, first, preparing a CZ-state on two
physical qubits and, then, encoding the state such that
the Pauli observables of the two qubits of the CZ state
can be represented as logical operators of the error-
detecting code we encode. Finally, we measure the stabi-
lizer operators of the code to encode the state, assuming
we obtain the correct stabilizer measurement outcomes.
The circuit used for the preparation step is shown in
Fig. 12(b).
We can make use of the stabilizer operators of the
CZ-state to simplify the preparation circuit shown in
Fig. 12(b). We define a stabilizer operator U, with re-
spect to state |ψ⟩, as an operator whose action is triv-
ial on its respective state, i.e., U|ψ⟩=|ψ⟩. One can
check that the CZ state is invariant under the action of
|0/angbracketright0
|0/angbracketright1
|0/angbracketright5
|0/angbracketright6|0/angbracketright2
|0/angbracketright3
|0/angbracketright4HV XX
HPrep. SXSZ|CZ /angbracketrightprep. encoding steps
trivial|0/angbracketright
|0/angbracketright HV X P
Q(a)(b)
(c)FIG. 12: Figure title - Magic-state preparation with-
out error suppression: We can encode a physical CZ state
using the circuit outlined in (a), where the preparation step,
Prep., is shown in (b). The magic state is then encoded using
stabilizer measurements SXandSZ. The preparation circuit,
(b), first prepares a CZ state and two physical qubits before
preparing the state to encode it in the four-qubit code by
stabilizer measurements. We find that we can simplify the
circuit once the CZ state is prepared by making use of the
stabilizer operators of the CZ state. As discussed in the main
text we observe that the circuit element in the box with a
dotted outline acts trivially on the CZ-state. The inclusion of
this stabilizer operator allows us to remove all of the Pauli-
X and controlled-not operations shown in the circuit, as the
circuit elements in the box negate their adjacent self-inverse
gates. Indeed, the circuit elements that lie in between the ver-
tical dashed lines act like the identity operator. (c) The CZ
state is prepared on two physical qubits. The circuit makes
use of V= exp( iθY) a Pauli-Y rotation with tan θ=√
2, a
controlled-Hadamard gate and a bitflip. We perform state to-
mography on this state by making different choices of single-
qubit Pauli measurements, PandQ, on the output of this
circuit.
a controlled-not gate conditioned on the control qubit in
the 0-state
CX′=|1⟩⟨1| ⊗11 +|0⟩⟨0| ⊗X.
This unitary gate is equivalent to a standard controlled-
not gate, CX=|0⟩⟨0|⊗11 +|1⟩⟨1|⊗X., followed by a bit
flip on the target qubit, i.e.,
CX′= (11⊗X)CX.
This observation allows us to simplify the preparation
circuit. Once the CZ state is prepared, we add the CX′
gate in the dashed box in Fig. 12, as the state we have
prepared at this stage is invariant under this inclusion.
The inclusion of this operator allows us to simplify the
circuit, as the repeated application of the two Pauli-X
rotations and the repeated application of two controlled-
not operations used in the circuit act like an identity
operation. This trivial step in the circuit is marked on
the figure between vertical dashed lines. We can there-
fore omit all of the controlled not operations and the
bit-flip operations from the circuit shown in our imple-
mentation of this method of state preparation. As such,
this preparation step only includes two entangling gates:
a controlled-Hadamard gate and a swap gate. We per-
form logical tomography by appending the circuits shown14
in Figs. 2(b) and (c) to the end of the circuit shown in
Fig. 12(a). Likewise, we can perform physical tomogra-
phy on the output of the circuit shown in Fig. 12(a).
As an aside, we note that the CZ state is also stabilized
by the swap gate
swap = ( 11 +X⊗X+Y⊗Y+Z⊗Z)/2,
andCZas defined in the main text. The CZ state is
uniquely stabilized by the Abelian stabilizer group gen-
erated by the set ⟨CZ, CX′swap⟩.
Finally, we also compare our error-suppressed magic-
state preparation scheme to a circuit that prepares the
same magic state on two physical qubits, see Fig. 12(c).
We prepare the state on two physical qubits using a sin-
gle entangling gate, together with single qubit rotations,
before measuring the state in varying single-qubit Pauli
bases, PandQ, to conduct state tomography on the
circuit output.
IV. DEVICE OVERVIEW
Encoded state data collection on ibm peekskill v2.4.0
spanned several days over a single region. During this
time, monitoring experiments were interleaved with to-
mography data collection trials. Device coherence times
for all qubits exceed ∼100µs and two qubit error per gate
was found to range from 0 .35−0.59%. Detailed moni-
toring of readout errors are provided in Fig. 13(f),(g)
and time-averaged readout fidelities ranged from 98 .1−
99.6% for all qubits. Average device characterization
data is summarized in Tables I,II. Unencoded magic
state data was collected over a single 24-hour period on
ibmpeekskill v2.5.4 on all physical pairs and the best
performing edge is reported in Table. II. While the unen-
coded magic state data was not interleaved with encoded
state tomography, the best performing pair of physical
qubits was found to have a low two qubit error per gate
of 0.38% and this error is comparable to the lowest two
qubit error per gate for edges used in the encoded magic
state experiments.
V. REAL-TIME FEEDFORWARD CONTROL OF
QUBITS
In the last decade, a number of experiments have been
performed that exploit fast feedback or real-time control
within the execution of a quantum program. Fast feed-
back has been used for conditional reset [64–67], state
and gate teleportation [68–70] with low branching com-
plexity, and in more demanding algorithms such as the
iterative phase estimation protocol [71], to name a few.
More recently, there have been quantum error correction
demonstrations using real-time control in various systems
[2, 6, 72, 73]. There have also been examples of work
toward classical-control micro architectures that enablethe seamless integration of qubits and classical operations
with tens of qubits.
Our work was performed with IBM Quantum’s first-
generation real-time control system, where we use cen-
tralized processing of mid-circuit measurement outcomes
to classically condition a quantum circuit. The control
system architecture is based on a hierarchical heteroge-
neous system of FPGA controllers with computing el-
ements for concurrent real-time processing, microwave
control, and qubit readout. These are synchronized
through a global clock and linked with a real-time com-
munication network to allow synchronized collective op-
erations such as control flow. Branching incurs a con-
stant latency penalty to execute the branch (of order
500ns). Real-time computations will incur a variable la-
tency overhead depending on the complexity of the de-
cision. The system provides specialized fast-path control
flow capabilities for rapid and deterministic conditional
reset operations. Collective control of the system requires
orchestration through a proprietary heterogeneous hard-
ware compiler and code generator. We use an open-access
platform that is programmable through Qiskit and Open-
QASM 3; an open-source imperative C-style real-time
quantum programming language [74]. All experiments
were performed through Qiskit and IBM’s Quantum Ser-
vices [75, 76].
VI. ESTIMATES FOR MAGIC STATE YIELD
Let us attempt to model the error rate of the com-
ponents of the device using the yield we have evaluated
experimentally. The yield is a helpful figure of merit as
it tells us precisely how often a single error event occurs
to leading order in the error rate. We first try to model
the yield using a simple three parameter model that we
derive below. We also compare the yield to numerical
simulations of our circuits. We show the estimated yield
for different experiments in Table III, in comparison to
our analytical model, and numerical results.
Both of our analyses have good agreement with exper-
iment if we assume a two-qubit gate error rate, and a
measurement error rate of the order of 2%. This is a
high error rate compared to those measured in Tables I
and II. However, we remark that neither our analytical
model, nor our simulations, account for common error
processes such as leakage, cross talk, two level systems,
as well as idoling errors that may occur during slow cir-
cuit processes, that will introduce additional noise to the
system. We suggest discrepancies in our modeling and
the experimentally observed yields can be attributed to
these details that are difficult to model analytically or
numerically.
Let us present our analytical model to evaluate yield.
To leading order we can estimate the magic-state yield
asQRwhere Qis probability the random measurement
outcomes we obtain throughout our experiment are cor-
rect, multiplied by the probability that the experiment15
Qubit ( QF)Freq. (GHz) Anharm. (MHz) T1(µs)Techo
2 (µs)EPG (%) Readout Fid. (%) P(0|1) P(1|0)
17 5.151 -339.9 256.3 170.7 0.024 99.6 0.00472 0.00305
18 5.083 -341.9 182.2 364.9 0.024 98.7 0.01297 0.01240
21 4.858 -344.2 366.7 362.2 0.012 99.4 0.00318 0.00822
15 4.958 -343.8 212.4 200.5 0.036 98.5 0.01658 0.01313
10 4.837 -345.0 200.6 120.9 0.027 98.4 0.01612 0.01542
12 4.899 -346.8 289.7 462.6 0.036 98.7 0.01505 0.01068
13 4.972 -345.8 322.4 166.1 0.024 98.1 0.01952 0.01818
TABLE I: Table title - Average single-qubit benchmarks: Data shown is for qubits of ibm peekskill used in this work.
Gate CX length (ns) EPG (%)
1210 334.2 0.58
1512 376.9 0.59
1312 462.2 0.37
1518 376.9 0.56
1817 640.0 0.43
1821 462.2 0.35
1821∗462.2 0.38
TABLE II: Table title - Average two-qubit gate bench-
marks: Data shown are for qubits of ibm peekskill used in
this work. CX gates, constructed from echoed cross-resonance
pulse sequence, are specified in one direction, with the reverse
directions accessed by addition of single qubit gate. Error per
gate (EPG) is extracted from isolated two-qubit randomized
benchmarking (spectator qubits idling). The notation∗de-
notes error rates for the best performing physical qubit pair
on ibm peekskill during unencoded magic state preparation
experiments defining the minimum (red line) in Fig. 3.
does not experience a single error R.
If we have that ϵPis the probability that a single parity
measurement introduces an error and Dis the number
of parity measurements that are conducted in an experi-
ment, i.e., the depth, we can write R= (1−ϵP)D, thereby
giving the equation
logical yield = Q(1−ϵP)D, (10)
We note that QandDvary for different experiments.
For our rough calculation we find reasonably good
agreement with the experimental data if we take ϵP≈
22%. This equates, approxiamtely, to a two-qubit gate
error rate, and a measurement error rate of ∼2% Each
parity measurement we perform uses eight entangling
gates and three mid-circuit measurements. Therefore,
neglecting higher-order terms, we obtain the probability
that a parity measurement introduces a single error is
ϵP≈8ϵ2Q+ 3ϵM, (11)
where ϵ2Qis the two-qubit gate error rate and ϵMis the
probability of a measurement error. If we set ϵ2Q=ϵM=
2%, we find that ϵP= 22%.
We also need to predict Qfor different experiments.
Let us begin with the error suppressed experiment wherecircuit QDanalytic numeric experiment
FF 2(b) 3/4 4∼28% ∼35%∼30−35%
FF 2(c) 3/4 6∼17% ∼14% ∼10%
PS 2(b) 3/8 4∼14% ∼20% ∼17%
PS 2(c) 3/8 6∼9% ∼8% ∼5−8%
standard 2(b) 1/4 3∼12% — ∼15−17%
standard 2(c) 1/4 5∼7% — ∼4−6%
TABLE III: Table title - Estimated magic-state yield
compared with experiment: We compare our analytical
model, Eqn. (10), and numerics to the experimental data.
We calculate the yield for the error-suppressed preparation
experiment using feedforward (FF) and the error-suppressed
preparation experiment using (PS). We also estimate accep-
tance rates for the standard experiment. The depth of the
circuits Dvary depending on the different tomography ex-
periment we run, so we treat them separately. We append
2(b) and 2(c) to the different experiments depending on the
tomography circuit we used, in reference to the circuits shown
in Fig. 2(b) and (c) in the main text.
we use feed forward. Here, in the noiseless case, we
have one random measurement outcome, where we ini-
tially measure W. It is readily checked that the prob-
ability that we project the |+ +⟩state onto the +1
eigenvalue eigenspace of the CZoperator is QFF=
⟨++|(1+CZ)|++⟩/2 = 3 /4. In the case that we do not
use feedforward, in addition to obtaining the correct out-
come for the Wmeasurement, we must also post select
on obtaining the correct outcome of the initial measure-
ment of SZ. We obtain the +1 eigenvalue subspace of
this operator with probability 1 /2. We therefore have
QPS= 3/4×1/2 = 3 /8. Lastly, in the standard prepa-
ration procedure, we measure both SZandSX, and we
require that both give the +1 outcome. Each measure-
ment gives the correct outcome with probability 1 /2, we
therefore have that QSTND = 1/2×1/2 = 1 /4.
Let us comment on the features of this model that
agree with experiment. First of all, we observe that the
error-suppressed scheme using feedforward has a consis-
tently better yield than the other two schemes, both the
error-suppressed scheme using post selection as well as
the standard preparation scheme. Furthermore, we ob-
serve that the error-suppressed post-selection scheme and
the standard scheme have comparable yields, for both to-16
mography circuit shown in Fig. 2.
Furthermore, our model explains the difference in yield
between different tomography experiments conducted us-
ing the two different circuits shown in Fig. 2. The to-
mography circuit in Fig. 2(c) uses two additional parity
measurements than that shown in Fig. 2(b). As such the
tomography circuit in Fig. 2(c) is inherently more noisy
than that in Fig. 2(b). This is reflected in Fig. 4 where
the yield for tomography circuits shown in Fig. 22(b)
(Fig. 22(c)) are shown to the left (right) in Fig. 4.
Our rudimentary analytical model correctly predicts
several qualitative features of our experimental data.
However, it neglects many details of the circuit. As we
might expect, we find better agreement with the exper-
imentally observed yield if we simulate our circuit. We
assume an error rate for each of the two-qubit entangling
gates and the measurement error rate of 2%. These re-
sults are also shown in Table III. Once again, the physical
error rate of these circuit elements is considerably higher
than the observed error rates of these components. As
mentioned at the beginning of this section, we attribute
this to noise processes that are not captured by either our
analytical model or our numerical simulations. In prac-
tice it is extremely difficult to capture all of the physical
details that occur in an experiment.
VII. STATE TOMOGRAPHY WITH READOUT
ERROR MITIGATION USING NOISY POSITIVE
OPERATOR-VALUED MEASUREMENTS
The state tomography in the main text uses the
qiskit experiments implementation of state tomogra-
phy [33]. A significant change from previous works
is that we do not use readout error mitigation in the
main text. Instead we perform tomographic fitting as-
suming ideal measurements, which attributes any un-
detectable measurement errors to errors in the recon-
structed quantum state. For physical tomography we use
the cvxpy gaussian lstsq fitter with measurement data
using the default Pauli-measurement basis on each phys-
ical qubit to obtain a weighted maximum likelihood esti-
mate, constrained to the space of positive semi-definite,
unit trace density matrices. For logical tomography we
use the cvxpy linea lstsq fitter with a custom measure-
ment basis using Pauli expectation values, rather than
Pauli eigenstate probabilities. In this case the custom
fitter weights are calculated from the inverse of the stan-
dard error in the Pauli expectation value estimates for
each post-selected logical Pauli operator measurement.
Susceptibility to measurement error is a common issue
for tomographic methods. In general, tomographic tools
are only as good as the noise model of the measurement
apparatus, i.e., our ability to calculate the likelihood rep-
resenting the conditional probability of obtaining a data
set given some test density matrix. In this section, we
discuss an alternative approach combining readout error
characterization with tomographic reconstruction. Whilethe dominant measurement error source in tomography
experiments is due to qubit readout, it is a common prac-
tice to assume local, uncorrelated readout errors in the
Z-basis. A set of noisy positive operator-valued measure-
ments (POVMs) on a single-qubit is,
Z′
0:="
1−p0
0q#
, Z′
1:="
p0
0 1−q#
, (12)
where p(q) is the probability of assigning outcome 1 (0)
to a true state |0⟩(|1⟩); i.e. p=P(1|0) and q=P(0|1).
We can also construct noisy POVMs for measurements in
the Pauli- Xor Pauli- Yeigenbases by rotating the noisy
POVMs shown in Eqn. (12) by an appropriate angle as-
suming ideal unitaries, since the measurement error is
typically several orders of magnitude greater than the
one-qubit gate error.
By interleaving small batches of experimental data col-
lection with readout calibration experiments, one can
construct noisy POVMs for each data qubit applicable to
a small duration of data collection to be used in fitting
procedures discussed above. In Fig. 13 (a), state infideli-
ties from fitting with noisy POVMs can be compared to
fitting with ideal projectors ( p, q≡0), where the latter is
reported in the main text. Using readout mitigation the
fault-tolerant tomography routines far-outperform both
un-encoded tomography, but also the physical tomogra-
phy of the encoded state. Since the terminating measure-
ments in the logical tomography are very similar to those
in the physical tomography, we would expect both of
these experiments to demonstrate similar infidelities. Re-
solving this discrepancy remains an open research ques-
tion.
It is additionally unclear if our assumed construction
of noisy POVMs, or the measured readout error calibra-
tions, collectively reflect the true measurement errors ex-
perienced by data qubits. We therefore test the sensi-
tivity of the outcomes of state tomography to the choice
of measurement compensation in Fig. 13 (b)-(d). State
infidelity is calculated from fitting experimental tomogra-
phy data to POVMs parameterized by p, q. To simplify,
these readout error probabilities are set to be constant for
all qubits and time. Dark blue regions of low infidelity
(with the minima marked with a red star) do not coin-
cide with the state infidelity calculated using the global
average of experimentally measured readout calibrations
(marked by a black dot). This disparity suggests that ei-
ther (a) the target experiments experienced initialization
or measurement errors at a higher rate than measured by
simpler calibrations and/or (b) fitting with potentially
incorrect A-matrices yields a highly non-positive state
that is mapped to a high-fidelity physical state under
constrained optimization.
Combining readout mitigation with tomography thus
remains an open question for further work and results of
the main text are limited by unaddressed readout error
on terminal measurements. We expect that state tomog-
raphy experiments in Fig. 13(b)-(e) at p=q= 0 provide17
Infidelity 
Raw physical tomography Logical tomographyError Suppressed StaandardMin infidelity
Expt. avg. A-matrix(b) (a) (c)
(d) (e)
(f)
(g)
Time 
Feedforward Postselection
FIG. 13: Figure title - Combining readout-error mitigation with state tomography methods: (a) State infidelity
for the standard (orange) vs. error-suppressed (blue) schemes using different tomographic methods; error-bars represent 1 σ
std. dev. from bootstrapping. On the x-axis, a state is reconstructed with either logical tomography (Logical) or physical
tomography after logical projection (Physical); tomography assumes either ideal projectors, as in the main text, or noisy
POVMs representing uncorrelated, local readout errors (RO) on terminal data qubit measurements. Raw physical tomography
(Raw Phys.) refers to the state on four physical qubits prior to logical projection. Red dotted (green dot-dashed) lines show
lowest (average) state infidelities of the two-qubit unencoded magic state prepared with RO mitigation. With RO mitigation,
logical tomography outperforms the min. unencoded state supporting conclusions in the main text. (b)-(e) Heatmap of state
infidelity vs. avg. measurement error, p≡P(1|0),q≡P(0|1). Experimental tomography data is fit to noisy POVMs using
a parameterized A-matrix, A:= [[1 −p, q],[p,1−q]], where p, qare constant for all qubits and time. Experimental readout
calibrations data are averaged over time and qubits and correspond to a single state infidelity in (b)-(e) (black dots). These state
infidelities (black dots) do not coincide with local minima (red stars) or even high-fidelity regions. (f)-(g) Readout calibration
measurements of p, qvs. time for all four data qubits over several days; average rates (black solid) are used in (b)-(e) for state
fidelities marked by black dots.
a reasonable upper bound on the error of the underlying magic state.
[1] R. Harper and S. T. Flammia, Phys. Rev. Lett. 122,
080504 (2019), URL https://link.aps.org/doi/10.
1103/PhysRevLett.122.080504 .
[2] C. Ryan-Anderson, J. G. Bohnet, K. Lee, D. Gresh,
A. Hankin, J. P. Gaebler, D. Francois, A. Chernogu-
zov, D. Lucchetti, N. C. Brown, et al., Phys. Rev. X
11, 041058 (2021), URL https://link.aps.org/doi/
10.1103/PhysRevX.11.041058 .
[3] L. Egan, D. M. Debroy, C. Noel, A. Risinger, D. Zhu,
D. Biswas, M. Newman, M. Li, K. R. Brown, M. Cetina,
et al., Nature 598, 281 (2021), URL https://doi.org/
10.1038/s41586-021-03928-y .
[4] E. H. Chen, T. J. Yoder, Y. Kim, N. Sundaresan, S. Srini-
vasan, M. Li, A. D. C´ orcoles, A. W. Cross, and M. Takita,
Phys. Rev. Lett. 128, 110504 (2022), URL https://
link.aps.org/doi/10.1103/PhysRevLett.128.110504 .
[5] N. Sundaresan, T. J. Yoder, Y. Kim, M. Li, E. H. Chen,
G. Harper, T. Thorbeck, A. W. Cross, A. D. C´ orcoles,
and M. Takita, Nature Communications 14, 2852 (2023),
URL https://doi.org/10.1038/s41467-023-38247-5 .
[6] C. Ryan-Anderson, N. C. Brown, M. S. Allman, B. Arkin,
G. Asa-Attuah, C. Baldwin, J. Berg, J. G. Bohnet,
S. Braxton, N. Burdick, et al., Implementing fault-
tolerant entangling gates on the five-qubit code and the
color code (2022), arXiv:2208.01863.
[7] L. Postler, S. Heuben, I. Pogorelov, M. Rispler, T. Feld-ker, M. Meth, C. D. Marciniak, R. Stricker, M. Ring-
bauer, R. Blatt, et al., Nature 605, 675 (2022), URL
https://doi.org/10.1038/s41586-022-04721-1 .
[8] R. Acharya, I. Aleiner, R. Allen, T. I. Andersen, M. Ans-
mann, F. Arute, K. Arya, A. Asfaw, J. Atalaya, R. Bab-
bush, et al., Nature 614, 676 (2023), URL https://doi.
org/10.1038/s41586-022-05434-1 .
[9] S. Bravyi and A. Kitaev, Phys. Rev. A 71,
022316 (2005), URL https://link.aps.org/doi/10.
1103/PhysRevA.71.022316 .
[10] A. M. Meier, B. Eastin, and E. Knill, Quantum Info.
Comput. 13, 195–209 (2013), ISSN 1533-7146.
[11] C. Chamberland, K. Noh, P. Arrangoiz-Arriola, E. T.
Campbell, C. T. Hann, J. Iverson, H. Putterman, T. C.
Bohdanowicz, S. T. Flammia, A. Keller, et al., PRX
Quantum 3, 010329 (2022), URL https://link.aps.
org/doi/10.1103/PRXQuantum.3.010329 .
[12] P. Shor, in Proceedings of 37th Conference on Founda-
tions of Computer Science (1996), pp. 56–65.
[13] A. G. Fowler, M. Mariantoni, J. M. Martinis, and A. N.
Cleland, Phys. Rev. A 86, 032324 (2012), URL https:
//link.aps.org/doi/10.1103/PhysRevA.86.032324 .
[14] D. Litinski, Quantum 3, 205 (2019), URL https://doi.
org/10.22331%2Fq-2019-12-02-205 .
[15] C. Gidney and M. Eker˚ a, Quantum 5, 433 (2021),
ISSN 2521-327X, URL https://doi.org/10.22331/18
q-2021-04-15-433 .
[16] M. E. Beverland, A. Kubica, and K. M. Svore, PRX
Quantum 2, 020341 (2021), URL https://link.aps.
org/doi/10.1103/PRXQuantum.2.020341 .
[17] F. Thomsen, M. S. Kesselring, S. D. Bartlett, and B. J.
Brown, Low-overhead quantum computing with the color
code (2022), arXiv:2201.07806, URL https://arxiv.
org/abs/2201.07806 .
[18] L. Z. Cohen, I. H. Kim, S. D. Bartlett, and B. J.
Brown, Science Advances 8, eabn1717 (2022),
https://www.science.org/doi/pdf/10.1126/sciadv.abn1717,
URL https://www.science.org/doi/abs/10.1126/
sciadv.abn1717 .
[19] R. Raussendorf, J. Harrington, and K. Goyal, An-
nals of Physics 321, 2242 (2006), ISSN 0003-
4916, URL https://www.sciencedirect.com/science/
article/pii/S0003491606000236 .
[20] Y. Li, New Journal of Physics 17, 023037 (2015),
URL https://dx.doi.org/10.1088/1367-2630/17/2/
023037 .
[21] C. Chamberland and A. W. Cross, Quantum 3, 143
(2019), ISSN 2521-327X, URL https://doi.org/10.
22331/q-2019-05-20-143 .
[22] C. Chamberland and K. Noh, npj Quantum Informa-
tion6, 91 (2020), URL https://doi.org/10.1038/
s41534-020-00319-5 .
[23] L. Lao and B. Criger, in Proceedings of the 19th ACM
International Conference on Computing Frontiers (Asso-
ciation for Computing Machinery, New York, NY, USA,
2022), CF ’22, p. 113–120, ISBN 9781450393386, URL
https://doi.org/10.1145/3528416.3530237 .
[24] S. Singh, A. S. Darmawan, B. J. Brown, and S. Puri,
Phys. Rev. A 105, 052410 (2022), URL https://link.
aps.org/doi/10.1103/PhysRevA.105.052410 .
[25] H. Bomb´ ın, M. Pant, S. Roberts, and K. I. Seetharam,
Fault-tolerant post-selection for low overhead magic state
preparation (2022), arXiv:2212.00813, URL https://
arxiv.org/abs/2212.00813 .
[26] C. Gidney, Cleaner magic states with hook injection
(2023), URL https://arxiv.org/abs/2302.12292 .
[27] C. Chamberland, G. Zhu, T. J. Yoder, J. B.
Hertzberg, and A. W. Cross, Phys. Rev. X 10,
011022 (2020), URL https://link.aps.org/doi/10.
1103/PhysRevX.10.011022 .
[28] E. Dennis, Phys. Rev. A 63, 052314 (2001), URL https:
//link.aps.org/doi/10.1103/PhysRevA.63.052314 .
[29] X. Ni, O. Buerschaper, and M. Van den Nest,
Journal of Mathematical Physics 56, 052201 (2015),
https://doi.org/10.1063/1.4920923, URL https://doi.
org/10.1063/1.4920923 .
[30] M. A. Webster, B. J. Brown, and S. D. Bartlett, Quan-
tum6, 815 (2022), ISSN 2521-327X, URL https://doi.
org/10.22331/q-2022-09-22-815 .
[31] R. Chao and B. W. Reichardt, Phys. Rev. Lett. 121,
050502 (2018), URL https://link.aps.org/doi/10.
1103/PhysRevLett.121.050502 .
[32] IBM Quantum (2022), URL https://
quantum-computing.ibm.com .
[33] N. Kanazawa, D. J. Egger, Y. Ben-Haim, H. Zhang,
W. E. Shanks, G. Aleksandrowicz, and C. J. Wood, Jour-
nal of Open Source Software 8, 5329 (2023), URL https:
//joss.theoj.org/papers/10.21105/joss.05329 .
[34] J. R. Wootton, Syndrome-derived error rates as a bench-
mark of quantum hardware (2022), arXiv:2207.00553,URL https://arxiv.org/abs/2207.00553 .
[35] M. Takita, A. W. Cross, A. D. C´ orcoles, J. M.
Chow, and J. M. Gambetta, Phys. Rev. Lett. 119,
180501 (2017), URL https://link.aps.org/doi/10.
1103/PhysRevLett.119.180501 .
[36] C. K. Andersen, A. Remm, S. Lazar, S. Krinner,
N. Lacroix, G. J. Norris, M. Gabureac, C. Eichler,
and A. Wallraff, Nature Physics 16, 875 (2020), ISSN
1745-2481, number: 8 Publisher: Nature Publish-
ing Group, URL https://www.nature.com/articles/
s41567-020-0920-y .
[37] E. Knill, Nature 434, 39 (2005), URL https://doi.org/
10.1038/nature03350 .
[38] D. Gottesman, Quantum Info. Comput. 14, 1338–1372
(2014), ISSN 1533-7146.
[39] H. Bombin and M. A. Martin-Delgado, Journal of
Physics A: Mathematical and Theoretical 42, 095302
(2009), URL https://dx.doi.org/10.1088/1751-8113/
42/9/095302 .
[40] D. Horsman, A. G. Fowler, S. Devitt, and R. V. Meter,
New Journal of Physics 14, 123011 (2012), URL https:
//dx.doi.org/10.1088/1367-2630/14/12/123011 .
[41] A. Paetznick and B. W. Reichardt, Phys. Rev. Lett.
111, 090505 (2013), URL https://link.aps.org/doi/
10.1103/PhysRevLett.111.090505 .
[42] J. T. Anderson, G. Duclos-Cianci, and D. Poulin, Phys.
Rev. Lett. 113, 080501 (2014), URL https://link.aps.
org/doi/10.1103/PhysRevLett.113.080501 .
[43] A. J. Landahl and C. Ryan-Anderson, Quantum comput-
ing by color-code lattice surgery (2014), arXiv:1407.5103,
URL https://arxiv.org/abs/1407.5103 .
[44] H. Bomb´ ın, New Journal of Physics 17, 083002
(2015), URL https://dx.doi.org/10.1088/1367-2630/
17/8/083002 .
[45] H. Bomb´ ın, New Journal of Physics 18, 043038
(2016), URL https://dx.doi.org/10.1088/1367-2630/
18/4/043038 .
[46] T. J. Yoder, R. Takagi, and I. L. Chuang, Phys. Rev. X
6, 031039 (2016), URL https://link.aps.org/doi/10.
1103/PhysRevX.6.031039 .
[47] B. J. Brown, K. Laubscher, M. S. Kesselring, and J. R.
Wootton, Phys. Rev. X 7, 021029 (2017), URL https:
//link.aps.org/doi/10.1103/PhysRevX.7.021029 .
[48] B. J. Brown and S. Roberts, Phys. Rev. Res. 2,
033305 (2020), URL https://link.aps.org/doi/10.
1103/PhysRevResearch.2.033305 .
[49] B. J. Brown, Science Advances 6, eaay4929 (2020),
https://www.science.org/doi/pdf/10.1126/sciadv.aay4929,
URL https://www.science.org/doi/abs/10.1126/
sciadv.aay4929 .
[50] M. S. Kesselring, J. C. M. de la Fuente, F. Thomsen,
J. Eisert, S. D. Bartlett, and B. J. Brown, Anyon con-
densation and the color code (2022), arXiv:2212.00042,
URL https://arxiv.org/abs/2212.00042 .
[51] C. Piveteau, D. Sutter, S. Bravyi, J. M. Gam-
betta, and K. Temme, Phys. Rev. Lett. 127,
200505 (2021), URL https://link.aps.org/doi/10.
1103/PhysRevLett.127.200505 .
[52] M. Lostaglio and A. Ciani, Phys. Rev. Lett. 127,
200506 (2021), URL https://link.aps.org/doi/10.
1103/PhysRevLett.127.200506 .
[53] R. Raussendorf, J. Harrington, and K. Goyal, New Jour-
nal of Physics 9, 199 (2007), URL https://dx.doi.org/
10.1088/1367-2630/9/6/199 .19
[54] C. Vuillot, L. Lao, B. Criger, C. G. Almud´ ever,
K. Bertels, and B. M. Terhal, New Journal of Physics
21, 033028 (2019), URL https://dx.doi.org/10.1088/
1367-2630/ab0199 .
[55] D. Gottesman, Ph.D. thesis, California Institute of Tech-
nology (1997).
[56] D. S. Wang, A. G. Fowler, and L. C. L. Hollenberg, Phys.
Rev. A 83, 020302(R) (2011), URL https://journals.
aps.org/pra/abstract/10.1103/PhysRevA.83.020302 .
[57] C. Chamberland and M. E. Beverland, Quantum 2,
53 (2018), ISSN 2521-327X, URL https://doi.org/10.
22331/q-2018-02-08-53 .
[58] C. Chamberland, A. Kubica, T. J. Yoder, and G. Zhu,
New Journal of Physics 22, 023019 (2020), URL https:
//dx.doi.org/10.1088/1367-2630/ab68fd .
[59] A. Kitaev, Annals of Physics 303, 2 (2003), ISSN 0003-
4916, URL https://www.sciencedirect.com/science/
article/pii/S0003491602000180 .
[60] H. Bombin and M. A. Martin-Delgado, Phys. Rev. Lett.
97, 180501 (2006), URL https://link.aps.org/doi/
10.1103/PhysRevLett.97.180501 .
[61] H. Poulsen Nautrup, N. Friis, and H. J. Briegel, Na-
ture Communications 8, 1321 (2017), URL https://
doi.org/10.1038/s41467-017-01418-2 .
[62] N. Shutty and C. Chamberland, Phys. Rev. Appl. 18,
014072 (2022), URL https://link.aps.org/doi/10.
1103/PhysRevApplied.18.014072 .
[63] J. R. Wootton, Quantum Science and Technology
5, 044004 (2020), URL https://dx.doi.org/10.1088/
2058-9565/aba038 .
[64] D. Rist` e, C. C. Bultink, K. W. Lehnert, and L. DiCarlo,
Phys. Rev. Lett. 109, 240502 (2012), URL https://
link.aps.org/doi/10.1103/PhysRevLett.109.240502 .
[65] N. Ofek, A. Petrenko, R. Heeres, P. Reinhold, Z. Legh-
tas, B. Vlastakis, Y. Liu, L. Frunzio, S. M. Girvin,
L. Jiang, et al., Nature 536, 441 (2016), URL https:
//www.nature.com/articles/nature18949 .
[66] Y. Salath´ e, P. Kurpiers, T. Karg, C. Lang, C. K. An-
dersen, A. Akin, S. Krinner, C. Eichler, and A. Wallraff,
Phys. Rev. Appl. 9, 034011 (2018), URL https://link.
aps.org/doi/10.1103/PhysRevApplied.9.034011 .
[67] C. K. Andersen, A. Remm, S. Lazar, S. Krinner, J. Hein-
soo, J.-C. Besse, M. Gabureac, A. Wallraff, and C. Eich-
ler, npj Quantum Information 5, 69 (2019), URL https:
//www.nature.com/articles/s41534-019-0185-4 .
[68] M. D. Barrett, J. Chiaverini, T. Schaetz, J. Britton,
W. M. Itano, J. D. Jost, E. Knill, C. Langer, D. Leibfried,
R. Ozeri, et al., Nature 429, 737 (2004), URL https:
//www.nature.com/articles/nature02608 .
[69] M. Riebe, H. H¨ affner, C. F. Roos, W. H¨ ansel, J. Benhelm,
G. P. T. Lancaster, T. W. K¨ orber, C. Becher, F. Schmidt-
Kaler, D. F. V. James, et al., Nature 429, 734 (2004),
URL https://www.nature.com/articles/nature02570 .
[70] L. Steffen, Y. Salathe, M. Oppliger, P. Kurpiers, M. Baur,
C. Lang, C. Eichler, G. Puebla-Hellmann, A. Fedorov,
and A. Wallraff, Nature 500, 319 (2013), URL https:
//www.nature.com/articles/nature12422 .
[71] A. D. C´ orcol es, M. Takita, K. Inoue, S. Lekuch, Z. K.
Minev, J. M. Chow, and J. M. Gambetta, Phys. Rev.
Lett. 127, 100501 (2021), URL https://link.aps.org/
doi/10.1103/PhysRevLett.127.100501 .
[72] J. Cramer, N. Kalb, M. A. Rol, B. Hensen, M. S. Blok,
M. Markham, D. J. Twitchen, R. Hanson, and T. H.
Taminiau, Nature Communications 7, 11526 (2016),URL https://www.nature.com/articles/ncomms11526 .
[73] V. V. Sivak, A. Eickbusch, B. Royer, S. Singh, I. Tsiout-
sios, S. Ganjam, A. Miano, B. L. Brock, A. Z. Ding,
L. Frunzio, et al., Nature 616, 50 (2023), URL https:
//www.nature.com/articles/s41586-023-05782-6 .
[74] A. Cross, A. Javadi-Abhari, T. Alexander, N. De Beau-
drap, L. S. Bishop, S. Heidel, C. A. Ryan, P. Sivarajah,
J. Smolin, J. M. Gambetta, et al., ACM Transactions on
Quantum Computing 3(2022), ISSN 2643-6809, URL
https://doi.org/10.1145/3505636 .
[75] URL https://zenodo.org/record/7591922 .
[76] URL https://quantumcomputing.ibm.com/lab/docs/
iql/manage/systems/cite .
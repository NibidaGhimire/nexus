Quantum algorithmic solutions to the shortest vector problem on simulated coherent
Ising machines
Edmund Dable-Heath,1, 2Laura Casas,3Victor Hertz,1Christian Porter,1Florian Mintert,3, 4and Cong Ling1
1Electronic and Electrical Engineering Department,
Imperial College London, Prince Consort Road, SW7 2AZ, United Kingdom
2The Applied Research Centre, The Alan Turing Institute,
British Library, 96 Euston Rd., London NW1 2DB
3Physics Department, Blackett Laboratory, Imperial College London,
Prince Consort Road, SW7 2AZ, United Kingdom
4Helmholtz-Zentrum Dresden-Rossendorf, Bautzner Landstraße 400, 01328 Dresden, Germany
(Dated: January 22, 2025)
Quantum computing poses a threat to contemporary cryptosystems, with advances to a state in
which it will cause problems predicted for the next few decades. Many of the proposed cryptosystems
designed to be quantum-secure are based on the Shortest Vector Problem and related problems. In
this paper we use the Quadratic Unconstrained Binary Optimisation formulation of the Shortest
Vector Problem implemented as a quantum Ising model on a simulated Coherent Ising Machine,
showing progress towards solving SVP for three variants of the algorithm.
I. INTRODUCTION
With the development on scalable quantum computing
on the horizon [1–3] the effort to create the quantum-
secure cryptographic systems for classical computation
has developed a clear front runner in lattice based cryp-
tography (LBC) [4]. Whilst cryptosystems based on lat-
tices appear to be resistant to related gate model quan-
tum attacks that have challenged RSA [5, 6], amongst
other contemporary systems [7], there is an ongoing en-
deavour to assess their security under a variety of quan-
tum computational models. The gate model of quantum
computing can be thought of as the quantum equivalent
to the standard digital model of classical computation,
however there are many alternative models that draw
closer comparison to analogue computing. In particular,
given the common practice of formulating computational
problems as Ising models [8], systems such as Coherent
Ising Machines (CIM) [9] that implement a physical Ising
model could provide efficient methods for solving these
problems. Here we investigate how CIMs could be used to
question the security assumptions of lattice based cryp-
tography.
The advent of quantum computing - especially Shor’s
algorithm [6] - has led to a need to question whether
the current cyptographic standards are good enough.
Whilst effective direct attacks on cryptographic systems
by quantum computers are a little way off [10] this has
led to the National Institute of Standards and Technol-
ogy (NIST) to run a standardisation competition [11].
Weakness to quantum attacks comes from attacks on
a piece of the fundamental design of cryptographic sys-
tems: the obfuscation of information by application of
a computationally hard mathemtical problem. Specifi-
cally problems that exhibit a trapdoor - easy to compute
functions with an inverse that is hard to compute with-
out already possessing the answer. A key example of
this is the factorisation of semi prime number n=pqinto their unique prime factors pandq. Knowing one or
both of the factors solves the problem simply, however
without this one must resort to computationally expen-
sive factorisation algorithms. RSA [5] bases its security
on this problem, with Diffie-Hellman [12] and El-Gamal
[13] based on related problems. It is this exact problem
(and related problems), however, that Shor’s algorithm
purports to solve in a computationally efficient manner.
Proposal schemes to the NIST standardisation proce-
dure look to replace this underlying hard problem with
problems that can’t be efficiently computed by quantum
computational models. Several of the proposed PQC
cryptosystems are based in LBC: learning-with-errors
(LWE) [14] and its structured adaptations ring-LWE [15]
and module-LWE [16], NTRU [17].
The computational problems in LBC center on min-
imising the distance between objects in high dimensional
spaces. The Shortest Vector Problem (SVP) poses find-
ing the closest non-zero vector to the origin, picking a
different target vector in the ambient space adapts this
to the Closest Vector Problem.
Coherent Ising Machines use quantum optical effects to
implement a physical Ising model, allowing one to pro-
gram the solution to a computational problem into the
energy eigenstates, for which the device optimises for.
Recent physical implementations of these devices have
seen up to 100,000 spin sites [18], with efficient operation
in solving several standard performance heuristic prob-
lems, such as the Max-Cut problem [19]. However, the
assessment of the performance of these devices on real-
world problems is still in its early days. In this paper
we develop an algorithm that applies a CIM as an SVP
solver, testing its performance under several key metrics
for a low dimensional set of lattices. Key to the efficient
running of any computational system is effective use of
the resources at hand, for which we also present several
variants of the CIM SVP solver and associated spatial
complexity bounds.
The paper is structured as follows: Section II lays outarXiv:2304.04075v3  [quant-ph]  20 Jan 20252
some preliminaries. In section III the quadratic uncon-
strained binary optimisation (QUBO) form of the short-
est vector is introduced and the quantum Ising model
encoding variants given. Within this section we also out-
line our method for removing the zero vector of the lattice
from the search space to ensure that the shortest non zero
vector is the ground state. The implementation of the
QUBO SVP into an Ising model using various encoding
methods is shown with complexity bound on the number
of qubits required for each encoding derived. Implemen-
tations of the QUBO SVP on a simulated CIM are shown
in section IV. Simulations include a low-dimensional im-
plementation of the three qubit encodings presented in
section III, and implementation of the constraint to re-
move the zero vector as the ground state.
II. PRELIMINARIES
Some general notes on notation: vectors are notated
by lowercase boldface x, matrices by uppercase boldface
Band lattices by Λ. All norms ∥x∥refer to the 2-norm:
∥x∥2=sX
ix2
i.
Operators are denoted ˆA, with ˆHreferring to the Hamil-
tonian operator. Where it is clear from context the tensor
productNis dropped.
A. Lattices
Lattices are discrete subsets of Rnwith a regular, re-
peating structure. See Fig. 1 for a two dimensional ex-
ample. They form linear spaces containing the origin,
making them attractive for computational problems.
Definition 1. Alattice Λ ⊂Rnis a discrete additive
subgroup of Rn. That is 0∈Λ, ifx,y∈Λthen−x,x+
y∈Λand for any x∈Λthere is a neighbourhood around
xinRnwhich contains no other lattice points.
A lattice is often defined by a basis B={b1, . . . ,bk},
with the lattice generated by all integer combinations of
the basis vectors,
Λ(BZn) =(kX
i=1zibizi∈Z)
. (1)
Bases Bare not unique as any two bases can be related
by a unimodular transform. The number of basis vectors
kdescribes the rank of the lattice, with a lattice Λ ⊂
Rnsuch that k=nknown as full rank. In this work
we restrict ourselves to full rank lattices. Any basis can
be described as being of good or bad quality with better
bases having shorter and closer to orthogonal vectors.
The following definitions, 2 - 6, are key for theorems
presented in section III.
FIG. 1: A two dimensional example lattice (here a
rotation Z2). Two example bases are pictured: the
green vectors, {g1, g2}, represent a ‘good’ basis with
short, orthogonal vectors, and the red vectors, {r1, r2},
a ‘bad’ basis with long, non-orthogonal vectors.
Definition 2 (Dual Lattice) .The dual lattice Λ∗of a
lattice Λ(B)is defined as
Λ∗(B) ={x∈Rn| ⟨x,Λ⟩ ⊂Z}. (2)
Definition 3. The fundamental parallelpiped P(B)is
defined as the set of point in Rn
P(B) ={x·B|x∈[0,1)n}, (3)
the volume of which is known as the lattice covolume and
denoted vol (Λ).
The geometry of the fundamental parallelpiped de-
pends on the basis, however the covolume is a lattice
invariant and independent of the choice of basis. One
can compute the covolume as |det(B)|. One can further
characterise the geometry of the basis by how far the vec-
tors are from orthonormal using the orthogonality defect.
Definition 4 (Orthogonality defect) .Given a basis for a
lattice Λ(B)the orthogonality defect of the basis is defined
as
δ(B) =Qn
i=1∥bi∥
vol(Λ)2
. (4)
Given a basis for a lattice in which one wishes to solve
computational problems one can improve the quality of
the basis - a process known as basis reduction - prior to
the application of any algorithms. The most widely used
reduction method is LLL reduction [20] due to its poly-
nomial time complexity. Another important reduction is3
HKZ reduction [21], which has an exponential time com-
plexity, though returns higher quality bases that LLL.
The exact definitions of these is not necessary for this
paper, however qualities of bases reduced by both meth-
ods are discussed in section III.
The lattice problem that is primarily of interest in this
work is the shortest vector problem :
Definition 5 (The Shortest Vector Problem (SVP)) .
Define λ1(Λ)to be the length of the shortest non-zero
vector in Λ. Then the shortest vector problem (SVP) is:
given a basis Bof a lattice Λ, compute a vector v∈Λ
such that ∥v∥=λ1(Λ).
In every lattice there are at least two shortest vectors,
v1and−v1. The sequence of vector norms with in-
creasing length are known as the sucessive minima, and
denoted λifor the ithminima. Approximate versions
of the above problem and related lattice problems - in
which one is looking to compute short vectors typically
with length within a multiple of the shortest - are also an
important class of lattice problem. The shortest vector
problem forms the security basis for many post-quantum
cryptosystems, due to a reduction from SVP to the LWE
problem [22].
Finally we note two important classes of lattices, cyclic
and negacylic lattices. These lattices are themselves a
subset of ideal lattices, lattices based on the correspon-
dence between ideals of polynomial rings and integer sub-
lattices Λ ⊂Zn. Cyclic lattices are ideal lattices con-
structed by applying a rotational shift operator to a vec-
tor formed by the coefficients of a polyonimal to form
successive rows of a basis matrix, with negacyclic lattices
formed by a rotational shift operator that introduces a
negative sign to certain coefficients on each application.
Negacyclic lattices form the basis for cryptosystems such
as ring-LWE [15] and Falcon [23], providing greater effi-
ciency than their unstructured counterparts, at the cost
of a reduction in security. The full technical definition of
such lattices is not necessary, however we take advantage
of two key properties of cyclic and negacylic lattices for
the complexity proofs of section III: the dual of a cyclic or
negacyclic lattice is also a cyclic or negacylic lattice, and
that these lattices are examples of well rounded lattices.
The latter property is formally defined as follows,
Definition 6 (Well Rounded Lattice) .LetΛ⊂Rnbe a
full rank lattice, and define the set of minimal vectors of
the lattice as,
S(Λ) := {v∈Λ| ∥v∥=λ1}, (5)
where λ1is the first successive minima of the lattice.
Then we see that Λiswell rounded ifSpR(S(Λ)) = Rn.
In other words the set of vectors in a well rounded lat-
tice solving the shortest vector problem span Rn, mean-
ing there are at least nshortest vectors in such lattices,
all sitting on a sphere of radius λ1centered at the origin.B. Computational Ising Models
Ising models have long since moved beyond exclusively
modelling ferromagnetic materials and now provide a
convenient computational framework for problems that
can be expressed as a minimisation over a set of binary
variables [8, 24]. In a quantum setting they form the
basis for adiabatic computation [25] and coherent Ising
machines. In our case that they have a convenient resem-
blance to quadratic unconstrained binary optimisation
problems [26]. This is expanded upon in section III.
Typically one considers particles with spin (usually two
level spin) on a lattice graph (which can be generalised
to arbitrary graph topology). Particles at graph nodes
in this model have interactions with other sites for which
they share an edge, and an overall external magnetic
field applied across all sites. For a classical Ising model
one considers a vector of spins - the spin configuration
s= (sk)k∈Λwhere sk∈ {− 1,1}. Each pair of adjacent
sites i, j∈Λ has an interaction term Jijand an exter-
nal magnetic field term hj, allowing the energy of any
particular configuration to be given by the Hamiltonian,
H(s) =−X
⟨i,j⟩Jijsisj−X
jhjsj. (6)
To map this to the quantum domain one replaces the
spin variables skwith Pauli- zoperators ˆZkacting on the
kthqubit of the system. The Pauli operators (along with
the identity) form a basis for qubit operators and can be
expressed as a set of four 2 ×2 matrices:
I=
1 0
0 1
, ˆX=
0 1
1 0
, (7)
ˆY=
0−i
i0
, ˆZ=
1 0
0−1
. (8)
By combining the identity operator and the Pauli- z
operator one can map binary variables in the computa-
tional basis with eigenvalues {−1,+1}to{0,1}using the
termI+ˆZ
2within an Ising Hamiltonian,
ˆH=X
⟨i,j⟩JijIi+ˆZj
2OIj+ˆZj
2+X
ihiIi+ˆZi
2.(9)
Several architectures now exist that allow a program-
mer to control the values of the coefficients of the cou-
plings Jijand the external magnetic field hi. These val-
ues can be set such that the ground state - or related
low energy states - encode solutions to the computational
problem they wish to solve.
C. Error Correcting Coherent Ising Machines
Coherent Ising Machines (CIM) have seen a lot of
progress in the last decade, with advances in the physical4
CIMs [18, 27] and success in many performance heuristic
problems in both simulation and physical CIMs [19, 28].
They physically implement an Ising model by storing the
spins as wave packets generated by optical parametric os-
cillators (OPO) and passing them through optical circuits
to implement interactions. This allows them to solve
computation problems that can be expressed as Ising
models. At current the CIMs are restricted to binary
variables and lack an external field component, however
have the ability to implement any graph topology re-
quired for the Ising system considered.
The standard coupling scheme performed by CIMs
suffers from amplitude heterogenity, meaning that the
programmed Ising Hamiltonian is incorrectly mapped to
the system resulting in unsuccessful operations [9]. This
problem can be resolved by the application of error cor-
rection within the CIM. Within this work we use error
correction by chaotic feed back control (CIM-CFC) [29].
Alongside the spin variables xi, auxiliary error variables
eiare introduced, with the following deterministic equa-
tions emulated on a CIM,
zi=eiξX
jJijxj, (10)
dei
dt=−βei(z2
i−α), (11)
dxi
dt=−x3
i+ (p−1)xi−zi. (12)
Here Jijare the coupling constants for the Ising system,
α, β andpare system parameters and ξis a normalisa-
tion constant for Jij. Typically one can achieve greater
success by varying the parameters, allowing the system
to explore the search space rapidly before converging to
a solution. Parameter choices are discussed in section
IV. As an Ising solver one considers the spin configura-
tionσi= sign( xi) as a possible solution to the associated
Ising problem defined by Jij. In simulation Gaussian
noise terms are often included, however to achieve a di-
verse set of spin trajectories within this work we consider
random initial spin amplitudes xi.
III. QUBO FORMULATION AND SPATIAL
COMPLEXITY BOUNDS
When implementing the SVP as a computational prob-
lem it is convenient to consider each integer coefficient
with respect to the basis vectors as a variable, as defined
by Eq. (1), for a lattice Λ = Λ( B)⊂Rn. The resultant
integer vector uniquely determines a lattice vector whose
length can easily be calculated using the basis matrix.
This approach also allows us to accurately limit the bi-
nary variables required whilst ensuring that the shortest
vector is still within the solution space - an especially
important feature for NISQ era architectures. There is a
natural correspondence between quadratic unconstrainedbinary (QUBO) forms with a general cost,
C(s1s2. . . sn) =c+X
i̸=jcijsisj+X
iciisi, (13)
where s1s2···snis a string of binary variables with
si∈ {0,1}andc,{cij}1≤i,j≤ncoefficients, and the Ising
Hamiltonian, Eq. (9) [30–32]. Further to this, if all of
the variables are integers then within the solution space
exists the vector in which all the coefficients are zero, the
trivial answer to which vector is the shortest within a
lattice. By adapting the QUBO formulation it is possi-
ble to impose the condition that the solution space, S,
becomes S ⊂Λ\0[32].
First we examine the QUBO formulation, followed
by variants on the integer encoding method. Then we
present a method for imposing the removal of the zero
vector from the solution space. Finally several spatial
complexity theorems are given.
A. The QUBO Formulation of SVP
Given v∈Λ(B)⊂Rn- where the rows of a matrix
Bspan the lattice - vcan be expressed as v=zBfor
z∈Zn. The length of said vector can therefore be ex-
pressed as ∥v∥2=zBBTzT=zGzTwhere G=BBT
is the Gramm matrix. This allows for a reformulation of
the shortest vector problem as a quadratic unconstrained
integer optimisation problem,
λ1(Λ)2= min
v∈Λ\{0}∥v∥2
= min
z∈Zn\{0}
nX
i=1z2
iGii+ 2X
1≤i<j≤nzizjGij
.
(14)
In the above formulation the variables zi∈zare as-
sumed to have integer values, a quality unfortunately
not accessible by the majority of contemporary quantum
hardware, including the CIM. Ideally we would have ac-
cess to a system composed of qudits, in which the spin
level dcould be tuned to the integer range we require.
In lieu of such a system one must instead encode integer
values into registers of qubits forming logical qudits. We
require one of these qudits per dimension to represent the
associated integer coefficient, with the number of qubits
composing each qudit register depending on the integer
range required and choice of encoding [31]. See Fig. 2 for
a schematic diagram of how the operators are associated
to the qubit registers for which they decode to integers.
Each circle in the diagram represents a qubit (with val-
ues here in the computational basis). Registers of qubits
forming a qudit are organised by columns, with an oper-
ator ˆQacting on the a particular column to decode the
qubit values and produce an integer coefficient zi. The
lines between sites represent nearest neighbour connec-
tions. For the QUBO setting a complete graph topology
is required.5
FIG. 2: Schematic diagram for encoding multiple qubits
as qudits representing integer coefficients for lattice
vectors. Each column in this diagram represents a
register of qubits that encode a integer decoded by Qto
produce the integer coefficient for each dimension zi.
The links here represent the nearest neighbours, in the
QUBO case we require a complete graph topology.
The different encodings can be unified by formulating
them as a map from a set of kqubits forming a qudit to
an integer range,
ˆQenc:{−1,+1}k→[−f(k), f(k)], (15)
where f(k) is dependent on the specific encoding. This
formulation results in the corresponding Ising Hamilto-
nian of the form,
ˆH=X
⟨i,j⟩ˆQi
encˆQj
encGij, (16)
where the index on the operator ˆQi
encrefers to the oper-
ator acting on the ithqudit, i.e. the ithregister of qubits.
Here we compare three different integer encodings.
a. Binary Encoding The binary operator takes a
register of qubits with states in the {−1,+1}basis and
maps them to the computational basis from which it as-
signs a value of 2kto the kthqubit as in standard binary
codes. The form of the operator is,
ˆQbin:{−1,+1}k→[−2k−1,2k−1]; (17)
ˆQbin=kX
p=02p−1ˆZp+I
2, (18)
where ˆZis the Pauli-Z operator corresponding to the pth
qubit of a qudit register. The final output is shifted down
by 2kto give an integer range of [ −2k,2k−1]. Whilst
this operator is the most efficient encoding of integers by
a binary string it has the downside of not being particu-
larly resistant to noise as it lacks any redundancy. Due
to the exponential significance of each qubit within the
encoding the binary encoding also leads to an exponen-
tial growth in the size of coupling constants in an Ising
model implementation, as seen in [31].b. Hamming Encoding The Hamming encoding
measures the Hamming weight of the code to obtain an
integer by counting the number of qubits in the +1 state
with form,
ˆQham:{−1,+1}2k+1→[−2k,2k]; (19)
ˆQham=1
22k+1X
p=1ˆZp. (20)
Note that in this case we require 2kqubits. This is
also shifted to be symmetric around zero with output
[−2k,2k]. The Hamming encoding has inbuilt redun-
dancy making it a more attractive choice for implement-
ing on near term quantum architecture, however we lose
the exponential scaling in the number of integers repre-
sented found in the binary case.
c. Polynomial Encoding The polynomial encoding
seeks to find a mid ground between the information den-
sity, but exponential coupling constant growth, of the bi-
nary encoding, and the redundancy but low information
density of the Hamming encoding. It takes the form,
ˆQpoly:{−1,+1}k→[−m, m ]; (21)
ˆQpoly=1
2kX
p=1pˆZp+I
2k
2
mod 2
. (22)
Here the second term is required to ensure an integer
is always returned. This returns integer in the range
[−m, m ] where,
m=k2+k
4. (23)
This particular polynomial encoding is quadratic in na-
ture, however it can be generalised for any polynomial by
adjusting the exponent of the pterm in Eq. (21). In this
work we restrict ourselves to the quadratic case, referring
to this as the polynomial encoding.
In section IV these encodings - including the follow-
ing adaptation - are used to apply a CIM to the SVP,
with spatial complexity bounds on the number of qubits
required to implement these algorithms presented here.
B. Removing the Zero Vector
When computing solutions for a computational prob-
lem by encoding them into an Ising model one typically
seeks to have the ground state respresent the solution to
the problem. In the above formulation a possible state
represents the integer vector 0, corresponding to 0∈Λ.
The length of this vector is naturally shorter than the
first succesive minima, λ1- representing the length of
the shortest non-zero vector - and therefore the state
representing this will be the ground state. However by
restricting the integer range that a qudit register can rep-
resent the ground state can instead be made to represent
the shortest vector in the lattice.6
The proposed method is as follows: one qudit at a time
- i.e. taking the integer coordinate for one dimension
at a time - restrict the integer range represented by the
qudit to [1 , m] for some chosen positive integer m. This
removes the zero vector from the search space. However,
for a given basis it is not known whether none of the
integer coordinates will be zero for the shortest vector,
so this Ising solver in this case must be repeated ntimes
for a lattice Λ ⊂Rnto ensure that the shortest vector is
apparent across the total set of vectors accessible by this
method. Formally, we define a family of lattice subsets
{˜Λi}i∈[n],
˜Λi:=BZi−1⊕Z>0⊕Zn−i, (24)
for which we apply the quantum algorithm to, repeating
for each value of i∈[n]. Here the notation BAdenotes
all combinations of the basis Bwith elements of the set
A, in this case a subset of the integers, ˜Zn=Zi−1⊕Z>0⊕
Zn−i. In practice the quantum algorithm is applied over a
subset bounded of an individual ˜Λiout of computational
necessity, with the bounds discussed in III C.
To implement this method new qudit operators are re-
quired, to be used in concert with the standard operators,
and only applied to the qudit chosen to be restricted.
a. Binary encoding To restrict this range to
[1,2k+ 1] we define the following operator,
ˆQ′
bin:{−1,+1}r→[1,2k+ 1]; (25)
ˆQ′
bin:=rX
p=02p−1ˆZp+2r+1+ 1
2I, (26)
where r=k−1.
b. Hamming encoding To restrict this range to
[1,2k+ 1] we define the following operator,
ˆQ′
ham:{−1,+1}2k→[1,2k+ 1]; (27)
ˆQ′
ham:=2kX
p=1ˆZp
2+ (2k−1+ 1)I. (28)
c. Polynomial Encoding To restrict this range to
[1, m+ 1] we define the following operator,
ˆQ′
poly:{−1,+1}r→[1, m+ 1]; (29)
ˆQ′
poly:=1
2rX
p=1pˆZp+r(r+ 1) + 4
4I (30)
+I
2lr
2m
mod 2
, (31)
where,
r=&p
2k(k+ 1)−7−1
2'
. (32)
Whilst this requires the ground state of the Ising model
to be computed a factor of ntimes over to ensure thatthe shortest vector is within the overall solution space
this reformulation should sample the shortest vector with
greater efficacy than the unrestricted formulation. It is
incorporated into the numerical simulations in section
IV.
1. Applying the Restriction to Cyclic and Negacyclic
Lattices
If we let Λ be an cyclic or negacyclic lattice this method
of removing the zero vector as the ground state can be
simplified, only having to restrict a single qudit register.
This is due to the following lemma, that ensures the ex-
istence of a shortest vector for each lattice subset defined
in Eq. (24),
Lemma 1. LetΛ⊂Rnbe a well rounded lattice, with a
set of minimal vectors,
S(Λ) := {v∈Λ| ∥v∥=λ1}, (33)
where λ1is the first successive minima of Λ. Fixing a
basis for the lattice, B, such that Λ = Λ( BZn), define a
family of lattice subsets {˜Λi}i∈[n],
˜Λi:=BZi−1⊕Z>0⊕Zn−i. (34)
Then ˜Λi∩S(Λ)̸=∅for all i∈[n].
Proof. See appendix A.
In other words there is always intersection between the
set of minimal vectors - solutions to SVP - and each lat-
tice subset used in the restricted formulation. Since every
lattice subset this method searches over is guaranteed to
contain a solution to shortest vector problem for cyclic or
negacyclic lattices one can pick an arbitrary i∈[n] as the
restricted dimension. This reduces the time complexity
of implementing this restriction by a factor of n, bringing
it in line with the unrestricted approach. There will be
a particular choice of isuch that the integer coefficients
are minimised, also increasing efficacy of the quantum al-
gorithm. However, the disparity between the size of the
integer coefficients for each solution can be minimised by
applying a basis reduction prior to the quantum algo-
rithm.
C. Spatial Complexity Bounds
A key question one can ask about this framework is
how does the number of qubits required to ensure the
shortest vector is within the search space scale with the
dimension of the problem? To answer this first requires
a bound on the integer coefficients for a lattice vector,
provided Lem. 1 of [32], stated here without proof.7
Lemma 2 ([32]).LetΛ = Λ( B)be a full rank lattice
with basis Band let x1, . . . ,xn∈Zbe such that ∥x1·
b1+···+xn·bn∥ ≤A. then for all i= 1, . . . , n we have
|xi| ≤A∥b∗
i∥where b∗
1, . . . ,b∗
nare rows of the dual basis
B∗.
The choice of the search radius Asuch that λ1≤A
butAis not too large is an important consideration. For
random lattices the Gaussian Heuristic [33] provides a
good estimate as,
gh(Λ) :=rn
2πevol(Λ)1/n. (35)
By setting A=gh(Λ) one can use Lem. 2 to bound the
number of qubits required to ensure the existence of the
shortest vector within the search space. For this work we
restrict ourselves to cyclic and negacyclic lattices to pro-
vide spatial complexity bounds for all three encodings, in
the case of an HKZ reduced basis. Proofs of the following
theorems can be found in appendix A.
Theorem 1. LetΛ⊆Znbe a full rank, cylcic or nega-
cyclic lattice such that Λ = Λ( B), where Bis an HKZ
reduced basis. Then there exists a quantum algorithm
employing the binary qubit encoding requiring,
Qbin(n)≤3n
2log2(n+ 3)−n
2(2 + log2πe) +O(1),(36)
qubits to ensure the existence of the shortest vector within
the search space.
Theorem 2. LetΛ⊆Znbe a full rank, cyclic or nega-
cyclic lattice such that Λ = Λ( B), where Bis an HKZ
reduced basis. Then there exists a quantum algorithm
employing the Hamming qubit encoding requiring,
Qham(n)≤2O(1)n5/2≈ O(n5/2), (37)
qubits to ensure the existence of the shortest vector within
the search space.
Theorem 3. LetΛ⊆Znbe a full rank, cyclic or nega-
cyclic lattice such that Λ = Λ( B), where Bis an HKZ
reduced basis. Then there exists a quantum algorithm
employing the polynomial qubit enocoding requiring,
Qpoly(n)≤2O(1)n7/4≈ O(n7/4), (38)
qubits to ensure the existence of the shortest vector within
the search space.
a. Comparing Bounds Fig. 3 plots a numerical com-
parison of the bounds found in Thm. 1, 2 and 3. As ex-
pected - given the growth of the respective state spaces
- the binary is the most spatially efficient, with the
Hamming the least efficient and the polynomial inbe-
tween the two. The polynomial bound is in fact only
O(n7/4−nlog2n) worse than the binary, which along-
side its ability to overcome several of the issues found
in the binary case makes it an attractive candidate for
QUBO SVP algorithms.
FIG. 3: A numerical comparison of the bounds from
Thm. 1, 2 and 3 against the dimension of the lattice.
The binary qubit number can be seen in the blue
triangle curve, Hamming orange square curve and
polynomial green circle curve. As the the dimension
scales the binary encoding remains the most spatially
efficient, however the polynomial encoding is not far
behind lending credence to its use as it also overcomes
several of the issues of the binary encoding.
IV. A CIM SVP SOLVER
We compare the efficacy of the CIM with CFC error
correction as a SVP solver using the QUBO formulation
in simulation for an initial lower dimensional setting and
the above restriction of 0/∈Λ.
To implement the QUBO Ising model stated in Eq.
(15) with the above operators requires single operator
terms, which correspond to external field considerations
in a physical Ising model - a feature the CIM can not
implement. Instead the above system is replaced by a
system containing an auxiliary site interacting with all
other sites, for which the state is kept constant. Opera-
tors in this system take the form,
ˆQ(i)
bin=kX
p=02p−2ˆZip+ 2−1ˆZA (39)
ˆQ(i)
poly=kX
p=1pˆZip+ˆZA
2k
2
mod 2
, (40)
where ˆZAis the Pauli- zoperator acting on the auxiliary
qubit.8
FIG. 4: Sample output distribution for the CIM-CFC applied to the QUBO approach to the SVP for the three
encodings, the Hamming (Eq. (19)), polynomial (Eq. (21)), and binary encodings (Eq. (17)), for the lattice in
dimension 7 defined by the basis given in Eq. (41). Here the orange line represents the length of the shortest vector
in the lattice and the green lines represent the lengths of the input basis vectors.
A. Initial Findings
In the low dimensional regime lattices are spanned by
the rows of random integer matrices containing elements
from{−1,0,1}- ensuring the existence of the the short-
est vector within the basis. Bases are subsequently trans-
formed by unimodular matrices with elements no greater
than 6 (for computational simplicity) to create a problem
set of hard bases.
Typically when running a CIM the parameters are var-
ied over the course of the process. This is to encourage
convergence to a state whilst still allowing for adequate
exploration of the state space. Table I contains a list of
the parameters used in the lower dimensional simulations
including how they varied.
Parameter Value
∆t 0.0001
Time-steps 320000
Varying Parameter Time Steps 288000
Stationary Parameter Time Steps 3200
β 0.8
Initial p -2
Stationary p 0
Initial α 1
Stationary α 2
TABLE I: Simulation parameters for the CIM-CFC
applied to the SVP. Varied parameters were varied
smoothly over the varying time steps and then held at
their stationary value until the end of the simulation.
The test set of low dimensional lattices were gener-
ated with entries from {−1,0,1}, making sure that the
shortest vector was already apparent within the basis,
then augmented by unimodular matrices with elements
no greater than 6 for computational simplicity. By con-
sidering each run as sampling from the lattice in partic-
ular we can assess the accuracy of the CIM-CFC as an
Ising solver for this problem by examining the outputsample distribution.
1. Representative Example
In Fig. 4, a representative example lattice for all three
qubit encodings - hamming, polynomial and binary - in
dimension 7, for a lattice spanned by the rows of,
B=
2 3 −1−3 3 1 4
1 2 −1−2 2 1 1
0 0 −3−4 4 0 1
−1−2−1−2 1 0 0
−1−2 3 4 −4 0 0
1 1 −1−1 1 0 1
1 3 3 2 −2 3 1
, (41)
can be seen. The green lines represent the lengths of the
basis vectors and the orange line (the furtherest left line
in each plot) the length of the shortest vector. In this ex-
ample output sample, the CIM SVP solver does sample
the shortest vector with non-zero probability, as well as
finding the ground state 0∈Λ. However, despite the fact
that it samples the shortest vector much less frequently
than large vectors and the zero vector the distribution
also skews shorter than the basis vectors suggesting that
this could be used to solve the approximate short vec-
tor problem. Whilst this sample distribution is skewed
toward shorter vectors the Ising system fails to achieve
the ground state more often than excited states, and for
the binary encoding does not find the ground state at
all. Considering this purely from the perspective of an
Ising solver this failure to find the ground state presents
a problem, however as an SVP solver the ground state
under this formulation represents the trivial solution, as
such this imperfect operation can be considered useful.
We can see from comparing SubFig. 4(a) and 4(b) to
SubFig. 4(c), the Hamming and polynomial encodings
are more effective in sampling short lattice vectors in this
instance.9
FIG. 5: Comparing the efficacy of the CIM-SVP solver across dimensions 2-7 for the all three encodings, the
Hamming (blue triangle), polynomial (orange circle), and binary (green square) encodings. Here the four panels
correspond to the four figures of merit stated above: the probability of measuring the zero vector (Eq. (42)), the
probability of measuring the solution to SVP (Eq. (43)), the probability of measuring vectors shorter than the
minimum basis vector (Eq. (44)) and the probability of measuring vectors shorter than the median basis vector (Eq.
(45)). The results are aggregated over all lattices in the set of test bases, with the mean value for each figure of
merit given per dimension.
2. Aggregated Results
To understand how this algorithm performs the dimen-
sion of the problem is scaled averaged over all the lattices,
with four key figures of merit (FoM) comparing the effi-
cacy of the three encoding variants, for sampled lattice
vectors v∈Λ = Λ( B) for a given input basis B,
1. The mean sample probability of the zero vector,
Pr(∥v∥= 0). (42)
2. The mean sample probability of the shortest vector,
Pr(∥v∥=λ1), (43)
where λ1is the first successive minima.
3. The mean sample probability of a vector being
shorter than the minimum basis vector,
Pr
∥v∥ ≤min
i∈[n]∥bi∥
, (44)
forbi∈B.
4. The mean sample probability of a vector being
shorter than the median basis vector,
Pr(∥v∥ ≤med∥bi∥), (45)
forbi∈B.Fig. 5 aggregates the results of 1000 CIM runs with the
above parameters, for each of the 32 test lattices in di-
mensions n={2,3,4,5,6,7}. All three algorithms ex-
hibit a decreasing success in each of the four FoMs as the
lattice dimensions is increased, a result that is to be ex-
pected given the increases in complexity of these systems
as the dimension scales. In general the Hamming (blue
triangle) and polynomial (orange circle) results sit above
the binary (green square), indicating a higher probability
of success for all metrics in each dimensions for these two
encodings.
The first metric, the probability of the CIM system
finding the ground state (representing the zero vector in
this case) - given by Eq. (42) - is compared for each
encoding in SubFig. 5(a). This is a good indicator in
the successful operation of the CIM, with the Hamming
encoding showing the greatest success, followed by the
polynomial then binary. This ordering of success, how-
ever, is likely due to the degeneracies in integer represen-
tation apparent in each encoding. Within in the binary
encoding each integer - and therefore each lattice vector
- is uniquely represented, a property not preserved in the
other two encodings. Both the Hamming and polynomial
encodings over represent small integers, with a Gassian
like distribution over the integers centered at zero with a
wide variance.
In contrast to SubFig. 5(a), the separation in success-
ful operation of the three encodings in finding the short-10
FIG. 6: Comparing the efficacy of the CIM-SVP solver with the condition 0/∈Λacross dimensions 2-7 for the all
three encodings, the Hamming (blue triangle), polynomial (orange circle), and binary (green square) encodings.
Here the three panels correspond to three of the four figures of merit stated above: the probability of measuring the
solution to SVP (Eq. (43)), the probability of measuring vectors shorter than the minimum basis vector (Eq. (44))
and the probability of measuring vectors shorter than the median basis vector (Eq. (45)). The results are
aggregated over all lattices in the set of test bases, with the mean value for each figure of merit given per dimension.
est vector of the lattice, given by SubFig. 5(b), is not as
clear. The binary encoding has greater success initially,
likely due to the lack of degeneracies in integer represen-
tation. However as the dimensions scale the Hamming
and polynomial encodings are still able to produce short
vectors, the binary encoding failing to compute the short-
est vector in the overwhelming majority of cases. This
figure of merit is of the greatest consequence as it mea-
sures the efficacy in directly solving SVP.
SubFig. 5(c) and 5(d) show the figures of merit corre-
sponding to the probability of the vectors returned hav-
ing shorter lengths than the shortest and median input
basis vectors respectively. This allows us an insight into
how effective this algorithm is at solving the approximate
shortest vector problem - useful for both the cryptanlysis
of schemes based on the approximate form of the prob-
lem [34], and in producing short vector candidates for
basis reductions algorithms [35]. Here the FoM shows a
high probability of success for all three encodings, no-
tably with a far less steep drop off in this efficacy as the
lattice dimension is scaled.
A key takeaway from figure 5 is the success of the
Hamming and polynomial encodings over the binary in
all metrics, especially the polynomial given its relatively
similar complexity to the binary, whilst simultaneously
solving several of the extant problems inherent in the bi-
nary encoding - for instance the exponential scaling in
the coupling coefficients. What this means for the secu-
rity for lattice based cryptosystems is less clear cut, withthe decay of the probability of finding the shortest vector
being the primary indicator. To assess this simulations
in dimensions not currently computationally accessible,
or implementations on physical CIMs would be required.
This would also necessitate a further investigation into
optimising the parameters of the CIM, which is beyond
the scope of this work.
B. Removal of Zero Vector Restriction
So far the method for solving the shortest vector prob-
lem has been to apply the CIM in an atypical way, with
the assumption that the CIM is not a perfect Ising solver.
In this way we presume that the ground state is not going
to be the final state the system settles in. The two de-
generate first excited states in this formulation represents
the shortest non zero vector and the negative shortest
vector, with each subsequent excited state representing
the successive minima. As seen above this allows the
CIM implementation to have success in the approximate
shortest vector problem. However by restricting the inte-
ger range that a qudit can represent the ground state can
instead be made to represent the shortest vector in the
lattice. This will become an especially important tech-
nique as the efficacy of Ising solvers in application to this
problem increases.
To implement this restriction the QUBO system is
adapted as in section III B. The alternative qudit oper-11
ator is applied to one dimension at a time producing an
integer z∈[1, f(k)], where f(k) depends on the choice
of encoding. This is then repeated for each dimension to
ensure that the shortest vector is within the total search
space - adding a multiplier to the time complexity of n.
As above the system is adapted to include an auxiliary
site to replicate external field considerations.
As in Fig. 5, Fig. 6 plots the results of repeated simula-
tion of the CIM across dimensions 2-7, aggregated across
the 32 test lattices per dimension, in this case for the
restricted formulation. Only the figures of merit giving
the probability of sampling the shortest vector and vec-
tors shorter than the minimum and median basis vectors
are shown as the zero vector is no longer a valid solu-
tion under this formulation. The restricted dimension
that encodes the shortest vector has been post-selected
for in these results, meaning that if all the samples for
each repeated case were collated the results in SubFig.
6(a) would be scaled down by approximately a factor of
n, however we would expect to see an increase in the
probabilities found in SubFig. 6(b) and 6(c). Similar
to the unresticted case given in Fig. 5, the Hamming
(blue triangle) and polynomial (orange circle) encodings
out perform the binary (green square) encoding across all
three figures of merit, with a decrease in efficacy across
all three as the lattice dimension increases. However, this
decrease is sharper than in the unrestricted case, espe-
cially in the sampling of short vectors with respect to the
basis.
In addition to this, whilst we no longer see any oc-
currences of the trivial solution to SVP, 0∈Λ, we do
not observe a great improvement in the ability of the re-
stricted system to directly solve SVP. This is likely to
due to the energy landscape of the search space becom-
ing more jagged - that is to say not smooth - than the
above method, with an emergence of local minima rep-
resenting vectors of greater length. Also contributing is
the fact that by restricting the output to only positive
integers only the positive shortest vector is within the
search space, similarly only positive vectors representing
the successive minima are evident.
V. DISCUSSION
The CIM SVP solver presented here shows promise in
solving SVP on average for the test lattices considered.
When considering the question of scaling this problem
there is a drop off in the ability of such a system in
solving exact SVP, however it could still aid in the so-
lution of approximate SVP. The efficacy of the system
presented in this work can certainly be improved upon
by optimising the parameters of the CIM, especially as
higher dimensions are considered. CIMs explore the state
space most effectively when the system is kept around aphase change, though uncovering the phase changes of an
Ising model is a hard problem in and of itself. Another
method to increase the efficacy of the above CIM SVP
solver would be to explore alternative encodings. This
would provide an alternative energy landscape over the
state space, which if carefully chosen could provide bet-
ter optimisation. Examples of these encodings include
Gray code ordering [36], which would make the energy
shift required for a change of one integer in a binary rep-
resentation uniform as each successive bitstring in Gray
code ordering varies by one bit. However, for a k-length
bitstring this requires k-local interactions, which are not
attainable by the CIM (and require 2k−1CNOT gates to
encode in a gate model).
Physical CIMs have already seen success with imple-
menting large numbers of qubits, and with the advent
of error correction their application to lattice problems
within the QUBO formulation in a higher dimensional
setting could see success if the issues discussed above
can be overcome. This could also be well placed within
MIMO fields as a decoder.
Analysis of the algorithms in section III reveal that the
binary encoding will continue to prove viable as the di-
mension of the lattice problems is scaled to cryptograph-
ically relevant dimensions. However, the scaling in the
coupling strengths required for the binary encoding dis-
closes a large disparity between interactions of the least
significant qubits and the rest of the system, a feature not
apparent in the Hamming and polynomial encodings. To
implement the binary encoding therefore requires a sharp
scaling on the interaction coefficients, leading to the po-
tential for greater error propagation. The polynomial en-
coding provides a solution to these problems by introduc-
ing a less sharp scaling in the coefficients, at the cost of
some efficiency. Along with a the numerical results above,
this suggests that the polynomial encoding would provide
a suitable alternative to the binary encoding. However,
due to the redundancy in the representation of integers
in both the Hamming and polynomial encodings, these
over represent small integers - with a zero centered, wide
variance, Gaussian like distribution over Z. If the inte-
gers required for short vectors in a particular basis are
found at the extremes of the range represented both the
Hamming and polynomial encodings could have difficulty
in finding these vectors.
ACKNOWLEDGMENTS
We would like to thank Andrew Mendhelson, Sam
Reifenstein, Satoshi Kako and Yoshihisa Yamamoto for
their helpful discussions. This work was supported in
part by the Engineering and Physical Sciences Research
Council (EPSRC) under Grant No. EP/S021043/1.12
[1] C. G. Almudever, N. Khammassi, L. Hutin, M. Vinet,
M. Babaie, F. Sebastiano, E. Charbon, and K. Bertels,
Towards a scalable quantum computer, in 2018 13th In-
ternational Conference on Design & Technology of Inte-
grated Systems In Nanoscale Era (DTIS) (IEEE, 2018)
pp. 1–1.
[2] E. A. Sete, W. J. Zeng, and C. T. Rigetti, A functional
architecture for scalable quantum computing, in 2016
IEEE International Conference on Rebooting Computing
(ICRC) (IEEE, 2016) pp. 1–6.
[3] J. L. O’brien, Optical quantum computing, Science 318,
1567 (2007).
[4] D. Moody, Nist status update on the 3rd round, Cryptog-
raphy Technology Group, National Institute of Standards
and Technology (2021).
[5] E. Milanov, The rsa algorithm, RSA laboratories , 1
(2009).
[6] P. W. Shor, Polynomial-time algorithms for prime factor-
ization and discrete logarithms on a quantum computer,
SIAM review 41, 303 (1999).
[7] A. Kumar and S. Garhwal, State-of-the-art survey
of quantum cryptography, Archives of Computational
Methods in Engineering 28, 3831 (2021).
[8] A. Lucas, Ising formulations of many np problems, Fron-
tiers in physics 2, 5 (2014).
[9] Z. Wang, A. Marandi, K. Wen, R. L. Byer, and Y. Ya-
mamoto, Coherent ising machine based on degenerate
optical parametric oscillators, Physical Review A 88,
063853 (2013).
[10] C. Ugwuishiwu, U. Orji, C. Ugwu, and C. Asogwa, An
overview of quantum cryptography and shor’s algorithm,
Int. J. Adv. Trends Comput. Sci. Eng 9(2020).
[11] D. Moody and L. Chen, The 2nd round of the nist pqc
standardization process, National Institute of Standards
and Technology, Tech. Rep (2019).
[12] U. M. Maurer and S. Wolf, The diffie–hellman protocol,
Designs, Codes and Cryptography 19, 147 (2000).
[13] A. V. Meier, The elgamal cryptosystem, in Joint Ad-
vanced Students Seminar (2005).
[14] O. Regev, The learning with errors problem, Invited sur-
vey in CCC 7, 11 (2010).
[15] V. Lyubashevsky, C. Peikert, and O. Regev, On ideal
lattices and learning with errors over rings, in Annual
international conference on the theory and applications
of cryptographic techniques (Springer, 2010) pp. 1–23.
[16] K. Boudgoust, C. Jeudy, A. Roux-Langlois, and W. Wen,
On the hardness of module learning with errors with
short distributions, Journal of Cryptology 36, 1 (2023).
[17] J. Hoffstein, J. Pipher, and J. H. Silverman, Ntru: A
ring-based public key cryptosystem, in International al-
gorithmic number theory symposium (Springer, 1998) pp.
267–288.
[18] T. Honjo, T. Sonobe, K. Inaba, T. Inagaki, T. Ikuta,
Y. Yamada, T. Kazama, K. Enbutsu, T. Umeki, R. Kasa-
hara, et al. , 100,000-spin coherent ising machine, Science
advances 7, eabh0952 (2021).
[19] Y. Haribara, S. Utsunomiya, and Y. Yamamoto, A co-
herent ising machine for max-cut problems: performance
evaluation against semidefinite programming and simu-
lated annealing, Principles and Methods of Quantum In-
formation Technologies , 251 (2016).[20] P. Q. Nguyen and B. Vall´ ee, The LLL algorithm
(Springer, 2010).
[21] G. Hanrot, X. Pujol, and D. Stehl´ e, Analyzing blockwise
lattice algorithms using dynamical systems, in Annual
Cryptology Conference (Springer, 2011) pp. 447–464.
[22] M. R. Albrecht, R. Fitzpatrick, and F. G¨ opfert, On the
efficacy of solving lwe by reduction to unique-svp, in In-
formation Security and Cryptology–ICISC 2013: 16th In-
ternational Conference, Seoul, Korea, November 27-29,
2013, Revised Selected Papers 16 (Springer, 2014) pp.
293–310.
[23] P.-A. Fouque, J. Hoffstein, P. Kirchner, V. Lyubashevsky,
T. Pornin, T. Prest, T. Ricosset, G. Seiler, W. Whyte,
and Z. Zhang, Falcon: Fast-fourier lattice-based com-
pact signatures over ntru, Submission to the NIST’s
post-quantum cryptography standardization process 36
(2018).
[24] S. Tanaka, R. Tamura, and B. K. Chakrabarti, Quan-
tum spin glasses, annealing and computation (Cambridge
University Press, 2017).
[25] T. Albash, T. F. Rønnow, M. Troyer, and D. A. Lidar,
Reexamining classical and quantum models for the d-
wave one processor, The European Physical Journal Spe-
cial Topics 224, 111 (2015).
[26] M. Lewis and F. Glover, Quadratic unconstrained binary
optimization problem preprocessing: Theory and empir-
ical analysis, Networks 70, 79 (2017).
[27] Y. Yamamoto, K. Aihara, T. Leleu, K.-i. Kawarabayashi,
S. Kako, M. Fejer, K. Inoue, and H. Takesue, Coherent
ising machines—optical neural networks operating at the
quantum limit, npj Quantum Information 3, 1 (2017).
[28] R. Hamerly, T. Inagaki, P. L. McMahon, D. Venturelli,
A. Marandi, T. Onodera, E. Ng, C. Langrock, K. Inaba,
T. Honjo, et al. , Experimental investigation of perfor-
mance differences between coherent ising machines and a
quantum annealer, Science advances 5, eaau0823 (2019).
[29] S. Kako, T. Leleu, Y. Inui, F. Khoyratee, S. Reifenstein,
and Y. Yamamoto, Coherent ising machines with error
correction feedback, Advanced Quantum Technologies 3,
2000045 (2020).
[30] D. Joseph, A. Ghionis, C. Ling, and F. Mintert, Not-so-
adiabatic quantum computation for the shortest vector
problem, Physical Review Research 2, 013361 (2020).
[31] D. Joseph, A. Callison, C. Ling, and F. Mintert, Two
quantum ising algorithms for the shortest-vector prob-
lem, Physical Review A 103, 032433 (2021).
[32] M. R. Albrecht, M. Prokop, Y. Shen, and P. Wallden,
Variational quantum solutions to the shortest vector
problem, arXiv preprint arXiv:2202.06757 (2022).
[33] H. Chen, A measure version of gaussian heuristic, Cryp-
tology ePrint Archive (2016).
[34] P. Nguyen and J. Stern, Cryptanalysis of the ajtai-dwork
cryptosystem, in Advances in Cryptology—CRYPTO’98:
18th Annual International Cryptology Conference Santa
Barbara, California, USA August 23–27, 1998 Proceed-
ings(Springer, 2006) pp. 223–242.
[35] Y. R. Zhu, D. Joseph, C. Ling, and F. Mintert, Iterative
quantum optimization with an adaptive problem hamil-
tonian for the shortest vector problem, Physical Review
A106, 022435 (2022).
[36] N. P. Sawaya, T. Menke, T. H. Kyaw, S. Johri,13
A. Aspuru-Guzik, and G. G. Guerreschi, Resource-
efficient digital quantum simulation of d-level systems
for photonic, vibrational, and spin-s hamiltonians, npj
Quantum Information 6, 1 (2020).
Appendix A: Proof of Various Statements
Collected proofs of various statements made above.
1. Proof of Lem. 1
The proof of Lem. 1 relies on the following technical
lemma,
Lemma 3. LetA∈Rn×nbe a full rank matrix. Then
there exists a row permutation Psuch that PAhas a zero
free diagonal, i.e. (PA)ii̸= 0for all i∈[n].
Proof. A= (aij) is full rank, and therefore non-singular:
det(A)̸= 0. Consider the following definition of the de-
terminant,
det(A) =X
σ∈Sn 
sign(σ)nY
i=1aiσi!
. (A1)
If there does not exists a permutation Psuch that PA
has a zero-free diagonal thenQn
i=1aiσi= 0 for all σ∈Sn,
which would set det( A) = 0. Thus we find a contradiction
and there must exist such a P.
Now we provide the proof of Lem. 1:
Proof. By the well rounded nature of Λ, SpR(S(Λ)) =
Rn. Then we can construct a linearly independent subset
˜S(Λ) = {v1, . . . ,vn} ⊂ S(Λ). This defines the matrix
S= [v1:···:vn]T, which is related to the basis by,
S=NB, (A2)where B= [b1:···:bn]Tis the basis matrix, and N=
[z1:···:zn]Tthe matrix of integer coefficients relating
StoB. The above condition is equivalent to exhibiting
a manipulation of Nsuch that Nii>0 for all i∈[n].
Since SandBare full rank, Nis also full rank. Then
the following facts allow us to construct Nthat fulfills
the above condition:
1. By Lem. 3 there exists a row permutation matrix
Psuch that N′=PNandN′
ii̸= 0. This is applied
asPS=PNB , which also reorders the rows of
Saccordingly, but retains the linear independence
and minimality of the vectors.
2. For each vi∈˜S(Λ) if the corresponding integer
value Nii<0 we can replace vi→ −vi. This
can be done as for each v∈S(Λ)−v∈S(Λ),
for which the substitution into ˜S(Λ) maintains the
linear independence of the set.
The final set will fulfill the above constraints. Since this
set can always be constructed each lattice subset ˜Λimust
contain at least one minimal vector.
2. Proofs of Thm. 1-3
For the proofs of these theorems we take advantage of
the well rounded nature of cyclic lattices by way of the
relation,
λi(Λ) = λ1(Λ), (A3)
for all i∈[n]. Further, if we have an HKZ reduced basis
B={b1, . . . ,bn}for a lattice Λ,
∥bi∥ ≤√i+ 3
2λi(Λ), (A4)
for the ithsuccessive minima of the lattice λi(Λ).
a. Proof of Thm. 1
Proof. Letkibe the number of qubits in register i, and
mi= max |zi|where ziis the integer represented by the
qubit register. For the binary encoding this is related as
ki=⌊log2(2mi)⌋+ 1. Then,14
Qbin(n) =nX
i=1(⌊log2(2mi)⌋+ 1),
≤2n+nX
i=1log2mi,
≤2n+n
2log2n
2πe
+nX
i=1log2∥b∗
i∥
vol(Λ∗)1/n,
≤n
2(1−log2πe) +n
2log2nnX
i=1log2√i+ 3λi(Λ∗)
vol(Λ∗)1/n,
≤nlog2(n+ 3) +n
2(1−log2πe) +nX
i=1log2λ1(Λ∗)
vol(Λ∗)1/n,
≤nlog2(n+ 3) +n
2(1−log2πe) +n
2log2γn,
≤nlog2(n+ 3) +n
2(1−log2πe) +n
2log21
8n+6
5
,
≤3n
2log2(n+ 3)−n
2(2 + log2πe) +O(1).
Giving the desired form.
b. Proof of Thm. 2
Proof. Letkibe the number of qubit sin register i, and
mi= max |zi|where ziis the integer represented by the
qubit register. For the Hamming encoding this is related
as 2ki=mi. Then,
Qham(n) =1
2nX
i=1mi,
≤rn
8πenX
i=1∥b∗
i∥
vol(B∗)1/n,
≤rn
8πenX
i=1√i+ 3
2·λi(Λ∗)
vol(Λ∗)1/n,
=rn
32πenX
i=1√
i+ 3·λ1(Λ∗)
vol(Λ∗)1/n,
≤rnγn
32πenX
i=1√
i+ 3,
≤rnγn
32πen√
n+ 3.
By taking log2of both sides we have,
log2Qham(n)≤2 log2(n+ 3) +1
2log21
8n+6
5
,
≤5
2log2n+O(1),
therefore,
Qham(n)≤25
2log2n+O(1)≈ O(n5/2).c. Proof of Thm. 3
Proof. Letkibe the number of qubits in register i, and
mi= max |zi|where ziis the integer represented by the
qubit register. First we derive a closed form for kin
terms of m,
m=1
2kX
i=1i=k(k+ 1)
4=⇒ k=√16m+ 1−1
2.
Then,
Qpoly(n) =1
2nX
i=1(√
16mi+ 1−1),
≤5
2nX
i=1√mi−n
2,
≤5
2n
2πe1/4nX
i=1s
∥b∗
i∥
vol(Λ∗)1/n−n
2,
≤5√
2
2n
2πe1/4nX
i=1s√i+ 3λi(Λ∗)
vol(Λ∗)1/n−n
2,
=5√
2
2n
2πe1/4nX
i=1s√i+ 3λi(Λ∗)
vol(Λ∗)1/n−n
2,
≤5√
2
2nγn
2πe1/4nX
i=1(i+ 3)1/4−n
2,
≤5√
2
2nγn
2πe1/4
n(n+ 3)1/4−n
2.15
By taking log2of both sides we find,
log2Qpoly(n)≤3
2log2n+1
41
8n+6
5
,
≤7
4log2n+O(1),
therefore,
Qpoly(n)≤27
4log2n+O(1)≈ O(n7/4).
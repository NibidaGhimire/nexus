On Semantically-Deterministic Automata∗
Bader Abu Radi and Orna Kupferman
School of Computer Science and Engineering
The Hebrew University, Jerusalem, Israel
May 26, 2023
Abstract
A nondeterministic automaton is semantically deterministic (SD) if different nondeterministic
choices in the automaton lead to equivalent states. Semantic determinism is interesting as it is a
natural relaxation of determinism, and as some applications of deterministic automata in formal
methods can actually use automata with some level of nondeterminism, tightly related to semantic
determinism.
In the context of finite words, semantic determinism coincides with determinism, in the sense
that every pruning of an SD automaton to a deterministic one results in an equivalent automaton.
We study SD automata on infinite words, focusing on B¨ uchi, co-B¨ uchi, and weak automata. We
show that there, while semantic determinism does not increase the expressive power, the combina-
torial and computational properties of SD automata are very different from these of deterministic
automata. In particular, SD B¨ uchi and co-B¨ uchi automata are exponentially more succinct than
deterministic ones (in fact, also exponentially more succinct than history-deterministic automata),
their complementation involves an exponential blow up, and decision procedures for them like uni-
versality and minimization are PSPACE-complete. For weak automata, we show that while an SD
weak automaton need not be pruned to an equivalent deterministic one, it can be determinized
to an equivalent deterministic weak automaton with the same state space, implying also efficient
complementation and decision procedures for SD weak automata.
1 Introduction
Automata are among the most studied computation models in theoretical computer science. Their
simple structure has made them a basic formalism for the study of fundamental notions, such as
determinism andnondeterminism [34]. While a deterministic computing machine examines a single
action at each step of its computation, nondeterministic machines are allowed to examine several
possible actions simultaneously. Understanding the power of nondeterminism is at the core of open
fundamental questions in theoretical computer science (most notably, the P vs. NP problem).
A prime application of automata on infinite words is specification, verification, and synthesis of
nonterminating systems. The automata-theoretic approach reduces questions about systems and
their specifications to questions about automata [27, 40], and is at the heart of many algorithms and
tools. A run of an automaton on infinite words is an infinite sequence of states, and acceptance is
determined with respect to the set of states that the run visits infinitely often. For example, in B¨ uchi
automata, some of the states are designated as accepting states, and a run is accepting iff it visits
states from the set αof accepting states infinitely often [8]. Dually, in co-B¨ uchi automata, a run is
∗A preliminary version appears in the Proceedings of the 50th International Colloquium on Automata, Languages,
and Programming, 2023. Research supported by the Israel Science Foundation, Grant 2357/19, and the European
Research Council, Advanced Grant ADVANSYNT.
1arXiv:2305.15489v1  [cs.FL]  24 May 2023accepting if it visits the set αonly finitely often. Then, weak automata are a special case of both
B¨ uchi and co-B¨ uchi automata in which every strongly connected component in the graph induced
by the automaton is either contained in αor is disjoint from α. We use DBW and NBW to denote
determinisitic and nondeterministic B¨ uchi word automata, respectively, and similarly for D/NCW,
D/NWW, and D/NFW, for co-B¨ uchi, weak, and automata on finite words, respectively.
For automata on infinite words, nondeterminism not only leads to exponential succinctness, but
may also increase the expressive power. This is the case, for example, in B¨ uchi and weak automata,
thus NBWs are strictly more expressive than DBWs [28], and NWWs are strictly more expressive than
DWWs [5]. On the other hand, NCWs are as expressive as DCWs [31], and in fact, also as NWWs [26].
In some applications of the automata-theoretic approach, such as model checking, algorithms can be
based on nondeterministic automata, whereas in other applications, such as synthesis and reasoning
about probabilistic systems, they cannot. There, the advantages of nondeterminism are lost, and
algorithms involve a complicated determinization construction [35] or acrobatics for circumventing
determinization [25, 20].
In a deterministic automaton, the transition function maps each state and letter to a single successor
state. In recent years there is growing research on weaker types of determinism. This includes, for
example, unambiguous automata , which may have many runs on each word, yet only one accepting
run [9, 11], automata that are deterministic in the limit , where each accepting run should eventually
reach a deterministic sub-automaton [39], and automata that are determinizable by pruning (DBP),
thus embody an equivalent deterministic automaton [3].
In terms of applications, some weaker types of determinism have been defined and studied with
specific applications in mind. Most notable are history-deterministic automata (HD), which can
resolve their nondeterministic choices based on the history of the run [17, 7, 22]1, and can therefore
replace deterministic automata in algorithms for synthesis and control, and good-for-MDPs automata
(GFM), whose product with Markov decision processes maintains the probability of acceptance, and
can therefore replace deterministic automata when reasoning about stochastic behaviors [15, 38].
The different levels of determinism induce classes of automata that differ in their succinctness and
in the complexity of operations and decision problems on them. Also, some classes are subclasses
of others. For example, it follows quite easily from the definitions that every automaton that is
deterministic in the limit is GFM, and every automaton that is DBP is HD.
In this paper we study the class of semantically deterministic automata (SD). An automaton A
is SD if its nondeterministic choices lead to equivalent states. Formally, if A=⟨Σ, Q, q 0, δ, α⟩, with
a transition function δ:Q×Σ→2Q, then Ais SD if for every state q∈Q, letter σ∈Σ, and
states q1, q2∈δ(q, σ), the set of words accepted from Awith initial state q1is equal to the set of
words accepted from Awith initial state q2. Since all nondeterministic choices lead to equivalent
states, one may be tempted to think that SD automata are DBP or at least have similar properties to
deterministic automata. This is indeed the case for SD-NFWs, namely when one considers automata
on finite words. There, it is not hard to prove that any pruning of an SD-NFW to a DFW results in
an equivalent DFW. Thus, SD-NFWs are not more succinct than DFWs, and operations on them are
not more complex than operations on DFWs.
Once, however, one considers automata on infinite words, the simplicity of SD automata is lost.
In order to understand the picture in the setting of infinite words, let us elaborate some more on HD
automata, which are strongly related to SD automata. Formally, a nondeterministic automaton A
is HD if there is a strategy gthat maps each finite word u∈Σ∗to a transition to be taken after
uis read, and following gresults in accepting all the words in the language of A. Obviously, every
DBP automaton is HD – the strategy gcan suggest the same transition in all its visits in a state.
On the other hand, while HD-NWWs are always DBP [24, 32], this is not the case for HD-NBWs
1The notion used in [17] is good for games (GFG) automata, as they address the difficulty of playing games on top
of a nondeterministic automaton. As it turns out, the property of being good for games varies in different settings and
HD is good for applications beyond games. Therefore, we use the term history determinism , introduced by Colcombet
in the setting of quantitative automata with cost functions [10].
2and HD-NCWs [6]. There, the HD strategy may need to suggest different transitions in visits (with
different histories) to the same state.
It is easy to see that a strategy gas above cannot choose a transition to states whose language
is strictly contained in the language of states that are reachable by other transitions. Thus, all HD
automata can be pruned in polynomial time to SD automata [19, 4]. The other direction, however,
does not hold: it is shown in [2] that an SD-NWW need not be HD (hence, SD-NBWs and SD-
NCWs need not be HD too). Moreover, while all all HD-NWWs are DBP, this is not the case for all
SD-NWWs.
In this work we study the succinctness of SD automata with respect to deterministic ones, as well
as the complexity of operations on them and decision problems about them. Our goal is to understand
the difference between determinism and semantic determinism, and to understand how this difference
varies among different acceptance conditions. Our study is further motivated by the applications of
automata with different levels of nondeterminism in algorithms for synthesis and for reasoning in a
stochastic setting. In particular, beyond the connection to HD automata discussed above, as runs of
an SD-NBW on words in the language are accepting with probability 1, all SD-NBWs are GFM [2].
We study semantic determinism for B¨ uchi, co–B¨ uchi, and weak automata. We consider automata
with both state-based acceptance conditions, as defined above, and transition-based acceptance con-
ditions. In the latter, the acceptance condition is given by a subset αof transitions, and a run is
required to traverse transitions in αinfinitely often (in B¨ uchi automata, termed tD/tNBW) or finitely
often (in co-B¨ uchi automata, termed tD/tNCW). As it turns out, especially in the context of HD
automata, automata with transition-based acceptance conditions may differ in their properties from
automata with traditional state-based acceptance conditions. For example, while HD-tNCWs can be
minimized in PTIME [1], minimization of HD-NCWs is NP-complete [37]. In addition, there is re-
cently growing use of transition-based automata in practical applications, with evidences they offer a
simpler translation of LTL formulas to automata and enable simpler constructions and decision proce-
dures [13, 14, 12, 39, 29]. Our results for all types of acceptance conditions are summarized in Table 1
below, where we also compare them with known results about deterministic and HD automata.
Deterministic HD SD
Succinctness n(B,C,W) n2(B), 2n(C),n(W) 2n(B,C), n(W)
[19, 24, 32] Theorems 3.3, 4.3, 5.3
Complementation n(B,C,W) n(B), 2n(C),n(W) 2n(B,C), n(W)
[21] [19] Theorems 3.4, 4.4, 5.4
Universality NL (B,C,W) P (B,C,W) PSPACE (B,C), P (W)
[21] [16, 19] Theorems 3.6, 4.5, 5.5
Minimization NP (B,C), P (W) NP (B,C), P (W) PSPACE (B,C), P (W)
(state based) [36, 30] [37, 24, 30] Theorems 3.7, 4.6, 5.5
Minimization open (B,C), P (W) open (B), P (C,W) PSPACE (B,C), P (W)
(transition based) [30] [1, 24, 30] Theorems 3.7, 4.6, 5.5
Table 1: Succinctness (determinization blow-up), complementation (blow-up in going from an au-
tomaton to a complementing one), universality (deciding whether an automaton accepts all words),
and minimization (deciding whether an equivalent automaton of a given size exists, and the described
results apply also for the case the given automaton is deterministic). All blow-ups are tights, except
for HD-NBW determinization, where the quadratic bound has no matching lower bound; all NL, NP,
and PSPACE bounds are complete.
Let us highlight the results we find the most interesting and surprising. While all three types of SD
automata are not DBP, we are able to determinize SD-NWWs in polynomial time, and end up with
a DWW whose state space is a subset of the state space of the original SD-NWW. Essentially, rather
than pruning transitions, the construction redirects transitions to equivalent states in deep strongly
3connected components of the SD-NWW, which we prove to result in an equivalent deterministic
DWW2. This suggests that despite the “not DBP anomaly” of SD-NWWs, they are very similar in
their properties to DWWs. On the other hand, except for their expressive power, SD-NBWs and
SD-NCWs are not at all similar to DBWs and DCWs: while HD-NBWs are only quadratically more
succinct than DBWs, succinctness jumps to exponential for SD-NBWs. This also shows that SD-
NBWs may be exponentially more succinct than HD-NBWs, and we show this succinctness gap also
for co-B¨ uchi automata, where exponential succinctness with respect to DCWs holds already in the
HD level.
The succinctness results are carried over to the blow-up needed for complementation, and to the
complexity of decision procedures. Note that this is not the case for HD automata. There, for
example, complementation of HD-NBWs results in an automaton with the same number of states [19].
Moreover, even though HD-NCWs are exponentially more succinct than DCWs, language-containment
for HD-NCWs can be solved in PTIME [16, 19], and HD-tNCWs can be minimized in PTIME [1].
For SD automata, we show that complementation involves an exponential blow-up. Also, universality
and minimization of SD B¨ uchi and co-B¨ uchi automata, with either state-based or transition-based
acceptance conditions, is PSPACE-complete, as it is for NBWs and NCWs. We also study the D-to-
SD minimization problem , where we are given a deterministic automaton Aand a bound k≥1, and
need to decide whether Ahas an equivalent SD automaton with at most kstates. Thus, the given
automaton is deterministic, rather than SD. By [18], the D-to-N minimization problem for automata
on finite words (that is, given a DFW, minimize it to an NFW) is PSPACE-complete. It is easy to
see that the D-to-SD minimization problem for automata on finite words can be solved in PTIME.
We show that while this is the case also for weak automata, D-to-SD minimization for B¨ uchi and
co-B¨ uchi automata is PSPACE-complete.
Our results show that in terms of combinatorial and computational properties, semantic deter-
minism is very similar to determinism in weak automata, whereas for B¨ uchi and co-B¨ uchi automata,
semantic determinism is very similar to nondeterminism. The results are interesting also in comparison
with history determinism, whose affect on B¨ uchi and co-B¨ uchi automata is different.
2 Preliminaries
2.1 Languages and Automata
For a finite nonempty alphabet Σ, an infinite word w=σ1·σ2··· ∈ Σωis an infinite sequence of
letters from Σ. A language L⊆Σωis a set of words. For 1 ≤i≤j, we use w[i, j] to denote the
infix σi·σi+1···σjofw, use w[i] to denote the letter σi, and use w[i,∞] to denote the infinite suffix
σi·σi+1···ofw. We also consider languages R⊆Σ∗of finite words, denote the empty word by ϵ,
and denote the set of nonempty words over Σ by Σ+; thus Σ+= Σ∗\ {ϵ}. For a set S, we denote
its complement by S. In particular, for languages R⊆Σ∗andL⊆Σω, we have R= Σ∗\Rand
L= Σω\L.
Anondeterministic automaton is a tuple A=⟨Σ, Q, Q 0, δ, α⟩, where Σ is an alphabet, Qis a finite
set of states ,Q0is a set of initial states ,δ:Q×Σ→2Q\ ∅is atransition function , and αis an
acceptance condition , to be defined below. For states qandsand a letter σ∈Σ, we say that sis
aσ-successor ofqifs∈δ(q, σ). Note that the transition function of Ais total, thus for all states
q∈Qand letters σ∈Σ,qhas at least one σ-successor. If |Q0|= 1 and every state qhas a single
σ-successor, for all letters σ, then Aisdeterministic . The transition function δcan be viewed as a
transition relation ∆ ⊆Q×Σ×Q, where for every two states q, s∈Qand letter σ∈Σ, we have
2Our result implies that checking language-equivalence between states in an SD-NWW can be done in PTIME,
as the check can be performed on the equivalent DWWs. We cannot, however, use this complexity result in our
algorithm, as this involves a circular dependency. Consequently, our construction of the equivalent DWWs involves a
language-approximation argument.
4that⟨q, σ, s⟩ ∈∆ iff s∈δ(q, σ). We define the sizeofA, denoted |A|, as its number of states, thus,
|A|=|Q|.
Given an input word w=σ1·σ2···, arunofAonwis a sequence of states r=r0, r1, r2, . . .,
such that r0∈Q0, and for all i≥0, we have that ri+1∈δ(ri, σi+1), i.e, the run starts in some
initial state and proceeds according to the transition function. If the word in the input is infinite,
then so is the run. We sometimes view the run r=r0, r1, r2, . . .onw=σ1·σ2···as a sequence
of successive transitions ⟨r0, σ1, r1⟩,⟨r1, σ2, r2⟩, . . .. Note that a deterministic automaton has a single
run on an input w. We sometimes extend δto sets of states and finite words. Then, δ: 2Q×Σ∗→2Q
is such that for every S∈2Q, finite word u∈Σ∗, and letter σ∈Σ, we have that δ(S, ϵ) =S,
δ(S, σ) =S
s∈Sδ(s, σ), and δ(S, u·σ) =δ(δ(S, u), σ). Thus, δ(S, u) is the set of states that Amay
reach when it reads ufrom some state in S.
The acceptance condition αdetermines which runs are “good”. For automata on finite words,
α⊆Q, and a run is accepting if it ends in a state in α. For automata on infinite words, we consider
state-based andtransition-based acceptance conditions. Let us start with state-based conditions. Here,
α⊆Q, and we use the terms α-states andα-states to refer to states in αand in Q\α, respectively.
For a run r∈Qω, let sinf(r)⊆Qbe the set of states that rvisits infinitely often. Thus, sinf(r) =
{q:q=rifor infinitely many i’s}. In B¨ uchi automata, risaccepting iffsinf(r)∩α̸=∅, thus if r
visits states in αinfinitely often. Dually, in co-B¨ uchi automata, risaccepting iffsinf(r)∩α=∅, thus
ifrvisits states in αonly finitely often.
We proceed to transition-based conditions. There, α⊆∆ and acceptance depends on the set of
transitions that are traversed infinitely often during the run. We use the terms α-transitions and
¯α-transitions to refer to transitions in αand in ∆ \α, respectively. For a run r∈∆ω, we define
tinf(r) ={⟨q, σ, s⟩ ∈∆ :q=ri, σ=σi+1,ands=ri+1,for infinitely many i’s}. As expected, in
transition-based B¨ uchi automata, ris accepting iff tinf(r)∩α̸=∅, and in transition-based co-B¨ uchi
automata, ris accepting iff tinf(r)∩α=∅.
Consider an automaton A=⟨Σ, Q, Q 0, δ, α⟩. In all automata classes, a run of Athat is not
accepting is rejecting . A word wis accepted by an automaton Aif there is an accepting run of Aon
w. The language of A, denoted L(A), is the set of words that Aaccepts.
Consider a directed graph G=⟨V, E⟩. A strongly connected set inG(SCS, for short) is a set
C⊆Vsuch that for every two vertices v, v′∈C, there is a path from vtov′. An SCS is maximal
if for every non-empty set C′⊆V\C, it holds that C∪C′is not an SCS. The maximal strongly
connected sets are also termed strongly connected components (SCCs, for short). An automaton
A=⟨Σ, Q, Q 0, δ, α⟩induces a directed graph GA=⟨Q, E⟩, where ⟨q, q′⟩ ∈Eiff there is a letter σ∈Σ
such that ⟨q, σ, q′⟩ ∈∆. The SCSs and SCCs of Aare those of GA.
An automaton A=⟨Σ, Q, Q 0, δ, α⟩with a state-based acceptance condition α⊆Qisweak [33] if
for each SCC CofA, either C⊆αin which case Cisaccepting , orC∩α=∅in which case Cis
rejecting . We view Aas a B¨ uchi automaton, yet note that a weak automaton can be viewed as both
a B¨ uchi and a co-B¨ uchi automaton. Indeed, a run of Avisits αinfinitely often iff it gets trapped in
an SCC that is contained in αiff it visits states in Q\αonly finitely often. Note also that when
Auses a transition-based acceptance condition, we can ignore the membership in αof transitions
between SCCs (indeed, such transitions are traversed only finitely often), and say that Ais weak if
the transitions in each SCC are all in αor all disjoint from α.
Consider two automata A1andA2. We say that A1iscontained in A2ifL(A1)⊆L(A2). Then, A1
andA2areequivalent ifL(A1) =L(A2), and A1isuniversal ifL(A1) = Σω(orL(A1) = Σ∗, in case
it runs on finite words). Finally, A1isminimal (with respect to a class of automata, say state-based
deterministic B¨ uchi automata) if for all automata A2equivalent to A1, we have that |A1| ≤ |A 2|.
52.2 SD and HD Automata
Consider an automaton A=⟨Σ, Q, Q 0, δ, α⟩. For a state q∈QofA, we define Aq=⟨Σ, Q,{q}, δ, α⟩,
as the automaton obtained from Aby setting the set of initial states to be {q}. We say that two
states q, s∈Qareequivalent , denoted q∼As, ifL(Aq) =L(As). We say that qis reachable if there
is a finite word x∈Σ∗with q∈δ(Q0, x), and say that qis reachable from sifqis reachable in
As. We say that Aissemantically deterministic (SD, for short) if different nondeterministic choices
lead to equivalent states. Thus, all initial states are equivalent, and for every state q∈Qand letter
σ∈Σ, all the σ-successors of qare equivalent. Formally, if s, s′∈δ(q, σ), then s∼As′. The following
proposition, termed the SDness property , follows immediately from the definitions and implies that
in SD automata, for all finite words x, all the states in δ(Q0, x) are equivalent. Intuitively, it means
that a run of an SD automaton can take also bad nondeterministic choices, as long as it does so only
finitely many times.
Proposition 2.1. Consider an SD automaton A=⟨Σ, Q, Q 0, δ, α⟩, and states q, s∈Q. Ifq∼As,
then for every σ∈Σ,q′∈δ(q, σ), and s′∈δ(s, σ), we have that q′∼As′.
A nondeterministic automaton Aishistory deterministic (HD, for short) if its nondeterminism can
be resolved based on the past, thus on the prefix of the input word read so far. Formally, AisHDif
there exists a strategy f: Σ∗→Qsuch that the following hold:
1. The strategy fis consistent with the transition function. That is, f(ϵ)∈Q0, and for every finite
word u∈Σ∗and letter σ∈Σ, we have that f(u·σ)∈δ(f(u), σ).
2. Following fcauses Ato accept all the words in its language. That is, for every word w=
σ1·σ2···, ifw∈L(A), then the run f(ϵ), f(w[1,1]),f(w[1,2]), . . .is an accepting run of Aon
w.
We say that the strategy fwitnesses A’s HDness. Note that, by definition, we can assume that every
SD and HD automaton Ahas a single initial state. Thus, we sometimes abuse notation and write A
asA=⟨Σ, Q, q 0, δ, α⟩, where q0is the single initial state of the SD (or HD) automaton A.
For an automaton A, we say that a state qofAisHD, ifAqis HD. Note that every deterministic
automaton is HD. Also, while not all HD automata can be pruned to deterministic ones [6], removing
of transitions that are not used by a strategy fthat witnesses A’s HDness does not reduce the
language of Aand results in an SD automaton. Moreover, since every state that is used by fis HD,
the removal of non-HD states does not affect A’s language nor its HDness. Accordingly, we have the
following [19, 4].
Proposition 2.2. Every HD automaton Acan be pruned to an equivalent SD automaton all whose
states are HD.
We use three-letter acronyms in {D,N} × { B,C,W,F} × { W}to denote the different automata
classes. The first letter stands for the branching mode of the automaton (deterministic or nondeter-
ministic); the second for the acceptance condition type (B¨ uchi, co-B¨ uchi, weak, or an automaton that
runs on finite inputs); and the third indicates that we consider automata on words. For transition-
based automata, we start the acronyms with the letter “t”, and for HD or SD automata, we add an
HD or SD prefix, respectively. For example, an HD-tNBW is a transition-based HD nondeterministic
B¨ uchi automaton, and an SD-NWW is a state-based weak SD automaton.
3 Semantically Deterministic B¨ uchi Automata
In this section we examine SD-tNBWs and SD-NBWs. Our results use the following definitions and
constructions: For a language R⊆Σ∗of finite words, we use ∞Rto denote the language of infinite
6words that contain infinitely many disjoint infixes in R. Thus, w∈ ∞Riffϵ∈Ror there are infinitely
many indices i1≤i′
1< i2≤i′
2<···such that w[ij, i′
j]∈R, for all j≥1. For example, taking
Σ ={a, b}, we have that ∞{ab}is the language of words with infinitely many abinfixes, namely all
words with infinitely many a’s and infinitely many b’s. We say that a finite word x∈Σ∗is agood
prefix for a language R⊆Σ∗if for all finite words y∈Σ∗, we have that x·y∈R. For example, while
the language ( a+b)∗·adoes not have a good prefix, the word ais a good prefix for the language
a·(a+b)∗.
Theorem 3.1 below states that one can translate an NFW that recognizes a language R⊆Σ∗to
an SD-tNBW for ∞R. Theorem 3.2 is more complicated and suggests that this translation can be
viewed as a reversible encoding, in the sense that one can obtain an NFW for Rfrom an SD-tNBW
for∞($·R·$), where $ /∈Σ. The translations involve no blow up, and both theorems play a major
rule in the rest of this section.
Theorem 3.1. Given an NFW N, one can obtain, in polynomial time, an SD-tNBW Asuch that
L(A) =∞L(N)and|A|=|N|.
Proof. LetN=⟨Σ, Q, Q 0, δ, F⟩. Then, A=⟨Σ, Q, Q 0, δ′, α⟩is obtained from Nby adding transitions
toQ0from all states with all letters. A new σ-transition is in αifQ0∩F̸=∅or when Ncould transit
with σto a state in F. Formally, for all s∈Qandσ∈Σ, we have that δ′(s, σ) =δ(s, σ)∪Q0, and
α={⟨s, σ, q⟩:q∈Q0and ( Q0∩F̸=∅orδ(s, σ)∩F̸=∅)}.
It is easy to see that |A|=|N|. In order to prove that Ais SD and L(A) =∞L(N), we prove
next that for every state q∈Q, it holds that L(Aq) =∞L(N). We distinguish between two cases.
First, if Q0∩F̸=∅, then ϵ∈L(N), in which case ∞L(N) = Σω. Indeed, every word in Σωhas
infinitely many empty infixes. Recall that when Q0∩F̸=∅, the tNBW Ahas Σ-labeled αtransitions
from every state to Q0. Then, the run q,(q0)ω, where q0∈Q0, is an accepting run of Aqon any word
w∈Σω. So, L(Aq) = Σω=∞L(N), and we are done.
Now, if Q0∩F=∅, we first prove that for every state q∈Q, we have that ∞L(N)⊆L(Aq).
Consider a word w∈ ∞L(N), and consider a run of Aqonwthat upon reading an infix σ1·u·σ2such
that u·σ2∈L(Nq0)⊆L(N), for some q0∈Q0, moves to q0while reading the letter σ1, and then
follows an accepting run of Nonu·σ2except that, upon reading the letter σ2, it moves to a state in
Q0, traversing an αtransition, instead of traversing a transition to F. Note that the transitions in A
enable such a behavior. Also note that ∞L(N)⊆ ∞Σ·L(N), and so such a run traverses αinfinitely
often and is thus accepting.
It is left to prove that L(Aq)⊆ ∞L(N) for every state q∈Q. Let r=r0, r1, . . .be an accepting
run of Aqon a word w=σ1·σ2···. We show that w∈ ∞L(N). For that, we show that for every
i≥0, there are k1, k2such that i≤k1≤k2andw[k1+ 1, k2+ 1] is an infix of winL(N). Being
accepting, the run rtraverses infinitely many α-transitions. Given i≥0, let k2≥ibe such that
t=⟨rk2, σk2+1, rk2+1⟩is an α-transition, but not the first α-transition that rtraverses when it reads
the suffix w[i+ 1,∞], and let k1be the maximal index such that i≤k1≤k2andrk1∈Q0. Since tis
not the first α-transition that rtraverses when it reads the suffix w[i+ 1,∞], and since α-transitions
lead to Q0, then k1exists. Note that the maximality of k1imply that the run rk1, rk1+1, . . . , r k2is a
run of Non the infix w[k1+ 1, k2]. Now, as ⟨rk2, σk2+1, rk2+1⟩ ∈αandQ0∩F=∅, it follows by the
definition of δ′that there is a state s∈δ(rk2, σk2+1)∩F. Hence, rk1, rk1+1, . . . , r k2, sis an accepting
run of Non the infix w[k1+ 1, k2+ 1], which is thus in L(N).
We proceed to the other direction, translating an automaton for ∞($·R·$) to an automaton
forR. Note that the language Ris well defined. That is, if R1⊆Σ∗andR2⊆Σ∗are such that
∞($·R1·$) =∞($·R2·$), then it must be that R1=R2.
Theorem 3.2. Consider a language R⊆Σ∗and a letter $/∈Σ. For every SD-tNBW Asuch that
L(A) =∞($·R·$), there exists an NFW Nsuch that L(N) =Rand|N| ≤ |A| + 1. In addition, if
Rhas no good prefixes, then |N| ≤ |A| .
7Proof. IfRis trivial, then one can choose Nto be a one-state NFW. Assume that Ris nontrivial.
LetA=⟨Σ∪ {$}, Q, q 0, δ, α⟩be an SD-tNBW for ∞($·R·$), W.l.o.g we assume that all the states
ofAare reachable. For a nonempty set of states S∈2Q\ ∅, we define the universal αlanguage ofS
asLuα(S) ={w∈(Σ∪{$})ω: for all q∈S, all the runs of Aqonwdo not traverse α}. We say that
Sishopeful when ($ ·R)ω⊆Luα. Note that Sis hopeful iff for every state q∈S, it holds that {q}is
hopeful. Also, if Sis hopeful, x∈Σ∗is a finite word, and there is a run from Son $·xthat traverses
α, then x∈R. Then, we say that Sisgood when for all words x∈Σ∗, it holds that x∈Riff all the
runs from Son $·xdo not traverse α, and the set δ(S,$·x) is hopeful. Note that as Ris nontrivial,
there exists a word xinR, and thus by definition, all the $-labled transitions going out from a good
setSare in α.
Note that good sets in Acharacterize the language R. We first show that a good set exists. Assume
towards contradiction that every nonempty set S∈2Q\∅is not good. We define iteratively a sequence
S1, S2, S3, . . .of nonempty sets in 2Q, and a sequence x1, x2, x3, . . .of finite words in (Σ ∪ {$})+, as
follows. The set S1is chosen arbitrarily. For all i≥1, given the set Si, we define xiandSi+1as
follows. By the assumption, Siis not good. Therefore at least one of the following holds:
(a) There is a witness in RthatSiis not good: there is a word ai∈Rsuch that all the runs from
Sion $·aido not traverse α, and the set δ(Si,$·ai) is hopeful.
(b) There is a witness in RthatSiis not good: there is a word bi∈Rsuch that there is a run from
Sion $·bithat traverses α, or the set δ(Si,$·bi) is not hopeful.
If there is a witness ai∈Rthat Siis not good, we take xi= $·aiandSi+1=δ(Si, xi). Otherwise,
there is a witness bi∈RthatSiis not good. Then, as we argure below, there exists a word zi∈($·R)+,
and there is a run rifrom Sionzithat traverses α. In this case, we take Si+1to be the set that
contains only the state that riends in, and we take xi=zi. To see why such ziexists, we distinguish
between two cases. First, if there is a run from Sion $·bithat traverses α, then we take zi= $·bi.
Otherwise, the set δ(Si,$·bi) is not hopeful. Therefore, it contains a state qthat has a run that
traverses αon a word in ($ ·R)ω. The latter implies that there is a word z′∈($·R)+such that there
is a finite run r′ofqonz′that traverses α. Then, since qis reachable from Siupon reading $ ·bi,
we take zi= $·bi·z′. Indeed, a run rifrom Sionzi= $·bi·z′that traverses α, starts from Siand
reaches qupon reading $ ·bi, and then follows the run r′upon reading z′.
So, let S1, S2, S3. . .andx1, x2, x3, . . .be sequences as above. We distinguish between three cases:
1. There exists i≥1 such that for all j≥i, there is a witness aj∈RthatSjis not good: consider
j≥i. In this case, xj= $·aj∈$·R,Sj+1=δ(Sj, xj), and all the runs of Sjonxjdo not
traverse α. Hence, all the runs from Sion the word w=xi·xi+1·xi+2··· ∈ ($·R)ωdo not
traverse α, in particular, if we consider a state q∈Si, we get that the word wis not accepted
from q. As all the states of Aare reachable, there is a word y∈(Σ∪{$})∗such that q∈δ(q0, y).
Then, the SDness property of Aimplies that all the states in δ(q0, y) do not accept w, and hence
the word y·wis not accepted by Aeven though it has infinitely many infixes in $ ·R·$, and
we have reached a contradiction.
2. There exists i≥1 such that for all j≥i, no word in Rwitnesses that Sjis not good: consider
j≥i. In this case, as argued above, there is a witness bj∈Rthat Sjis not good. So,
xj=zj∈($·R)+, and there is a run rjfrom Sjonzjthat traverses αand ends in a state
sj+1, where Sj+1={sj+1}. The concatenation of the runs ri, ri+1, . . .is an accepting run of
Aq, for some q∈Si, on the word zi·zi+1·zi+2··· ∈ ($·R)ω. Let y∈(Σ∪ {$})∗be such that
q∈δ(q0, y); then the word w=y·zi·zi+1·zi+2···is accepted by Aeven though it has only
finitely many infixes in $ ·R·$, and we have reached a contradiction.
3. If the above two cases do not hold, then there are infinitely many indices i≥1 such that no
word in Rwitnesses that Siis not good, and there are infinitely many indices i≥1 such that
8there is a witness in RthatSiis not good. Therefore, there must be i≥1 such that there is a
witness ai∈Rthat Siis not good, and no word in Rwitnesses that Si+1is not good. On the
one hand, the set Si+1=δ(Si,$·ai) is hopeful. On the other hand, the fact that no word in R
witnesses that Si+1is not good, implies that there is a witness bi+1∈RthatSi+1is not good,
and thus there is a run from Si+1that traverses αon the word xi+1=zi+1∈($·R)+. Thus,
we have reached a contradiction to the fact that Si+1is hopeful.
We show now that a good set in Ainduces an NFW NforRwith the required properties. Let
S∈2Q\ ∅be a good set. We define the NFW N=⟨Σ, Q∪ {qacc}, QS
0, δS, FS⟩, where QS
0=δ(S,$),
FS={qacc}∪{q∈Q: the set {q}is not hopeful }, and the transition function δSis defined as follows.
For every two states q, s∈Qand letter σ∈Σ, it holds that s∈δS(q, σ) iff⟨q, σ, s⟩ ∈α. Also,
qacc∈δS(q, σ) iff there is a σ-labeled α-transition going out from qinA. Also, for all letters σ∈Σ,
it holds that δ(qacc, σ) ={qacc}; that is, qaccis an accepting sink. Thus, Nbehaves as the states in
δ(S,$) as long as it reads αtransitions of A, moves to the accepting sink qaccwhenever an α-transition
is encountered, and accepts also whenever it reaches a state in Qthat is not hopeful.
We prove next that L(N) =R. We first prove that L(N)⊆R. Consider a word x=σ1·σ2···σn∈
L(N). If there is a state q∈δ(S,$) such that Aqhas a run on xthat traverses α, then as Sis good,
we get that x∈R. Otherwise, for all states q∈δ(S,$), it holds that all the runs of Aqonxdo not
traverse α. Let r=r0, r1, . . . r nbe an accepting run of Nonx. By the definition of N, we have
that r0∈δ(S,$); in particular, all the runs of Ar0onxdo not traverse α. Hence, since rfollows a
run of Ar0as long it does not visit qacc, and since rvisits qacconly when it follows a run of Ar0that
traverses α, we get that the run rexists in A. Hence, rn∈Qand as ris an accepting run of N, we
get that the set {rn}is not hopeful. The fact that rexists in Aimplies also that rn∈δ(S,$·x), and
soδ(S,$·x) is not hopeful. Hence, as Sis a good set, we conclude that x∈R.
For the other direction, namely R⊆L(N), consider a word x∈R. If there is a state q∈δ(S,$)
and a run rofAqonxthat traverses α, then an accepting run r′ofNonxcan be obtained by
following the run r, and moving to the accepting sink qaccwhen rtraverses αfor the first time. Indeed,
q∈QS
0,αtransitions of Aexist in N, andNmoves to qaccwhenever Atraverses α. Otherwise, for all
q∈δ(S,$), it holds that all the runs of Aqonxdo not traverse α. Also, recall that all the $-labeled
transitions from a good set are in α. Hence, all the runs from Son $·xdo not traverse α. In this
case, as Sis a good set, and x∈R, it follows that δ(S,$·x) is not hopeful. Therefore, there is a state
s∈δ(S,$·x) such that {s}is not hopeful. Hence, by the definition of N, it holds that s∈FS. Hence,
a run in Afrom δ(S,$) that reaches supon reading xand does not traverse α, is an accepting run of
Nonx, and we are done.
Since the state space of NisQ∪{qacc}, then |N|=|A|+ 1. Moreover, as qaccis an accepting sink,
a word x∈L(N) that has a run that ends in qaccis a good prefix for L(N). Hence, as L(N) =R,
ifRhas no good prefixes, then qaccis not reachable in Nand thus can be removed without affecting
N’s language. Thus, in this case, we get an NFW NforRwhose size is at most |A|.
3.1 Succinctness and Complementation
In this section we study the succinctness of SD B¨ uchi automata with respect to deterministic ones,
and the blow-up involved in their complementation. We show that SD-tNBWs are exponentially more
succinct than tDBWs, matching the known upper bound [2], and in fact, also from HD-tNBWs. We
also prove an exponential lower bound for complementation. Similar results for SD-NBWs follow, as
the transition between the two types of acceptance conditions is linear.
Theorem 3.3. There is a family L1, L2, L3, . . .of languages such that for every n≥1, there is an
SD-tNBW with 3n+ 3states that recognizes Ln, yet every tDBW or HD-tNBW that recognizes Ln
needs at least 2nstates.
9Proof. Forn≥1, let [ n] ={1, . . . , n }, and let Σ n={1, . . . , n, $,#}. We say that a word z∈Σ∗
nis
good ifz= $·x·#·i, where x∈[n]+andiappears in x. Let Rn⊆Σ∗
nbe the language of all good
words. We define Ln=∞Rn. First, it is not hard to see that Rncan be recognized by an NFW Nn
with 3 n+ 3 states. Essentially, Nnguesses the last letter iin the input word and then checks that the
guess is correct. A sketch of Nnappears in Figure 1 below. By Theorem 3.1, there is an SD-tNBW
forLnwith 3 n+ 3 states.
Figure 1: The NFW Nn. Missing transitions lead to a rejecting-sink
Before we prove that every tDBW or HD-tNBW that recognizes Lnneeds at least 2nstates,
let us note that it is already known that going from a DFW for a language R⊆Σ∗to a tDBW
for∞R, may involve a blow-up of 2n−2−log2(n)[23]. Thus, Theorem 3.1 implies an exponential gap
between SD-tNBWs and tDBWs. Moreover, as HD-tNBWs are at most quadratically more succinct
than tDBWs [19], the above can be extended to a 2n−2−log2(n)
2 lower bound for the succinctness of
SD-tNBWs with respect to HD-tNBWs. Our example here is tighter.
We now prove that every HD-tNBW that recognizes Lnneeds at least 2nstates. Assume towards
contradiction that A=⟨Σn, Q, q 0, δ, α⟩is an HD-tNBW for Lnwith|Q|<2nstates. Below, we
iteratively define infinite sequences of finite words x1, x2, x3, . . .and states q0, q1, . . .such that for all
k≥1, the word xkstarts with $, has no good infixes, and there is a run of the form rk=qk−1xk− →qkin
Aonxkthat traverses α. To see why such sequences imply a contradiction, note that the concatenation
of the runs r1, r2, . . .is an accepting run of Aon the word x=x1·x2···. AsArecognizes Ln=∞Rn,
it follows that x∈ ∞Rn. On the other hand, xhas no good infixes, and so x /∈ ∞Rn. Indeed, if there
is a good infix in x, then it must contain letters from different xk’s; in particular, it must contain at
least two $’s.
We proceed by describing how, given x1, x2, . . . , x k−1andq0, q1, . . . , q k−1, we define xkandqk.
The challenging part in the construction is to make it valid also for HD (and not only deterministic)
automata. For this, the definition of the words in the sequence is defined with respect to a strategy
that attempts to witness the HDness of A. First, recall that by Proposition 2.2, we can assume that
Ais SD and all its state are HD. Also, note that q0x1− →q1x2− →q2···xk−1− − − → qk−1is a run in A; in
particular, qk−1is reachable in A. Hence, L(A)⊆L(Aqk−1). Indeed, if yis a word in L(A) =∞Rn,
then x1·x2···xk−1·y∈ ∞Rn, and so the SDness of Aimplies that all the states in δ(q0, x1·x2···xk−1);
in particular qk−1, accept y. We abuse notation and use S, for a subset S⊆[n], to denote a finite
word over [ n] consisting of exactly the numbers appearing in S. We can now define xkandqk. Fix
u0, d0=qk−1, and let fbe a strategy witnessing Aqk−1’s HDness. We define inductively two infinite
10runs ruandrdon distinct words, and of the form
ru=u0$·2[n]
− − − → p0#·[n]− − − → u1$·2[n]
− − − → p1#·[n]− − − → u2$·2[n]
− − − → ···
rd=d0$·2[n]
− − − → p0#·[n]− − − → d1$·2[n]
− − − → p1#·[n]− − − → d2$·2[n]
− − − → ···
Thus, while the states uianddiare not necessarily equal, the runs meet infinitely often at the states
piupon reading infixes of the form $ ·2[n]. When we define the runs, we make sure that both are
runs of Aqk−1that are consistent with the strategy f. Consider j≥0, and assume that we have
defined the following sub-runs u0zj
u− →ujandd0zj
d− →djthat are consistent with the strategy f. A
finite run rof the state ujon a word z=z1·z2···znisconsistent if it is of the form the form
r=f(zj
u), f(zj
u·z1), . . . , f (zj
uzn); that is, ris consistent with the strategy fw.r.t the prefix zj
u.
Similarly, we consider runs of djthat are consistent with the strategy fw.r.t the prefix zj
d. As
|Q|<2n, there are subsets Sj+1, Tj+1⊆[n] with ij+1∈Sj+1\Tj+1such that
((uj$·Sj+1− − − − → pj#·ij+1− − − − → uj+1) and ( dj$·Tj+1− − − − → pj#·ij+1− − − − → dj+1))
or
((uj$·Tj+1− − − − → pj#·ij+1− − − − → uj+1) and ( dj$·Sj+1− − − − → pj#·ij+1− − − − → dj+1))
where the runs are consistent. Indeed, if we consider all consistent runs of ujon words of the form
$·2[n]and all consistent runs of djon words of the form $ ·2[n], we get that there are two runs, of
ujand of dj, corresponding to distinct subsets of [ n], that reach the same state pj. So far, we have
defined two infinite runs of Aqk−1that are consistent with the strategy f:
ru=u0$·U1− − − → p0#·i1− − − → u1$·U2− − − → p1#·i2− − − → u2$·U3− − − → ···
rd=d0$·D1− − − → p0#·i1− − − → d1$·D2− − − → p1#·i2− − − → d2$·D3− − − → ···
where for all j≥1,ij∈(Uj\Dj)∪(Dj\Uj). In particular, exactly one of $ ·Uj·#·ijand
$·Dj·#·ijis good. Therefore, at least one of the runs ruandrdruns on a word in ∞Rn. Since both
runs are consistent with the strategy fand∞Rn⊆L(Aqk−1), we get that one of the runs traverses
αinfinitely often. W.l.o.g consider some j >0 such that the sub-run pj#ij+1− − − − → uj+1$·Uj+2− − − − → pj+1
traverses α. We define
xk= ($·A1·#·i1)·($·A2·#·i2)···($·Aj·#·ij)·($·Aj+1·#·ij+1)·$·Uj+2
where for all 1 ≤l≤j+ 1, it holds that Al∈ {Ul, Dl}andil/∈Al. In particular, xkstarts with $
and has no good infixes. To conclude the proof, we show that there is a run rkofAqk−1onxkthat
traverses an α-transition (in particular, we can choose qkto be the last state that rkvisits). The run
rkcan obtained from the runs ruandrdas follows. First, rkstarts by following one of the sub-runs
u0$·U1− − − → p0ord0$·D1− − − → p0, depending on whether A1=U1orA1=D1, respectively. Then, if the
runrkis in a state of the form pm, for m < j , the run rkproceeds, upon reading # ·im+1, to one
of the states um+1ordm+1, depending on whether the next two letters to be read are $ ·Um+2or
$·Dm+2, respectively. Finally, once rkreaches pj, it ends by traversing αwhile following the sub-run
pj#ij+1− − − − → uj+1$·Uj+2− − − − → pj+1.
Remark 3.1. In order to get a slightly tighter bound, one can show that a minimal tDBW for Ln
needs at least 2n+1states and that the language Lnis not HD-helpful . That is, a minimal HD-tNBW
forLnis not smaller than a minimal tDBW for Ln, and so the 2n+1bound holds also for a minimal
11HD-tNBW. The proof starts with a tDBW for Lnthat has 2n+1states, considers its complement
tDCW, and shows that the application of the polynomial minimization algorithm of [1] on it, namely
the algorithm that returns an equivalent minimal HD-tNCW, does result in a smaller automaton. The
result then follows from the fact that a minimal HD-tNCW for a language is smaller than a minimal
HD-tNBW for its complement [19]. The proof is easy for readers familiar with [1], yet involves many
notions and observations from there. We thus leave it for the appendix. Specifically, in Appendix A.1,
we describe a tDBW with 2n+1states for Ln, and readers familiar with [1] can observe that the
application of the HD-tNCW minimization algorithm on its dual tDCW does not make it smaller.
Theorem 3.4. There is a family L1, L2, L3, . . .of languages such that for every n≥1, there is an
SD-tNBW with O(n)states that recognizes Ln, yet every SD-tNCW that recognizes Lnneeds at least
2O(n)states.
Proof. Let Σ = {0,1}. For n≥1, let Rn={w:w∈0·(0 + 1)n−1·1 + 1·(0 + 1)n−1·0}. Thus, Rn
contains all words of length n+1 whose first and last letters are different. It is easy to see that Rncan
be recognized by an NFW (in fact, a DFW) Nnwith O(n) states. We define Ln=∞Rn. First, by
Theorem 3.1, there is an SD-tNBW with O(n) states for Ln. In order to prove that an SD-tNCW for
Lnneeds at least 2O(n)states, we prove that in fact every tNCW for Lnneeds that many states. For
this, note that Lnconsists of all words wfor which there is u∈(0 + 1)nsuch that w∈(0 + 1)∗·uω.
Indeed, for such words w, the suffix uωcontains no infix in Rn. Also, if a word contains only finitely
many infixes in Rn, then it must have a suffix with no infixes in Rn, namely a suffix of the form uωfor
some u∈(0 + 1)n. Then, the proof that a tNCW for Lnneeds exponentially many states is similar
to the proof that an NFW for {u·u:u∈(0 + 1)n}needs exponentially many states. Indeed, it has
to remember the last nletters read.
3.2 Decision Problems
We continue to decision problems about SD-tNBWs and SD-NBWs, and show that the exponential
succinctness comes with a price: the complexity of all the problems we study coincides with the one
known for tNBWs and NBWs. Accordingly, we only prove lower bounds for SD-tNBWs. Matching
upper bounds follow from the known complexity for tNBWs, and same bounds for SD-NBWs follow
from linear translations between SD-tNBWs and SD-NBWs. The problems we study are language
containment: given two SD-tNBWs A1andA2, decide whether L(A1)⊆L(A2),universality: given
an SD-tNBW A1, decide whether L(A1) = Σω, and minimization: given an SD-tNBW A1and an
integer k≥1, decide whether there is an SD-tNBW A2such that L(A1) =L(A2) and |A2| ≤k.
The exponential succinctness of SD automata motivates also the study of the D-to-SD minimization
problem . Here, we are given a tDBW A1and an integer k≥1, and we need to decide whether there is
an SD-tNBW A2such that L(A1) =L(A2) and |A2| ≤k. For automata on finite words, the D-to-N
minimization problem is known to be PSPACE-complete [18].
Note that a lower bound for universality implies a lower bound also for language containment. We
still start with language containment, as it is much simpler.
Theorem 3.5. The language-containment problem for SD-tNBWs is PSPACE-hard.
Proof. We describe a reduction from the universality problem for NFWs. Given an NFW Nover Σ,
letN′be an NFW over Σ ∪ {$}such that L(N′) = $·L(N)·$. Now, let A1be a 1-state tDBW over
Σ∪{$}such that L(A1) =∞$, and let A2be the SD-tNBW obtained by applying the operation from
Theorem 3.1 on N′. Note that L(A2) =∞($·L(N)·$) and |A2|=|N|+ 3.
We claim that Nis universal iff L(A1)⊆L(A2). First, if L(N) = Σ∗, then L(A2) =∞($·Σ∗·$) =
∞$ and so L(A1)⊆L(A2). Conversely, if there is a word x∈Σ∗\L(N), then the word w= ($·x)ω
is in L(A1)\L(A2). Indeed, whas infinitely many $’s, yet for every infix $ ·y·$ ofw, we have that
y̸∈L(N), and so w̸∈L(A2).
12The proof in Theorem 3.5 uses ∞$ as the “contained language”. For the universality problem, we
cannot relay on hints from words in the contained language. In particular, taking the union of A2
there with an automaton for “only finitely many $’s” results in an automaton that is not SD, and it
is not clear how to make it SD. Consequently, we have to work much harder. Specifically, we prove
PSPACE hardness by a generic reduction from polynomial space Turing machines. Such reductions
associate with a Turing machine Tan automaton Athat recognizes the language Rof words that
do not encode legal rejecting computations of T, and so R= Σ∗iff the machine has no rejecting
computations. The automaton Ais nondeterministic, as it has to guess violations of attempts to
encode legal accepting computations. In order to replace Aby an SD automaton, we manipulate the
Turing machine so that the language of the generated automaton is of the form ∞R, for which we
can construct an SD-tNBW.
Theorem 3.6. The universality problem for SD-tNBWs is PSPACE-hard.
Proof. We do a reduction from polynomial-space Turing machines. Given a Turing machine Twith
space complexity s:N→N, we construct in time polynomial in |T|ands(0), an SD-tNBW Aof size
polynomial in Tands(0), such that Ais universal iff Taccepts the empty tape3. Let n0=s(0). Thus,
each configuration in the computation of Ton the empty tape uses at most n0cells. We assume that
Thalts from all configurations (that is, not just from these reachable from an initial configuration of
T); Indeed, by adding a polynomial-space counter to T, one can transform a polynomial-space Turing
machine that need not halt from all configurations to one that does halt. We also assume, without loss
of generality, that once Treaches a final (accepting or rejecting) state, it erases the tape, moves with
its reading head to the leftmost cell, and moves to the initial state. Thus, all computations of Tare
infinite and after visiting a final configuration for the first time, they eventually consists of repeating
the same finite computation on the empty tape that uses at most n0tape cells.
We define Aso that it accepts a word wiff (C1) no suffix of wis an encoding of a legal computation
ofTthat uses at most n0tape cells, or (C2) whas infinitely many infixes that encode the accepting
state of T.
It is not hard to see that Taccepts the empty tape iff Ais universal. Indeed, if Taccepts the empty
tape, and there is a word wthat does not satisfy (C1), thus whas a suffix that is an encoding of a
legal computation of Tthat uses at most n0cells, then the encoded computation eventually reaches
a final configuration, from which it eventually repeats the accepting computation of Ton the empty
tape infinitely many times, and so wsatisfies (C2). Conversely, If Trejects the empty tape, then the
word wthat encodes the computation of Ton the empty tape does not satisfy (C1) nor (C2), and so
Adoes not accept w.
Finally, the fact that Tis a polynomial-space Turing machine enables us to define Awith polyno-
mially many states, as we detail next. Let T=⟨Γ, Q,→, q0, qacc, qrej⟩be a Turing machine with
polynomial space complexity s:N→N, where Γ is the tape-alphabet, Qis the set of states,
→⊆ Q×Γ×Q×Γ× {L, R}is the transition relation (we use ( q, a)→(q′, b,∆) to indicate that
when Tis in state qand it reads the input ain the current tape cell, it moves to state q′, writes bin
the current tape cell, and its reading head moves one cell to the left/right, according to ∆), q0is the
initial state, qaccis the accepting state, and qrejis the rejecting one.
We encode a configuration of Tthat uses at most n0=s(0) tape cells by a word of the form
#γ1γ2. . .(q, γi). . . γ n0. That is, the encoding of a configuration starts with a special letter #, and all
its other letters are in Γ, except for one letter in Q×Γ. The meaning of such a configuration is that
thej’th cell in T, for 1 ≤j≤n0, isγj-labeled, the head of Tpoints at i’th cell, and Tis in the state
3This is sufficient, as one can define a generic reduction from every language Lin PSPACE as follows. Let TLbe
a Turing machine that decides Lin polynomial space f(n). On input wfor the reduction, the reduction considers the
machine Twthat on every input, first erases the tape, writes won its tape, and then runs as TLonw. Then, the
reduction outputs an automaton A, such that Twaccepts the empty tape iff Ais SD. Note that the space complexity
ofTwiss(n) = max( n, f(|w|)), and that wis in LiffTwaccepts the empty tape. Since Ais constructed in time
polynomial in s(0) = f(|w|) and |Tw|= poly( |w|), it follows that the reduction is polynomial in |w|.
13q. For example, the initial configuration of Ton the empty tape is encoded as #( q0, b)b . . . b (with
n0−1 occurrences of b’s) where bstands for an empty cell. We can now encode a computation of T
as a sequence of configurations.
Let Σ = {#} ∪Γ∪(Q×Γ), and let # σ1. . . σ n0#σ′
1. . . σ′
n0be two successive configurations of T.
We also set σ0,σ′
0, and σn0+1to #. For each triple ⟨σi−1, σi, σi+1⟩with 1 ≤i≤n0, we know, by
the transition relation of T, what σ′
ishould be. In addition, the letter # should repeat exactly every
n0+ 1 letters. Let next(σi−1, σi, σi+1) denote our expectation for σ′
i. That is,
•next(σi−1, σi, σi+1) =σiifσi= #, or if non of σi−1, σiandσi+1are in Q×Γ.
•next((q, γi−1), γi, γi+1) =next((q, γi−1), γi,#) =
γi If (q, γi−1)→(q′, γ′
i−1, L)
(q′, γi) If ( q, γi−1)→(q′, γ′
i−1, R)
•next(γi−1, γi,(q, γi+1)) =next(#, γi,(q, γi+1)) =
γi If (q, γi+1)→(q′, γ′
i+1, R)
(q′, γi) If ( q, γi+1)→(q′, γ′
i+1, L)
•next(γi−1,(q, γi), γi+1) =next(γi−1,(q, γi),#) = next(#,(q, γi), γi+1) =γ′
iwhere ( q, γi)→
(q′, γ′
i,∆).4
Note that every word that encodes a legal computation of Tthat uses at most n0tape cells must be
consistent with next.
Consider now an infinite word w. Note that if wsatisfies (C1), then whas infinitely many infixes
that witness a violation of the encoding of a legal computation of Tthat uses at most n0tape cells.
Accordingly, we can write the language of Aas∞R, where Ris the language of one-letter words of
the form ( qacc, γ), or words that describe a violation of a legal computation that uses at most n0cells.
Words that describe a violation, either are words of length n0+ 1 that describe a violation of the
encoding of a single configuration, or are words of length n0+ 3 that describe a violation next.
We can now define an NFW NforRof size polynomial in Tandn0, and thus the required SD-
tNBW Acan be obtained from Nby applying the construction described in Theorem 3.1. The NFW
Nis defined as follows. From its initial states, Nguesses to check whether the input word is a single-
letter word of the form ( qacc, γ), or guesses to check whether the input is a violation of the encoding
of a legal computation of Tthat uses at most n0tape cells: this amounts to guessing that the input
is a word of length n0+ 1 that has no #’s, or starts with #, yet does not encode a legal configuration,
or amounts to guessing that the input is a word of length n0+ 3 that describes a violation of next,
where Nchecks whether the input start with three letters σ1, σ2, σ3describing three successive letters
in the encoding and ends with a letter σ′
2, which comes n0+ 1 letters after σ2in the encoding, yet is
different than next(σ1, σ2, σ3).
We continue to the minimization problem. Note that here, a PSPACE upper bound does not
follow immediately from the known PSPACE upper bound for tNBWs, as the candidate automata
need to be SD. Still, as SDness can be checked in PSPACE [2], a PSPACE upper bound follows.
Also note that here, the case of SD-NBWs is easy, as a non-empty SD-NBW is universal iff it has
an equivalent SD-NBW with one state. For transition-based acceptance, the language of a single-
state SD-tNBW need not be trivial, and so we have to examine the specific language used for the
universality PSPACE-hardness proof:
4We note that in the case where the head of Tis at leaft most cell, and Tmoves its head to the left should be
handeled slightly differently, as we assume that the tape of Tis left bounded.
14Theorem 3.7. The minimization problem for SD-tNBWs is PSPACE-hard.
Proof. We argue that the SD-tNBW Ain the proof of Theorem 3.6 has an equivalent one-state SD-
tNBW iff Ais universal. To see why, assume towards contradiction that Trejects the empty tape
and there is a one-state SD-tNBW Dequivalent to A. Recall that we encode computations of Tas a
sequence of successive configurations of length n0each, separated by the letter #. On the one hand,
as the word #ωhas infinitely many violations, then it is in L(A), and so the #-labeled self-loop at
the state of Dmust be an α-transition. On the other hand, the word wthat encodes the computation
ofTon the empty tape is not in L(A), yet it has infinitely many #’s.
As we show below, the minimization problem stays hard even when we start from a deterministic
automaton:
Theorem 3.8. The D-to-SD minimization problem for B¨ uchi automata is PSPACE-hard.
Proof. We start with B¨ uchi automata with transition-based acceptance, and describe a reduction
from the D-to-N minimization problem for automata on finite words: given a DFW A1, and an
integer k≥1, decide whether there is an NFW A2such that L(A1) =L(A2) and |A2| ≤k. In [18],
the authors prove that the problem is PSPACE-hard, in fact PSPACE-hard already for DFWs that
recognize a language that has no good prefixes.
Consider a language R⊆Σ∗. The reduction is based on a construction that turns an NFW for R
into an SD-tNBW for ∞($·R·$), for a letter $ /∈Σ. Note that by applying the construction from
Theorem 3.1 on the language $ ·R·$, we can get an SD-tNBW for ∞($·R·$). The construction there,
however, does not preserve determinism. Therefore, we need a modified polynomial construction,
which takes advantage of the $’s. We describe the modified construction below.
Given an NFW A=⟨Σ, Q, Q 0, δ, F⟩, and a letter $ /∈Σ, we construct the tNBW A′=⟨Σ∪
{$}, Q, Q 0, δ′, α⟩, where for all states q∈Qand letters σ∈Σ, we have that δ′(q, σ) =δ(q, σ). Also,
δ′(q,$) = Q0, and α={⟨s,$, q⟩:q∈Q0ands∈F}. Thus, A′is obtained from Aby adding
$-transitions from all states to Q0. A new transition is in αiff its source is an accepting state of A.
It is not hard to see that the construction of A′preserves determinism. Indeed, if Ais deterministic,
then all the $-transitions in A′are deterministic since they are directed to the single initial state of
A. To show that A′is SD and L(A′) =∞($·L(A)·$), we prove below, similarly to Theorem 3.1,
that for all states q∈Q, it holds that L(A′q) =∞($·L(A)·$).
Consider a state q∈Q, we first show that L(A′q)⊆($·L(A)·$). Consider a word w∈L(A′q)
and let r=r0, r1, r2, . . .be an accepting run of A′qonw. We show that for every i≥1, there are
k1, k2such that i≤k1≤k2andw[k1, k2+ 1] is an infix of win $·L(A)·$. Given i≥1, let k2
be such that t=⟨rk2, w[k2+ 1], rk2+1⟩is an α-transition, but not the first $-transition that rreads
when it runs on the suffix w[i,∞], and let k1be the maximal index such that i≤k1≤k2and
⟨rk1−1, w[k1], rk1⟩=⟨rk1−1,$, rk1⟩. Since tis not the first $-transition that rtraverses when it reads
the suffix w[i,∞], then k1exists. Note that the fact that new transitions lead to Q0inA′, and the
maximality of k1, imply that the run rk1, rk1+1, . . . , r k2is a run of Aon the infix w[k1+1, k2]. Also, as
tis an αtransition, the latter run is an accepting run of A. Now, as the transitions ⟨rk1−1, w[k1], rk1⟩
andtare $-transitions, we get that rk1−1, rk1, . . . , r k2, rk2+1is a run on a word in $ ·L(A)·$. Thus,
w[k1, k2+ 1] is an infix of win $·L(A)·$.
Next, we show that ∞($·L(A)·$)⊆L(A′q). Consider a word w∈ ∞($·L(A)·$), and consider
a run of A′qonwthat upon reading an infix $ ·x·$ in $ ·L(Aq0)·$, for some q0∈Q0, moves to q0
while reading $, and then follows an accepting run of Aq0onx, and finally moves to a state in Q0,
traversing αwhile reading $. Note that the transitions in A′enable such a behavior. Thus, such a
run traverses αinfinitely often and is thus accepting.
We now describe the reduction. Given a DFW Aover Σ such that L(A) has no good prefixes, and
given an integer k, the reduction returns the polynomial tDBW A′and the integer k. We prove next
that the reduction is correct. Thus, the DFW Ahas an equivalent NFW with at most kstates iff
15the tDBW A′has an equivalent SD-tNBW with at most kstates. For the first direction, if Bis an
NFW equivalent to Awhose size is at most k, then by the above construction, it holds that B′is an
SD-tNBW whose size is at most k, and L(B′) =∞($·L(B)·$) =∞($·L(A)·$) = L(A′).
Conversely, if B′is an SD-tNBW for ∞($·L(A)·$) whose size is at most k, then as L(A) has no
good prefixes, we get by Theorem 3.2 that there is an NFW BforL(A) whose size is at most k, and
we are done.
Finally, we show next that despite the fact that transitions between automata with transition-based
and state-based acceptance may involve a linear blow-up, it is possible to adapt the above arguments
to automata with state-based acceptance, thus PSPACE-completeness holds also for B¨ uchi automata
with state-based acceptance. Essentially, given a DFW Aand an integer k, the reduction returns a
DBW for ∞($·L(A)·$) and the integer k+ 1.
To see why such a reduction exists, note that the construction of the SD-tNBW A′from the NFW
Acan be adapted to the state-based setting by adding a single new αstate to A′that behaves as the
initial states of A, and captures infixes in $ ·L(A)·$. Formally, given an NFW A=⟨Σ, Q, Q 0, δ, F⟩,
and a letter $ /∈Σ, we construct the NBW A′=⟨Σ∪{$}, Q∪{qacc}, Q0, δ′,{qacc}⟩, where for all states
q∈Qand letters σ∈Σ, we have that δ′(q, σ) =δ(q, σ). Also, δ′(Q\F,$) = Q0,δ′(F,$) ={qacc},
δ(qacc,$) = Q0, and δ′(qacc, σ) =δ(Q0, σ). Intuitively, the state qaccmimics traversal of αtransitions.
Then, Theorem 3.2 can also be adapted to SD-NBWs as follows. If Ais an SD-NBW for ∞($·R·$)
for some nontrivial language R⊆Σ∗that has no good prefixes, then one can construct an NFW Nfor
Rwith at most |A|− 1 states. Essentially, we view Aas a transition-based automaton Atby considering
transitions that leave αstates as αtransitions. Then, we consider the proof of Theorem 3.2 when
applied on At. As Rhas no good prefixes, then the state qaccofNis unreachable. Hence, all runs
from QS
0cannot reach αtransitions in At. In particular, αstates of Aare unreachable in Nand they
can be removed with qaccas well.
4 Semantically Deterministic co-B¨ uchi Automata
In this section we study SD co-B¨ uchi automata. Here too, our results are based on constructions that
involve encodings of NFWs by SD-tNCWs. Here, however, the constructions are more complicated,
and we first need some definitions and notations.
Consider a tNCW A=⟨Σ, Q, Q 0, δ, α⟩. We refer to the SCCs we get by removing A’sα-transitions
as the α-components ofA; that is, the α-components ofAare the SCCs of the graph GA¯α=⟨Q, E¯α⟩,
where ⟨q, q′⟩ ∈E¯αiff there is a letter σ∈Σ such that ⟨q, σ, q′⟩ ∈α. We say that Aisnormal if there
are no α-transitions connecting different α-components. That is, for all states qandsofA, if there is
a path of α-transitions from qtos, then there is also a path of α-transitions from stoq. Note that an
accepting run of Aeventually gets trapped in one of A’sα-components. In particular, accepting runs
inAtraverse transitions that leave α-components only finitely often. Hence, we can add transitions
among α-components to αwithout changing the language of the automaton. Accordingly, in the
sequel we assume that given tNCWs are normal.
We proceed to encoding NFWs by SD-tNCWs. For a language R⊆Σ∗, we define the language
▷ ◁$(R)⊆(Σ∪ {$})ω, by
▷ ◁$(R) ={w: ifwhas infinitely many $, then it has a suffix in ($ R)ω}.
Also, we say that a finite word x∈Σ∗is abad infix forRif for all words w∈Σ∗that have xas an
infix, it holds that w∈R.
Note that for every language R⊆Σ∗, we have that ▷ ◁$(R) =∞($·R·$). Thus, ▷ ◁$(R) com-
plements ∞($·R·$). Yet, unlike tDCWs and tDBWs, which dualize each other, SD-tNBWs and
SD-tNCWs are not dual. Hence, adjusting Theorems 3.1 and 3.2 to the co-B¨ uchi setting, requires
different, in fact more complicated, constructions.
16Theorem 4.1. Given an NFW N, one can obtain, in linear time, an SD-tNCW Asuch that
L(A) =▷ ◁$(L(N))and|A|=|N|.
Proof. Given N=⟨Σ, Q, Q 0, δ, F⟩, we obtain Aby adding $-transitions from all states to Q0. The
new transitions are in αiff they leave a state in Q\F. Formally, A=⟨Σ∪ {$}, Q, Q 0, δ′, α⟩, where
for all s∈Qandσ∈Σ, we have that δ′(s, σ) =δ(s, σ), and δ′(s,$) = Q0. Then, α={⟨s,$, q⟩:
q∈Q0ands∈Q\F}. It is easy to see that |A|=|N|. In order to prove that Ais SD and
L(A) =▷ ◁$(L(N)), we prove next that for every state q∈Q, it holds that L(Aq) =▷ ◁$(L(N)).
First, we show that ▷ ◁$(L(N))⊆L(Aq). Consider a word w∈▷ ◁$(L(N)). If whas finitely many
$’s, then as αtransitions in Aare $-labeled, we have that all runs of Aqonwtraverse αfinitely often
and thus are accepting. Assume that w=z·y, where yis of the form $ x1$x2$x3···, where for all i,
xi∈L(N). An accepting run rofAqonwcan be defined arbitrarily upon reading z. Then, upon
reading an infix of the form $ xi,rmoves to q0upon reading $, where q0∈Q0andxi∈L(Nq0).
Then, rproceeds by following an accepting run of Nq0onxi. As accepting runs of Nend in states in
F, and $-transitions from Fare in α, we get that rdoes not traverse αupon reading the $’s after x1.
Also, as transitions of Nareαtransitions in A, we get that rfollows a run that does not traverse α
when it reads xi. Hence, reventually vists only αtransitions and thus is accepting.
Next, we show that L(Aq)⊆▷ ◁$(L(N)). Consider a word w=σ1·σ2··· ∈ L(Aq) and let r=
r0, r1, . . .be an accepting run of Aqonw. Ifwhas finitely many $’s, then w∈▷ ◁$(L(N)) and we are
done. Assume that whas infinitely many $’s and let tbe such that r[t−1,∞] =rt−1, rt, rt+1, . . .is
a run that does not traverse αonw[t,∞]. To conclude the proof, we show that between every two
consecutive $’s in w[t,∞] there is a word in L(N). That is, we show that for all t≤t1< t2such that
σt1=σt2= $ and w[t1+ 1, t2−1] has no $’s, it holds that w[t1+ 1, t2−1]∈L(N). As $-transitions
lead to Q0, we have that rt1, rt2∈Q0. Recall that r[t−1,∞] does not traverse α, in particular, we
have that r[t1, t2] =rt1, rt1+1, . . . r t2is a run from Q0toQ0that traverses only αtransitions, on the
infix w[t1+1, t2]. Also, r[t1, t2] traverses $ only in its last transition. As the transition ⟨rt2−1, σt2, rt2⟩
is an α$-transition that leads to Q0, then rt2−1∈F. Also, since all the transitions that r[t1, t2−1]
traverses are Σ-labeled, then they are transitions in N, and so r[t1, t2−1] is an accepting run of N
onw[t1+ 1, t2−1]. Hence w[t1+ 1, t2−1]∈L(N) and we are done.
Theorem 4.2. Consider a language R⊆Σ∗and a letter $/∈Σ. For every tNCW Asuch that
L(A) =▷ ◁$(R), there exists an NFW Nsuch that L(N) =Rand|N| ≤ |A| + 1. In addition, if Rhas
bad infixes, then |N| ≤ |A| .
Proof. LetA=⟨Σ∪ {$}, Q, Q 0, δ, α⟩be a tNCW for ▷ ◁$(R). We assume that Ais normal and all of
its states are reachable. We define the NFW N=⟨Σ, Q∪ {qrej}, QN
0, δN, FN⟩, where QN
0={q∈Q:
there is a state q′such that ⟨q′,$, q⟩ ∈α},FN={q∈Q: there is a state q′such that ⟨q,$, q′⟩ ∈α},
and for every two states q, s∈Qand letter σ∈Σ, it holds that s∈δN(q, σ) iff⟨q, σ, s⟩ ∈α.
Also, if {q} × { σ} ×δ(q, σ)⊆α, then δN(q, σ) =qrej. Also, for all letters σ∈Σ, it holds that
δN(qrej, σ) =qrej; that is, qrejis a rejecting sink. Thus, Ntries to accept words x∈Σ∗for which
there is a run in Athat does not traverse αon the word $ ·x·$.
We prove that L(N) =R. We first prove that R⊆L(N). Consider a word x∈R, and let
r=r0, r1, r2, . . .be an accepting run of Aon ($·x)ω. As ris accepting, there are i < j such that
ri, ri+1, . . . , r jis a run that does not traverse αon $·x·$. By the definition of δN,ri+1∈QN
0, rj−1∈
FN, and so ri+1, ri+2, . . . , r j−1is an accepting run of Nonx.
We prove next that L(N)⊆R. Consider a word x=σ1·σ2···σn∈L(N) and let r=r0, r1, . . . r nbe
an accepting run of Nonx. Asrends an accepting state of N, then it does not visit qrej. Hence, the
definition of δNimplies that ris a run that does not traverse αinA. Also, as r0∈QN
0andrn∈FN,
there are states q1, q2∈Qsuch that ⟨q1,$, r0⟩,⟨rn,$, q2⟩ ∈α. Hence, q1, r0, r1, . . . , r n, q2is a run that
does not traverse αinAon the word $ ·x·$. AsAis normal, there is a word y∈(Σ∪{$})∗such that
there is a run that does not traverse αofAq2onythat reaches q1. Therefore, ($ ·x·$·y)ω∈L(Aq1). As
17all the states of Aare reachable, it follows that there is a word z∈(Σ∪{$})∗such that q1∈δ(Q0, z),
and thus z·($·x·$·y)ω∈L(A). Hence, as L(A) =▷ ◁$(R), we get that x∈R.
Since the state space of NisQ∪ {qrej}, we have that |N|=|A|+ 1. Moreover, if Rhas a bad
infix x, then x∈R. Hence, if we consider the word xω, then as it has no $’s, it is accepted by A.
Hence, there is a state q∈Qsuch that Aqhas a run on xωthat does not leave the α-component of
q. As we detail below, the fact that xis a bad infix of Rimplies that the α-component of qdoes not
contain $-transitions. Hence, since the only states in Qthat are reachable in Nlie in α-components
that contain a $-transition, we can remove the state qrejfromNand make qa rejecting sink instead.
Hence, in this case, we have that |N| ≤ |A| , and we are done.
Letxbe a bad infix of R, and let q∈Qbe such that Aqhas a run on xωthat does not leave the
α-component of q. Let S(q) denote the α-component of q. To conclude the proof, we show that S(q)
does not contain a $-transition. Assume by contradiction that S(q) contains a $-transition s1$− →s2.
Asqhas a run on xωthat does not leave S(q), we get that qhas a finite run of the form qx− →qxonx
that does not leave S(q). AsAis normal, we get that there is a run in S(q) that starts at qx, passes
through the transition s1$− →s2, and finally ends in q:qxy1− →s1$− →s2y2− →q. Hence, we get that there
is a cycle in S(q) of the form qx·y− − →qon a word of the form x·y, where ycontains a $. Hence, ( x·y)ω
is accepted from qinA.
Note that the word ( x·y)ω=x·y·x·y···has infinitely many infixes of the form $ ·u·$, where
u∈Σ∗is a bad infix of R. To see why, consider the infix z=y·x·ythat appears infinitely often in
(x·y)ω, and consider the infix $ ·u·$ ofz=y·x·ythat starts at last $ of the first yand ends at the
first $ of the second y. Clearly, such uis over Σ, and since it contains xas an infix, then it is also a
bad infix. In particular, u∈R. As all the states of Aare reachable, there is a word v∈(Σ∪ {$})∗
such that q∈δ(q0, v). Hence, the word v·(x·y)ωis accepted in Aeven though it has infinitely
many infixes of the form $ ·u·$, where u∈R, and we have reached a contradiction to the fact that
L(A) =▷ ◁$(R).
4.1 Succinctness and Complementation
In this section we study the succinctness of SD co-B¨ uchi automata with respect to deterministic ones,
and the blow-up involved in their complementation. Recall that unlike B¨ uchi automata, for co-B¨ uchi
automata, HD automata are exponentially more succinct than deterministic ones. Accordingly, our
results about the succinctness of SD automata with respect to HD ones are more surprising than those
in the setting of B¨ uchi automata.
Theorem 4.3. There is a family L1, L2, L3, . . .of languages such that for every n≥1, there is an
SD-tNCW with 3n+ 3states that recognizes Ln, yet every tDCW or HD-tNCW that recognizes Ln
needs at least 2nstates.
Proof. Forn≥1, consider the alphabet Σ n= [n]∪ {#}, and the language Rn={x·#·i:x∈[n]+
andiappears in x} ⊆Σ∗
n. We define Ln=▷ ◁$(Rn). Recall that a word over z∈(Σn∪ {$})∗is good
ifz= $·x·#·i, where x∈[n]+andiappears in x, and note that Lnconsists of exactly the words
with finitely many $’s, or that have a suffix that is a concatenation of good words. First, it is not
hard to see that Rncan be recognized by an NFW Nnwith 3 n+ 3 states, for example, a candidate
forNncan be obtained from the NFW in Figure 1 by removing the $-transitions from q0, and letting
q0guess to behave as any state inS
i∈[n]{q1
i}. By Theorem 4.1, there is an SD-tNCW for Lnwith
3n+ 3 states.
We show next that an HD-tNCW for Lnneeds at least 2nstates. Consider an HD-tNCW
A=⟨Σn∪ {$}, Q, q 0, δ, α⟩forLn. By [19, 1], we can assume that Aisα-deterministic , thus
for all states qand letters σ, we have that there is at most one state q′such that ⟨q, σ, q′⟩ ∈α.
We also assume that Ais normal, and all its states are reachable. To prove that |Q| ≥ 2n,
we first prove that there is a state q∈Qsuch that ($ ·Rn)ω⊆Lα(q), where Lα(q) ={w:
18there is a run from qonwthat does not traverse α}. Then, we argue that the α-component of qhas
at least 2nstates.
For a nonempty set S∈2Q, and a letter σ∈Σn∪{$}, define δα(S, σ) ={q′∈Q: there is a state q∈S
such that ⟨q, σ, q′⟩ ∈α}. Consider the tDCW D=⟨Σn∪ {$},2Q\ ∅, Q, δD, αD⟩, where for every
nonempty set S∈2Q\ ∅, and letter σ∈Σn∪ {$}, it holds that δD(S, σ) =δα(S, σ), ifδα(S, σ)̸=∅,
andδD(S, σ) =Q, otherwise. The former type of transitions are in αD, and the latter are in αD.
Thus, the state space of Dencodes nonempty sets S∈2Qof states, and Dstarts a run from the set
of all states Q. Reading its input, Dkeeps track of runs in Athat have not traversed αfrom the last
traversal of αD, and when all tracked runs in Ahave traversed α, the tDCW Dresets again to the
set of all states Q.
We prove next that5L(A)⊆L(D). Consider a word w∈L(A), and let r=r0, r1, r2, . . .be an
accepting run of Aonw. As ris accepting, there is i≥0 such that r[i,∞] =ri, ri+1, ri+2, . . .does
not traverse αon the suffix w[i+ 1,∞]. Let rS=S0, S1, S2, . . .denote the run of Donw, and assume
towards contradiction that rStraverses αDinfinitely often. Then, consider an index j≥isuch that
⟨Sj, w[j+1], Sj+1⟩ ∈αD. By the definition of D, we have that Sj+1=Q. Consider the run r[j+1,∞]
on the suffix w[j+ 2,∞]. As rj+1∈Sj+1,r[j+ 1,∞] is a run of rj+1that does not traverse α, andD
keeps track of runs in Athat do not traverse αfrom the last reset, then it must be the case that the
runrS[j+ 1,∞] =Sj+1, Sj+2, Sj+3, . . .does not traverse αD, and we have reached a contradiction.
Next, we show that there is a state q∈Qsuch that ($ ·Rn)ω⊆Lα(q). Assume towards contradiction
that for all states q∈Q, it holds that there is a word wq∈($·Rn)ω\Lα(q). We define a sequence
S0, S1, S2, . . .of states in D, and a sequence w1, w2, w3, . . .of finite words in ($ ·Rn)+such that for
alli≥0, it holds that δD(Si, wi+1) =Si+1. We take S0=Q. For all i≥0, given Si, we define
wi+1andSi+1as follows. Consider a state qi∈Siand the word wqi∈($·Rn)ω\Lα(qi). Then, as
we argue below, there exists a prefix hqofwqiin ($·Rn)+such that all runs of qionhqtraverse
α. We take wi+1to be hq, and take Si+1=δD(Si, wi+1). We explain now why such a prefix exists.
Assume contrarily that there are indices k1< k 2< k 3<···such that for all j≥1, the word
wqi[1, kj] =σ1·σ2···σkj∈($·Rn)+is a prefix of wqi=σ1·σ2·σ3···such that qihas a run rkjthat
does not traverse αonwqi[1, kj]. Then, as Aisαdeterministic, we get that the run rkj2extends the
runrkj1for all j2> j1. Hence, there is an infinite run of qithat does not traverse αonwqi, and we
have reached a contradiction to the fact that wqi/∈Lα(qi).
Consider sequences S0, S1, S2, . . .andw1, w2, w3, . . .as above. First, it holds that the word w=
w1·w2·w3···is in ($ ·Rn)ω⊆Ln, and, by definition, rS=S0w1− − →S1w2− − →S2···is a run of D
onw. Recall that L(A) =Ln⊆L(D); in particular w∈L(D). To reach a contradiction, we prove
below that the run rSofDonw, is rejecting. We claim that it is sufficient to show that for all i≥0,
either the run ri→i+1=Siwi+1− − − → Si+1traverses αD, or|Si|>|Si+1|. Indeed, if the latter holds, and
there is i≥0 such that the run Siwi+1− − − → Si+1wi+2− − − → Si+2···does not traverse αD, then we get that
|Sj|>|Sj+1|for all j≥i, which is a impossible.
So we prove next that for all i≥0, either the run ri→i+1=Siwi+1− − − → Si+1traverses αD, or
|Si|>|Si+1|. Consider a state SofD, a letter σ∈Σn∪ {$}, and note the following. If for
allq∈Sit holds that ( {q} × { σ} ×δ(q, σ))∩α̸=∅, then as Sproceeds to the α σ successors
of the states in Supon reading σ, and as Aisαdeterministic, we get that |S| ≥ | δD(S, σ)|and
⟨S, σ, δ D(S, σ)⟩ ∈αD. Otherwise, if there is a state q∈Ssuch that ( {q} × { σ} ×δ(q, σ))∩α=∅,
then either ⟨S, σ, δ D(S, σ)⟩ ∈αD, or|S|>|δD(S, σ)|. Consider i≥0. Let wi+1=σ1·σ2···σni, and
consider the run ri→i+1=Siwi+1− − − → Si+1=T0, T1, . . . , T ni. If, by contradiction, the run ri→i+1does
not traverse αDand|Si|=|Si+1|, then by the above, for all 0 ≤j < n iandq∈Tj, we have that
({q}×{σj+1}×δ(q, σj+1))∩α̸=∅. Hence, if we consider a state t0∈T0, we get that there is a transition
⟨t0, σ1, t1⟩ ∈α, and by the defition of δD, we have that t1∈T1. Then, proceeding iteratively from t1,
5In fact, using the fact that all the states of Aare reachable, the fact that HD-tNCWs can be assumed to be SD
[19], and the fact that Arecognizes Ln, one can prove that Dis equivalent to A.
19we get that there is a run of t0inAthat does not traverse αon the word wi+1=σ1·σ2···σni. As
the latter holds for all t0∈T0=Si; in particular, for t0=qi, we get a contradiction to the definition
ofwi+1.
What we have shown so far is that there exists a state q∈Qsuch that ($ ·Rn)ω⊆Lα(q). To
complete the proof, we prove next that the α-component of qhas at least 2nstates. Assume towards
contradiction that the α-component of qhas strictly less than 2nstates. For every subset S⊆[n], we
abuse notation and use Sto also denote a word in [ n]∗consisting of exactly the numbers that appear
inS. Then, consider the word $ ·S. The word $ ·Scan be extended to a word in ($ ·Rn)ω⊆Lα(q).
Hence, qhas a run rSthat does not traverse αon the word $ ·S, and as Ais normal, we have that rS
ends in a state that belongs to the α-component of q. As the α-component of qhas strictly less than
2nstates, there are sets S, T⊆[n] and i∈[n] such that i∈S\T, and rSandrTend in the same
state q′. AsAisαdeterministic, we get that the run rSis the only run that does not traverse αfrom
the state qon the word $ ·S. Hence, as $ ·S·#·i·$ can be extended to a word in ($ ·Rn)ω⊆Lα(q)
andrSends in q′, we get that there is a run of the form q′#·i·$− − − → q′′that traverses only αtransitions,
in particular, it does not leave the α-component of q. Now consider the run r=q$·T− − → q′#·i·$− − − → q′′.
The run ris a run that does not traverse αfrom the state qon the word $ ·T·#·i·$. AsAis normal,
there is a word y∈(Σn∪{$})∗such that there is a run that does traverse αofAq′′onythat reaches
q. Therefore, ($ ·T·#·i·$·y)ω∈Lα(q)⊆L(Aq). As all the states of Aare reachable, there is a
word z∈(Σn∪ {$})∗such that q∈δ(q0, z). Hence, the word z·($·T·#·i·$·y)ωis accepted by A
even though it has infinitely many infixes in $ ·Rn·$, and we have reached a contradiction.
Remark 4.1. As has been the case with B¨ uchi automata, here too, an analysis of the application of the
HD-tNCW minimization algorithm on a tDCW for Lnleads to a slightly tighter bound. Specifically,
in Appendix A.2, we describe a tDCW for Lnwith 2n+1+ 1 states, such that the application of the
HD-tNCW minimization algorithm on it does not make it smaller.
Theorem 4.4. There is a family L1, L2, L3, . . .of languages such that for every n≥1, there is an
SD-tNCW with O(n)states that recognizes Ln, yet every SD-tNBW that recognizes Lnneeds at least
2O(n)states.
Proof. Let Σ = {0,1}, and let Rn={w:w∈(0 + 1)∗·(0·(0 + 1)n−1·1 + 1·(0 + 1)n−1·0)·(0 + 1)∗}.
Thus, Rnis the language of all words that contain two letters that are at distance nand are different.
We define Ln=▷ ◁$(Rn).
It is easy to see that Rncan be recognized by an NFW with O(n) states. Hence, by Theorem 4.1,
there is an SD-tNCW with O(n) states for Ln. We prove next that every SD-tNBW for Lnneeds
at least 2O(n)states. For this, note that Lnconsists of all words wsuch that wcontains infinitely
many $’s yet has no suffix in ($ Rn)ω. Thus, wcontains infinitely many infixes in $ Rn$. Therefore,
Ln=∞($·Rn·$). It is not hard to prove that an NFW for Rnneeds at least 2O(n)states. Then, by
Theorem 3.2, this bound is carried over to a 2O(n)lower bound on an SD-tNBW for Ln.
4.2 Decision Problems
We continue to decision problems for SD-tNCWs and SD-NCWs. As in Section 3.2, we state only the
lower bounds, and for SD-tNCWs. Matching upper bounds and similar results for SD-NCWs follow
from the known upper bounds for tNCWs and the known linear translations between state-based and
transition-based automata.
We start with language-containment and universality.
Theorem 4.5. The language-containment and universality problems for SD-tNCWs are PSPACE-
hard.
20Proof. We describe a reduction from universality of NFWs to universality of SD-tNCWs. Given an
NFW Nover Σ, the reduction returns the SD-tNCW Aover Σ ∪ {$}that is obtained by applying the
operation from Theorem 4.1 on N. Thus, L(A) =▷ ◁$(L(N)).
First, if L(N) = Σ∗, then (Σ ∪ {$})∗·($L(N))ω=∞$, and so L(A) = (Σ ∪ {$})ω. Conversely,
if there is a word x∈Σ∗\L(N), then the word w= ($x)ωis not in L(A). Indeed, whas infinitely
many $’s, yet it has a word not in L(N) between every two consecutive $’s.
We continue to the minimization problem. Note that while minimization is PSPACE-complete for
NCWs, it is NP-complete for DCWs and in PTIME for HD-tNCWs. Thus, our PSPACE lower bound
suggests a significant difference between SD and HD automata. Note also that, as has been the case
with B¨ uchi automata, the case of SD-NCWs is easy, as a non-empty SD-NCW is universal iff it has
an equivalent SD-NCW with one state, which is not the case for SD-tNCWs:
Theorem 4.6. The minimization problem for SD-tNCWs is PSPACE-hard.
Proof. We analyze the reduction from Theorem 4.5 and show that an NFW Nover Σ is universal iff
the SD-tNCW Aover Σ ∪ {$}that is constructed in Theorem 4.1 for ▷ ◁$(L(N)) has an equivalent
SD-tNCW with a single state.
First, note that Nis universal iff ▷ ◁$(L(N)) is universal. Hence, if Nis universal, then Ahas an
equivalent SD-tNCW with a single state. For the other direction, assume that Ahas an equivalent
SD-tNCW Dwith a single state, and assume towards contradiction that Nis not universal. Then,
there is a word x /∈L(N). Consider the word ($ x)ω. By the definition of ▷ ◁$(L(N)), we have that
($x)ω̸∈L(A). Hence, ($ x)ωis not accepted by Dand so at least one of the letters σin the word $ x
is such that the σ-labeled self-loop at the state of Dis an α-transition. Now as L(A) =▷ ◁$(L(N)), we
get that Daccepts all words that have no $’s; in particular, the α-self-loop at the state of Dmust be
$-labeled.
Recall that the universality problem for NFWs is PSPACE-hard already for NFWs Nthat accept
ϵ. For example, this is valid for the NFW that is generated in the generic reduction from a PSPACE
Turing machine, and which accepts all words that do not encode a valid computation of the Turing
machine. Hence, for such an NFW N, the word $ωis in ▷ ◁$(L(N)), and should be accepted by D,
and we have reached a contradiciton.
We continue to the D-to-SD minimization problem, showing it stays PSPACE-hard.
Theorem 4.7. The D-to-SD minimization problem for co-B¨ uchi automata is PSPACE-hard.
Proof. We reduce from the D-to-N minimization problem for automata on finite words, which is
already PSPACE-hard for languages that have bad infixes [18]. We start with co-B¨ uchi automata
with transition-based acceptance.
Consider the construction from Theorem 4.1. Recall it takes an NFW Aas input, returns an
SD-tNCW A′of the same size for ▷ ◁$(L(A)), and preserves determinism.
Consider a DFW Aover Σ such that L(A) has a bad infix, and an integer k. The reduction
returns the SD-tNCW A′constructed from Ain Theorem 4.1, and the integer k. Recall that L(A′) =
▷ ◁$(L(A)), and that the construction in Theorem 4.1 preserves determinism. Thus, the automaton A′
is really a tDCW.
We prove next that the reduction is correct. That is, the DFW Ahas an equivalent NFW with
at most kstates iff the tDCW A′has an equivalent SD-tNCW with at most kstates. For the
first direction, if Bis an NFW equivalent to Awhose size is at most k, then, by applying to it
the construction from Theorem 4.1, we get an SD-tNCW B′whose size is at most k, and L(B′) =
▷ ◁$(L(B)) =▷ ◁$(L(A)) =L(A′).
Conversely, if B′is an SD-tNCW for ▷ ◁$(L(A)) whose size is at most k, then as L(A) has bad
infixes, we get by Theorem 4.2 that there is an NFW BforL(A) whose size is at most k, and we are
done.
21Finally, as in B¨ uchi automata, it is not hard to see that the above arguments can be adapted to
state-based automata, and so the D-to-SD minimization problem is PSPACE-hard also for co-B¨ uchi
automata with state-based acceptance. Essentially, given a DFW Aand an integer k, the reduction
returns a DCW for ▷ ◁$(L(A)) and the integer k+ 1.
The above reduction exists since the construction from Theorem 4.1 can be adapted to state-based
automata, essentially, by letting the co-B¨ uchi automaton have one additional αstate that behaves as
the initial states, and that is reachable from every state in Q\Fupon reading $.
Also, Theorem 4.2 can be adapted to the state-based setting. Indeed, if Ais an NCW for ▷ ◁$(R)
for some language language R⊆Σ∗that has a bad infix x, then one can construct an NFW NforR
with at most |A|− 1 states. To see why, we view Aas a transition-based automaton Atby considering
transitions that touch αstates as αtransitions. Then, we consider the proof of Theorem 4.2 when
applied on At. We claim that all states pthat are αstates of Acan be removed from Nwithout
affecting its language. Indeed, the α-component of such a state pinAtis{p}and contains no
transitions, in paritcular, no $-transitions. Also, note that such states pare distinct from the state q
that has a run that does not traverse αtransitions on xω. Thus, they can be removed from Nalong
with the state qrej. Hence, we get in this case that |N| ≤ |A| − 1.
5 Semantically Deterministic Weak Automata
By [2], SD-NWWs need not be DBP or even HD. For completeness we describe here the example
from [2], as it highlights the challenges in SD-NWW determinization. Consider the automaton Ain
Figure 2.
Figure 2: An SD-NWW that is not DBP.
It is easy to see that Ais weak, and all its states are universal, and so it is SD. On the other hand,
Ais not HD as every strategy has a word with which it does not reach qacc– a word that forces
every visit in qaandqbto be followed by a visit in q0. Below we show that despite not being DBP,
SD-NWWs can be determinized in polynomial time. Essentially, our proof is based on redirecting
transitions of the SD-NWW to deep components in the automaton. In our example, note that while
the SD-NWW Ais not HD, it has a deterministic state qaccthat recognizes L(A).
Consider an SD-NWW A=⟨Σ, Q, q 0, δ, α⟩. We denote the set of A’s SCCs by C(A), and the SCC
containing a state qbyC(q). Let C1≤C2≤ ··· ≤ Cmbe a total order on the SCCs of A, extending
the partial order induced by δ. That is, if q′∈δ(q, σ), for some letter σ, then C(q)≤C(q′). When
C≤C′, we say that C′isdeeper than C. Thus, states along runs of a weak automaton proceed from
SCCs to deeper ones, and eventually get stuck in some SCC.
If we had an algorithm that checks language equivalence between states in Ain polynomial time,
we could have a polynomial determinization algorithm that defines the σ-successor of a state as the
deepest state among all states equivalent to its σ-successors (since Ais SD, all these successors agree
on their language). Since we still do not have such an algorithm (in fact, it would follow from our
construction), we approximate language equivalence by an equivalence that follows from the semantic
determinism of A.
22For two states s1, s2∈Q, we say that s1ands2areδ-close , if there is a state q∈Qand a word
w∈Σ∗such that s1, s2∈δ(q, w). Note that the δ-close relation refines equivalence, yet the converse
does not hold. Indeed, the SDness property implies that s1∼As2for all δ-close states s1ands2.
Lemma 5.1. Ifs1ands2areδ-close, then there is a state qand word wof length at most |Q|2such
thats1, s2∈δ(q, w).
Proof. Consider δ-close states s1ands2. Let qandwbe such that s1, s2∈δ(q, w). If|w|>|Q|2, then
in the runs from qtos1and from qtos2there must be a pair of states ⟨p1, p2⟩that repeats twice, and
we can shorten wby removing the subword between the two occurrences of ⟨p1, p2⟩. Formally, there
is a partition of w=x·y·zsuch that p1, p2∈δ(q, x),p1∈δ(p1, y),p2∈δ(p2, y),s1∈δ(p1, z), and
s2∈δ(p2, z). Then, s1, s2∈δ(q, x·z). This process can repeat until wis of length at most |Q|2.
In order to calculate the δ-close relation in polynomial time, we define a sequence H0, H1, H2, . . .⊆
Q×Qof relations, where ⟨s1, s2⟩ ∈Hiiff there is a state qand word wof length at most isuch that
s1, s2∈δ(q, w). By Lemma 5.1, we are guaranteed to reach a fixed point after at most |Q|2iterations.
The relations Hiare defined as follows.
•H0={⟨q, q⟩:q∈Q}.
•Fori≥0, we define Hi+1=Hi∪ {⟨s1, s2⟩: there is ⟨q1, q2⟩ ∈Hiand letter σ∈Σ such that
s1∈δ(q1, σ) and s2∈δ(q2, σ)}.
Letj≥0 be such that Hj+1=Hj. It is not hard to see that Hjis the δ-close relation. While the
δ-close relation is reflexive and symmetric, it is not transitive. Now, let H⊆Q×Qbe the closure
ofHjunder transitivity. That is, ⟨s1, s2⟩ ∈Hiff there is k≥2 and states q1, q2, . . . , q ksuch that
q1=s1,qk=s2and⟨qi, qi+1⟩ ∈Hjfor all 1 ≤i < k .
The following lemma implies that Hpropagates to successor states.
Lemma 5.2. IfH(s, s′), then for every letter σ∈Σand states q∈δ(s, σ)andq′∈δ(s′, σ), we have
thatH(q, q′).
Proof. Consider the fixed point relation Hj. By definition, if Hj(s, s′), then for every letter σ∈Σ
and states q∈δ(s, σ) and q′∈δ(s′, σ), we have that Hj+1(q, q′), and since Hjis the fixed point, then
Hj(q, q′). Then, the lemma follows from the definition of Has the closure of Hjunder transitivity.
Indeed, if H(s, s′), then there is k≥2 and states q1, q2, . . . , q ksuch that q1=s, qk=s′andHj(qi, qi+1)
for all 1 ≤i < k . Now if s1, s2, . . . , s kare such that si∈δ(qi, σ), then by the above considerations,
we have that Hj(si, si+1) for all 1 ≤i < k . Hence, the definition of Himplies that H(s1, sk), and we
are done.
It is easy to see that His an equivalence relation. Let P={P1, . . . , P k}be the set of the equivalence
classes of H. For each equivalence class P∈ P, we fix the representative of Pas some state in P∩C,
where C∈ C(A) is the deepest SCC that intersects P. Let p1, . . . , p kbe the representatives of the
sets in P. For a state q∈Q, leteqdenote the representative of the set P∈ Pwith q∈P. Note that
asHrefines ∼A, we have that q∼Aeq.
Theorem 5.3. Given an SD-NWW Awith state space Q, we can construct, in polynomial time, an
equivalent DWW Dwith state space Q′, for Q′⊆Q.
Proof. Given A=⟨Σ, Q, q 0, δ, α⟩, we define D=⟨Σ, Q′, q′
0, δ′, α∩Q′⟩, where
•Q′={p1, . . . , p k}. Note that indeed Q′⊆Q.
•q′
0=eq0.
23•Forp∈Q′andσ∈Σ, we define δ′(p, σ) = ˜q, for some q∈δ(p, σ). Note that all the states in
δ(p, σ) are δ-close, and thus belong to the same set in P. Hence, the choice of qis not important,
asδ′(p, σ) is the representative of this set.
We prove that Dis a DWW equivalent to A. First, in order to see that Dis weak, consider states
p, p′such that p′∈δ′(p, σ). Thus, p′is the representative of a state q∈δ(p, σ). As Ais weak, we
have that C(p)≤C(q). As p′= ˜q, we have that C(q)≤C(p′). Hence C(p)≤C(p′), and we are done.
We continue and prove that L(A) =L(D). We first prove that L(A)⊆L(D). Consider a word
wand assume that w∈L(A). Let r=q0, q1, q2, . . .be an accepting run of Aonw, and let r′=
s0, s1, s2, . . .be the run of Donw. Ifr′is accepting, we are done. Otherwise, namely if r′is rejecting,
we point to a contradiction. Let j≥0 be the index in which r′visits only states in sinf(r′). Note
that all the states sj, sj+1, sj+2, . . .belong to some SCC CofA. Since we assume that r′is rejecting,
and acceptance in Dis inherited from A, we get that Cis a rejecting SCC of A. We claim that all
the runs of Asjon the suffix w[j+ 1,∞] ofware stuck in C. Thus, w[j+ 1,∞]̸∈L(Asj). On the
other hand, we claim that for all i≥0, we have that qi∼Asi. Then, however, w[j+ 1,∞]̸∈L(Aqj),
contradicting the fact that ris accepting:
The easy part is to prove that for all i≥0, we have that qi∼Asi. Indeed, it follows from the fact
that for all i≥0, we have that H(qi, si) and the fact that Hrefines ∼A. The proof proceeds by an
induction on i. First, as for every state q∈Q, we have that H(q,eq), then H(q0, q′
0), and so the claim
follows from s0being q′
0. Assume now that H(qi, si). Recall that si+1iseqfor some q∈δ(si, w[i+ 1]).
Also, qi+1∈δ(qi, w[i+ 1]). Then, by Lemma 5.2, we have that H(qi+1, q). Since, in addition, we have
thatH(q,eq), then the transitivity of Himplies that H(qi+1, si+1), and we are done.
We proceed to the other part, namely, proving that all the runs of Asjon the suffix w[j+1,∞] ofw
are stuck in C. Let uj+1, uj+2, . . .be such that for all i≥1, it holds that uj+i∈δ(sj+i−1, w[j+i]) and
H(uj+i, sj+i). Note that such states exist, as sj+i−1w[j+i]− − − − → sj+iis a transition of Dand so sj+i=eq
for all q∈δ(sj+i−1, w[j+i]). Consider a run r′′=v0, v1, v2, . . .ofAsjonw[j+ 1,∞]. Note that
v0=sj, and so H(v0, sj). Therefore, by Lemma 5.2, we have that H(v1, uj+1), implying H(v1, sj+1).
By repeated applications of Lemma 5.2, we get that H(vi, uj+i), implying H(vi, sj+i), for all i≥1.
Assume now by way of contradiction that the run r′′leaves the SCC C, and so there is i≥1 such
thatC(vi)̸≤C(sj+i). As H(vi, sj+i), the states viandsj+iare in the same equivalence class P∈ P.
Then, the definition of Q′implies that C(sj+i)≥C(vi), and we have reached a contradiction.
It is left to prove that L(D)⊆L(A). The proof follows similar considations and is detailed next.
Consider a word w∈L(D). Let r′=s0, s1, s2, . . .be the run of Donw, and let j≥0 be the index
in which r′visits only states in sinf(r′); in particular, as argued above, sinf(r′) is included in some
SCC CofA. Thus, all the states sj, sj+1, sj+2, . . .are in C. Since w∈L(D), then r′is accepting,
and so Cis an accepting SCC of A. As in the previous direction, it holds that sjisA-equivalent to
all the states in δ(q0, w[1, j]). Hence, to conclude that w∈L(A), we show that there is an accepting
run of Asjonw[j+ 1,∞]. Assume by way of contradiction that all the runs of Asjonw[j+ 1,∞] are
rejecting. In particular, all these runs leave the SCC C. As in the previous direction, this contradicts
the choice of the states sj, sj+1, sj+2, . . .as representatives of equivalence classes in P.
Since DWWs can be complemented by dualization (that is, by switching αand ¯α), Theorem 5.3
implies the following.
Theorem 5.4. Given an SD-NWW Awith nstates, we can construct, in polynomial time, an SD-
NWW (in fact, a DWW) that complements A.
Since the language-containment problem for DWW can be solved in NLOGSPACE, and minimiza-
tion for DWW is similar to minimization of DFWs and can be solved in polynomial time [30], we have
the following.
Theorem 5.5. The language-containment, universality, and minimality problems for SD-NWWs can
be solved in polynomial time.
24References
[1] B. Abu Radi and O. Kupferman. Minimizing GFG transition-based automata. In Proc. 46th Int.
Colloq. on Automata, Languages, and Programming , volume 132 of LIPIcs , pages 100:1–100:16.
Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2019.
[2] B. Abu Radi, O. Kupferman, and O. Leshkowitz. A hierarchy of nondeterminism. In 46th Int.
Symp. on Mathematical Foundations of Computer Science , volume 202 of LIPIcs , pages 85:1–
85:21, 2021.
[3] B. Aminof, O. Kupferman, and R. Lampert. Reasoning about online algorithms with weighted
automata. ACM Transactions on Algorithms , 6(2), 2010.
[4] M. Bagnol and D. Kuperberg. B¨ uchi good-for-games automata are efficiently recognizable. In
Proc. 38th Conf. on Foundations of Software Technology and Theoretical Computer Science ,
volume 122 of LIPIcs , pages 16:1–16:14, 2018.
[5] B. Boigelot, S. Jodogne, and P. Wolper. On the use of weak automata for deciding linear arith-
metic with integer and real variables. In Proc. Int. Joint Conf. on Automated Reasoning , volume
2083 of Lecture Notes in Computer Science , pages 611–625. Springer, 2001.
[6] U. Boker, D. Kuperberg, O. Kupferman, and M. Skrzypczak. Nondeterminism in the presence of a
diverse or unknown future. In Proc. 40th Int. Colloq. on Automata, Languages, and Programming ,
volume 7966 of Lecture Notes in Computer Science , pages 89–100, 2013.
[7] U. Boker and K. Lehtinen. When a little nondeterminism goes a long way: an introduction to
history-determinism. ACM SIGLOG News , 10(1):177–196, 2023.
[8] J.R. B¨ uchi. On a decision method in restricted second order arithmetic. In Proc. Int. Congress
on Logic, Method, and Philosophy of Science. 1960 , pages 1–12. Stanford University Press, 1962.
[9] Olivier Carton and Max Michel. Unambiguous b¨ uchi automata. Theoretical Computer Science ,
297(1):37–81, 2003.
[10] T. Colcombet. The theory of stabilisation monoids and regular cost functions. In Proc. 36th Int.
Colloq. on Automata, Languages, and Programming , volume 5556 of Lecture Notes in Computer
Science , pages 139–150. Springer, 2009.
[11] T. Colcombet, K. Quaas, and M. Skrzypczak. Unambiguity in automata theory (dagstuhl seminar
21452). Dagstuhl Reports , 11(10):57–71, 2021.
[12] A. Duret-Lutz, A. Lewkowicz, A. Fauchille, Th. Michaud, E. Renault, and L. Xu. Spot 2.0 — a
framework for LTL and ω-automata manipulation. In 14th Int. Symp. on Automated Technology
for Verification and Analysis , volume 9938 of Lecture Notes in Computer Science , pages 122–129.
Springer, 2016.
[13] P. Gastin and D. Oddoux. Fast LTL to B¨ uchi automata translation. In Proc. 13th Int. Conf. on
Computer Aided Verification , volume 2102 of Lecture Notes in Computer Science , pages 53–65.
Springer, 2001.
[14] D. Giannakopoulou and F. Lerda. From states to transitions: Improving translation of LTL
formulae to B¨ uchi automata. In Proc. 22nd International Conference on Formal Techniques for
Networked and Distributed Systems , volume 2529 of Lecture Notes in Computer Science , pages
308–326. Springer, 2002.
25[15] E.M. Hahn, M. Perez, S. Schewe, F. Somenzi, A. Trivedi, and D. Wojtczak. Good-for-MDPs
automata for probabilistic analysis and reinforcement learning. In Proc. 26th Int. Conf. on Tools
and Algorithms for the Construction and Analysis of Systems , volume 12078 of Lecture Notes in
Computer Science , pages 306–323. Springer, 2020.
[16] T.A. Henzinger, O. Kupferman, and S. Rajamani. Fair simulation. Information and Computation ,
173(1):64–81, 2002.
[17] T.A. Henzinger and N. Piterman. Solving games without determinization. In Proc. 15th Annual
Conf. of the European Association for Computer Science Logic , volume 4207 of Lecture Notes in
Computer Science , pages 394–410. Springer, 2006.
[18] T. Jiang and B. Ravikumar. Minimal NFA problems are hard. SIAM Journal on Computing ,
22(6):1117–1141, 1993.
[19] D. Kuperberg and M. Skrzypczak. On determinisation of good-for-games automata. In Proc.
42nd Int. Colloq. on Automata, Languages, and Programming , pages 299–310, 2015.
[20] O. Kupferman. Avoiding determinization. In Proc. 21st IEEE Symp. on Logic in Computer
Science , pages 243–254, 2006.
[21] O. Kupferman. Automata theory and model checking. In Handbook of Model Checking , pages
107–151. Springer, 2018.
[22] O. Kupferman. Using the past for resolving the future. Frontiers in Computer Science , 4, 2023.
[23] O. Kupferman and O. Leshkowitz. On repetition languages. In 45th Int. Symp. on Mathematical
Foundations of Computer Science , Leibniz International Proceedings in Informatics (LIPIcs),
2020.
[24] O. Kupferman, S. Safra, and M.Y. Vardi. Relating word and tree automata. Ann. Pure Appl.
Logic , 138(1-3):126–146, 2006.
[25] O. Kupferman and M.Y. Vardi. Safraless decision procedures. In Proc. 46th IEEE Symp. on
Foundations of Computer Science , pages 531–540, 2005.
[26] R.P. Kurshan. Complementing deterministic B¨ uchi automata in polynomial time. Journal of
Computer and Systems Science , 35:59–71, 1987.
[27] R.P. Kurshan. Computer Aided Verification of Coordinating Processes . Princeton Univ. Press,
1994.
[28] L.H. Landweber. Decision problems for ω–automata. Mathematical Systems Theory , 3:376–384,
1969.
[29] W. Li, Sh. Kan, and Z. Huang. A better translation from LTL to transition-based generalized
B¨ uchi automata. IEEE Access , 5:27081–27090, 2017.
[30] C. L¨ oding. Efficient minimization of deterministic weak ω-automata. Information Processing
Letters , 79(3):105–109, 2001.
[31] S. Miyano and T. Hayashi. Alternating finite automata on ω-words. Theoretical Computer
Science , 32:321–330, 1984.
[32] G. Morgenstern. Expressiveness results at the bottom of the ω-regular hierarchy. M.Sc. Thesis,
The Hebrew University, 2003.
26[33] D.E. Muller, A. Saoudi, and P. E. Schupp. Weak alternating automata give a simple explanation
of why most temporal and dynamic logics are decidable in exponential time. In Proc. 3rd IEEE
Symp. on Logic in Computer Science , pages 422–427, 1988.
[34] M.O. Rabin and D. Scott. Finite automata and their decision problems. IBM Journal of Research
and Development , 3:115–125, 1959.
[35] S. Safra. On the complexity of ω-automata. In Proc. 29th IEEE Symp. on Foundations of
Computer Science , pages 319–327, 1988.
[36] S. Schewe. Beyond Hyper-Minimisation—Minimising DBAs and DPAs is NP-Complete. In Proc.
30th Conf. on Foundations of Software Technology and Theoretical Computer Science , volume 8
ofLeibniz International Proceedings in Informatics (LIPIcs) , pages 400–411, 2010.
[37] S. Schewe. Minimising good-for-games automata is NP-complete. In Proc. 40th Conf. on Foun-
dations of Software Technology and Theoretical Computer Science , volume 182 of LIPIcs , pages
56:1–56:13. Schloss Dagstuhl - Leibniz-Zentrum f¨ ur Informatik, 2020.
[38] S. Schewe, Q. Tang, and T. Zhanabekova. Deciding what is good-for-MDPs. CoRR ,
abs/2202.07629, 2022. URL: https://arxiv.org/abs/2202.07629 ,arXiv:2202.07629 .
[39] S. Sickert, J. Esparza, S. Jaax, and J. Kˇ ret´ ınsk´ y. Limit-deterministic B¨ uchi automata for linear
temporal logic. In Proc. 28th Int. Conf. on Computer Aided Verification , volume 9780 of Lecture
Notes in Computer Science , pages 312–332. Springer, 2016.
[40] M.Y. Vardi and P. Wolper. Reasoning about infinite computations. Information and Computa-
tion, 115(1):1–37, 1994.
A Missing Details
A.1 Missing details in Remark 3.1
Consider the tDBW Dn=⟨Σn,2[n]× {a, c},⟨∅, c⟩, δ, α⟩, defined as follows (see Figure 3). The state
space of Dnconsists of two copies of subsets of [ n]: the a-copy 2[n]× {a}, with “a” standing for
“accumulate”, and the c-copy 2[n]×{c}, with “c” standing for “check”. Essentially, the state ⟨S, a⟩in
thea-copy remembers that we have read only numbers in [ n] after the last $ and also remembers the
setS⊆[n] of these numbers. The state ⟨S, c⟩in the c-copy remmbers, in addition, that we have just
read #. Accordingly, ⟨S, c⟩checks whether the next letter is in Sin order to traverse α. Effectively,
Dntraverses αwhen a good infix is detected. Formally, for every state ⟨S, o⟩ ∈2[n]×{a, c}, and letter
σ∈Σn, we define:
δ(⟨S, a⟩, σ) =

⟨S∪ {σ}, a⟩,ifσ∈[n]
⟨S, c⟩, ifσ= #
⟨∅, a⟩, ifσ= $δ(⟨S, c⟩, σ) =(
⟨∅, c⟩,ifσ̸= $
⟨∅, a⟩,ifσ= $
Also, α={⟨⟨S, c⟩, σ,⟨∅, c⟩⟩:σ∈S}.
Note that reading $ from any state we move to ⟨∅, a⟩to detect a good infix, and if at some point
we read an unexpected letter, we move to ⟨∅, c⟩, where we wait for $ to be read. It is easy to see that
Dnrecognizes Lnand has 2n+1states.
27Figure 3: The tDBW Dn. For a finite word x∈[n]+, we denote the set of numbers that appear in x
byS(x). Dashed transitions are α-transitions.
A.2 Missing details in Remark 4.1
Consider the tDCW Dn=⟨Σn∪{$},(2[n]×{a, c})∪{qpass},⟨∅, c⟩, δ, α⟩defined as follows (see Figure 4).
The state space of Dnconsists of a state qpassand two copies of subsets of [ n]: the a-copy 2[n]×{a}, with
“a” standing for “accumulate”, and the c-copy 2[n]× {c}, with “c” standing for “check”. Essentially,
the state ⟨S, a⟩in the a-copy remembers that we have read only numbers in [ n] after the last $ and also
remembers the set S⊆[n] of these numbers. The state ⟨S, c⟩in the c-copy remembers, in addition,
that we have just read #. Accordingly, the state ⟨S, c⟩, for a nonempty set S, checks whether the
next letter is in Sand moves to the state qpassvia a transition in αonly when the check passes. The
fact that the above transitions are in α, and we can move from qpassback to ⟨∅, a⟩upon reading $
and without traversing α, imply that qpasscan trap runs that do not traverse αon words of the form
z1·z2···, where for all l≥1zlis good. Formally, for every state ⟨S, o⟩ ∈2[n]× {a, c}, and letter
σ∈Σn∪ {$}, we define:
δ(⟨S, o⟩, σ) =

⟨S∪ {σ}, a⟩,ifo=aandσ∈[n]
⟨S, c⟩, ifo=a, S̸=∅andσ= #
qpass, ifo=candσ∈S
⟨∅, c⟩, if⟨S, o⟩=⟨∅, c⟩andσ=¬$
⟨∅, c⟩, ifo=candσ∈([n]∪ {#})\S
⟨∅, a⟩, ifσ= $
⟨∅, c⟩, if⟨S, o⟩=⟨∅, a⟩andσ= #
where all types transitions are in αexcept for the last three. In addition, by reading a letter σ
from qpasswe move to ⟨∅, a⟩via a transition in αwhen σ= $, and otherwise, we move to ⟨∅, c⟩via an
α-transition. Note that by reading $ from any state we move to ⟨∅, a⟩to detect a suffix of the form
z1·z2···, where for all l≥1zlis good, and if at some point we read an unexpected letter, we move
to⟨∅, c⟩, where we wait for $ to be read.
It is easy to see that Dnrecognizes Lnand has 2n+1+ 1 states.
28Figure 4: The tDCW Dn. For a finite word x∈[n]+, we denote the set of numbers that appear in x
byS(x). Dashed transitions are α-transitions.
29
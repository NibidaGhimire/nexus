arXiv:2303.14338v2  [cs.AI]  20 Jun 2023From Gödel’s Incompleteness Theorem
to the completeness of bot beliefs
(Extended abstract)
Dusko Pavlovic∗1and Temra Pavlovic**
1University of Hawaii, Honolulu HI
Abstract
Hilbert and Ackermann asked for a method to consistently ext end incomplete theories
to complete theories. Gödel essentially proved that any the ory capable of encoding its
own statements and their proofs contains statements that ar e true but not provable.
Hilbert did not accept that Gödel’s construction answered h is question, and in his late
writings and lectures, Gödel agreed that it did not, since th eories can be completed
incrementally, by adding axioms to prove ever more true stat ements, as science normally
does, with completeness as the vanishing point. This pragma tic view of validity is
familiar not only to scientists who conjecture test hypothe ses but also to real-estate
agents and other dealers, who conjure claims, albeit invali d, as necessary to close a
deal, conﬁdent that they will be able to conjure other claims , albeit invalid, suﬃcient
to make the ﬁrst claims valid. We study the underlying logica l process and describe
the trajectories leading to testable but unfalsiﬁable theo ries to which bots and other
automated learners are likely to converge.
1 Introduction
Logic as the theory of theories was originally developed to p rove true statements. Here we
study developments in the opposite direction: modifying in terpretations to make true some
previously false statements. In modal logic, such logical p rocesses have been modeled as
instances of belief update [2, 3, 10]. In the practice of science, such processes arise w hen
theories are updated to explain new observations [22, Ch. 4] . In public life, the goal of such
processes is to inﬂuence some public perceptions to better s uit some private preferences [11,
∗Partially supported by NSF and AFOSR.
1Part V]. This range of applications gave rise to a gamut of tec hniques for inﬂuence and belief
engineering, covering the space from unsupervised learnin g to conditioning.
From incomplete theories to complete beliefs. The idea to incrementally complete in-
complete theories [9] arose soon after Gödel proved his Inco mpleteness Theorem [14]. Alan
Turing wrote a thesis about ordinal towers of completions an d discovered the hierarchy of
unsolvability degrees [35]. The core idea was to keep recogn izing and adding true but unprov-
able statements to theories. In the meantime, interests shi fted from making true statements
provable to making false statements true. Many toy examples of belief updates and revisions
have been formalized and studied in dynamic-epistemic logi c [4, 7], but the advances in belief
engineering and the resulting industry of inﬂuence overtoo k the theory at great speed, and
turned several corners of market and political monetizatio ns. The theory remained frag-
mented even on its own. While modal presentations of Gödel’s theorems appeared early on
[33], the computational ideas, that made his self-referent ial constructions possible [34], never
transpired back into modal logic. The point of the present paper is that combining belief
updates with universal languages and self-reference leads to a curious new logical capability,
whereby theories and models can be steered to assure consist ency and completeness of future
updates. This capability precludes disproving current beliefs and t he framework becomes
belief-complete in a suitable formal sense, discussed below.
The logical framework combining belief updates and univers al languages may seem unfamil-
iar. The main body of this paper is devoted to an attempt to des cribe how it arises from
familiar logical frameworks. Here we try to clarify the unde rlying ideas.
Universality. Just like Gödel’s incompleteness theorems, our constructi ons of unfalsiﬁable
beliefs are based on a universal language L. The abstract characterization of universality,
which we borrow from [24, Ch. 2], is that Lcomes equipped with a family of interpreters
{}:L×A− →B, one for each pair of types1A,B, such that every function f:A− →Bhas a
description2/rightanglenwf/rightangleneinL, satisfying3
f={/rightanglenwf/rightanglene} (1)
This is spelled out in Sec. 4. The construction in Sec. 5 will i mply that every g:L×A− →B
has a ﬁxpoint Γ, satisfying
g(Γ,a) ={Γ}(a) (2)
Any complete programming language can be used as L. Its interpreters support (1) and its
specializers induce (2). A suﬃciently expressive software speciﬁcation framework [28] would
also ﬁt the bill, as would a general scientiﬁc formalism [22] .
1Each pair carries a diﬀerent interpreter {}AB
but we elide the superscripts.
2There may be many descriptions for each fand/rightanglenwf/rightanglenerefers to an arbitrary one.
3The curly bracket notation allows abbreviating λa.{}(p,a)to{p}.
2Gödel’s incompleteness: true but unprovable statement. Gödel used the set of
natural numbers NasL, with arithmetic making it into a programming language. The
concept of a programming language did not yet exist, but it ca me into existence through
Gödel’s construction. An arithmetic expression specifyin g a function fwas encoded as a
number/rightanglenwf/rightangleneand decoded by an arithmetic function {}:N×N− →Nas in (1). A restriction
of (2) was proved for arithmetic predicates p:N− →B, where B={0,1}⊂N, and a ﬁxpoint
of a predicate g:L×A− →Bwas constructed as a predicate encoding /rightanglenwγ/rightanglenesatisfying4
g(/rightanglenwγ/rightanglene,a) ={/rightanglenwγ/rightanglene}(a) =γ(a) (3)
To complete the incompleteness proof, Gödel constructed a p redicate¶:N− →Bcharacter-
izing provability in formal arithmetic:
¶(/rightanglenwp/rightanglene,a)⇐⇒ ⊢ p(a) (4)
for all arithmetic predicates p:N− →B. Although proofs may be arbitrarily large, they are
always ﬁnite, and if p(a)has a proof,¶will eventually ﬁnd it. On the other hand, since
arithmetic predicates, like all arithmetic functions, sat isfyp={/rightanglenwp/rightanglene}, we also have
¶(/rightanglenwp/rightanglene,a) ={/rightanglenwp/rightanglene}(a) =p(a) (5)
Settingg(p,a) =¶(/rightanglenw¬p/rightanglene,a)in (2) induces a ﬁxpoint γwith
¶(/rightanglenw¬γ/rightanglene,a)(3)={/rightanglenwγ/rightanglene}(a)(5)=¶(/rightanglenwγ/rightanglene,a) (6)
But (4) then implies
⊢¬γ(a)⇐⇒ ⊢ γ(a) (7)
which means that neither γnor¬γcan be provable. On the other hand, the disjunction
γ∨¬γis classically true. The statement γ∨¬γis thus true but not provable, and arithmetic
is therefore incomplete.
Belief completeness: universal updating. Remarkably, the same encoding-ﬁxpoint
conundrum (1–2), which leads to the incompleteness of stati c theories, also leads to the
completeness of dynamically updated theories. Updating is presented as state dependency.
The function fin (1) is now in the form f:X×A− →X×BwhereXis the state space.
It may be more intuitive to think of fas aprocess , since it captures state changes5. We
conveniently present it as a pair f=/an}bracketle{tf′,f′′/an}bracketri}ht, wheref′:X×A− →Xis thenext state update,
whereas f′′:X×A− →Bis anX-indexed family of functions f′′
x:A− →B. The elements
4Although this discussion is semi-formal, it may be helpful t o bear in mind that the equality {/rightanglenwγ/rightanglene}(a) =
γ(a)isextensional : it just says that interpreting the description /rightanglenwγ/rightangleneon a value aalways outputs the value
γ(a). But the process whereby {/rightanglenwγ/rightanglene}(a)arrives at this value may be diﬀerent from a given direct eval uation
ofγ(a).
5In automata theory, such functions are called the Mealy machines .
3of the universal language Lare now construed as belief states . Its universality means that
every observable state xfrom any state space Xis expressible as a belief. The interpreters
{}:L×A− →L×Bare also presented as pairs {}=/angbracketleftbig
{}′,{}′′/angbracketrightbig
, where{}′:L×A− →L
updates the belief states whereas {}′′:L×A− →Bevaluates beliefs to functions. Just like
every state xinXdetermines a function f′′
x:A− →B, every belief ℓinLdetermines a
function{ℓ}′′:A− →B, which makes predictions based on the current belief. Gener alizing
the ﬁxpoint construction (2), every process f=/an}bracketle{tf′,f′′/an}bracketri}ht:X×A− →X×Bnow induces an
assignment /llbracketf/rrbracket:X− →Lof beliefs to states such that
{/llbracketf/rrbracket(x)}′=/llbracketf/rrbracket(f′
x){/llbracketf/rrbracket(x)}′′=f′′
x (8)
The construction of /llbracketf/rrbracketis presented in Sec. 6. Here we propose an interpretation. Th e
second equation says that the output component of {}behaves as it did in (1): it interprets
the description /llbracketf/rrbracket(x)and recovers the function f′′
xexecuted by the process fat the state
x. The ﬁrst equation says that the interpreter {}maps the /llbracketf/rrbracket-description of the state xto
the/llbracketf/rrbracket-description of the updated state f′
x:
f′:x/mapsto−→f′
x
{}′:/llbracketf/rrbracket(x)/mapsto−→/llbracketf/rrbracket(f′
x)(9)
Any state change caused by the process fis thus explained by a belief update of /llbracketf/rrbracketalong
{}. Interpreting the belief states /llbracketf/rrbracketby the interpreter {}provides belief updates that can
be construed as explanations in the language Lof any state changes in the process f. All
that can be learned about fis already expressed in /llbracketf/rrbracketand all state changes that may be
observed will be explained by the updates anticipated by the current belief, as indicated in
(9). The belief is complete.
Remark. In coalgebra and process calculus, the universal interpret ers{}:L×A− →L×B
would be characterized as weakly ﬁnal simulators [30]. They are universal in the sense that
the same state space Lworks for all types A,B. See [24, Sec. 7.2] for details and references.
The logic of going dynamic. When Lis a programming language, the interpreter {}
interprets programs as computable functions A− →B, whereAandBare types, usually
predicates that allow type checking. When Lis a language of software speciﬁcations or
scientiﬁc theories construed as beliefs about the state of t he world, the interpreter {}updates
beliefs to explain the state changes observed in explainabl e processes X×A− →X×B, where
A,BandXare state spaces. States are usually also deﬁned by some pred icates, but their
purpose is not to be easy to check but to deﬁne the state change s as semantical reassignments.
This is spelled out in Sec. 2.1. Dynamic reassignments of mea ning bring us into the realm
ofdynamic logic . If the propositions from a lattice Tare used as assertions about the states
of the world or the states of our beliefs about the world, then the dynamic changes of these
assertions under the inﬂuence of events from a lattice Ecan be expressed in terms of Hoare
triples
A{e}B (10)
4saying that the event e∈Eafter the precondition A∈Tleads to the postcondition B∈T.
TheHoare logic of such statements was developed in the late 1960s as a method for reasoning
about programs. The algebra of events Ewas generated by program expressions, whereas
the propositional lattice Twas generated by formal versions of the comments inserted by
programmers into their code, to clarify the intended meanin gs of blocks of code [13, 17].
A triple (10) would thus correspond to a block of code e, a comment Adescribing the
assumed state before eis executed, as its precondition, and a comment Bdescribing the
guaranteed state after eis executed, as its postcondition. By formalizing the “assume-
guarantee” reasoning of software developers, the Hoare triples provid ed a stepping stone into
the logic of state transitions in general. The propositiona l algebra of dynamic logic can be
viewed as a monotone map
To×E×T−{−}−−−−−−→O
whereOis a lattice of truth values, whereas TandEare as above, and ToisTwith
the opposite order. If the lattice Tis complete, then each event e∈Einduces a Galois
connection
A⋊e⊢B⇐⇒A{e}B⇐⇒A⊢[e]B
determining a dynamic modality [e]:T − →T for every e∈E[31]. The induced interior
operation ([e]B)⋊E⊢Bsays that [e]Bis the weakest precondition that guarantees Bafter
e. The induced closure A⊢[e](A⋊e)says that A⋊eis the strongest postcondition that can
be guaranteed by the assumption Abeforee. In addition to formal program annotations,
dynamic logic found many other uses and interpretations [6, 10, 15]. Here we use it as a
backdrop for the coevolution of theories and their interpre tations.
Updating completeness. In static logic, a theory is complete when all statements tru e in a
reference model are provable in the theory. In dynamic logic , the model changes dynamically
and the true statements vary. There are diﬀerent ways in whic h the notion of completeness
can be generalized for dynamic situations. The notion of com pleteness that seems to be
of greatest practical interest is the requirement that the t heory and the model can be dy-
namically adapted to each other: the theory can be updated to make provable some true
statements or the model can be updated to make true some false statements. This require-
ment covers both the theory updates in science and the model u pdates by self-fulﬁlling and
belief-building announcements in various non-sciences. T he logical frameworks satisfying
such completeness requirements allow for matching current beliefs and future states.
2 World as a monoidal category
2.1 State spaces as objects
In computation, a state is a family of typed variables with a p artial assignment of values. In
science, a state is a family of observables, some with expect ed values. Formally, a state can
5be viewed as a family of predicates, or a theory in ﬁrst-order logic, with a speciﬁed model.
Both can be presented in the standard Tarskian format, where a theory is a quadruple of
sorts, operations, predicates, and axioms, and its interpr etation is an inductively deﬁned
model [8].
Theories as sketches. In this extended abstract, theories are presented as catego rical
sketches and their models are speciﬁed in extended functorial semant ics [1, 5, 19, 20, 21].
While this may not be the most popular view, it is succinct eno ugh to ﬁt into the available
space. The main constructions, presented in Sec. 4–6, do not depend on the choice of
presentation. The reader could thus skip to Sec. 3 and come ba ck as needed.
Deﬁnition 2.1. AcloneΣis a cartesian category6freely generated by sorts, operations, and
equational axioms of a logical theory. A theory is a pair Θ =/an}bracketle{tΣ,Γ/an}bracketri}ht, whereΣis a clone and
Γis a set of cones and cocones in Σ, capturing the general axioms7of the logical theory. A
model ofΘis a cartesian functor M: Σ− →Setmapping the Γ-cones into limit cones and
theΓ-cocones into colimit cocones. A state of belief (orbelief state ) is a triple
A=/an}bracketle{tΣA,ΓA,MA/an}bracketri}ht
whereΘA=/an}bracketle{tΣA,ΓA/an}bracketri}htis a theory andMAits model in a category Setof sets and functions.
An element of the model MAis called an observable of the state A.
States of Aas extensions of MA.The reference model MAdetermines the notion of
truth in the state space A. It expresses properties that may not be proved in the theory ΘA
or even eﬀectively speciﬁed8. The reference model MAshould thus not be thought of as a
single object of the category of all models of ΘAbut as the (accessible) subcategory of model
extensions ofMA. These model extensions are the states of the state space A. The structure
of a state space can be further reﬁned to capture other featur es of theories in science and
engineering, including their statistical and complexity- theoretic valuations [32, 36]. While
such reﬁnements have no direct impact on our considerations , they signal that we are in the
realm of inductive inference, which may feel unusual for the Tarskian framewor k of static
logic, normally concerned with deductive aspects. The fact that the theory ΘAhas a model
MAimplies that it is logically consistent but it does not imply that it is true within an
external frame of reference, a “reality” that may drive the state transitions, i.e. the processes
of extending and reinterpreting theories. The intuition is that the states in the space Aare
observables that may never be observed, since MAmay be incompatible with the actual
observations. The theory ΘAmay be consistent but wrong.
6We stick with the traditional terminology where a category i s cartesian when it has cartesian products.
The cartesian product preserving functors are abbreviated tocartesian functors . This clashes with the
standard terminology for morphisms between ﬁbrations, but ﬁbrations do not come about in this paper.
7Equational axioms could be subsumed among cones and cocones , and omitted from Σ, which would boil
down to the free category generated by sorts and operations.
8E.g., the set of all true statements of Peano arithmetic is ex pressed by its standard model, but most of
them cannot be described eﬀectively.
6Examples of state spaces include logical theories with standard mode ls that arise not only in
natural sciences but also in social systems, as policy forma lizations. A software speciﬁcation
with a reference implementation can also be viewed as a state space. Updates and evolution
of a software system can then be analyzed using a higher-orde r dynamic logic [12]. The
functorial semantics view was spelled out in [23], used in a s oftware synthesis tool [26, 28, 29],
and applied in algorithm design [25, 27].
2.2 Transitions as morphisms
Intuitively, a transition ffrom a state space Ato a state space Bis a speciﬁcation that
induces a transition from any A-state to a B-state. We ﬁrst consider the transitions arising
from reinterpreting theories and then expand to modifying t he reference models.
Deﬁnition 2.2. Aninterpretation of state space Ain a state space Bis a logical inter-
pretation of the theory ΘB=/an}bracketle{tΣB,ΓB/an}bracketri}htin the theory ΘA=/an}bracketle{tΣA,ΓA/an}bracketri}htwhich reduces the
reference modelMAtoMB. More precisely, an interpretation f:A− →Bis a cartesian
functorf: ΣA← −ΣBmapping ΓB-(co)cones to ΓA-(co)cones according to a given assign-
mentfΓ: ΓA← −ΓBand making the following diagram commute
ΣA ΣB
SetMA MBf
(11)
The modelsMAandMBmap the (co)cones from ΓAandΓBto (co)limits of sets, as required
by Def. 2.1.
Interpretations as assignments. The structure of interpretations of software speciﬁca-
tions and the method to compose them were spelled out in [23, 2 8]. Since software speciﬁ-
cations are ﬁnite, an interpretation f: ΣA← −ΣBboils down to a tuple of assignments
x1:=t1;x2:=t2;...;xn:=tn
of terms t=/an}bracketle{tt1,t2,...,t n/an}bracketri}htfromΣAto variables x=/an}bracketle{tx1,x2,...,x n/an}bracketri}htfromΣBin such a way
that, for each axiom γ∈ΓB, the substitution instance
f(γ) = [x:=t]γ
is a theorem derivable from the axioms in ΓA. In Hoare logic [17], a state transition f: ΣA← −
ΣBis presented as a triple ΘA{x:=t}ΘB. By deﬁnition, this triple is valid if and only if
ΘA⊢[x:=t]ΘB, where[x:=t]ΘBis the result substituting the ΘA-termstforΘB-variables
7xin all axioms γ∈ΓB. Condition (11) moreover requires that this theory interpr etation
recovers the model MBfrom the modelMA.
In general, however, it is not always possible to transform a ll computational states annotated
at all relevant program points into one another by mere subst itutions. That is why Hoare
logic does not boil down to the assignment clause, but speciﬁ es the meaning of other program
constants in other clauses, which can be viewed as more gener al state transitions.
Deﬁnition 2.3. Astate transition f:A− →Bis a cartesian functor f: ΘA← −ΘBmapping
ΓB-(co)cones to ΓA-(co)cones according to a given assignment fΓ: ΓA← −ΓBand moreover
making the following diagram commute
ΘA ΘB
SetMA MBf
(12)
whereMAis the extension of MAalong the completion ΣA֒→ΘAofΣAunder the limits
and colimits generated by ΓA; ditto forMB.
General sketches. In Def. 2.2, theories were presented as pairs Θ =/an}bracketle{tΣ,Γ/an}bracketri}ht, where the
category Σis comprised of sorts, operations, and equations of the theo ry, whereas the cones
and the cocones in Γspecify its predicates and axioms. In Def. 2.3, a theory Θis presented as
the category obtained by completing Σunder the limits and the colimits speciﬁed by Γ. This
general sketch, with the family of limit cones and colimit co cones from Γ, is now denoted Θ,
by abuse of notation. A detailed construction of this sketch can be found in [21, §4.2–3]. It
is a canonical view of the theory derived in the signature Σfrom the axioms Γ. Since the
category Θis theΓ-completion of Σ, any functorM: Σ− →Setmapping the Γ-(co)cones
inΣto (co)limit (co)cones in Sethas a unique Γ-preserving extension M: Θ− →Set. These
extensions are displayed in (11). The upshot of saturating t he sketches from Def. 2.2 in the
formΘ =/an}bracketle{tΣ,Γ/an}bracketri}htto the general sketches over Θin Def. 2.3 is that the general explainable
transitions are now simply the structure-preserving funct ors displayed in (11).
2.3 Monoidal category of state spaces and transitions
Let
•Ube the category of state spaces from Def. 2.1 and transitions from Def. 2.3, and let
•U•be the category of state spaces from Def. 2.1 and interpretat ions from Def. 2.2.
8In both cases, the monoidal structure is induced by the disjo int unions of theories:
A⊗B=/angbracketleftBig
ΣA+ΣB,ΓA+ΓB,[MA+MB]/angbracketrightBig
(13)
whereMA⊗B= [MA+MB]: ΣA+ΣBΓA⊗B−−−→SetmapsΣAlikeMAandΣBlikeMB. The
tensor unit is I=/an}bracketle{t⊥,⊥,∅/an}bracketri}ht, where the truth value ⊥denotes the inconsistent theory or
sketch, its only axiom, and ∅is its empty model. It obviously satisﬁes I⊗A=A=A⊗I.
The associativity of the tensor ⊗follows from the associativity of the disjoint union +. The
arrow part of⊗is induced by the disjoint unions as coproducts. The coprodu ct structure
equips every state space Awith a cartesian comonoid structure
A⊗A∆←−−−−− A
⊸•
−−−−→I (14)
ΣA+ΣA[id,id]−−−−→ΣA⊥←−−−⊥
This provides a categorical mechanism for cloning and erasi ng states, which makes some
observations repeatable and deletable, as required for tes ting in science and software engi-
neering. However, Uis not a cartesian category, and ⊗is not a cartesian product, because
some transitions f:A− →Bdo not in general boil down to functors ΣA← −ΣB, but only to
functors ΘA← −ΣB, whereΘAis a completion of ΣAunder the ΓA-(co)-limits. Intuitively,
this means that the axioms of the theory ΘBmay not be interpreted as axioms of ΘA, but
may be mapped into theorems, which only arise in the ΓA-completion. This captures the
uncloneable and undeletable states that arise in many scien ces, including physics of very
small or very large (quantum or cosmological) and economics . The only transitions that
preserve the cartesian structure (14) are the interpretati onsf:A− →B, with the underlying
functors ΣA← −ΣB. They form the category U•, which is the largest cartesian subcategory
ofU. If the states α∈U(I,A)are thought of as observables, the states a∈U•(I,A)are the
actual observations.
3 String diagrams
Constructions in monoidal categories yield to insightful p resentations in terms of string
diagrams [18, 24, Ch. 1]. We will need them to present the cons tructions like (2) and in
particular (8). While commutative diagrams like (11) displ ay compositions of morphisms and
abbreviate their equations, string diagrams display decompositions of morphisms. Monoidal
categories come with two composition operations: the categ orical (sequential) morphism
composition◦and the monoidal (parallel) composition ⊗. The former is drawn along the
vertical axis, the latter along the horizontal axis. The obj ects are drawn as strings, the
morphisms as boxes. A morphism Af− →Bis presented as a box fwith a string Ahanging
from the bottom and a string Bsticking out from the top. The identities are presented as
invisible boxes: the identity on Ais just the string A. The unit type Iis presented as the
9invisible string. There are thus boxes with no strings attac hed. The composite morphism
g◦f= (Af− →Bg− →C)is drawn bottom-up, by hanging the box fon the string Bunder the
boxg. The monoidal composition is presented as the horizontal ad jacency: the composite
(g◦f)⊗(s◦t)is drawn by placing the boxes g◦fnext to the boxes for s◦t:
B
AfgC
UV
t
f⊗tg◦f
sW
(15)
The middle-two-interchange law (g◦f)⊗(s◦t) = (g⊗s)◦(f⊗t)corresponds to the two
ways of reading the diagram: vertical-ﬁrst and horizontal- ﬁrst, marked by the red and the
blue rectangle respectively. The string diagrams correspo nding to the cartesian comonoids
(14) are
A AA A
⊸•
∆(16)
The equations that make them into commutative comonoids loo k like this:
= == =
State parametrization and updating. Products A⊗Bdenote a space where AandB
but do not interfere. In a diagram, they are just parallel str ings. Since the product states
from the space X⊗Ado not interfere, a transition g:X⊗A− →Bcan be viewed as X-
parametrized family gx:A− →B, as it was viewed in Sec. 1. Since the product states from
X⊗Balso remain separate, a transition q:X⊗A− →X⊗Bcan be viewed as X-updating
10process, as it was also viewed in Sec. 1. The corresponding st ring diagrams are
B
X AgB
X AX
q(17)
Shape conventions. While the boxes in (15) and (17) are rectangular, the cartesi an “boxes”
in (16) are reduced to black dots. In general, the boxes denot ing general transitions can vary
in shape, and ﬁxed shapes are used for generic notations. E.g ., the interpreters, introduced
in (19) below, are denoted by trapezoids, and the interpreta tions, that are fed to them, by
triangles. A black dot on a box signals that it is cartesian, i .e. belongs toU•.
Projections. Using the cartesian structure from (16), a state updating tr ansitionqcan still
be decomposed like before
q′=/parenleftbigg
X⊗Aq− →X×Bid⊗
⊸•
−−→X/parenrightbigg
q′′=/parenleftbigg
X⊗Aq− →X⊗B
⊸•⊗id−−→B/parenrightbigg
(18)
In general, however, although the transitions u:Z− →Uandv:Z− →Vcan be paired into
/an}bracketle{tu,v/an}bracketri}ht= (Z∆− →Z⊗Zu⊗v−−→U⊗V), the pair/an}bracketle{tq′,q′′/an}bracketri}htmay not be equal to qin the universeU,
unless it happens to be cloneable, in the sense that it commut es with∆.
4 Universal language
A theory of theories, such as the categorical theory of sketc hes, is a theory. Category theory
is also a theory and functorial semantics provides a categor ical theory of reference models.
The theory of state spaces from Sec. 2.1 can thus be formalize d and presented as a state
space in the category U. The theory of state spaces from Sec. 2.1 can thus be formaliz ed into
a sketch with a reference model and presented as a state space in the categoryU. The theory
of state transitions from Sec. 2.2 is another sketch, and wit h another reference model it is
also a state space in U. Call it L. The fact that the states in Lcorrespond to the transitions
inUmeans that it satisﬁes a parametrized version of (1). It is a u niversal language for U.
Its interpreters follow from its deﬁnition, as the models of the theory of transitions. Since
there is no room here to spell out the details of a theory of tra nsitions and show that the
correspondence of its cartesian models and the transitions inUequips Lwith all interpreters,
we postulate the existence of the interpreters by the follow ing deﬁnition.
Deﬁnition 4.1. Anuniversal interpreter for state spaces A,Bis a transition{}:L⊗A− →B
inUwhich is universal for all parametric families of transitio ns fromAtoB. This means
11that for any state space Xand any transition g∈U(X⊗A,B)there is an interpretation
G∈U•(X,L)with
{}
=PB B
X Ag
G
X A•(19)
On one hand, a universal interpreter is universal for parame tric families. On the other hand,
it is a parametric family itself. It is thus capable of interp reting itself. This capability of self-
reﬂection was crucial for Gödel’s incompleteness construc tion. This capability is embodied
in the specializers , which are derived directly from Def 4.1.
Lemma 4.2. For anyX,A,B there is an interpretation []∈U•(L×X,L)which specializes
from a given X⊗A-interpreter to an A-interpreter, in the sense
{}
=LB B
X A{}
[]
X A•
L L(20)
Hoare logic of interpreters and specializers. If interpreters are presented as Hoare
triples in the form (X⊗A){G}B, and ifX[G]denotes a specialization of GtoXas above,
then (20) can be written as the invertible Hoare rule
(X⊗A){G}B
= ========== =
A{X[G]}B
Explanations. Interpretations (in the sense of Def. 2.2) of arbitrary stat es from some space
XalongG∈U•(X,L)in a universal language Lcan be construed as explanations . IfL
is a programming language, they are programs. The idea that e xplaining a process means
programming a computation has been pursued in theory of scie nce from various directions
[22, and references therein]. A universal language Lis thus a universal space of explanations.
The idea of programming languages as universal state spaces is pursued in [24, Ch. 7].
12Just like any universal programming language makes every co mputation programmable, any
universal language from Def. 4.1 makes any observable trans ition explainable. What we
cannot explain, we cannot recognize, and therefore we canno t observe. But it gets funny
when we take into account how our explanations inﬂuence our o bservations, and how our
current explanations can be made to steer future observatio ns. This is sketched in the next
two sections.
5 Self-explanations
When a state change depends on our explanations, then we can ﬁ nd an explanation consistent
with its own impact: the state changes the way the explanatio n predicts. More precisely,
if a family of transitions in the form t:L⊗X⊗A− →B, then the predictions tℓxcan be
steered by varying the explanations ℓfor every xuntil a family of explanations /rightanglenwt/rightanglene:X− →L
is found, which is self-conﬁrming at all states x, i.e. it satisﬁes t(/rightanglenwt/rightanglenex,x,a) ={/rightanglenwt/rightanglenex}a.
Proposition 5.1. For any belief transition t∈U(L⊗X⊗A,B)there is an explanation
/rightanglenwt/rightanglene∈U•(X,L)such that
• •
A AtB B
{}=
/rightanglenwt/rightanglene /rightanglenw t/rightanglene
X X•(21)
Proof. LetT∈U•(X,L)be an explanation of the transition on the left in (21).
•• •
A A[]tB B
{} =
T
X X(22)
13Hexists by Def. 4.1. Then /rightanglenwt/rightanglenex= [Tx]is self-conﬁrming, because
•• •
A A[]tB B
{} =
T
X X•T
••T
AB
{} =
X•T
AB
{} =
••[]
X•T•/rightanglenwt/rightanglene /rightanglenwt/rightanglene
•(23)
6 Unfalsiﬁable explanations
A transition in the form q:X⊗A− →X⊗Bupdates the state xon input ato a state x′=q′
x(a)
inXand moreover produces an output b=q′′
x(a)inB. A correct explanation /llbracketq/rrbracket:X− →L
of the process qmust correctly predict the next state and the output. The pre dictions
are extracted from an explanation by the interpreter {}. In this case, the predictions of
an explanation /llbracketq/rrbracketof the process qat a state xand on an input awill be in the form
{/llbracketq/rrbracketx}(a)inX⊗B. A correct prediction of the output b=q′′
x(a)is simply{/llbracketq/rrbracketx}′′(a) =b.
However, the external state x′=q′
x(a)may not be directly observable. It is believed to
be explained by /llbracketq/rrbracketx′. A correct prediction of the next state is thus a correct pred iction
of its explanation{/llbracketq/rrbracketx}′(a) =/llbracketq/rrbracketx′. At each state x, the explanation /llbracketq/rrbracketxis required
to anticipate the explanations /llbracketq/rrbracketx′of all future states and be consistent with them. If the
explanation /llbracketq/rrbracketx′at a future state x′=q′
x(a)is found to be inconsistent with the explanation
{/llbracketq/rrbracketx}′(a), then the explanations /llbracketq/rrbracketof the process qhave been proven false. This is the
standard process of testing explanations. Our claim is, how ever, that a universal language
allows constructing testable but unfalsiﬁable explanations , that remain consistent at all future
states. This persistent consistency can be viewed as a dynam ic form of completeness. It
is achieved by predicting the state updates of the given proc essqand anticipating their
explanations, as in the following construction.
Proposition 6.1. For any process q∈U(X⊗A,X⊗B)there is an explanation /llbracketq/rrbracket∈
14U•(X,L)which maintains consistency of all future explanations:
=L
X/llbracketq/rrbracket
AB
qL
X AB
•
•/llbracketq/rrbracket
{}(24)
Proof. Set/llbracketq/rrbracket= [Q]whereQis an explanation of the belief transition qpostcomposed with
a specialization over the state space Xof updates:
=
Qq•
•Q{}
•[]
=
Q•{}
•[](25)
7 From natural science to artiﬁcial delusions
7.1 What did we learn?
We sketched the category Uof state spaces A,B,... , comprised of theories with reference
models. A transition f:A− →Btransforms A-states to B-states. Such morphisms capture
theory expansions, reinterpretations, and map observable s of type Ato observables of type B.
They can be construed in terms of dynamic logic and support re asoning about the evolution
of software systems or scientiﬁc theories. The crucial poin t is that the category Ucontains a
universal language Lof explanations and belief updates. The self-reference in s uch languages
was the crux of Gödel’s incompleteness constructions. Whil e Gödel established that static
theories capable of self-reference cannot be complete or pr ove their own consistency, we note
thatdynamic theory and model updates allow constructing testable theor ies that preempt
falsiﬁcation. While a static model of a given theory ﬁxes a sp ace of true statements once and
15for all, the availability of dynamic semantical updates ope ns up the ﬂoodgates of changing
models and varying notions of truth. Faster learners conque r this space faster. The bots, as
the fastest learners among us, have been said to acquire thei r delusions from our training sets.
The presented constructions suggest that they may also beco me delusional by dynamically
updating their belief states and steering their current exp lanations of reality into persistent
consistency, resilient to further learning. They may also c ombine the empiric delusions from
our training sets with the logical delusions constructed in a universal language, leverage one
against the other, and get the best of both worlds.
But why would they do that?
7.2 Beyond true and false
Why did the Witches tell Macbeth that it is his destiny to be ki ng thereafter, whereupon he
proceeded to kill the King? Why did the Social Network have to convince its very ﬁrst users
that more than half of their friends were already users? Some statements only ever become
true if they are announced to be true when they are false. They are self-fulﬁlling prophecies.
There are also self-defeating claims. In the dynamic logic o f social interactions, most claims
interfere with their own truth values in one way or another. I f I convince enough people that
I am rich, I stand a better chance to become rich. If we convinc e enough people that this
research direction is promising and well-funded, it will be come well-funded and promising.
Just like true statements about nature help us to build machi nes and get ahead in the
universe, the manipulations of truth help us get ahead in soc iety. They are the high-level
patterns of language that used to be studied in early logic ri ght after the low-level patterns
of meaning (that used to be called “categories” ). If you train a bot to speak correctly, it will
start speaking convincingly as soon as it learns long enough n-grams. It will lie not only the
static lies contained in its training set but also the lies ge nerated dynamically, according to
the rules of rational interaction. Rhetorics used to be stud ied right after grammar, sophistic
argumentation after syllogisms, witchcraft arose from coo king, magic from tool building.
The bot religions arise along that well-trodden path.
We presented two constructions. One produces self-conﬁrmi ng explanations. The other one
explains all future states, so it is testable but not falsiﬁa ble. Science requires that its theories
are testable and falsiﬁable. Religion explains all future o bservations. If you train a bot on
long enough n-grams, it may arrive at persistently unfalsiﬁable false be liefs.
Truth be told, all of the constructions presented in this ext ended abstract have only been
tested on toy examples. We may be just toying with logic. Neve rtheless, the fact that
semantical assignments are programmable , tacitly established by Gödel and mostly ignored
as an elephant in the room of logic ever since, seems to call fo r attention, as beliefs transition
beyond the human carriers.
16References
[1] Jiři Adámek and Jiři Rosický. Locally Presentable and Accessible Categories . Number
189 in London Mathematical Society Lecture Notes. Cambridg e University Press, 1994.
[2] Alexandru Baltag, Bob Coecke, and Mehrnoosh Sadrzadeh. Epistemic actions as re-
sources. Journal of Logic and Computation , 17:555–585, 2007.
[3] Alexandru Baltag and Lawrence S. Moss. Logics for episte mic programs. Synthese ,
139:165–224, 2004.
[4] Alexandru Baltag and Mehrnoosh Sadrzadeh. The algebra o f multi-agent dynamic belief
revision. Electronic Notes in Theoretical Computer Science , 157:37–56, 2006.
[5] Andrée Bastiani and Charles Ehresmann. Categories of sk etched structures. Cahiers de
topologie et géométrie diﬀérentielle catégoriques , 13(2):104–214, 1972.
[6] Johan van Benthem. Language in Action: Categories, Lambdas and Dynamic Logic .
North-Holland, 1995.
[7] Johan van Benthem. Logical Dynamics of Information and Interaction . Cambridge
University Press, 2011.
[8] Chen Chung Chang and Jerome Keisler. Model Theory . Number 73 in Studies in Logic
and the Foundations of Mathematics. North-Holland, 1973. T hird edition, 1990.
[9] Martin Davis, editor. The Undecidable : Basic papers on undecidable propositions ,
unsolvable problems, and computable functions . Raven Press, Helwett, N.Y., 1965.
[10] Hans van Ditmarsch, Wiebe van der Hoek, and Barteld Kooi .Dynamic Epistemic Logic .
Synthese Library. Springer Netherlands, 2007.
[11] David Easley and Jon Kleinberg. Networks, Crowds, and Markets: Reasoning about a
Highly Connected World . Cambridge University Press, 2010.
[12] José-Luiz Fiadeiro, Ionut Tutu, Antonia Lopez, and Dus ko Pavlovic. Logics for Actor
Networks: A Case Study in Constrained Hybridization. J. of Logical and Algebraic
Methods in Programming , 106:141 – 166, 2019.
[13] Robert Floyd. Assigning meaning to programs. In J. T. Sc hwartz, editor, Mathemat-
ical Aspects of Computer Science , number 19 in Proceedings of Symposia in Applied
Mathematics, pages 19–32. American Mathematical Society, 1967.
[14] Kurt Gödel. Über formal unentscheidbare Sätze der Prin cipia Mathematica und ver-
wandter Systeme I. Monatshefte für Mathematik und Physik , 38:173–198, 1931. English
translations, “On Formally Undecidable Propositions of ‘P rincipia Mathematica’ and
Related Systems” published by Oliver and Boyd, 1962 and Dove r, 1992; also in [9],
pp. 5–38 and [16], pp. 596–616;.
17[15] D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic . Foundations of Computing. MIT
Press, 2000.
[16] Jean van Heijenoort, editor. From Frege to Gödel: a Source Book in Mathematical
Logic, 1879–1931 . Harvard University Press, 1967. Reprinted 1971, 1976.
[17] C. A. R. Hoare. An axiomatic basis for computer programm ing.Commun. ACM ,
12(10):576–580, oct 1969.
[18] André Joyal and Ross Street. The geometry of tensor calc ulus I. Adv. in Math. , 88:55–
113, 1991.
[19] Christian Lair. Catégories modelables et catégories e squissables. Diagrammes , 6:L1–
L20, 1981.
[20] Christian Lair. Catégories qualiﬁables et catégories esquissables. Diagrammes , 17:1–153,
1987.
[21] Michael Makkai and Robert Paré. Accessible Categories: the Foundations of Categorical
Model Theory . Number 104 in Contemporary Mathematics. American Mathema tical
Society, 1990.
[22] Eric Martin and Daniel N. Osherson. Elements of Scientiﬁc Inquiry . MIT Press, 1998.
[23] Dusko Pavlovic. Semantics of ﬁrst order parametric spe ciﬁcations. In J. Woodcock
and J. Wing, editors, Formal Methods ’99 , volume 1708 of Lecture Notes in Computer
Science , pages 155–172. Springer Verlag, 1999.
[24] Dusko Pavlovic. Programs as Diagrams: From Categorical Computability to Co mputable
Categories . Springer, 2023. to appear.
[25] Dusko Pavlovic, Peter Pepper, and Douglas R. Smith. Col imits for concurrent collectors.
In Nachum Dershowitz, editor, Veriﬁcation — Theory and Practice. Essays Dedicated
to Zohar Mana on the Occasion of His 64th Birthday , volume 2772 of Lecture Notes in
Computer Science , pages 568–597. Springer Verlag, 2003.
[26] Dusko Pavlovic, Peter Pepper, and Douglas R. Smith. Evo lving speciﬁcation engineer-
ing. In Jose Meseguer and Grigore Rosu, editors, Proceedings of AMAST 2008 , volume
5140 of Lecture Notes in Computer Science , pages 299–314. Springer Verlag, 2008.
[27] Dusko Pavlovic, Peter Pepper, and Douglas R. Smith. For mal derivation of concurrent
garbage collectors. In Jules Desharnais, editor, Proceedings of MPC 2010 , volume 6120
ofLecture Notes in Computer Science , pages 353–376. Springer Verlag, 2010. full version
arxiv.org:1006.4342.
[28] Dusko Pavlovic and Douglas R. Smith. Composition and re ﬁnement of behavioral spec-
iﬁcations. In Automated Software Engineering 2001. The Sixteenth Intern ational Con-
ference on Automated Software Engineering . IEEE, 2001.
18[29] Dusko Pavlovic and Douglas R. Smith. Software developm ent by reﬁnement. In Bern-
hard K. Aichernig and Tom Maibaum, editors, Formal Methods at the Crossroads , vol-
ume 2757 of Lecture Notes in Computer Science . Springer Verlag, 2003.
[30] Dusko Pavlovic and Muzamil Yahia. Monoidal computer II I: A coalgebraic view of
computability and complexity. In C. Crîstea, editor, Coalgebraic Methods in Computer
Science (CMCS) 2018 — Selected Papers , volume 11202 of Lecture Notes in Computer
Science , pages 167–189. Springer, 2018. https://arxiv.org/abs/1704.04882 .
[31] Vaughan R. Pratt. Semantical considerations on Floyd- Hoare logic. In Proceedings of
17th Annual Symposium on Foundations of Computer Science (F oCS), pages 109–121.
IEEE, 1976.
[32] Jorma Rissanen. Information and Complexity in Statistical Modeling . Information
Science and Statistics. Springer, New York, 2007.
[33] Barkley Rosser. Extensions of some theorems of Gödel an d Church. Journal of Symbolic
Logic, 1:87–91, 1936. Reprinted in [9].
[34] Craig Smorynski. Self-Reference and Modal Logic . Universitext. Springer New York,
2012.
[35] Alan M. Turing. Systems of logic based on ordinals. Proc. of the London Mathematical
Society. Second Series , 45:161–228, 1939. Reprinted in [9].
[36] Christopher S. Wallace. Statistical and Inductive Inference by Minimum Message
Length . Information Science and Statistics. Springer, 2005.
19
arXiv:2401.10008v1  [cs.CR]  18 Jan 2024Attack tree metrics are operad algebras
Milan Lopuha¨ a-Zwakenberg
University of Twente
Enschede, the Netherlands
m.a.lopuhaa@utwente.nl
Abstract —Attack Trees (ATs) are a widely used tool for
security analysis. ATs can be employed in quantitative secu rity
analysis through metrics, which assign a security value to a n AT.
Many different AT metrics exist, and there exist multiple ge neral
deﬁnitions that aim to study a wide variety of AT metrics at
once. However, these all have drawbacks: they do not capture all
metrics, and they do not easily generalize to extensions of A Ts.
In this paper, we introduce a deﬁnition of AT metrics based on
category theory, speciﬁcally operad algebras. This encomp asses
all previous deﬁnitions of AT metrics, and is easily general ized
to extensions of ATs. Furthermore, we show that under easily
expressed operad-theoretic conditions, existing metric c alculation
algorithms can be extended in considerable generality.
Index Terms —Attack trees, security analysis, operads, category
theory
I. I NTRODUCTION
OR AND BAS
rrob bank
fs
blby force steal
break in lockpicks
Fig. 1: Attack tree of an at-
tacker robbing a bank ( r). They
can either take the money by
force (f), or they steal the
money (s) by purchasing lock-
picks for the vault ( l) and
breaking in at night ( b).Attack trees (ATs) are hierar-
chical diagrams that categorize
and classify the vulnerabilities
of a (high-tech) system. ATs
have been employed in a vari-
ety of settings, such as railway
control systems [9], smart grids
[2] and nuclear control systems
[15]. ATs consist of basic at-
tack steps (BASs), indivisible
basic actions which can be per-
formed by an adversary, as well
asAND/OR-gates whose activa-
tion depends on the activation
of their children. An attack is
considered succesful if the top
node is activated. Note that an
AT is not necessarily a tree, as
a node may have multiple parents. Besides ‘standard’ ATs
numerous extensions exists, usually with extra gates, such as
sequential AND-gates [14] or defenses [17].
Apart from the qualitative analysis of categorizing all at-
tacks, ATs can also be used for quantitative analysis, in whi ch
a system’s vulnerability is expressed by a security value. T his
is usually done by assigning a value to each BAS, and then
using these to calculate the system’s value. For instance, e ach
BAS can be assigned a cost value representing the resources
the attacker has to spend to perform this BAS; given these, th e
min cost metric is then the minimal cost of a succesful attack
[28]. There are many other such metrics, such as the minimal
time of a succesful attack, mean time to compromise, orattack damage [24]. Because many AT metrics are relevant for
security analysis, there is a demand for a general framework
in which AT metrics can be formulated and computed.
Question. What is a general deﬁnition for AT metrics, and
what algorithms exist to calculate general AT metrics?
→
a bc→
T1 T2
T1T2
[14]2tamax{tb,tc}
[18]tamax{tb,tc}
[20]∞tb+tc
[21]∞max{tb,tc}
Fig. 2: The conﬂicting deﬁni-
tions of the min time metric
in previous work, for dynamic
ATsT1andT2. The time of
BASais denoted ta.Approaches to a generic for-
malization of AT metrics have
been proposed in the litera-
ture [23, 4, 20]. These assume
the metric to take values in a
semiring : a set in which the
BASs take their value (e.g.,
R≥0formin cost ), that has
two operations satisfying cer-
tain axioms [23], which are
used to deﬁne the AT’s secu-
rity value in terms of that of
the BASs. However, different
works have different ways of
deﬁning the AT metric in terms
of the BAS values, leading to
different, noncompatible deﬁ-
nitions of the same metric. For
instance, the min time metric of dynamic ATs (with a sequen-
tial AND gate) has four different deﬁnitions in the literatu re,
that are incompatible even for small examples, see Fig. 2. In
particular, there is not one deﬁnition of semiring metrics , but
at least three noncompatible ones, see Table 1.
The fact that many metrics have different, noncompatible
deﬁnitions is likely due to the fact many papers deﬁne their
metric along with a computation algorithm: min time as
deﬁned in [14] comes with a bottom-up algorithm, while the
min time of [18] is calculated via priced-timed automata. As a
result, metrics are often deﬁned in a way to ﬁt the algorithm,
at a cost of possibly being inconsistent with earlier litera ture.
Another approach is to deﬁne the metric directly from the
semantics [8, 21]; calculating these metrics is NP-hard.
Besides the existence of noncompatible metric formaliza-
tions, there are two other issues with existing AT metric
formalizations. First, there are still metrics that do not ﬁ t into
any existing framework, such as total attack probability [2 7].
Second, semiring formalizations are only deﬁned for standa rd
ATs (justAND/OR-gates). Extending them to extensions of ATs
typically requires a completely new deﬁnition [16, 20].
Summarizing the previous paragraphs, we conclude thatmetric type source cost time damage probability skill satisﬁability Pareto fr onts Operad metric?
standard ATs
Total attack probability [27] + yes
propositional semiring metrics [20] + + + + + + + yes
bottom-up semiring metrics [23] + + + + + + yes
set semantics semiring metrics [4] + + + + + + + yes
mean time to compromise [24] + yes/no
Dynamic ATs
well-formed propositional dynamic semiring [8] + yes
propositional dynamic semiring [21, 20] + yes
bottom-up dynamic semiring [14] + yes
priced-timed-automata [18] + + + + yes
Attack-defense trees
bottom-up attribute domain [16, 12] + + + + + + + yes
set semantics attribute domain [16] + + + + + + + no
TABLE I: Attack tree metric formalizations from the literat ure and the metrics that fall under their framework. Differe nt entries in one
column are noncompatible deﬁnitions. Most of these are uniﬁ ed under the operad algebra framework; for mean time to compromise this
comes at a loss of computational efﬁciency, see Section V.
there is a need for a formal framework for AT metrics that is
generic enough to capture all existing frameworks and metri cs,
and has straightforward extensions to extensions of ATs suc h
as dynamic ATs and attack-defense trees.
Contributions. In this paper, we create a single, compre-
hensive framework for AT metrics based on category theory.
This framework aims to encompass all sensible metrics; whil e
it is possible to construct pathological counterexamples, we
show that the necessary and sufﬁcient conditions for a metri c
to fall within our framework are completely natural, and
indeed are met by almost all metrics from the literature.
Hence, rather than adding yet another row to the table in
Fig. 2, we provide an overarching deﬁnition of which all
existing deﬁnitions are special cases. Furthermore, this n ew
framework has straightforward extensions to extensions of the
AT formalism. An overview of existing metrics and metric
formalisms that are now uniﬁed under a single framework is
given in Table I.
Existing deﬁnitions of AT metrics deﬁne how, given a value
xain a setXfor each BAS a, and an AT T, one calculates
a metric value xT∈X. We shift perspective, and in this
paper a metric assigns to each AT TwithnBASs a function
ϕT:Xn→Xthat maps the BAS values /vector xtoxT. This is more
easily understood in terms of operads [22], which generalize
sets of multivariate functions on a set. The sets Endn(X)of
mapsXn→X, together with a natural composition operation,
form an operad End(X). We show that ATs form an operad
AT; thus we deﬁne an AT metric as an operad morphism
ϕ: AT→End(X), i.e.,Xis an operad algebra . This
approach is closely related to other operad models of treeli ke
structures, such as phylogenetic trees [1] and proof trees [ 25].
Operads are a natural tool to formalize treelike structures , since
their composition operation mirrors the hierarchical natu re of
trees. Note that Xneed not be a set but can be an object
in a general category (e.g. topological spaces), which impl ies
special properties of the function ϕT(e.g. continuity).
Beyond the deﬁnition the operad algebra framework, we
also give a list of necessary and sufﬁcient conditions for an
AT metric to be considered an operad algebra. As our metric is
very general, these are almost always satisﬁed. Showing tha t ametric is an operad algebra has two advantages, the ﬁrst bein g
that it acts as a type of sanity check: the only nontrivial axi om
for an operad algebra is that the metric should respect the
hierarchical structure of attack trees. This is desired beh aviour
for many metric deﬁnitions, and operad algebras form a natur al
formalization for this.
Second, expressing a metric in the operad algebrad frame-
work gives access to the metric calculation algorithms deve l-
oped in this paper. By design, our deﬁnition is very general,
and we cannot hope for a fast general algorithm for all metric s,
especially since this is known to be NP-complete [20]. Inste ad,
we formulate two existing algorithms, the bottom-up algori thm
[23] and a BDD-based algorithm [20], in the language of
operad algebras, and we give sufﬁcient conditions on metric s
as to when they can be applied. Both are state-of-the-art for the
metrics to which they apply; thus there is no loss in efﬁcienc y
incurred by the increased generality of our framework.
As a ﬁnal contribution, this paper also showcases how the
operad algebra framework can be extended to extensions of
the AT formalism, by showing how this is done for dynamic
ATs [14] and attack-defense trees [17]. These extensions al so
generalize a number of metrics as summarized in Table I.
Contributions: We create generalized operad-theoretical
framework for attack tree metrics which:
1) encompasses a wide variety of existing AT metrics;
2) can straightforwardly be extended to extensions of the
AT formalism;
3) can be used in a general, category-theoretical setting;
4) has easy to understand necessary and sufﬁcient con-
ditions;
5) allows for a generalization of state-of-the-art metric
computation algorithms to a wide variety of metrics.
A. Related work
There are three approaches to deﬁning AT metrics in terms
of semirings. The ﬁrst one [23] deﬁnes a metric bottom-up:
At every node, a value is calculated based on its childrens’
values, with the operation determined by the type of gate. Th eAT’s metric value is the top node’s value. This approach has
also been extended to dynamic ATs [14] and attack-defense
trees [17]. By deﬁnition, these metrics are quickly compute d
via a bottom-up algorithm. However, this model assumes that
a node must be activated once for each parent. It can be argued
that this limits the scenarios that can be modeled by ATs [21] .
Another approach is to ﬁrst deﬁne a metric value to each
(minimal) succesful attack, and then combine them into a
single metric value for the AT [20]. For instance, for min
cost one ﬁrst calculates the cost of each succesful attack, and
then takes the minimum over all of these. This too can be
extended to attack-defense trees [16], and with a bit more
effort to dynamic ATs [20]. This approach is more ﬂexible
than the bottom-up approach, but calculating such metrics i s
NP-hard in general. In [20] a BDD-based approach to metric
calculation is proposed, which is still worst-case exponen tial,
but considerably faster in practice. The BDD approach has
also been applied to total attack probability [7]. The third
approach to semiring metrics [4] is a middle ground between
the ﬁrst two: ﬁrst a candidate set of attacks is created botto m-
up, and then this set is used as the set of minimal attacks
in the previous approach. The created set contains the set of
minimal attacks, so these metrics coincide with those of [20 ]
when minimal metrics are known to be optimal, which is true
for most but not all semirings.
Operads and their algebras originate in algebraic topology ,
but have many applications in other ﬁelds [22]. In computer
science, they have been applied to wiring diagrams [30],
design speciﬁcation [13], and information theory [5]. Oper ads
have also been used to model treelike structures such as
phylogenetic trees [1] and proof trees [25]. Finally, ATs ar e
closely related to fault trees, which are used in safety [19] .
Since the mathematical formalisms are the same, the results
of this paper can also be applied to fault tree metrics such as
mean time to fail .
Notation. Isomorphisms are written∼−→. Categories are
Set,Pos,Top,... The set{1,...,n}is written [n]forn∈Z≥0.
We letB={0,1}. Multisets are denoted {{...}}, with multiset
union denoted⊎.
II. A TTACK TREES
In this section, we review the formalism of ATs. They are
deﬁned as follows:
Deﬁnition II.1. Anattack tree is a tripleT= (N,E,γ),
where(N,E)is a rooted directed acyclic multigraph and γ
is a function γ:N→{OR,AND,BAS}, such thatγ(v) =BAS
if and only if vis a leaf of (N,E).
Multigraph here means that Eis a multiset in N×N,
meaning there can be multiple edges between two nodes. We
need this to model ATs such as T1in Fig. 2, as well as the
constructs that come up when we merge BASs in Section VII.
The root of Tis denoted RT, and the children of a node
vform the multiset ch(v) ={{w∈N|(v,w)∈E}}. If
ch(v) ={{v1,...,v n}}, we also write v=OR(v1,...,v n)or
AND(v1,...,v n)depending on γ(v); the order of the vidoesT[T′/a]
aT
a
T′
Fig. 3: Modular composition of ATs.
not matter here. The set of BASs is denoted BT; we write
Bif there is no confusion. For v∈N, we letTvbe the
full subDAG of Twith rootv, i.e., the DAG consisting of all
descendants of v. Note that despite their names, ATs are not
necessarily trees.
The role of an AT is to identify possible attacks on a system.
The set of attacks on TwithBT={a1,...,a n}isBn, where
/vectorb∈Bnrepresents the attack caused by activating all aifor
whichbi=1. The effect of an attack on the AT is given by its
structure function ST, whereST(/vectorb,v)∈Bexpresses whether
the attack/vectorbactivates the node v:
Deﬁnition II.2. LetTbe an AT with BT={a1,...,a n}.
Thestructure function ofTis the function ST:Bn×N→B
deﬁned as
ST(/vectorb,v) =

bi, ifv=ai,/logicalandtext
w∈ch(v)ST(/vectorb,w),ifγ(v) =AND,/logicalortext
w∈ch(v)ST(/vectorb,w),ifγ(v) =OR.
Deﬁnition II.3. An attack/vectorb∈Bnis called successful if
ST(/vectorb,RT) =1. The set of successful attacks on Tis denoted
SucT.
An important way of combining ATs is modular composi-
tion[11]: in an AT T, a BASais replaced by an entire AT T′,
to obtain the larger AT T[T′/a], see Fig. 3. This is used, for
instance, when in an AT created by a domain expert a BAS a,
which was ﬁrst considered its own indivisible event, is give n
its own AT to describe its failure conditions. Formally:
Deﬁnition II.4. LetT= (N,E,γ)andT′= (N′,E′,γ′)be
ATs withN∩N′=∅, and leta∈Nsuch thatγ(a) =BAS.
Then the modular composition T[T′/a] = (N′′,E′′,γ′′)is the
AT deﬁned as
N′′= (N\{a})∪N′,
γ′′(w) =/braceleftBigg
γ(w), ifw∈N,
γ′(w),ifw∈N′,
E′′={{(v,w)∈E|w/\e}atio\slash=a}}⊎E′
⊎{{(w,RT′)|w∈N,(w,a)∈E}}.
Besides categorizing succesful attacks on a system, ATs
can also be used in quantitative security analysis to calcul ate
security metrics, such as the minimal time or cost an attacke r
needs for a succesful attacks. Such metrics work by assignin gf
fi
σ(i)
σ−1 τσ(f)f
Fig. 4: The map τσ(f)represented diagrammatically: ﬁrst σ−1is
applied to permute the arguments, and then fis applied to the
permuted arguments.
a certain security value αato each BAS, and using these to
calculate a security value αTfor the AT. However, there are
many ways of deﬁning αTin terms of the αa, leading to
noncompatible deﬁnitions of AT metrics in the literature. I n the
following sections, we introduce an overarching framework .
The concept of ATs has been extended by multiple works to
meet the demands of more elaborate forms of security analysi s.
These extensions typically deﬁne new types of gates, such
as defense gates [17] or sequential AND-gates [14, 20]. Such
extensions often require completely new deﬁnitions of metr ics.
III. O PERADS
In this section we will deﬁne operads and their morphisms.
Operads arise as a way to axiomatize collections of maps
Xn→Xfor a setX[22]. Forn∈Z≥0and a setX, consider
the sets of maps Endn(X) :=Xn→X(soEnd0(X) =X).
As we range over n, the sets Endn(X)have the following
structures:
1) For each permutation σ: [n]∼−→[n]there is a map
τσ: End n(X)∼−→Endn(X)deﬁned as follows: for
f:Xn→Xand/vector x∈Xnone hasτσ(f)(/vector x) =
f(xσ(1),...,x σ(n)), see Fig. 4.
2) There is an element id∈End1(X)representing the
identityX∼−→X.
3) Letn∈Z≥1and letm1,...,m n∈Z≥0; and letf∈
Endn(X)andgi∈Endmi(X)for alli. We then deﬁne
the composition f⋆/vector g∈End/summationtext
imi(X)by ﬁrst applying
eachgito its own miarguments, and then applying
fto thenresulting outcomes. More formally, for all
x1,1,...,x 1,m1,...,x n,1,...,x n,mn∈X:
(f ⋆/vector g)(x1,1,...,x n,mn)
=f(g1(x1,1,...,x 1,m1),...,g n(xn,1...,xn,mn)).
The constructs τσ,id,⋆satisfy a number of different
properties; for instance id⋆f=ffor eachf∈Endn(X).
The idea behind operads is to take the collection of all
Endn(X),τσ,id,⋆as the primordial object, rather than the set
X; we call this new object End(X), the operad of maps on
X. Thus, an operad can be thought of as a collection of maps,
but examples will show that the deﬁnition is more general.
Deﬁnition III.1. Anoperad is a tupleO= (O,τ,id,⋆)
consisting of: a set Onfor eachn∈Z≥0; a bijection
τσ:On∼−→Onfor each bijection σ: [n]∼−→[n]; anf
g1
σ−1
1gn
σ−1
nf
τσ1(g1)f ⋆/vector g
(σ1,...,σ n)−1
Fig. 5: Axiom 4) of Deﬁnition III.1 for the endomorphism oper ad
End(X): Applying fto arguments of the form τσi(gi)yields the
same function as ﬁrst permuting all arguments via (σ1,...,σ n)−1
and then applying f ⋆/vector g .
elementid∈O1; and for each n,m1,...,m n∈Z≥0, a
map⋆:On×/producttextn
i=1Omi→O/summationtext
imi. These must satisfy the
following axioms:
1)For eachσ,σ′: [n]∼−→[n]one hasτσ◦σ′=τσ◦τσ′;
2)For eachnandf∈Onone has id⋆f=f ⋆
(id,...,id) =f;
3)For alln,m1,...,m n,k1,1,...,k n,mn∈Z≥0and for
allf∈On,gi∈Omiandhi,j∈Oki,jone has (i≤n
andj≤mi)
f ⋆(g1⋆(h1,1,...,h 1,m1),...,g n⋆(hn,1,...,h n,mn))
= (f ⋆/vector g)⋆/vectorh;
4)For alln,m1,...,m n∈Z≥0,f∈On,gi∈Omi, and
σi: [mi]∼−→[mi]one has
f ⋆(τσ1(g1),...,τ σn(gn)) =τ(σ1,...,σn)(f ⋆/vector g).
where(σ1,...,σ n): [/summationtext
imi]→[/summationtext
imi]is given by
(σ1,...,σ n)/parenleftbig/summationtext
i′<imi′+k/parenrightbig
=/summationtext
i′<imi′+σi(k), for
alli≤nandk≤mi+1.
5)For alln,m1,...,m n∈Z≥0,f∈On,gi∈Omi, and
σ: [n]∼−→[n]one has
τσ(f)⋆/vector g=f ⋆(gσ(1),...,g σ(n));
Most of these axioms are understandable from the perspec-
tive ofEndn(X). In 4), the permutation (σ1,...,σ n)keeps
then‘blocks’ of miconsecutive elements in place, while
permuting each block via σi. The equality is then shown for
End(X)by the diagram of Fig. 5.
Example III.2. Forn∈Z≥0, deﬁne∆n⊂Rn
≥0by
∆n=/braceleftBigg
/vector p∈Rn
≥0/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/summationdisplay
ipi= 1/bracerightBigg
(so∆0=∅); that is, ∆nis the set of probability distributions
on[n]. Furthermore, deﬁne
/vector p⋆(/vector q1,...,/vector q n) = (p1q1,1,...,p 1q1,m1,...,p nqn,mn).
One can interpret p⋆/vector q as a two-step probabilistic process: ﬁrst
one drawsX∈[n]via probability distribution p; and then one
drawsY∈[mX]via probability distribution qX. The resulting
random variable Y∈[/summationtext
imi]has probability distribution p⋆/vector q.
Upon deﬁning idandτσin a straightforward way, one obtains
theprobability operad ∆.Example III.3. The construction of the operad End(X)from
the beginning of this section can also be done in any symmetri c
monoidal category (C,⊗). For an object X∈obj(C), deﬁne
Endn(X) := Hom C(X⊗n,X). Thenidis again the identity
map, andτσis precomposition with the induced isomorphism
X⊗n∼−→X⊗nthat sends the σ(i)-th component to the i-th
component. Furthermore, f⋆/vector g is deﬁned to be the composition
X⊗/summationtext
imi∼−→n/circlemultiplydisplay
i=1X⊗mi/circlemultiplytext
igi−−−−→X⊗nf−→X.
This deﬁnes the operad EndC(X). We write End(X)whenC
is clear. In this paper, ⊗will always be the binary product (in
a category that has these).
Remark III.4. Some authors deﬁne a set OIfor each ﬁnite
setI, representing the maps XI→X[10]. This is ‘cleaner’ in
the sense that it does not assume an ordering on the arguments ;
the cost is paid in having a slightly more elaborate deﬁnitio n
ofτσ. The two deﬁnitions are equivalent via the identiﬁcation
On=O[n]. We choose our deﬁnition as it is more convenient
for our metric computation algorithms later on, as well as to
emphasize that we think of AT metrics as n-ary functions.
A. Operad algebras
The motivation behind deﬁning operads was to axiomatize
End(X). The link between operads and sets of functions can
be made more direct by considering operad algebras , which
are sets (or more generally, category objects) upon which an
operad acts. To deﬁne this, we ﬁrst deﬁne operad morphisms.
Deﬁnition III.5. LetO= (O,τ,id,⋆),O′= (O′,τ′,id,⋆)be
two operads. A morphismϕ:O→O′is a collection of maps
ϕn:On→O′
nfor eachn, such that:
1)For alln,m1,...,m n∈Z≥0andf∈On,gi∈Omi
one has
ϕ/summationtext
imi(f ⋆(g1,...,g n))
=ϕn(f)⋆(ϕm1(g),...,ϕ mn(g));
2)For each bijection σ: [n]∼−→[n]one hasϕn◦τσ=
τ′
σ◦ϕn.
We omit the subscript nfromϕn(f)whennis clear. As
one expects, an operad morphism is a map between operads
that preserves all relevant structure. An operad algebra is then
a morphism O→EndC(X).
Deﬁnition III.6. LetCbe a category with ﬁnite products, and
letObe an operad. An O-algebra inCis a pair(X,ϕ)where
Xis an object ofC, andϕ:O→EndC(X)is an operad
morphism.
Example III.7. LetXbe a convex subset of RNfor someN.
To deﬁne a ∆-algebra structure on X(in the category Set),
we need to deﬁne a map ϕ(/vector p):Xn→Xfor each/vector p∈∆n.
We do this by deﬁning ϕ(/vector p)(x1,...,x n) =/summationtextn
i=1pixi, which
can be shown to satisfy the axioms of Deﬁnition III.5. Note
that ifXis a linear subspace of RN, then this actually deﬁnesa∆-algebra in the category VecRof real vector spaces, since
eachϕ(/vector p)is a linear map.
IV. T HE ATTACK TREE OPERAD
In this section, we show how attack trees form an operad,
and we show how AT metrics can be deﬁned as algebras over
this operad. We ﬁrst deﬁne so-called anchored ATs, which are
necessary to deﬁne the sets ATnthat make up the operad AT.
Deﬁnition IV .1. LetT= (N,E,γ)andT′= (N′,E′,γ′)be
ATs withnBASs.
1)Ananchoring of Tis a bijection µ:BT∼−→[n]. The
pair(T,µ)is called an anchored AT .
2)Letµandµ′be anchorings of TandT′. An anchor iso-
morphism (T,µ)∼−→(T′,µ′)is a graph isomorphism
m:N∼−→N′, such thatγ=γ′◦mandµ=µ′◦m.
3)We call (T,µ),(T′,µ′)equivalent if there exists an
anchor isomorphism (T,µ)∼−→(T′,µ′).
We are now in a position to deﬁne the operad of attack trees.
The elements of ATnare anchored ATs with nBASs, and, as
we will make more precise below, ⋆is modular composition.
Deﬁnition IV .2. Forn∈Z≥0, letATnbe the set of equiv-
alence classes of anchored ATs with nBASs (so AT0=∅).
Letid∈AT1be the AT consisting of a single BAS. Let
T= (N,E,γ,µ )∈ATnandTi= (Ni,Ei,γi,µi)∈ATmi
for eachi≤n. AssumeNand theNiare pairwise disjoint.
We deﬁne (N′,E′,γ′,µ′) =T ⋆(T1,...,T n)∈AT/summationtext
imiby
N′={v∈N|γ(v)/\e}atio\slash=BAS}∪/uniondisplay
iNi,
E′={{(v,w)∈E|γ(w)/\e}atio\slash=BAS}}
⊎{{(v,RTi)|(v,µ−1(i))∈E}}⊎/unionmultidisplay
Ei,
γ′(v) =/braceleftBigg
γ(v),ifv∈N
γi(v)ifv∈Ni,
µ′(v) =/summationdisplay
i′<imi+µi(v)ifv∈Ni.
For eachσ: [n]∼−→[n]deﬁneτσ(T,µ) = (T,σ◦µ). Then
these data together deﬁne the Attack tree operad AT.
Every equivalence class in ATnhas a representative for
whichBT={a1,...,a n}andµ(ai) =i. Unless speciﬁed
otherwise, in what follows we always take such a represen-
tative, and we suppress µin the notation. The composition
T ⋆(T1,...,T n)has an elaborate deﬁnition, but it is just the
modular composition T[T1/a1,...,T n/an], i.e., each BAS ai
is replaced with the AT Ti.
The objects of ATare isomorphism classes of anchored
ATs, rather than (anchored) ATs themselves. This makes the
deﬁnition more elaborate, but is necessary to express the fa ct
that two ATs with the same gates and topological structure
should have the same metrics.
We are now in a position to deﬁne AT metrics. Traditionally,
a metric assigns to each T∈ATn, and each collection of BAS
values(xi)i≤n, where each xiis in a given set X, a valuexTrepresenting which is again in X. Shifting the perspective
slightly, a metric assigns to each T∈ATna mapXn→
X, whose input is (xn)i≤nand whose output is xT. In other
words, we have a map ATn→Endn(X), which then directly
leads to the following deﬁnition:
Deﬁnition IV .3 (AT metric) .LetCbe a category with ﬁnite
products. An attack tree metric inCis anAT-algebra inC.
The fact that an AT-algebra arises from an operad morphism
ϕ: AT→EndC(X)has an important implication: The
preservation of ⋆means that the metric allows for modular
analysis . To calculate the metric on T[T′/a]given thexifor
each BASai, ﬁrst calculate xT′usingϕ(T′), and then take
xa=xT′as an imput for ϕ(T)to calculatexT. Many existing
AT metrics have been shown to satisfy modular analysis [23,
21]; furthermore, modular analysis ﬁts within the philosop hy
that an AT can be reﬁned by replacing a BAS with a new AT
without affecting quantitative analysis. In the next secti on, we
will give necessary and sufﬁcient conditions for AT metrics to
fall under Deﬁnition IV .3.
Remark IV .4. We allow AT metrics to live in another category
than sets. This is mainly useful for stating that a metric is
structure-preserving in some way. For instance, the fact th at
for everyTthe map/vector x/mapsto→xTis continuous (order-preserving,
linear,...) means that the metric lives in the category Top
(Pos,VecR,...).
Example IV .5. 1) Consider the structure function STfrom
Deﬁnition II.2; we show how this can be interpreted
as an AT metric in the category Set. To do this,
we takeX=B, and we have to deﬁne a map
ϕstruc: ATn→Endn(B)for everyn≥1. This means
that for every AT TwithnBASs, we have to deﬁne a
mapϕstruc(T):Bn→B. The structure function can be
viewed as such, by taking ϕstruc(T)(/vectorb) = ST(/vectorb,RT)for
all/vectorb∈Bn. A straightforward, but technical proof shows
that thisϕstrucsatisﬁes Deﬁnition III.5, so (B,ϕstruc)
is an AT metric.
Since ATs do not contain NOT-gates, the function /vectorb/mapsto→
ST(/vectorb,RT)is monotonous. This means that we can re-
gardϕstrucas a map AT→EndPos(B), so(B,ϕstruc)is
anAT-algebra in Pos. We denote EndPos(B) =: MBool ,
the operad of monotonous Boolean functions.
2) Give a probability pi∈[0,1]to each BAS ai. The total
attack probability is
TAP(T,/vector p) =/summationdisplay
/vectorb∈SucTn/productdisplay
i=1pbi
i(1−pi)1−bi∈[0,1],
i.e.,TAP(T,/vector p)is the probability that an attack is
succesful given the compromise probabilities of all
BASs (recall that SucTis the set of all successful
attacks). Then ϕTAP: AT→End([0,1])given by
ϕTAP(T)(/vector p) = TAP( T,/vector p)is an operad morphism,
and so total attack probability is an AT metric (in thecategory of topological posets, in fact). It cannot be
written as one of the two semiring metrics below.
3) For an AT T, letMTbe the set of minimal elements in
SucT, for the partial order inherited from Bn; this is the
set of minimal succesful attacks, usually called minimal
attacks . Furthermore, let D= (X,△,▽)be a semiring,
i.e.,Xis a set,△and▽are binary commutative
associative operations on X, and▽distributes over△.
For/vector x∈Xn, the security metric ˆx(T)is deﬁned as
ˆx(T) =/hugetriangledown
/vectorb∈MT/hugetriangleup
i:bi=1xi. (1)
These are the propositional semiring metrics as deﬁned
in [20]. For example, if D= (Z≥0,min,+), thenˆxis
theminimal cost metric: the minimal cost an attacker
needs to succesfully attack the system.
Deﬁne a map ϕps
D,n: ATn→Endn(V)by
ϕps
D,n(T)(/vector x) = ˆx(T); this deﬁnes an AT-algebra
(X,ϕps
D)inSet. To show that ϕpsis an operad mor-
phism, i.e., that it preserves ⋆, is quite non-trivial;
compare Theorem 9.2 of [20]. Changing MTby other
sets of attacks in (1) yields different, noncompatible
metrics, see for instance the so-called set semantics of
[4].
4) LetT∈ATnand letx∈Xn, for a semiring D=
(X,△,▽). we extend xrecursively to a ˜x∈VNby
˜xv=

xi, ifv=bi,/bigtriangledown
w∈ch(v)˜xw,ifγ(v) =OR,/bigtriangleup
w∈ch(v)˜xw,ifγ(v) =AND.
The security metric for Tis then deﬁned ˜x(T) =
˜xRT. The map ϕbu
D,n: ATn→Endn(V)given by
ϕbu
D,n(T)(/vector x) = ˜x(T)deﬁnes an AT-algebra(X,ϕbu
D)
inSet. Note that this is a different AT-algebra structure
than the one in point 3) above; these are the bottom-up
semiring metrics of [23].
Remark IV .6. From the example above it is clear that even
ostensibly straightforward metrics like min cost have multiple,
noncompatible deﬁnitions, even though some of those are
based on the same mathematical formalism (semirings). This
might seem strange to the reader; in my opinion there are two
main causes for this. The ﬁrst is that there are different ide as
on what a node vwith multiple parents in an AT represents.
In some works, this means that vmust be activated multiple
times, once for every parent [23]. In other works, activatin g
vonce is enough to serve as input for all its parents [8].
The ﬁrst interpretation naturally incurs a greater overall attack
cost; these metrics also have semantics slightly different from
Deﬁnition II.3, phrased in terms of multisets instead.
The second reason for noncompatible deﬁnitions is that
metrics are often deﬁned alongside the algorithms to comput e
them; as such, the metric is chosen in such a way that it
conforms to the algorithm. We discuss this in detail in Secti on
VI for dynamic ATs, where min time has multiple deﬁnitions,and each of them conforms to the algorithm introduced to
calculate it.
Remark IV .7. In some works, treelike structures in com-
puter science are modeled not by operads but by so-called
multicategories a.k.a. coloured operads [25]. Where operads
axiomatize maps Xn→X, multicategories axiomatize maps
X1×...×Xn→Y. For AT metrics this higher level of
generalization is not necesary, since each BAS’ security va lue
lies in the same domain, and the AT’s security value lies in th is
domain as well; for example X=R≥0for the minimal attack
time metric. Metrics where this is not the case are discussed
in Section V. In Section VI, we show how metrics on attack-
defense trees can be modeled as bicoloured operads.
V. N ECESSARY AND SUFFICIENT CONDITIONS FOR
OPERAD METRICS
We argue that almost all metrics that one encounters are, in
fact, operad metrics. We show this by giving necessary and
sufﬁcient conditions for a metric to be an operad algebra,
and argue that these conditions are natural. This section is ,
in effect, an informal summary of the preceding section.
Setting aside Deﬁnition IV .3, any attack tree metric from
the literature can be phrased as assigning to each attack tre e
Tand each vector of nBAS attribute values /vector x, a security value
F(T,/vector x). To encode this as an operad algebra, one needs to
deﬁne the function ϕ(T)asϕ(T)(/vector x) =F(T,/vector x). This is not
so much an encoding task as it is a shift of perspective, i.e.,
an AT metric is not a value but a function . In order for ϕto
be an operad algebra, i.e., to ﬁt Deﬁnition IV .3, it is necess ary
and sufﬁcient to satisfy the following conditions:
1)Isomorphism independence : two ATs that are the same,
except for the names of the nodes, should yield the same
metric value.
2)Input-output correspondence : the set of possible metric
values must be a subset of the set of possible BAS
attribute values.
3)Allows for modular analysis : IfT′=T ⋆(T1,...,T n),
thenϕ(T′)(/vector x) =ϕ(T)(/vector y), whereyi=ϕ(Ti)(x(i))and
x(i)is the restriction of /vector xto the BASs of Ti.
Condition 1) is true for any reasonable metric, since metric
values should only depend on the mathematical structure. In
the operad algebra framework, this is reﬂected by the fact th at
ATnconsists of isomorphism classes of ATs rather than ATs
themselves. Some metrics need more information than the AT
structure, and this can be done by extending the mathematica l
framework, as we do for dynamic ATs in Section VI.
Condition 2) is usually met: for instance, each BAS is
assigned a cost value (in R≥0) used to calculate the minimal
cost of a succesful attack (again in R≥0). However, there are
counterexamples: for instance, each BAS can be assigned a
compromise time, given as a probability distribution on R≥0,
and the desired metric might be the mean time to compromise
of the entire AT, which is an element of R≥0[24].
In such cases, it is often possible to put the metric in the
operad algebra framework by retaining additional structur e.For instance, the mean time to compromise metric above can be
extended so that the metric value is not just the expected val ue
of compromise time, but the entire probability distributio n of
compromise time; then both the BAS values and the metric
values are probability distributions on R≥0. Retaining this
additional structure does have the downside of potentially
making metric calculation more complicated.
Condition 3) is the crux of Deﬁnition IV .3, as this ensures
thatϕrespects the operad operation ⋆. This is almost always
satisﬁed: while it is possible to create pathological examp les
of metrics that do not meet condition 3), like Example V .1
below, all metrics from the literature known to me that
satisfy 2) also satisfy 3). Modular analysis is natural from
the hierarchical nature of attack trees, in which an AT can be
further reﬁned by replacing a BAS with a subtree describing
its vulnerabilities. Condition 3) then states that the metr ic
respects this reﬁnement: calculating the metric for the lar ge
AT should yield the same result as ﬁrst calculating the metri c
value of the subtree, and then using this as an input for furth er
calculation. Since AT reﬁnement is such a natural operation , it
is no surprise that many metrics respect this reﬁnement. Thi s
also shows why operad algebras are such a natural ﬁt for AT
metric formalization, as the operad axioms capture the one
property that is, in our mind, fundamental to the nature of AT
metrics. An example of a metric for attack-defense trees tha t
does notallow for modular analysis is given in Section VI.
Although condition 3) is very natural for AT metrics, it
can nonetheless be non-straightforward to show that a metri c
satisﬁes it. When a metric is deﬁned bottom-up, like Example s
IV .5.1) and IV .5.4), or top-down, condition 3) is usually me t
automatically. However, when a metric is deﬁned taking the
entire AT structure into account, like IV .5.2) and IV .5.3), a
proof of the applicability of modular analysis can be quite
nontrivial [21].
Example V .1. Consider the sizemetric of an AT, that assigns
to an ATT= (N,E,γ)the integer ϕ(T) =|N|. We can
consider this as a function Nn→Nby taking it to be the
constant function with value |N|. Then this does not satisfy
modular analysis: If T′= (N′,E′,γ′)satisﬁesT′=T ⋆
(T1,...,T n), thenϕ(T′)(/vector x) =|N′|regardless of /vector x, while
ϕ(T)(/vector y) =|N|.
VI. E XTENSIONS OF THE AT FRAMEWORK
In this section, we showcase how the operad algebra frame-
work can be extended to deﬁne metrics for extensions of ATs.
We consider two popular extensions, dynamic ATs and attack-
defense trees, and their metrics. The general technique, ho w-
ever, has wider applicability: to deﬁne metrics on an extend ed
AT formalism, ﬁrst deﬁne the operad of such extended ATs.
Then a metric is simply an algebra over that operad.
A. Dynamic ATs
Dynamic ATs (DATs) are used when not only the set of BAS
undertaken by the attacker are relevant, but also their rela tive
order [14]. DATs have a new gate type, SAND (“sequential
AND”), where SAND(v1,v2)is only activated if both v1andv2abc→
(a) A dynamic AT. In order to reach
the root, aandbcan be activated in
parallel, and once both are done ccan
be activated. The total attack time is
max(ta,tb)+tc.d
a
bc
(b) An attack-defense tree. The at-
tacker (red) can reach the root by
attacka; this can be prevented by the
defender’s (green) action b. This can
itself be stopped by attacker action c.
Alternatively, the attacker can reach
the root by attack dwhich cannot be
stopped by the defender.
Fig. 6: A dynamic AT and an attack-defense tree.
are activated, and v1is activated before v2(see Figure 6a).
Thus aSAND -gate also needs to know the relative order of its
children, leading to the following deﬁnition.
Deﬁnition VI.1. Adynamic attack tree is a triple T=
(N,E,γ,α ), where(N,E)is a rooted directed acyclic multi-
graph and γis a function γ:N→ {OR,AND,BAS,SAND}
such thatγ(v) =BAS if and only if vis a leaf of (N,E).
Furthermore, αconsists of, for every v∈Nwithγ(v) =SAND
withnchildren, a bijection αv: [n]∼−→ch(v).
Informally, modular composition of DATs is exactly the
same as that of ATs, by replacing a BAS with another AT.
This can be formalized analogous to Deﬁnition II.4. One can
also deﬁne anchorings and isomorphisms of DATs analogous
to Deﬁnition IV .1, leading to the deﬁnition of the operad DAT
of DATs. Then DAT metrics are deﬁned as follows.
Deﬁnition VI.2. LetCbe a category with ﬁnite products. A
DAT metric inCis anDAT -algebra inC.
Example VI.3. The metrics below are all noncompatible, and
yield the four deﬁnitions of min time of Figure 1.
1) One way to deﬁne the semantics on a DAT BTis by
deﬁning an attack to be a tuple (A,≺), whereA⊆BT
and≺is a partial order on A; the intuition is that a≺b
means thatamust be ﬁnished before bis started [8, 21].
If each BAS is assigned a duration xa∈R≥0, then the
total duration of an attack (A,≺)is equal to
t(A,≺) = max
Cmax.chain
of(A,≺)/summationdisplay
a∈Cxa.
HereCranges over the maximal chains of A, i.e., the
maximal subsets on which ≺is a linear order; all BASs
in such a chain must happen sequentially, which explains
the summation. Once we deﬁne the set of minimal
attacksMTonT, we then deﬁne the minimal attack
time as
mt(T) = min
(A,≺)∈MTt(A,≺).There are multiple, slightly conﬂicting deﬁnitions of
MT, leading to different metrics [8, 21]. Both of
these choices can be shown to satisfy modular analysis
and hence can be viewed as DAT metrics DAT→
End(R≥0). This deﬁnition of min time can also be
extended to more general dynamic semiring metrics
[8] which extend the semiring framework of Example
IV .5.3) with a third operator ♦.
2) Given such a dynamic semiring (X,▽,△,♦), we can
extend the bottom-up metric of Example IV .5.4) with
˜xv=♦w∈ch(v)˜xwifγ(v) =SAND , yielding the bottom-
up dynamic semiring metrics of [14]. For min time , one
has▽= min ,△= max ,♦= +. This metric can also
be expressed in terms of series-parallel graph semantics.
As bottom-up methods, it is straightforward to show that
modular analysis applies, and that this can be expressed
as aDAT -algebra.
3) A top-down approach to DAT metrics based on priced
timed automata (PTA) is developed in [18]. A PTA,
constructed in UPPAAL from the DAT, can be used
to calculate metrics such as time and cost. Again one
can show that these metrics can be regarded as DAT -
algebras, as this is a straightforward consequence from
its top-down deﬁnition. However, this approach does
not consider the feasibility of attacks, yielding differen t
values of min time from the deﬁnitions above.
B. Attack-Defense Trees
Attack-defense trees (ADTs) were introduced to not only
model attacker or proponent actions and goals, but also
defender or opponent actions and goals. To this end, each
nodevis assigned a label ̺(v), eitherporo, to mark it as
an opponent or proponent action or goal. OR- andAND-gates
marked with an actor can only have children belonging to the
same actor. A new “counter” gate Cis added, that must have
exactly two children with different labels: if v=C(v1,v2)
with̺(v) =̺(v1)/\e}atio\slash=̺(v2), thenvis activated if and only
ifv1is activated, but v2is not. This allows a defender to
stop attackv1from propagating, by activating defense v2(see
Figure 6b). Formally, ADTs are deﬁned as follows.
Deﬁnition VI.4. Aattack-defense tree is a quadruple T=
(N,E,γ,̺ )where(N,E)is a rooted directed acyclic graph
andγ:N→ {OR,AND,BAS,C}and̺:N→ {p,o}are
functions satisfying:
1)γ(v) =BAS if and only if vis a leaf;
2)ifvis a nonleaf with ch(v) =v1,...,v n, then:
a)ifγ(v)∈{OR,AND}, then̺(vi) =̺(v);
b)ifγ(v) =C, thenn= 2 and̺(v1)/\e}atio\slash=̺(v2).
Unlike ATs and DATs, modular composition for ADTs is
more nuanced: a BAS can only be replaced by an ADT whose
top node agent ( ̺-value) is the same as the BAS agent. This
can be phrased in terms of bicoloured operads , an operad
in which only ‘matching’ elements can be composed. Below,
we brieﬂy sketch the idea behind coloured operads; for more
information the reader is referred to [29].Instead of End(X), we consider two sets (or in gen-
eral, objects in a category) Xp,Xo, and maps of the form
Xn
p×Xm
o→XpandXn
p×Xm
o→Xo. These form
setsBicn,m,p(Xp,Xo)andBicn,m,o(Xp,Xo). On these sets,
one has a composition operation ⋆that is deﬁned only on
matching domains and codomains. Taken all together, this is
the structure Bic(Xp,Xo); axiomatising such a structure leads
to the concept of a bicoloured operad. Deﬁning composition
as usual, we can deifne the bicoloured operad ADT of attack-
defense trees. This leads to the following deﬁnitions:
Deﬁnition VI.5. LetCbe a category with ﬁnite products.
1)LetBbe a bicoloured operad. A B-algebra inCis triple
(Xp,Xo,ϕ)whereXp,Xoare objects inCandϕ:B→
Bic(Xp,Xo)is a morphism of bicoloured operads.
2)AnADT metric inCis anADT -algebra inC.
Example VI.6. Consider a tuple (X,▽p,△p,/squarep,▽o,△o,/squareo),
whereXis a set and the last six elements are binary operations
onX. Via such a set two ADT metrics are deﬁned in [16].
First, one can consider a bottom-up deﬁnition similar to Exa m-
ple IV .5.4), where the operator of vdepends on both γ(v)and
̺(v)(/squarep,/squareoare forC-gates). For instance, the minimal cost
of an attack that succeeds regardless of defender actions co r-
responds to the tuple ([0,∞],min,+,+,+,min,min) , with
eacho-BAS having attribute value ∞. As a bottom-up metric,
it is straightforwardly shown to satisfy modular analysis, and
it can be expressed as an ADT -algebra with Xo=Xp=X.
Alternatively, similar to Example IV .5.3) one can ﬁrst deﬁn e
a set of succesful attacks, and then deﬁne the metric globall y
analogous to (1). This is done via so-called set semantics
in [16]. However, this does not generally yield a metric in
the operad-theoretic sense, as this deﬁnition is not compat ible
with modular decomposition; for that one needs additional
assumptions on the operations and their interplay. Precise ly
deﬁning the required axioms is beyond the scope of this paper .
VII. B OTTOM -UP ALGORITHM FOR METRIC COMPUTATION
By design, our AT metrics are considerably more general
than other deﬁnitions in the literature: we wish to encapsul e
many existing deﬁnitions into one common framework. A
consequence is, however, that existing algorithms to calcu late
AT metrics cannot be shown to work in general under our
deﬁnition. In this section and the following one, we general ize
existing metric calculation algorithms to the operad algeb ra
setting, and give sufﬁcient operad-theoretic properties, such
that the algorithms can be applied to metrics that satisfy
these properties. This section is dedicated to the bottom-u p
algorithm ﬁrst deﬁned in [23]. For the metrics it applies to
it is the state-of-the-art method with only linear complexi ty;
thus the increased generality of the operad framework does
not come at a loss of efﬁciency. Throughout this section, we
consider metrics in the category Set.
A. The operators CnandDn
Forn∈Z≥1, letTOR,n∈ATnbe the AT with nBASs
and a single non-BAS (the root), which is an OR-gate, see
xn
a1a2 anxn
a1a2 an
Fig. 7: The ATs TOR,nandTAND,n.
Input:T= (N,E,γ)∈ATn;ϕ: AT→End(X);
/vector x∈Xn;v∈N.
Output:BU(T,ϕ,/vector x,v) =ϕ(Tv)(/vector xv)∈X
1ifv=aithen
2 returnxi
3else ifv=OR(w1,...,w m)then
4∀i≤m:yi←BU(T,ϕ,/vector x,w i);
5 returnCn(y1,...,y n)
6else
// Nowv=AND(w1,...,w m)
7∀i≤m:yi←BU(T,ϕ,/vector x,w i);
8 returnDn(y1,...,y n)
Algorithm 1: The algorithm BU. Recall that Tvis the
subDAG of Twith rootv, so to compute ϕ(T)(/vector x)one
takesv= RT.
Figure 7. For an AT-algebraϕ: AT→End(X)inSet, let
Cn:Xn→Xbe the map ϕ(TOR,n). Becauseϕis an operad
morphism, the operator Cndoes not depend on the order
of its arguments, since the BAS of TOR,ncan be permuted
freely without changing its isomorphism class of anchored A T.
Therefore,Cnis symmetric. Similarly, there is a symmetric
operatorDn:Xn→Xcoming from the analogously-deﬁned
ATTAND,n. The operators CnandDndepend on the operad
algebra(X,ϕ), but we will omit this from the notation.
Example VII.1. Consider the bottom-up metric from Example
IV .5.4). It is easy to see that here Cn(/vector x) =/bigtriangledownn
i=1xi, and
Dn(/vector x) =/bigtriangleupn
i=1xi. Less obvious is that the metric from
Example IV .5.3) has the same Cn,Dn.
In the example above CnandCmforn/\e}atio\slash=mare clearly re-
lated: they are the same operation applied to more arguments .
This is not true in general: in our deﬁnition there need not
be any relation between CnandCm. In fact, any choice of
symmetric operators Cn,Dncan be extended to an AT metric.
B. The bottom-up algorithm
A ‘naive’ algorithm to calculate the value AT-metric bottom -
up is presented in Algorithm 1. In this algorithm, we write /vector xwfor the vector in X|BTw|consisting of all xisuch that the BAS
aiis part of the AT Tw(recall thatTwis the subDAG of T
with rootw). ThusBU(T,ϕ,/vector x,v )calculates the metric value
of the ATTv, for BAS metric values inherited from (T,/vector x).
In order to get ϕ(T)(/vector x), we takev= RT. The algorithm
works by applying, at every node v, eitherCnorDnto the
values of its children, all the way up to the root, whose value
is the AT metric. For speciﬁc metrics, this algorithm has bee n
discussed many times in the existing literature, see for ins tance
[23, 17, 20]. Algorithm 1 is concise and efﬁcient: it has
time complexityO(|N|+|E|). However, its main drawback
is that it does not calculate every AT metric correctly [20].
Nevertheless, Algorithm 1 works when when the underlying
graph is an actual tree and not just any DAG.
Deﬁnition VII.2. An ATT= (N,E,γ)is called treelike if
the underlying graph (N,E)is a (rooted) tree.
Theorem VII.3. LetT∈ATn, let(X,ϕ)be anAT-
algebra, and let /vector x∈Xn. IfTis treelike, then ϕ(T)(/vector x) =
BU(T,ϕ,/vector x,RT).
Theorem VII.3 does not hold for DAG-shaped ATs, but it
has been shown to hold for a number of metrics [16, 20].
For the remainder of this section, we give a necessary and
sufﬁcient, operad-theoretic condition under which Theore m
VII.3 also holds for DAG-shaped ATs. We start by developing
the necessary machinery.
C. Scoperads
bc aThe essential ingredient of the proof
of Theorem VII.3 is that every tree-
likeTcan be modularly decomposed,
via⋆, into basic ATs of the forms
TOR,n,TAND,n. As this does not hold
for general, DAG-shaped T,BUdoes
not correctly calculate AT metrics for
everyT. From a graph-theoretical per-
spective every AT is built up from OR- andAND-gates. How-
ever, the operad structure of AT, i.e. modular composition,
does not ‘see’ this: ATs such as AND(OR(a,b),OR(b,c))are
indecomposable from an operad perspective. To amend this
discrepancy, we introduce scoperads (“surjectively complete
operads”): operads with additional structure, that allows us to
decompose any AT into OR/AND-gates on an operad level. The
necessary structure is the existence of τσfor all surjective σ:
as we will show below, this allows us to merge BASs in AT.
Deﬁnition VII.4. Ascoperad is a tupleO= (O,τ,id,⋆)of
a setOnfor eachn∈Z≥0; amapτσ:On→On′for each
surjective mapσ: [n]։[n′]forn,n′∈Z≥0; an element
1∈O1; and a map ⋆:On×/producttextn
i=1Omi→O/summationtext
imifor all
n,m1,...,m n∈Z≥0. These must satisfy 1)–4) of Deﬁnition
III.1 for all σ, and 5) for bijective σ.
Example VII.5. 1) For an object Xin a category with
ﬁnite products, consider the operad End(X). We can
consider this as a scoperad, by deﬁning the mapa3
a2a1
T1 2 3
1 2
σa2a1
τσT
Fig. 8: An example of τσTfor surjective σand ATT.
τσ: Endn(X)→Endn′(X)as follows: For i′∈[n′],
let̺i′:X→Xσ−1(i′)be the diagonal embedding, and
let̺=/producttext
i′∈I′̺i′:Xn′→Xn; then forf:Xn→X
one hasτσ(f) =f◦̺. IfXis a set, then for /vector x∈Xn
we haveτσ(f)(/vector x) =f(σ∗/vector x), where(σ∗/vector x)i=xσ(i)for
alli. This is the same as for bijective f, except now a
coefﬁcientxσ(i)can appear multiple times.
2) LetT∈ATnand letσ: [n]։[n′]be surjective.
Deﬁneτσ(T)by merging two BASs ai,ai′whenever
σ(i) =σ(i′); see Fig. 8 for an example. Thus τσ(T) =
(N′,E′,γ′)where
N′=N\BT∪{˜a1,...,˜an′},
E′={{(v,w)∈E|v,w /∈BT}}
⊎{{(v,˜aσ(i))|(v,ai)∈E}},
γ′(v) =/braceleftBigg
γ(v),ifv∈N\BT,
BAS, ifv= ˜ai.
This gives ATthe structure of a scoperad.
D. The AT scoperad
For us, the key advantage of deﬁning scoperads is that now
every AT can be decomposed into TOR,n,TAND,n, as is shown
by the following result:
Deﬁnition VII.6. An AT is called a prime AT if it is isomor-
phic toTOR,norTAND,nfor somen.
Lemma VII.7. In the scoperad AT, every AT not equal to
id∈AT1can be obtained from prime ATs and operations of
the form⋆andτσ.
Based on Example VII.5, we can deﬁne a scoperad AT
metric to be a scoperad morphism ϕ: AT→End(X), i.e.,
an operad morphism that preserves τσfor general surjective
σ. In the following theorem, we show that scoperad metrics
are precisely those that can be calculate by Algorithm 1. Thi s
gives a necessary and sufﬁcient condition for when bottom-u p
methods work.
Theorem VII.8. Letϕ: AT→End(X)be an AT-metric.
ThenBU(T,ϕ,/vector x,RT) =ϕ(T)(/vector x)for allT,/vector x if and only if ϕ
is a scoperad morphism.
For the propositional metrics of Example IV .5.2, Algorithm
1 has been shown not to work for DAG-like ATs in general,because BAS with multiple parents will occur twice some-
where in the calculation. Theorem VII.8 shows that this is th e
only obstruction: if two BAS can be merged or split without
consequences for the metric, then the bottom-up approach
works.
Remark VII.9. Bottom-up algorithms have also been pro-
posed to calculate metrics on extensions of ATs, by deﬁning
new operators for the new gates that have been introduced [16 ,
20]. The results have been more or less analogous: bottom-up
algorithms succeed at calculating metrics on treelike ATs, but
only work on general ATs under additional assumptions, such
as idempotence of the operators.
VIII. BDD- BASED ALGORITHMS
Binary decision diagrams (BDDs) form a compact way of
representing Boolean functions. Applying these to the stru cture
function of ATs, one can obtain efﬁcient methods to calculat e
metrics, provided that the metric only depends on the struct ure
function [26, 20]. In this section, we unify these existing
methods under a common, generic algorithm for our operad
algebra metrics, and we give sufﬁcient conditions when this
algorithm works. For the metrics to which it applies it is the
state-of-the-art [20], again showing that there is no loss o f
efﬁciency in adopting the generic operad algebra framework .
We again assume that all metrics ϕ: AT→End(X)are in
the category Set.
A. Reduced ordered BDDs
A BDD is a rooted DAG with two leaves 0and1, and each
nonleaf is labeled with a variable F1,...,F n. Furthermore,
each nonleaf has exactly two outgoing edges, labeled 0and
1. A BDD encodes a function f:Bn→Bas follows: given
/vectorb∈Bn, starting from the root, at each node vwith labelFi,
follow its 0- or1-edge depending on the value of bi. The value
off(/vectorb)is equal to the leaf we end up in. This allows us to
represent Boolean functions in a way that is typically compa ct
[27, 3], making it suitable for storage and computation.
In this paper, we used reduced ordered BDDs , which are
BDDs in which the variables Fioccur in order, which are then
reduced to be of minimal size by getting rid of redundant and
duplicate nodes. The formal deﬁnition is as follows:
Deﬁnition VIII.1. Letn≥0. A reduced ordered binary
decision diagram (ROBDD) ofnvariables is a tuple B=
(N,E,t N,tE)where:
•(N,E)is a rooted DAG where every nonleaf has exactly
two children.
•tN:N→{F1,...,F n}∪{0,1}satisﬁestN(v)∈{0,1}
iffvis a leaf.
•tE:E→{0,1}is such that the two outgoing edges of
each nonleaf vhave different values; the two children are
denotedc0(v)andc1(v)depending on the edge values.
•If(v,v′)is an edge and tN(v) =Fi,tN(v′) =Fi′, then
i<i′.a1a3 a2
0.7 0.3 0 .5F1
F2
F3
0 11
1100
0
Fig. 9: An AT (with probability values) and its ROBDD.
•Ifv,v′are two nodes such that tN(v) =tN(v′), and
for nonleaves furthermore c0(v) =c0(v′)andc1(v) =
c1(v′), thenv=v′.
Each Boolean function can be represented by a unique
ROBDD [7]. The size of the ROBDD representing fis
worst-case exponential in n, but in practice it is often quite
compact [6]. The size depends heavily on the ordering of the
nvariables, but ﬁnding the optimal ordering is NP-complete.
B. The BDD algorithm
The BDD of SThas been used to efﬁciently calculate AT
metrics, see below. One necessary condition is that an AT’s
metric value only depends on its structure function. This is
formalized in the deﬁnition below. Recall that MBool=
EndPos(B)is the operad of monotonous Boolean functions.
Deﬁnition VIII.2. LetMBoolnc⊂MBool be the sub-operad
of nonconstant Boolean functions (so MBoolnc
0=∅). An AT
metricϕ: AT→End(X)is called propositional if there exists
aψ: MBoolnc→End(X)such thatϕ=ψ◦ϕstruc, where
ϕstruc: AT→MBoolncis the structure function operad of
Example IV .5.1.
In Example IV .5.1, the map ϕstruchas codomain MBool ,
but structure functions are always nonconstant: one has
ST((0,...,0),RT) =0andST((1,...,1),RT) =1. There-
fore, one can take MBoolncfor the codomain. In fact, if one
does so, then each ϕstruc: ATn→MBoolnc
nis surjective;
henceψ, if it exists, is uniquely deﬁned.
Some examples of propositional metrics are ϕstrucitself
(trivial) and the metrics ϕTAPandϕps
Dfrom Example IV .5.
A non-example is given by the bottom-up semiring metrics of
Example IV .5.4).
For propositional metrics, one can formulate metric-
calculating algorithms by traversing the ROBDD bottom-up.
This is presented in Algorithm 2. Such an algorithm requires ,
apart from X, a function g:X3→Xprescribing how a
node’s value should be computed, from the values of its two
children and the BAS value of its label. We also need initial
valuesz0,z1∈X. Of course, g,z0,z1should be chosen so
that the algorithm calculates ϕ(T)(/vector x)as intended.
Algorithm 2 has only linear complexity in the size of B,
and as such is very fast when Bis small. Unfortunately, Bis
of worst-case exponential size. Nevertheless, in practice BisInput: SetX, functiong:X3→X, initial values
z0,z1∈X; ATT= (N,E,γ)∈ATn, BAS
values/vector x∈Xn
Output:BDD(X,g,z0,z1,T,/vector x) =ϕ(T)(/vector x)∈X
1B←ROBDD representing ST(•,RT);
2returnBDDBU(B,x,RB)
Algorithm 2: The algorithm BDD (see Algorithm 3 for
BDDBU).
Input: SetX, functiong:X3→X, initial values
z0,z1∈X; ROBDDB= (N,E,t N,tE), BAS
values/vector x∈Xn,nodev∈N
Output: valueBDDBU(B,/vector x,v)∈X
1iftN(v) =bithen
2 return
g(xi,BDDBU(B,/vector x,c0(v)),BDDBU(B,/vector x,c1(v))
3else iftN(v) =0then
4 returnz0
5else
6 returnz1
Algorithm 3: The algorithm BDDBU. For notational con-
venience, the arguments X,g,z0,z1are omitted from the
notation.
often quite small, making BDD-based algorithms the state-o f-
the-art approach for the two metrics described in the exampl e
below [20], when these metrics cannot be covered by the
bottom-up algorithm of Section VII.
Example VIII.3. We consider two of the metrics from Ex-
ample IV .5.
1) The metric ϕTAPof Example IV .5.4 can be calculated
this way, by taking z0= 0,z1= 1, andg(p,q,r) =
(1−p)q+pr[26]. For example, consider the AT T
of Fig. 9 and its ROBDD B; for the BAS values we
take/vector x= (0.7,0.5,0.3). Then we ﬁnd ϕTAP(T)(/vector x)by
traversing the ROBDD bottom-up:
BDDBU(B,/vector x,0) =z0 = 0,
BDDBU(B,/vector x,1) =z1 = 1,
BDDBU(B,/vector x,F 3) = (1−0.3)·0+0.3·1 = 0.3,
BDDBU(B,/vector x,F 2) = (1−0.5)·0.3+0.5·1 = 0.65,
BDDBU(B,/vector x,F 2) = (1−0.7)·0+0.7·0.65 = 0.455.
HenceϕTAP(T)(/vector x) = 0.455. Choosing a different vari-
able order would have resulted in a different ROBDD,
but the resulting probability would have been the same.
2) Consider the min cost metric of Example IV .5.2; this
is calculated by Algorithm 2, for z0=∞,z1= 0,
andg(x,y,z) = min(y,x+z). This construction can
be applied to general propositional semiring metrics
D= (V,△,▽), provided that there exist identity el-
ements1△,1▽for△and▽, and that the semiring is
absorbing , i.e.,x▽(x△y) =xfor allx,y∈V. Thenthe propositional semiring metric ϕps
Dcan be found using
z0= 1▽,z1= 1△, andg(x,y,z) =y▽(x△z). For more
details see [20].
C. BDD algorithms for general metrics
In this section, we give sufﬁcient conditions for the validi ty
of Algorithm 2. The main conditions are that a metric ϕ
preserves certain constructions, which are given in Deﬁnit ions
VIII.4 and VIII.5 below.
For eachn, deﬁne a partial order /precedesequalonMBool nbyf/precedesequalf′
iff(/vectorb)≤f′(/vectorb)for all/vectorb∈Bn. We use this to deﬁne Shannon
composition , which for monotonous functions is the reverse
operation of the well-known Shannon expansion: that is, f
andf′are the Shannon cofactors of Sh(f,f′).
Deﬁnition VIII.4. Letf,f′∈MBool n−1withf≺f′. The
Shannon composition off,f′is the map Sh(f,f′)∈MBool n
deﬁned by
Sh(f,f′)(x1,...,x n) =f(x2,...,x n)∨(x1∧f′(x2,...,x n)).
The second operation we want to introduce is a formality:
we create a (n+ 1) -ary function from an n-ary function by
adding an irrelevant argument.
Deﬁnition VIII.5. ForX, andn∈Z≥0, deﬁne
δn: End n(X)→Endn+1(X)by(δnf)(x1,...,x n+1) =
f(x2,...,x n+1)forx∈Xn+1.
SinceMBool = EndPos(B), this also deﬁnes δnon
MBool n.
F1
BfBf′01Every function in MBool can be
created from the constant functions
0,1∈MBool 0through repeated ap-
plications of Shandδn. Furthermore,
on BDDs these operations have a
straightforward representation: fand
δnfare represented by the same ROBDD, and Sh(f,f′)is
represented by the BDD on the right, where BfandBf′are
ROBDDs representing fandf′; this BDD can be reduced to
a ROBDD by identifying identical nodes on the left and right.
Theorem VIII.6 uses this idea to connect BDDs to metric
calculation: if δnis irrelevant to a metric ϕ, and if Shis
mapped to the application of g, then Algorithm 2 correctly
calculatesϕ.
Theorem VIII.6. Letϕ: AT→End(X)be propositional,
and letψ: MBoolnc→End(X)be such that ϕ=ψ◦φstruc.
Letιbe the inclusion MBoolnc֒→MBool . Letg:X3→X
andz0,z1∈X. Suppose there exists a Ψ: MBool→End(X)
satisfying the following conditions:
1)ψ= Ψ◦ι;
2)Ψ(0) =z0andΨ(1) =z1;
3)Ψ◦δn=δn◦Ψfor alln;
4)For alln≥1andf,f′∈MBool n−1withf≺f′, and
all/vector x∈Xn, one has
Ψ(Sh(f,f′))(/vector x)
=g(x1,Ψ(f)(x2,...,x n),Ψ(f′)(x2,...,x n)).ThenBDD(X,g,z0,z1,T,x) =ϕ(T)(/vector x)for allT∈ATnand
/vector x∈Xn.
Theorem VIII.6 requires a number of conditions, but they
are not all equally hard to satisfy. The requirements that ϕbe
propositional and that δis preserved are necessary conditions:
this is because the ROBDD depends only on the structure
function, and because adding irrelevant variables does not
change the ROBDD. Furthermore, the extension Ψ, if it exists,
is unique: the constant functions 0and1have to be sent to
the neutral elements for the operators C2andD2, respectively.
This also shows that z0andz1are determined by ψ. The key
property needed to make Algorithm 2 work is the fact that Ψ
maps Shannon composition to g.
Example VIII.7. ConsiderϕTAPof Example IV .5.4. For a
given/vector p∈[0,1]n, letYi∼Ber(pi), with allYiindepen-
dent; thenϕTAP(T)(/vector p) = Pr[S T(/vectorY,RT) =1]. We can
extendϕTAPto aΨ: MBool→End([0,1])byΨ(f)(/vector p) =
Pr[f(Y) =1]. We show that this maps Shannon composi-
tion to the gof Example VIII.3.1). For f≺f′one has
f′(Y2,...,Y n) =1wheneverf(Y2,...,Y n) =1; hence
Sh(f,f′)(Y) =1if eitherY1=1andf′(Y2,...,Y n) =1,
orY1=0andf(Y2,...,Y n) =1. Hence
Ψ(Sh(f,f′))(/vector p) = (1−p1)Pr[f(Y2,...,Y n) =1]
+p1Pr[f′(Y2,...,Y n) =1]
=g(p1,Ψ(f)(p2,...,p n),Ψ(f′)(p2,...,p n)).
This shows condition 4 of Theorem VIII.6. The other con-
ditions are straightforward to check, and together show tha t
Algorithm 2 works for ϕTAP.
IX. C ONCLUSION
This work introduces a new deﬁnition of AT metrics based
on operad theory. This deﬁnition captures all existing deﬁn i-
tions, and can be used in a wider, category-theoretical cont ext.
It also generalizes existing metric calculation algorithm s and
gave operad-theoretical conditions as to when they apply.
Future work can consider metric calculation on extensions
such as dynamic ATs or attack-defense trees, or investigate
to what extent our work applies to fault trees.
ACKNOWLEDGEMENTS
This research has been partially funded by ERC Consolida-
tor grant 864075 CAESAR and the European Union’s Horizon
2020 research and innovation programme under the Marie
Skłodowska-Curie grant agreement No. 101008233.
REFERENCES
[1] John C Baez and Nina Otter. “Operads and phylogenetic
trees”. In: arXiv:1512.03337 (2015). Preprint.
[2] Kristian Beckers et al. “Determining the probability of
smart grid attacks by combining attack tree and attack
graph analysis”. In: International Workshop on Smart
Grid Security . Springer. 2014, pp. 30–47.[3] Andrea Bobbio, Lavinia Egidi, and Roberta Terruggia.
“A methodology for qualitative/quantitative analysis of
weighted attack trees”. In: IFAC Proceedings Volumes
46.22 (2013), pp. 133–138.
[4] Ang` ele Bossuat and Barbara Kordy. “Evil twins: han-
dling repetitions in attack–defense trees”. In: Interna-
tional Workshop on Graphical Models for Security .
Springer. 2017, pp. 17–37.
[5] Tai-Danae Bradley. “Entropy as a topological operad
derivation”. In: Entropy 23.9 (2021), p. 1195.
[6] Randal E. Bryant. “Graph-based algorithms for boolean
function manipulation”. In: Computers, IEEE Transac-
tions on 100.8 (1986), pp. 677–691.
[7] Randal E. Bryant. “Symbolic boolean manipulation
with ordered binary-decision diagrams”. In: ACM Com-
puting Surveys (CSUR) 24.3 (1992), pp. 293–318.
[8] Carlos E Budde and Mari¨ elle Stoelinga. “Efﬁcient al-
gorithms for quantitative attack tree analysis”. In: 2021
IEEE 34th Computer Security Foundations Symposium
(CSF) . IEEE. 2021, pp. 1–15.
[9] Huiyu Dong, Hongwei Wang, and Tao Tang. “An at-
tack tree-based approach for vulnerability assessment
of communication-based train control systems”. In:
2017 Chinese Automation Congress (CAC) . IEEE. 2017,
pp. 6407–6412.
[10] Martin Doubek, Branislav Jurco, and Lada Peksova.
“Properads and Homotopy Algebras Related to Sur-
faces”. In: arXiv preprint arXiv:1708.01195 (2017).
[11] Yves Dutuit and Antoine Rauzy. “A linear-time algo-
rithm to ﬁnd modules of fault trees”. In: IEEE Trans-
actions on Reliability 45.3 (1996), pp. 422–425.
[12] Barbara Fila and Wojciech Wideł. “Efﬁcient attack-
defense tree analysis using Pareto attribute domains”.
In:2019 IEEE 32nd Computer Security Foundations
Symposium (CSF) . IEEE. 2019, pp. 200–20015.
[13] John D Foley et al. “Operads for complex system design
speciﬁcation, analysis and synthesis”. In: Proceedings
of the Royal Society A 477.2250 (2021), p. 20210099.
[14] Ravi Jhawar et al. “Attack trees with sequential con-
junction”. In: IFIP International Information Security
and Privacy Conference . Springer. 2015, pp. 339–353.
[15] Parvaiz Ahmed Khand and Poong Hyun Seong. “An
attack model development process for the cyber security
of safety related nuclear digital I&C systems”. In:
Proceedings of the Korean Nucleary Society (KNS) Fall
meeting . 2007.
[16] Barbara Kordy and Wojciech Wideł. “On quantitative
analysis of attack–defense trees with repeated labels”.
In:International Conference on Principles of Security
and Trust . Springer. 2018, pp. 325–346.
[17] Barbara Kordy et al. “Foundations of attack–defense
trees”. In: International Workshop on Formal Aspects
in Security and Trust . Springer. 2010, pp. 80–95.
[18] Rajesh Kumar, Enno Ruijters, and Mari¨ elle Stoelinga.
“Quantitative attack tree analysis via priced timed au-
tomata”. In: International Conference on Formal Mod-eling and Analysis of Timed Systems . Springer. 2015,
pp. 156–171.
[19] Nikolaos Limnios. Fault trees . John Wiley & Sons,
2013.
[20] Milan Lopuha¨ a-Zwakenberg, Carlos E. Budde, and
Mari¨ elle Stoelinga. “Efﬁcient and Generic Algorithms
for Quantitative Attack Tree Analysis”. In: IEEE Trans-
actions on Dependable and Secure Computing (2022),
pp. 1–18. DOI: 10.1109/TDSC.2022.3215752.
[21] Milan Lopuha¨ a-Zwakenberg and Mari¨ elle Stoelinga.
“Attack time analysis in dynamic attack trees via
integer linear programming”. In: arXiv preprint
arXiv:2111.05114 (2021).
[22] Martin Markl, Steven Shnider, and James D Stasheff.
Operads in algebra, topology and physics . V ol. 96.
American Mathematical Society Providence, RI, 2002.
[23] Sjouke Mauw and Martijn Oostdijk. “Foundations of at-
tack trees”. In: International Conference on Information
Security and Cryptology . Springer. 2005, pp. 186–198.
[24] Miles A. McQueen et al. “Time-to-compromise model
for cyber risk reduction estimation”. In: Quality of
protection . Springer, 2006, pp. 49–64.
[25] Jos´ e Meseguer. “General logics”. In: Studies in Logic
and the Foundations of Mathematics . V ol. 129. Elsevier,
1989, pp. 275–329.
[26] Antoine Rauzy. “New algorithms for fault trees analy-
sis”. In: Reliability Engineering & System Safety 40.3
(1993), pp. 203–211.
[27] Antoine Rauzy and Yves Dutuit. “Exact and truncated
computations of prime implicants of coherent and non-
coherent fault trees within Aralia”. In: Reliability Engi-
neering & System Safety 58.2 (1997), pp. 127–144.
[28] Bruce Schneier. “Attack trees”. In: Dr. Dobb’s journal
24.12 (1999), pp. 21–29.
[29] Donald Yau. Colored operads . V ol. 170. American
Mathematical Society, 2016.
[30] Donald Yau. Operads of wiring diagrams . V ol. 2192.
Springer, 2018.
APPENDIX A
PROOF OF THEOREM VII.3
Proof. We prove this by bottom-up induction on v. Ifvis the
leafai, thenγ(v) =BAS, andTv= id∈AT1. Sinceϕis
an operad morphism, ϕ(Tv) = id , andϕ(Tv)(/vector xv) =xi=
BU(T,ϕ,/vector x,v).
Now suppose v=OR(w1,...,w m), and the state-
ment is true for w1,...,w m. The recursive deﬁnition of
BU(T,ϕ,/vector x,w i)depends only on the subDAG Twi. As such
one can prove by a straightforward induction proof that
BU(T,ϕ,/vector x,w i) =BU(Twi,ϕ,/vector xwi,wi). (2)
Now, sinceTis a tree, the subtrees Tw1,...,T wmare disjoint,
and
T=TOR,m[Tw1/a1,...,T wm/am]
=TOR,m⋆(Tw1,...,T wm).Sinceϕis an operad morphism, we get
ϕ(T)(/vector x)
=ϕ(TOR,m⋆(Tw1,...,T wm))(/vector x)
=ϕ(TOR,m)(ϕ(Tw1)(/vector xw1),...,ϕ(Tw1)(/vector xwm)) (3)
=Cm(BU(Tw1,ϕ,/vector xw1,w1),...,BU(Twm,ϕ,/vector xwm,wm))
=Cm(BU(T,ϕ,/vector x,w 1),...,BU(T,ϕ,/vector x,w m)) (4)
=BU(T,ϕ,/vector x,v ).
Here we use the induction hypothesis in (4) and (2) in (3). Thi s
proves the theorem for γ(v) =OR; the case that γ(v) =AND
is completely analogous.
APPENDIX B
PROOF OF LEMMA VII.7
Proof. Deﬁne a preorder/precedesequalon the set of (isomorphism classes)
of ATs byT/precedesequalT′ifThas less non-BAS nodes that T′, or if
Thas as much non-BAS nodes as T′, andThasmore BAS
nodes with multiple parents than T′. We prove the lemma
by induction over /precedesequal. The basis for the induction are the
Twith only 1 non-BAS node. These are not necessarily of
the formTOR,norTAND,n, as there may be multiple edges
between the root and a given BAS. However, we can obtain T
from a prime AT by merging BASs via a τσ. More precisely,
supposeT= (N,E,γ); thenN={RT,a1,...,a n}; let
E={{e1,...,e m}}. Deﬁneσ: [m]։[n]byσ(i) =jif
and only if ei= (RT,aj). ThenT=τσT′, whereT′is
eitherTOR,morTAND,mdepending on γ(RT). This proves the
induction basis.
Now letTbe an AT with more than 1 non-BAS node, and
letvbe a node of Twith only BAS children. If every child of
vhas onlyvas a parent, then T=T′[Tv/v], whereT′≺T
andTvhas only 1 non-BAS node; hence by the induction
hypothesisTcan be constructed from prime trees. If such
avdoes not exist, there is a BAS awith multiple parents.
Construct a new tree T′with multiple independent copies of
a, such that each parent is only connected to a single copy.
ThenT′≺T, and furthermore T=τσ(T′)for aσthat
merges all the copies of b. By the induction hypothesis T′,
and therefore T, can be constructed from prime trees.
APPENDIX C
PROOF OF THEOREM VII.8
For the proof we need one auxiliary lemma.
Lemma C.1. LetT∈ATnbe an AT, let σ: [n]→[n′]be
a surjective map, and let τσT= (N′,E′,γ′)as in Example
VII.5.2). Deﬁne a map π:N→N′by
π(v) =/braceleftBigg
a′
j,ifv=aiandσ(i) =j,
v, ifv /∈BT.
Let(ϕ,X)be an AT metric, and let /vector x∈Xn. Letσ∗/vector xbe as
in Example VII.5.1). Then for all v∈N
BU(τσT,ϕ,/vector x,π (v)) =BU(T,ϕ,σ∗/vector x,v).Proof. The proof is a straightforward induction on T. Ifvis
the BASaiwithσ(i) =j, then
BU(τσT,ϕ,/vector x,π (v)) =BU(τσT,ϕ,/vector x,a′
j)
=xj
= (σ∗/vector x)i
=BU(T,ϕ,σ∗/vector x,v).
Ifv=OR(w1,...,w m), thenπ(v) =OR(π(w1),...,π(wm)).
From this we show the statement for vgiven the induction
hypothesis for the wi, and the AND-case is analogous.
Proof of Theorem VII.8. First assume that ϕis a scoperad
morphism. For all nand allT∈ATn, we want to prove
the property
∀/vector x∈Xn:BU(T,ϕ,/vector x,RT) =ϕ(T)(/vector x). (5)
Clearly (5) holds for idand for prime ATs. We will show that
(5) is preserved under τσand⋆; by Lemma VII.7 this shows
that it holds for all T.
Suppose (5) holds for T∈ATn, and letσ: [n]։[m]
be a surjective map. Let /vector x∈Xm; we aim to show that
BU(τσT,ϕ,/vector x,RτσT) =ϕ(τσT)(/vector x). We then have
BU(τσT,ϕ,/vector x,RτσT) =BU(T,ϕ,σ∗/vector x,RT) (6)
=ϕ(T)(σ∗/vector x) (7)
=τσ(ϕ(T))(/vector x) (8)
=ϕ(τσT)(/vector x). (9)
Here (6) is due to Lemma C.1, (7) is because (5) holds for
T, (8) is from the deﬁnition of τσonEnd(X)from Example
VII.5.1), and (9) is because ϕis a scoperad morphism. We
conclude that (5) holds for τσ(T).
Now assume (5) holds for T∈ATnandT1∈
ATm1,...,T n∈ATmn; we aim to prove it for T′=
T ⋆(T1,...,T n). Hence, for every (/vector x(i))i≤n∈/producttext
iXmiwe
want to show that
BU(T′,ϕ,(/vector x(i))i≤n,RT′) =ϕ(T′)((/vector x(i))i≤n).
By its bottom-up nature, BUrespects modular decomposition;
more formally,
BU(T′,ϕ,(/vector x(i))i≤n,RT′) =BU(T,ϕ,/vector y,RT)
whereyi=BU(Ti,ϕ,/vector x(i),RTi). Since (5) holds for Ti, we
haveyi=ϕ(Ti)(/vector x(i)); since (5) also holds for Twe have
BU(T′,ϕ,(/vector x(i))i≤n,RT′) =BU(T,ϕ,/vector y,RT)
=BU(T,ϕ,(ϕ(Ti)(/vector x(i)))i≤n,RT)
=ϕ(T)((ϕ(Ti)(/vector x(i)))i≤n)
= (ϕ(T)⋆(ϕ(T1),...,ϕ(Tn)))((/vector x(i))i≤n)
=ϕ(T′)((/vector x(i))i≤n).
Here we used the fact that ϕpreserves⋆in the last line.
This concludes our proof that BUworks ifϕis a scoperad
morphism.To prove the opposite direction, we assume (5) for all T,
and we need to show that ϕpreservesτσand⋆. For the ﬁrst
one, observe that for all /vector xandσwe have
τσϕ(T)(/vector x) =ϕ(T)(σ∗/vector x)
=BU(T,ϕ,σ∗/vector x,RT)
=BU(τσT,ϕ,/vector x,RτσT)
=ϕ(τσT)(/vector x).
For the second one, for T′and/vector yas before we have
ϕ(T′)((/vector x(i))i≤n) =BU(T′,ϕ,(/vector x(i))i≤n,RT′)
=BU(T,ϕ,/vector y,RT)
=ϕ(T)(/vector y)
=ϕ(T)((ϕ(Ti)(/vector x(i)))i≤n)
= (ϕ(T)⋆(ϕ(T1),...,ϕ(Tn)))((/vector x(i))i≤n),
which proves that ϕpreserves⋆. We conclude that ϕis a
scoperad morphism.
APPENDIX D
PROOF OF THEOREM VIII.6
Proof. Forf∈MBool n, letBfbe the unique ROBDD
representing it. We will prove by induction on nthe claim
thatBDDBU(Bf,/vector x,RB) = Ψ(f)(x)for eachf∈MBool n
and each/vector x∈Xn; this proves the theorem. Since Ψ(0) =z0
andΨ(1) =z1, it holds for the two elements of MBool 0. Now
assume that the claim holds for n′<n, and letf∈MBool n.
IftN(RBf)/\e}atio\slash=F1, then there is no vwithtN(v) =F1, and
fdoes not depend on its ﬁrst variable; hence f=δn−1f′for
somef′∈MBool n−1, which furthermore satisﬁes Bf=Bf′.
It follows that
Ψ(f)(x1,...,x n) = Ψ(δn−1f′)(/vector x)
= (δn−1Ψ(f′))(/vector x)
= Ψ(f′)(x2,...,x n)
=BDDBU(Bf′,(x2,...,x n),RBf′)
=BDDBU(Bf,x,RBf).
This proves the claim for f. Now suppose tN(RBf) =F1. Let
B0,B1be the sub-BDDs of Bfwith rootsc0(RBf),c1(RBf),
and letf0,f1:Bn−1→Bbe the functions they represent
(where a label Fistands for the (i−1)-th entry of a boolean
vector, as the labels now range from F2toFn). Thenf0≺f1
becausefis monotonous, and f= Sh(f0,f1). Write˘x∈
Xn−1for(x2,...,x n). It follows that
Ψ(f)(/vector x)
= Ψ(Sh(f0,f1))(/vector x)
=g(x1,Ψ(f0)(˘x)),Ψ(f1)(˘x))
=g(x1,BDDBU(B0,˘x,RB0),BDDBU(B1,˘x,RB1))
=g/parenleftbig
x1,BDDBU(Bf,˘x,c0(RBf)),BDDBU(Bf,˘x,c1(RBf))/parenrightbig
=BDDBU(Bf,/vector x,RBf).
This proves the claim for f; by induction this completes the
proof.
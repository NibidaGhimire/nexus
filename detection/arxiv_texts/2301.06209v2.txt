EÔ¨Écient Loop Conditions for
Bounded Model Checking Hyperproperties?
Tzu-Han Hsu1
, C√©sar S√°nchez2
, Sarai Sheinvald3
, and
BBorzoo Bonakdarpour1
1Michigan State University, East Lansing, MI, USA {tzuhan,borzoo}@msu.edu
2IMDEA Software Institute, Madrid, Spain cesar.sanchez@imdea.org
3Dept. of Software Engineering, Braude College, Israel sarai@braude.ac.il
Abstract. Bounded model checking (BMC) is an eÔ¨Äective technique for
hunting bugs by incrementally exploring the state space of a system. To
reason about inÔ¨Ånite traces through a Ô¨Ånite structure and to ultimately
obtain completeness, BMC incorporates loop conditions that revisit pre-
viously observed states. This paper focuses on developing loop conditions
for BMC of HyperLTL ‚Äì a temporal logic for hyperproperties that allows
expressing important policies for security and consistency in concurrent
systems, etc. Loop conditions for HyperLTL are more complicated than
forLTL,asdiÔ¨Äerenttracesmayloopinconsistentlyinunrelatedmoments.
Existing BMC approaches for HyperLTL only considered linear unrollings
without any looping capability, which precludes both Ô¨Ånding small in-
Ô¨Ånite traces and obtaining a complete technique. We investigate loop
conditions for HyperLTL BMC, for HyperLTL formulas that contain up to
onequantiÔ¨Åeralternation. WeÔ¨Årstpresentageneralcompleteautomata-
based technique which is based on bounds of maximum unrollings. Then,
we introduce alternative simulation-based algorithms that allow exploit-
ing short loops eÔ¨Äectively, generating SAT queries whose satisÔ¨Åability
guarantees the outcome of the original model checking problem. We also
report empirical evaluation of the prototype implementation of our BMC
techniques using Z3py.
1 Introduction
Hyperproperties[14] havebeen getting increasing attention due to their power to
reason about important speciÔ¨Åcations such as information-Ô¨Çow security policies
that require reasoning about the interrelation among diÔ¨Äerent execution traces.
HyperLTL [13] is an extension of the linear-time temporal logic LTL[33] that
allows quantiÔ¨Åcation over traces; hence, capable of describing hyperproperties.
For example, the security policy observational determinism can be speciÔ¨Åed as
?This research has been partially supported by the United States NSF
SaTC Award 2100989, by the Madrid Regional Gov. Project BLOQUES-CM
(S2018/TCS-4339), by Project PRODIGY (TED2021-132464B-I00) funded by
MCIN/AEI/10.13039/501100011033/ and the EU NextGenerationEU/PRTR, and
by a research grant from Nomadic Labs and the Tezos Foundation.arXiv:2301.06209v2  [cs.LO]  26 Jan 20232 T.-H. Hsu et al.
HyperLTL formula:8:80:(o‚Üîo0)W:(i‚Üîi0);which speciÔ¨Åes that for
every pair of traces and0, if they agree on the secret input i, then their
public output omust also be observed the same (here ‚Äò W‚Äô denotes the weak
until operator).
Several works [15,24] have studied model checking techniques for HyperLTL
speciÔ¨Åcations, which typically reduce this problem to LTLmodel checking queries
of modiÔ¨Åed systems. More recently, [29] proposed a QBF-based algorithm for the
direct application of bounded model checking (BMC) [12] to HyperLTL , and suc-
cessfully provided a push-button solution to verify or falsify HyperLTL formulas
with an arbitrary number of quantiÔ¨Åer alternations. However, unlike the clas-
sic BMC for LTL, which included the so-called loop conditions , the algorithm
in [29] is limited to (non-looping) linear exploration of paths. The reason is that
extending path exploration to include loops when dealing with multiple paths
simultaneously is not straightforward. For example, consider the HyperLTL for-
mula'1=8:90:(a/shortrightarrowb0)and a pair of Kripke structures K1andK2as
follows:
K1fgs1
fgs2fags3
fgs4K2fgq1fgq2
fgq3fagq4
fgq5
Assume trace ranges over K1and trace0ranges over K2. ProvinghK1;K2i6j=
'1canbeachievedbyÔ¨ÅndingaÔ¨Ånitecounterexample(i.e.,path s1s2s3fromK1).
Now, consider '2=8:90:(a‚Üîa0):It is easy to see that hK1;K2ij='2.
However, to prove hK1;K2ij='2, one has to show the absence of counterexam-
ples in inÔ¨Ånite paths, which is impossible with model unrolling in Ô¨Ånite steps as
proposed in [29].
In this paper, we propose eÔ¨Écient loop conditions for BMC of hyperproper-
ties. First, using an automata-based method, we show that lasso-shaped traces
are suÔ¨Écient to prove inÔ¨Ånite behaviors of traces within Ô¨Ånite exploration. How-
ever, this technique requires an unrolling bound that renders it impractical. In-
stead, our eÔ¨Écient algorithms are based on the notion of simulation [34] between
two systems. Simulation is an important tool in veriÔ¨Åcation, as it is used for ab-
straction, and preserves ACTLproperties [6,26]. As opposed to more complex
properties such as language containment, simulation is a more local property
and is easier to check. The main contribution of this paper is the introduction
of practical algorithms that achieve the exploration of inÔ¨Ånite paths following
a simulation-based approach that is capable of relating the states of multiple
models with correct successor relations.
We present two diÔ¨Äerent variants of simulation, SIM EAand SIM AE, allowing to
check the satisfaction of 98and89hyperproperties, respectively. These notions
circumvent the need to boundlessly unroll traces in both structures and synchro-
nize them. For SIM AE, in order to resolve non-determinism in the Ô¨Årst model, we
also present a third variant, where we enhance SIM AEby using prophecy vari-
ables[1,7]. Prophecy variables allow us to handle cases in which 89hyperprop-EÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 3
erties hold despite the lack of a direct simulation. With our simulation-based
approach, one can capture inÔ¨Ånite behaviors of traces with Ô¨Ånite exploration
in a simple and concise way. Furthermore, our BMC approach not only model-
checks the systems for hyperproperties, but also does so in a way that Ô¨Ånds
minimal witnesses to the simulation (i.e., by partially exploring the existentially
quantiÔ¨Åedmodel),whichwewillfurtherdemonstrateinourempiricalevaluation.
Case 'with:'with	
8small9big SIM AE/shortrightarrowj=89'BMC/shortrightarrow6j=89'
8big9small SIM AE/shortrightarrowj=89'BMC/shortrightarrow6j=89'
9small8big SIM EA/shortrightarrowj=98'BMC/shortrightarrow6j=98'
9big8small SIM EA/shortrightarrowj=98'BMC/shortrightarrow6j=98'
Table 1: Eight categories of HyperLTL formulas with
diÔ¨Äerent forms of quantiÔ¨Åers, sizes of models, and
diÔ¨Äerent temporal operators.We also design algo-
rithms that generate SAT
formulas for each vari-
ant (i.e., SIM EA,SIM AE,
and SIM AEwith prophe-
cies), where the satisÔ¨Åabil-
ity of formulas implies the
model checking outcome.
We also investigate the
practical cases of models
with diÔ¨Äerent sizes leading
to the eight categories in
Table 1. For example, the
Ô¨Årst row indicates the category of verifying two models of diÔ¨Äerent sizes with the
fragment that only allows 89quantiÔ¨Åers and (i.e.,globallytemporal operator);
8small9bigmeans that the Ô¨Årst model is relatively smaller than the second model,
andthepositiveoutcome( j=89')canbeprovedbyoursimulation-basedtech-
nique SIM AE, while the negative outcome ( 6j=89') can be easily checked using
non-looping unrolling (i.e., [29]). We will show that in certain cases, one can
verify a formula without exploring the entire state space of the bigmodel to
achieve eÔ¨Éciency.
We have implemented our algorithms1using Z3py, the Z3[17] API in python.
We demonstrate the eÔ¨Éciency of our algorithm exploring a subset of the state
space for the larger (i.e., big) model. We evaluate the applicability and eÔ¨É-
ciency with cases including conformance checking for distributed protocol syn-
thesis, model translation, and path planning problems. In summary, we make
the following contributions: (1) a bounded model checking algorithm for hyper-
properties with loop conditions, (2) three diÔ¨Äerent practical algorithms: SIM EA,
SIM AE, and SIM AEwith prophecies, and (3) a demonstration of the eÔ¨Éciency and
applicability by case studies that cover through all eight diÔ¨Äerent categories of
HyperLTL formulas (see Table 1).
Related Work. Hyperproperties were Ô¨Årst introduced by Clarkson and Schnei-
der [14]. HyperLTL was introduced as a temporal logic for hyperproperties in [13].
The Ô¨Årst algorithms for model checking HyperLTL were introduced in [24] using
alternating automata. Automated reasoning about HyperLTL speciÔ¨Åcations has
received attention in many aspects, including static veriÔ¨Åcation [16,22‚Äì24] and
monitoring [2,9,11,20,21,28,35]. This includes tools support, such as MCHy-
per[16,24] for model checking, EAHyper [19] and MGHyper [18] for satisÔ¨Åability
1Available at: https://github.com/TART-MSU/loop_condition_tacas234 T.-H. Hsu et al.
checking, and RVHyper [20] for runtime monitoring. However, the aforementioned
tools are either limited to HyperLTL formulas without quantiÔ¨Åer alternations, or
requiring additional inputs from the user (e.g., manually added strategies [16]).
Recently, this diÔ¨Éculty of alternating formulas was tackled by the bounded
model checker HyperQB [29] using QBF solving. However, HyperQB lacks loop
conditions to capture early inÔ¨Ånite traces in Ô¨Ånite exploration. In this paper, we
developsimulation-basedalgorithmstoovercomethislimitation.Therearealter-
native approaches to reason about inÔ¨Ånite traces, like reasoning about strategies
to deal with89formulas [15], whose completeness can be obtained by gener-
ating a set of prophecy variables [8]. In this work, we capture inÔ¨Ånite traces
in BMC approach using simulation. We also build an applicable prototype for
model-check HyperLTL formulas with models that contain loops.
2 Preliminaries
Kripke structures. AKripke structure Kis a tuplehS;S0;;AP;Li, whereS
is a set of states,S0Sis a set of initial states ,SSis a total transition
relation, andL:S/shortrightarrow2APis alabeling function , which labels states s2Swith
a subset of atomic propositions in APthat hold in s. ApathofKis an inÔ¨Ånite
sequence of states s(0)s(1)2S!, such thats(0)2S0, and (s(i);s(i+ 1))2,
for alli0. AloopinKis a Ô¨Ånite path s(n)s(n+1)s(`), for some 0n`,
such that (s(i);s(i+ 1))2, for allni < `, and (s(`);s(n))2. Note that
n=`indicates a self-loop on a state. A traceofKis a tracet(0)t(1)t(2)2 !,
such that there exists a path s(0)s(1)2S!witht(i) =L(s(i))for alli0.
We denote by Traces (K;s)the set of all traces of Kwith paths that start in
states2S. We use Traces (K)as a shorthand forS
s2S0Traces (K;s), andL(K)
as the shorthand for Traces (K).
Simulationrelations. LetKA=hSA;S0
A;A;APA;LAiandKB=hSB;S0
B;B;
APB;LBibe two Kripke structures. A simulation relation RfromKAtoKBis
a relationRSASBthat meets the following conditions:
1. For every sA2S0
Athere exists sB2S0
Asuch that (sA;sB)2R.
2. For every (sA;sB)2R, it holds that LA(sA) =LB(sB).
3. For every (sA;sB)2R, for every (sA;s0
A)2A, there exists (sB;s0
B)2B
such that (s0
A;s0
B)2R.
The Temporal Logic HyperLTL. HyperLTL [13] is an extension of the linear-
time temporal logic ( LTL) for hyperproperties. The syntax of HyperLTL formulas
is deÔ¨Åned inductively by the following grammar:
'::=9:'j8:'j
::=truejaj:j_j^jUjRj

wherea2APis an atomic proposition and is atrace variable from an inÔ¨Ånite
supply of variables V. The Boolean connectives :,_, and^have the usual
meaning,Uis the temporal untiloperator,Ris the temporal releaseoperator,
and
is the temporal nextoperator. We also consider other derived BooleanEÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 5
connectives, such as /shortrightarrowand‚Üî, and the derived temporal operators eventually
	'trueU'andglobally ':	:'. A formula is closed(i.e., asentence)
if all trace variables used in the formula are quantiÔ¨Åed. We assume, without loss
of generality, that no trace variable is quantiÔ¨Åed twice. We use Vars(')for the
set of trace variables used in formula '.
Semantics. An interpretation T=hTi2Vars (')of a formula 'consists of a
tuple of sets of traces, with one set Tper trace variable inVars('), denoting
the set of traces that ranges over. Note that we allow quantiÔ¨Åers to range over
diÔ¨Äerent models, which is called the multi-model semantics [25,29]2. That is,
each set of traces comes from a Kripke structure and we use K=hKi2Vars (')
to denote a familyof Kripke structures, so T=Traces (K)is the traces that
can range over, which comes from K2K. Abusing notation, we write T=
Traces (K).
The semantics of HyperLTL is deÔ¨Åned with respect to a trace assignment,
which is a partial map :Vars(')*!. The assignment with the empty
domain is denoted by ;. Given a trace assignment , a trace variable , and
a concrete trace t2!, we denote by [/shortrightarrowt]the assignment that coincides
witheverywhere but at , which is mapped to trace t. The satisfaction of
aHyperLTL formula'is a binary relation j=that associates a formula to the
models (T;;i )wherei2Z0is a pointer that indicates the current evaluating
position. The semantics is deÔ¨Åned as follows:
(T;;0)j=9:  iÔ¨Ä there is a t2T;such that (T;[/shortrightarrowt];0)j= ;
(T;;0)j=8:  iÔ¨Ä for all t2T;such that (T;[/shortrightarrowt];0)j= ;
(T;;i )j=true
(T;;i )j=a iÔ¨Äa2()(i);
(T;;i )j=: iÔ¨Ä (T;;i )6j= (T;;i )
(T;;i )j= 1_ 2iÔ¨Ä (T;;i )j= 1or(T;;i )j= 2;
(T;;i )j= 1^ 2iÔ¨Ä (T;;i )j= 1and(T;;i )j= 2;
(T;;i )j=
 iÔ¨Ä (T;;i + 1)j= ;
(T;;i )j= 1U 2iÔ¨Ä there is a jifor which (T;;j )j= 2and
for allk2[i;j);(T;;k )j= 1;
(T;;i )j= 1R 2iÔ¨Ä either for all ji;(T;;j )j= 2, or,
for someji;(T;;j )j= 1and
for allk2[i;j] : (T;;k )j= 2:
We say that an interpretation TsatisÔ¨Åes a sentence ', denoted byT j=', if
(T;;;0)j='. We say that a family of Kripke structures KsatisÔ¨Åes a sen-
tence', denoted byK j=', ifhTraces (K)i2Vars (')j='. When the same
Kripke structure Kis used for all path variables we write Kj='.
DeÔ¨Ånition 1. Anondeterministic B√ºchi automaton (NBW) is a tuple
A=h;Q;Q 0;;Fi, whereis analphabet,Qis a nonempty Ô¨Ånite set of
2In terms of the model checking problem, multi-model and (the conventional) single-
model semantics where all paths are assigned traces from the same Kripke struc-
ture [13] are equivalent (see [25,29]).6 T.-H. Hsu et al.
states,Q0Qis a set of initial states ,FQis a set of accepting states , and
QQis atransition relation .
Given an inÔ¨Ånite word w=12over, arun ofAonwis an inÔ¨Ånite
sequence of states r= (q0;q1;:::), such that q02Q0, and (qi 1;i;qi)2for
everyi>0. The run is accepting ifrvisits some state in FinÔ¨Ånitely often. We
say thatAacceptswif there exists an accepting run of Aonw. Thelanguage of
A, denotedL(A), is the set of all inÔ¨Ånite words accepted by A. An NBW Ais
called asafetyNBW if all of its states are accepting. Every safety LTLformula
 can be translated into a safety NBW over 2APsuch thatL(A)is the set of all
traces over APthat satisfy  [30].
3 Adaptation of BMC to HyperLTL on InÔ¨Ånite Traces
There are two main obstacles in extending the BMC approach of [29] to handle
inÔ¨Ånite traces. First, a trace may have an irregular behavior. Second, even traces
whose behavior is regular, that is, lasso shaped, are hard to synchronize, since
the length of their respective preÔ¨Åxes and lassos need not to be equal. For the
latter issue, synchronizing two traces whose preÔ¨Åxes and lassos are of lengths
p1;p2andl1;l2, respectively, is equivalent to coordinating the same two traces,
when deÔ¨Åning both their preÔ¨Åxes to be of length maxfp1;p2g, and their lassos to
be of length lcmfl1;l2g, where ‚Äò lcm‚Äô stands for ‚Äòleast common multiple‚Äô. As for
the former challenge, we show that restricting the exploration of traces in the
models to only consider lasso traces is sound. That is, considering only lasso-
shaped traces is equivalent to considering the entire trace set of the models.
LetK=hS;S0;;AP;Libe a Kripke structure. A lasso path ofKis a
paths(0)s(1):::s(`)such that (s(`);s(n))2for some 0n < `. This path
induces a lasso trace (or simply, a lasso)L(s0):::L(sn 1) (L(sn):::L(s`))!. Let
hK1;:::;Kkibe a multi-model. We denote the set of lasso traces of KibyCi
for all 1ik, and we useL(Ci)as the shorthand for the set of lasso traces
ofKi.
Theorem 1. LetK=hK1;:::;Kkibe a multi-model, and let '=Q11:Qk
k: be a HyperLTL formula, both over AP, thenKj='iÔ¨ÄhC1;:::;Ckij='.
Proof.(sketch) For an LTLformula over APfigk
i=1, we denote the trans-
lation of to an NBW over 2APfigk
i=1byA [36]. Given =Q11Qkk,
where Qi2 f9;8g, we deÔ¨Åne the satisfaction of A byKw.r.t., denoted
Kj= (,A ), in the natural way: 9icorresponds to the existence of a path
assigned to iinKi, and dually for8i. Then,Kj= (;A )iÔ¨Ä the various k-
assignments of traces of Ktofigk
i=1according to are accepted by A , which
holds iÔ¨ÄKj='.
For a model K, we denote by K\kA the intersection of KandA w.r.t.
APfkg, taking the projection over APfigk 1
i=1. Thus,L(K\kA )is the
set of all (k 1)-words that an extension (i.e.,9) by a word inL(K)to ak-
word inL(A ). Oppositely,L(K\kA )is the set of all (k 1)-words that every
extension (i.e.,8) by ak-word inL(K)is inL(A ).EÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 7
We Ô¨Årst construct NBWs A2;:::;Ak 1;Ak, such that for every 1< i < k,
we havehK1;:::;Kiij= (i;Ai+1)iÔ¨ÄKj= (;A ), wherei=Q11:::Qii.
Fori=k, ifQk=9, thenAk=Kk\kA ; otherwise if Qk=8,Ak=
Kk\kA . For 1<i<k, ifQi=9thenAi=Ki\iAi+1; otherwise if Qi=8,
Ai=Ki\iAi+1. Then, for every 1<i<k, we havehK1;:::;Kiij= (i;Ai+1)
iÔ¨ÄhK1;:::;Kkij='.
We now prove by induction on kthatKj='iÔ¨ÄhC1;:::Ckij='. Fork= 1,
it holds thatKj='iÔ¨ÄK1j= (Q11;A2). IfQ1=8, thenK1j= (Q11;A2)
iÔ¨ÄK1\A2=;. IfQ1=9, thenK1j= (Q11;A2)iÔ¨ÄK1\A26=;. In both
cases, a lasso witness to the non-emptiness exists. For 1< i < k , we prove
thathC1;:::;Ci;Ki+1ij= (i+1;Ai+2)iÔ¨ÄhC1;:::;Ci;Ci+1ij= (i+1;Ai+2). If
Qi=8, then the Ô¨Årst direction simply holds because L(Ci+1)
L(Ki+1). For the second direction, every extension of c1;c2;:::ci(i.e., lassos in
C1;C2;:::Ci)byapathinKi+1isinL(Ai+2).Indeed,otherwisewecanextract
a lassoci+1such thatc1;c2;:::ci+1is inL(Ai+2), a contradiction. If Qi=9,
thenL(Ci+1)L(Ki+1)implies the second direction. For the Ô¨Årst direction, we
can extract a lasso ci+12L(Ci+1)such thathc1;c2;:::ci;ci+1i2L (Ai+2).u t
One can use Theorem 1 and the observations above to construct a sound
and complete BMC algorithm for both 89and98hyperproperties. Indeed,
consider a multi-model hK1;K2i, and a hyperproperty '=8:90:  . Such
a BMC algorithm would try and verify hK1;K2ij='directly, or try and prove
hK1;K2ij=:'. In both cases, a run may Ô¨Ånd a short lasso example for the
model under9(K2in the former case and K1in the latter), leading to a shorter
run. However, in both cases, the model under 8would have to be explored to
the maximal lasso length implicated by Theorem 1, which is doubly-exponential.
Therefore, this naive approach would be highly ineÔ¨Écient.
4 Simulation-Based BMC Algorithms for HyperLTL
WenowintroduceeÔ¨Écientsimulation-basedBMCalgorithmsforverifyinghyper-
properties of the types 8:90:Predand9:80:Pred, where Predis arelational
predicate (a predicate over a pair of states). The key observation is that simu-
lation naturally induces the exploration of inÔ¨Ånite traces without the need to
explicitly unroll the structures, and without needing to synchronize the indices
of the symbolic variables in both traces. Moreover, in some cases our algorithms
allow to only partially explore the state space of a Kripke structure and give a
conclusive answer eÔ¨Éciently.
LetKP=hSP;S0
P;P;APP;LPiandKQ=hSQ;S0
Q;Q;APQ;LQibe two
Kripke structures, and consider a hyperproperty of the form 8:90:Pred.
Suppose that there exists a simulation from KPtoKQ. Then, every trace in
KPis embodied in KQ. Indeed, we can show by induction that for every trace
tp=sp(1)sp(2):::inKP, there exists a trace tq=sq(1)sq(2):::inKQ, such
thatsq(i)simulatessp(i)for everyi1; therefore, tpandtqare equally la-
beled. We generalize the labeling constraint in the deÔ¨Ånition of standard simu-
lation by requiring, given Pred, that if (sp;sq)is in the simulation relation, then8 T.-H. Hsu et al.
(sp;sq)j=Pred. We denote this generalized simulation by SIM AE. Following sim-
ilar considerations, we now have that for every trace tpinKP, there exists a
tracetqinKQsuch that (tp;tq)j=Pred. Therefore, the following result holds:
Lemma 1. LetKPandKQbe Kripke structures, and let '=8:90:Predbe
aHyperLTL formula. If there exists SIMAEfromKPtoKQ, thenhKP;KQij='.
We now turn to properties of the type 9:80:Pred. In this case, we must
Ô¨Ånd a single trace in KPthat matches every trace in KQ. Notice that SIM AE
(in the other direction) does not suÔ¨Éce, since it is not guaranteed that the
same trace in KPis used to match all traces in KQ. However, according to
Theorem 1, it is guaranteed that if hKP;KQij=9:80:Pred, then there ex-
ists such a single lasso trace tpinKPas the witness of the satisfaction. We
therefore deÔ¨Åne a second notion of simulation, denoted SIM EA, as follows. Let
tp=sp(1)sp(2):::sp(n):::sp(`)be a lasso trace in KP(wheresp(`)closes to
sp(n), that is, (sp(`);sp(n))2P). A relation RfromtptoKQis considered as
aSIM EAfromtptoKQ, if the following holds:
1.(sp;sq)j=Predfor every (sp;sq)2R.
2.(sp(1);sq)2Rfor everysq2S0
Q.
3. If (sp(i);sq(i))2R, then for every successor sq(i+ 1)ofsq(i), it holds that
(sp(i+ 1);sq(i+ 1))2R(wheresp(`+ 1)is deÔ¨Åned to be sp(n)).
Ifthereexistsalassotrace tp,thenwesaythatthereexists SIM EAfromKPtoKQ.
Notice that the third requirement in fact unrolls KQin a way that guarantees
that for every trace tqinKQ, it holds that (tp;tq)j=Pred. Therefore, the
following result holds:
Lemma 2. LetKPandKQbe Kripke structures, and let '=9:80:Pred.
If there exists a SIMEAfromKPtoKQ, thenhKP;KQij='.
Lemmas 1 and 2 enable sound algorithms for model-checking 8:90:Pred
and9:80:Predhyperproperties with loop conditions. To check the former,
check whether there exists SIM AEfromKPtoKQ; to check the latter, check
for a lasso trace tpinKPand SIM EAfromtptoKQ. Based on these ideas, we
introduce now two SAT-based BMC algorithms.
For89hyperproperties, we not only check for the existence of SIM AE, but also
iteratively seek a small subset of SQthat suÔ¨Éces to simulate all states of SP.
While Ô¨Ånding SIM AE, as for standard simulation, is polynomial, the problem of
Ô¨Ånding a simulation that uses a bounded number of KQstates is NP-complete
(see Appendix A.1 for details). This allows us to eÔ¨Éciently handle instances in
whichKQis large. Moreover, we introduce in Subsection 4.3 the use of prophecy
variables , allowing us to overcome cases in which the models satisfy the property
butSIM AEdoes not exist.
For98hyperproperties, we search for SIM EAby seeking a lasso trace tpin
KP, whose length increases with every iteration, similarly to standard BMC
techniques for LTL. Of course, in our case, tpmust be matched with the states
ofKQin a way that ensures SIM EA. In the worst case, the length of tpmay beEÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 9
doubly-exponential in the sizes of the systems. However, as our experimental
results show, in case of satisfaction the process can terminate much sooner.
WenowdescribeourBMCalgorithmsandourSATencodingsindetail.First,
we Ô¨Åx the unrolling depth of KPtonand ofKQtok. To encode states of KPwe
allocate a family of Boolean variables fxign
i=1. Similarly, we allocate fyjgk
j=1to
represent the states of KQ. Additionally, we encode the simulation relation Tby
creatingnkBoolean variables fsimijgn
i=1;k
j=1such that simijholds if and only
ifT(pi;qj). We now present the three variations of encoding: (1) EA-Simulation
(SIM EA), (2) AE-Simulation ( SIM AE), and (3) a special variation where we enrich
AE-Simulation with prophecies.
4.1 Encodings for EA-Simulation
The goal of this encoding is to Ô¨Ånd a lasso path tpinKPthat guarantees that
there exists SIM EAtoKQ. Note that the set of states that tpuses may be much
smaller than the whole of KP, while the state space of KQmust be explored
exhaustively. We force x0be an initial state of KPand forxi+1to followxi
for everyiwe use, but for KQwe will let the solver Ô¨Åll freely each ykand add
constraints3for the full exploration of KQ.
All states are legal states. The solver must only search legal encodings
of states of KPandKQ(we useKP(xi)to represent the combinations of
values that represent a legal state in SPand similarly KQ(yj)forSQ):
n^
i=1KP(xi)^k^
j=1KQ(yj) (1)
Exhaustive exploration of KQ.We require that two diÔ¨Äerent indices yj
andyrrepresent two diÔ¨Äerent states in KQ, so ifk=jKQj, then all states
are represented (note that the validity of states is implied by (1)):
^
j6=r(KQ(yj)^KQ(yr))/shortrightarrow(yj6=yr) (2)
whereyj6=yrcaptures that some bit distinguishes the states encoded by j
andr.
The initial S0
Pstate simulates all initial S0
Qstates.Statex0is an initial
state ofKPand simulates all initial states of KQ(we useIPto represent a
legal initial state in KPandIQ(yj)forS0
QofKQ):
IP(x0)^ k^
j=1IQ(yj)/shortrightarrowT(x0;yj)
(3)
3An alternative is to Ô¨Åx an enumeration of the states of KQand force the assignment
ofy0: : :according to this enumeration instead of constraining a symbolic encoding,
but the explanation of the symbolic algorithm above is simpler.10 T.-H. Hsu et al.
Successors in KQare simulated by successors in KP.We Ô¨Årst intro-
ducethefollowingformula succT(x;x0)tocaptureone-stepofthesimulation,
that is,x0followsxand for all yifT(x;y)thenx0simulates all successors
ofy(we useQ(y;y0)to represent that yandy0states are in QofKQ,
similarly for (x;x0)2PofKPwe useP(x;x0)):
succT(x;x0)def=yk^
y=y1T(x;y)/shortrightarrow yk^
y0=y1Q(y;y0)/shortrightarrowT(x0;y0)
We can then deÔ¨Åne that xi+1followsxi:
n 1^
i=1
P(xi;xi+1)^succT(xi;xi+1)
(4)
And,xnhas a jump-back to a previously seen state:
n_
i=1
P(xn;xi)^succT(xn;xi)
(5)
Relational state predicates are fulÔ¨Ålled by simulation. Everything
relating in the simulation Ô¨Åts the relational predicate, deÔ¨Åned as a function
Predof two sets of labels (we use LQ(y)to represent the set of labels on the
y-encoded state in KQ, similarly, LP(x)for thex-encoded state in KP):
n^
i=1k^
j=1T(xi;yj)/shortrightarrowPred(LP(xi);LQ(yj)) (6)
We use'n;k
EAfor the SAT formula that results of conjoining (1)-(6)for bounds n
andk. If'n;k
EAis satisÔ¨Åable, then there exists SIM EAfromKPtoKQ.
4.2 Encodings for AE-Simulation
Our goal now is to Ô¨Ånd a set of states S0
QSQthat is able to simulate all states
inKP. Therefore, as in the previous case, the state space KPcorresponding to
the8quantiÔ¨Åer will be explored exhaustively, and so n=jKPj, whilekis the
number of states in KQ, which increases in every iteration. As we have explained,
this allows Ô¨Ånding a small subset of states in KQwhich suÔ¨Éces to simulate all
states ofKP.
All states in the simulation are legal states. Again, every state guessed
in the simulation is a legal state from KPorKQ:
n^
i=1KP(xi)^k^
j=1KQ(yj) (10)EÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 11
KPis exhaustively explored. Every two diÔ¨Äerent indices in the states of
KPare diÔ¨Äerent states4:
^
i6=r(KP(xi)^KP(xr))/shortrightarrow(xi6=xr) (20)
All initial states in KPmust match with some initial state in KQ.
Note that, contrary to the 98case, here the initial state in KQmay be
diÔ¨Äerent for each initial state in SP:
n^
i=1k_
j=1IP(xi)/shortrightarrow 
IQ(yj)^T(xi;yj)
(30)
For every pair in the simulation, each successor in KPmust match
with some successor in KQ.For each (xi;yj)in the simulation, every
successor state of xihas a matching successor state of yj:
n^
i=1n^
t=1P(xi;xt)/shortrightarrowk^
j=1h
T(xi;yj)/shortrightarrowk_
r=1
Q(yj;yr)^T(xt;yr)i
(40)
Relational state predicates are fulÔ¨Ålled. Similarly, all pairs of states in
the simulation should respect the relational Pred:
n^
i=1k^
j=1T(xi;yj)/shortrightarrowPred(LP(xi);LQ(yj)) (50)
We now use 'n;k
AEfor the SAT formula that results of conjoining ( 10)-(50) for
boundsnandk. If'n;k
AEis satisÔ¨Åable, then there exists SIM AEfromKPtoKQ.
4.3 Encodings for AE-Simulation with Prophecies
The AE-simulation encoding introduced in Section 4.2 can handle most prop-
erties of the form 89Pred; however, it is unable to cope well with systems (in
particularthesystem KPforthe8quantiÔ¨Åer)thatexhibitnon-determinism.The
reason, as illustrated in the following example, is that the simulation matches
immediately the successor for the 9path without inspecting the future of the 8
path. This is illustrated in the following example.
Example 1. Consider Kripke structures K1andK2from Section 1, and HyperLTL
formula'2=8:90:(a‚Üîa0). It is easy to see that the two models satisfy
'2, since mapping the sequence of states (s1s2s3)to(q1q2q4)and(s1s2s4)to
(q1q3q5)guarantees that the matched paths satisfy (a‚Üîa0). However, the
technique in Section 4.2 cannot diÔ¨Äerentiate the occurrences of s2in the two
diÔ¨Äerent cases. u t
4As in the previous case, we could Ô¨Åx an enumeration of the states of SPand Ô¨Åx
x0x1: : :to be the states according to the enumerations.12 T.-H. Hsu et al.
a
a
a
a
a
Fig.1: Prophecy automaton for 

a(left) and its composition with K1(right).
To solve this, we incorporate the notion of prophecies to our setting. Prophe-
cies have been proposed as a method to aid in the veriÔ¨Åcation of hyperlive-
ness [15] (see [7] for a systematic method to construct these kind of prophecies).
For simplicity, we restrict here to prophecies expressed as safety automata. A
safety prophecy over APis a Kripke structure U=hS;S0;;AP;Li, such that
Traces (U) =AP!. The product KUof a Kripke structure Kwith a prophecy
Upreserves the language of K(since the language of Uis universal). Recall
that in the construction of the product, states (s;u)2(KU)that have in-
compatible labels are removed. The direct product can be easily processed by
repeatedly removing dead states, resulting in a Kripke structure K0whose lan-
guage isTraces (K0) =Traces (K). Note that there may be multiple states in K0
that correspond to diÔ¨Äerent states in Kfor diÔ¨Äerent prophecies. The prophecy-
enriched Kripke structure can be directly passed to the method in Section 4.2,
so the solver can search for a SIM AEthat takes the value of the prophecy into
account.
Example 2. Consider the prophecy automaton shown in Fig. 1 (left), where all
states are initial. Note that for every state, either all its successors are labeled
witha(or none are), and all successors of its successors are labeled with a
(or none are). In other words, this structure encodes the prophecy 

a. The
productK0
1ofK1with the prophecy automaton Ufor

ais shown in Fig. 1
(right). Our method can now show that hK0
1;K2ij='2, since it can distinguish
the two copies of s1(one satisÔ¨Åes 

aand is mapped to (q1q2q4), while the
other is mapped to (q1q3q5)). u t
5 Implementation and Experiments
Wehaveimplemented ouralgorithms usingtheSATsolver Z3throughits python
API Z3Py[31]. The SAT formulas introduced in Section 4 are encoded into the
two scripts simEA.py and simAE.py , for Ô¨Ånding simulation relations for the
SIM EAand SIM AEcases, respectively. We evaluate our algorithms with a set of
experiments, which includes all forms of quantiÔ¨Åers with diÔ¨Äerent sizes of given
models, as presented earlier in Table 1. Our simulation algorithms beneÔ¨Åt the
most in the cases of the form 8small9big. When the second model is substantially
larger than the Ô¨Årst model, SIM AEis able to prove that a 89hyperproperty
holds by exploring only a subset of the second model. In this section, besides
8small9bigcases, we also investigate multiple cases on each category in Table 1 toEÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 13
demonstrate the generality and applicability of our algorithms. All case studies
are run on a MacBook Pro with Apple M1 Max chip and 64 GB of memory.
5.1 Case Studies and Empirical Evaluation
Conformance in Scenario-based Programming. In scenario-based pro-
gramming, scenarios provide a big picture of the desired behaviors of a program,
and are often used in the context of program synthesis or code generation. A
synthesized program should obey what is speciÔ¨Åed in the given set of scenarios
to be considered correct. That is, the program conforms with the scenarios. The
conformance check between the scenarios and the synthesized program can be
speciÔ¨Åed as a89-hyperproperty:
'conf=8:90:^
p2AP(p‚Üîp0);
whereis over the scenario model and 0is over the synthesized program. That
is, for all possible runs in the scenarios, there must exists a run in the program,
such that their behaviors always match.
We look into the case of synthesizing an Alternating Bit Protocol (ABP) from
four given scenarios, inspired by [3]. ABP is a networking protocol that guar-
antees reliable message transition, when message loss or data duplication are
possible. The protocol has two parties: senderand receiver , which can take
three diÔ¨Äerent actions: send,receive, andwait. Each action also speciÔ¨Åes which
message is currently transmitted: either a packetoracknowledgment (see [3] for
more details). The correctly synthesized protocol should not only have complete
functionality but also include all scenarios . That is, for every trace that appears
in some scenario, there must exist a corresponding trace in the synthesized pro-
tocol. By Ô¨Ånding SIM AEbetween the scenarios and the synthesized protocols,
we can prove the conformance speciÔ¨Åed with 'conf. Note that the scenarios are
often much smaller than the actual synthesized protocol, and so this case falls
in the8small9bigcategory in Table 1. We consider two variations: a correct and
an incorrect ABP (that cannot handle packet loss). Our algorithm successfully
identiÔ¨Åes a SIM AEthat satisÔ¨Åes 'conffor the correct ABP, and returns UNSAT
for the incorrect protocol, since the packet loss scenario cannot be simulated.
VeriÔ¨Åcation of Model Translation. It is often the case that in model trans-
lation (e.g., compilation), solely reasoning about the source program does not
provide guarantees about the desirable behaviors in the target executable code.
Since program veriÔ¨Åcation is expensive compared with repeatedly checking the
target, alternative approaches such as certiÔ¨Åcate translation [4] are often pre-
ferred. CertiÔ¨Åcate translation takes inputs of a high-level program (source) with
a given speciÔ¨Åcation, and computes a set of veriÔ¨Åcation conditions (certiÔ¨Åcates)
for the low-level executable code (target) to prove that a model translation is
safe. However, this technique still requires extra eÔ¨Äorts to map the certiÔ¨Åcates
to a target language, and the size of generated certiÔ¨Åcates might explode quickly14 T.-H. Hsu et al.
(see [4] for retails). We show that our simulation algorithm can directly show
the correctness of a model translation more eÔ¨Éciently by investigating the source
and target with the same formula 'confused for ABP. That is, the speciÔ¨Åcations
from the source runs are always preserved in some target runs 0, which infers
a correct model translation. Since translating a model into executable code im-
plies adding extra instructions such as writing to registers, it also falls into the
8small9bigcategory in Table 1.
Weinvestigate aprogramfrom[4]thatperforms matrix multiplication (MM) .
When executed, the C program is translated from high-level code (C) to low-
level code RTL (Register Transfer Level), which contains extra steps to read
from/write to memories. SpeciÔ¨Åcations are triples of hPre;annot;Posti, where
Pre, and Postare assertions and annotis a partial function from labels to as-
sertions (see [4] for detailed explanations). The goal is to make sure that the
translation does not violate the original veriÔ¨Åed speciÔ¨Åcation. In our framework,
instead of translating the certiÔ¨Åcation, we Ô¨Ånd a simulation that satisÔ¨Åes 'conf,
proving that the translated code also satisÔ¨Åes the speciÔ¨Åcation. We also investi-
gate two variations in this case: a correct translation and an incorrect transla-
tion, and our algorithm returns SAT (i.e., Ô¨Ånds a correct SIM AEsimulation) in
the former case, and returns UNSAT for the latter case.
Fig.2: The common branch fac-
torization example [32].Compiler Optimization. Secure compiler
optimization aims at preserving input-output
behaviors of an original implementation and
a target program after applying optimization
techniques, including security policies. The
conformance between source and target pro-
grams guarantees that the optimizing proce-
duredoesnotintroducevulnerabilitiessuchas
information leakage. Furthermore, optimiza-
tion is often not uniform for the same source,
because one might compile the source to mul-
tiple diÔ¨Äerent targets with diÔ¨Äerent optimiza-
tion techniques. As a result, an eÔ¨Écient way
to check the behavioral equivalence between
the source and target provides a correctness
guarantee for the compiler optimization.
Imposing optimization usually results in
a smaller program. For instance, common
branch factorization (CBF) Ô¨Ånds common operations in an if-then-else struc-
ture, and moves them outside of the conditional so that such operation is only
executed once. As a result, for these optimization techniques, checking the con-
formance of the source and target falls in the 8big9smallcategory. That is, given
two programs, source ( big) and target ( small), we check the following formula:
'sc=8:90:(in‚Üîin0)/shortrightarrow(out‚Üîout0):EÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 15
In this case study we investigate the strategy CBF using the example in
Figure 2 inspired by [32]. We consider two kinds of optimized programs for the
strategy, one is the correct optimization, one containing bugs that violates the
original behavior due to the optimization. For the correct version, our algorithm
successfully discovered a simulation relation between the source and target, and
the simulation relation returns a smaller subset of states in the second model
(i.e.,jQ0j<jQj). For the incorrect version, we received UNSAT.
Fig.3: A
robust paths.RobustPathPlanning. Inroboticplanning, robustness plan-
ning (RP) refers to a path that is able to consistently complete
a mission without being interfered by the uncertainty in the en-
vironment (e.g., adversaries). For instance, in the 2-D plane in
Fig. 3, an agent is trying to go from the starting point (blue
grid) to the goal position (green grid). The plane also contains
three adversaries on the three corners other than the starting
point (red-framed grids), and the adversaries move trying to
catch the agent but can only move in one direction (e.g., clockwise). This is a
9small8bigsetting, since the adversaries may have several ways to cooperate and
attempt to catch the agent. We formulate this planning problem as follows:
'rp=9:80:(pos6‚Üîpos0):
Thatis,thereexistsarobustpathfortheagenttosafelyreachthegoalregardless
of all the ways that the adversaries could move. We consider two scenarios, one
in which there exists a way for the agent to form a robust path and one does
not. Our algorithm successfully returns SAT for case which the agent can form a
robust path, and returns UNSAT for which a robust path is impossible to Ô¨Ånd.
Plan Synthesis. The goal of plan synthesis (PS) is to synthesize a single com-
prehensive plan that can simultaneously satisfy all given small requirements has
wide application in planning problems. We take the well-known toy example,
wolf, goat, and cabbage5, as a representative case here. The problem is as fol-
lows. A farmer needs to cross a river by boat with a wolf, a goat, and a cabbage.
However, the farmer can only bring one item with him onto the boat each time.
In addition, the wolf would eat the goat, and the goat would eat the cabbage,
if they are left unattended. The goal is to Ô¨Ånd a plan that allows the farmer
to successfully cross the river with all three items safely. A plan requires the
farmer to go back and forth with the boat with certain possible ways to carry
diÔ¨Äerent items, while all small requirements (i.e., the constraints among each
item) always satisÔ¨Åed. In this example, the overall plan is a big model while the
requirements form a much smaller automaton. Hence, it is a 9big8smallproblem
that can be speciÔ¨Åed with the following formula:
'ps=9:80:(action6‚Üîviolation0):
5https://en.wikipedia.org/wiki/Wolf,_goat_and_cabbage_problem16 T.-H. Hsu et al.
Type Quants Cases jSPjjSQjZ3 Outcome solve[s]
SIM AE8small9bigABP 1114sat jS0
Qj=11 9.37
ABP w/ bug 1114unsat - 9.46
MM 2727sat jS0
Qj=27 67.74
MM w/ bug 2727unsat - 66.85
8big9smallCBF 159sat jS0
Qj=8 3.49
CBF w/ bug 159unsat - 3.51
SIM EA9small8bigRP 3389sat jS0
Pj=5 1.09
RP 33
no sol.89unsat - 1.02
9big8smallGCW 164sat jS0
Pj=8 3.36
GCW no sol.164unsat - 2.27
Table 2: Summary of our case studies. The outcomes with simulation discovered
show how our algorithms Ô¨Ånd a smaller subset for either KPorKQ.
5.2 Analysis and Discussion
The summary of our empirical evaluation is presented in Table 2. For the 89
cases, our algorithm successfully Ô¨Ånds a set jS0
Qj<jSQjthat satisÔ¨Åes the prop-
erties for the cases ABP and CBF. Note that case MM does not Ô¨Ånd a small
subset, since we manually add extra paddings on the Ô¨Årst model to align the
length of both traces. We note that handling this instance without padding re-
quires asynchornicity‚Äî a much more diÔ¨Écult problem, which we leave for future
work. For the98cases, we are able to Ô¨Ånd a subset of SPwhich forms a single
lasso path that can simulate all runs in SQfor all cases RP and GCW. We em-
phasize here that previous BMC techniques (i.e., HyperQB) cannot handle most
of the cases in Table 2 due to the lack of loop conditions.
6 Conclusion and Future Work
We introduced eÔ¨Écient loop conditions for bounded model checking of fragments
ofHyperLTL . We proved that considering only lasso-shaped traces is equivalent to
consideringtheentiretracesetofthemodels,andproposedtwosimulation-based
algorithms SIM EAand SIM AEto realize inÔ¨Ånite reasoning with Ô¨Ånite exploration
forHyperLTL formulas. To handle non-determinism in the latter case, we com-
bine the models with prophecy automata to provide the (local) simulations with
enough information to select the right move for the inner 9path. Our algorithms
are implemented using Z3py. We have evaluated the eÔ¨Äectiveness and eÔ¨Éciency
with successful veriÔ¨Åcation results for a rich set of input cases, which previous
bounded model checking approach would fail to prove.
As for future work, we are working on exploiting general prophecy automata
(beyond safety) in order to achieve full generality for the 89case. The second
direction is to handle asynchrony between the models in our algorithm. Even
though model checking asynchronous variants of HyperLTL is in general unde-
cidable [5,10,27], we would like to explore semi-algorithms and fragments with
decidability properties. Lastly, exploring how to handle inÔ¨Ånite-state systems
with our framework by applying abstraction techniques is also another promis-
ing future direction.EÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 17
References
1. M. Abadi and L. Lamport. The existence of reÔ¨Ånement mappings. Theoretical
Computer Science , 82:253‚Äì284, 1991.
2. Shreya Agrawal and Borzoo Bonakdarpour. Runtime veriÔ¨Åcation of k-safety hyper-
propertiesinHyperLTL. In Proc. of the 29th IEEE Computer Security Foundations
Symposium (CSF‚Äô16) , pages 239‚Äì252. IEEE, 2016.
3. Rajeev Alur, Milo Martin, Mukund Raghothaman, Christos Stergiou, Stavros Tri-
pakis, and Abhishek Udupa. Synthesizing Ô¨Ånite-state protocols from scenarios and
requirements. In Haifa VeriÔ¨Åcation Conference , pages 75‚Äì91. Springer, 2014.
4. Gilles Barthe, Benjamin Gr√©goire, Sylvain Heraud, C√©sar Kunz, and Anne Pacalet.
Implementing a direct method for certiÔ¨Åcate translation. In International Confer-
ence on Formal Engineering Methods , pages 541‚Äì560. Springer, 2009.
5. Jan Baumeister, Norine Coenen, Borzoo Bonakdarpour, Bernd Finkbeiner, and
C√©sar S√°nchez. A temporal logic for asynchronous hyperproperties. In Proc. of the
33rd Int‚Äôl Conf. on Computer Aided VeriÔ¨Åcation (CAV‚Äô21), Part I , volume 12759
ofLNCS, pages 694‚Äì717. Springer, 2021.
6. S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. Property preserving sim-
ulations. In Proc. 4th Int. Conf. on Computer Aided VeriÔ¨Åcation , volume 663 of
Lecture Notes in Computer Science , pages 260‚Äì273. Springer-Verlag, 1992.
7. Raven Beutner and Bernd Finkbeiner. Prophecy variables for hyperproperty veri-
Ô¨Åcation. In Proc. of Computer Security Foundations Symposium (CSF‚Äô22) . IEEE,
2022.
8. Raven Beutner and Bernd Finkbeiner. Prophecy variables for hyperproperty veri-
Ô¨Åcation. CoRR, abs/2206.01797, 2022.
9. Borzoo Bonakdarpour, C√©sar S√°nchez, and Gerardo Schneider. Monitoring hyper-
properties by combining static analysis and runtime veriÔ¨Åcation. In Proc. of the
8th Int‚Äôl Symposium on Leveraging Applications of Formal Methods, VeriÔ¨Åcation
and Validation (ISoLA‚Äô18), Part II , volume 11245 of LNCS, pages 8‚Äì27. Springer,
2018.
10. Laura Bozzelli, Adriano Peron, and C√©sar S√°nchez. Asynchronous extensions of
HyperLTL. In Proc. of the 36th Annual ACM/IEEE Symposium on Logic in Com-
puter Science (LICS‚Äô21) , pages 1‚Äì13. IEEE, 2021.
11. Noel Brett, Umair Siddique, and Borzoo Bonakdarpour. Rewriting-based runtime
veriÔ¨Åcation for alternation-free HyperLTL. In Proc. of the 23rd Int‚Äôl Conf. on Tools
and Algorithms for the Construction and Analysis of Systems (TACAS‚Äô17), Part
II, volume 10206 of LNCS, pages 77‚Äì93. Springer, 2017.
12. Edmund M. Clarke, Armin Biere, Richard Raimi, and Yunshan Zhu. Bounded
model checking using satisÔ¨Åability solving. Formal Methods in System Design ,
19(1):7‚Äì34, 2001.
13. Michael R. Clarkson, Bernd Finkbeiner, Masoud Koleini, Kristopher K. Micinski,
Markus N. Rabe, and C√©sar S√°nchez. Temporal logics for hyperproperties. In Proc.
of the 3rd Int‚Äôl Conf. on Principles of Security and Trust (POST‚Äô14) , volume 8414
ofLNCS, pages 265‚Äì284. Springer, 2014.
14. MichaelR.ClarksonandFredB.Schneider. Hyperproperties. Journal of Computer
Security, 18(6):1157‚Äì1210, 2010.
15. Norine Coenen, Bernd Finkbeiner, C√©sar S√°nchez, and Leander Tentrup. Verifying
hyperliveness. In Proc. of the 31st Int‚Äôl Conf. on Computer Aided VeriÔ¨Åcation
(CAV‚Äô19) , volume 11561 of LNCS, pages 121‚Äì139. Springer, 2019.18 T.-H. Hsu et al.
16. Norine Coenen, Bernd Finkbeiner, C√©sar S√°nchez, and Leander Tentrup. Verifying
hyperliveness. In Proc. of the 31st Int‚Äôl Conf. on Computer Aided VeriÔ¨Åcation
(CAV‚Äô19), Part I , volume 11561 of LNCS, pages 121‚Äì139. Springer, 2019.
17. Leonardo M. de Moura and Nikolaj Bj√∏rner. Z3: An eÔ¨Écient SMT solver. In Tools
and Algorithms for the Construction and Analysis of Systems (TACAS) , pages
337‚Äì340, 2008.
18. Bernd Finkbeiner, Cristopher Hahn, and Tobias Hans. MGHyper: Checking satisÔ¨Å-
ability of HyperLTL formulas beyond the 98fragment. In Proc. of the 16th Int‚Äôl
Symposium on Automated Technology for VeriÔ¨Åcation and Analysis (ATVA‚Äô18) ,
volume 11138 of LNCS, pages 521‚Äì527. Springer, 2018.
19. Bernd Finkbeiner, Cristopher Hahn, and Marvin Stenger. Eahyper: SatisÔ¨Åability,
implication, and equivalence checking of hyperproperties. In Proc. of the 29th Int‚Äôl
Conf. on Computer Aided VeriÔ¨Åcation (CAV‚Äô17), Part II , volume 10427 of LNCS,
pages 564‚Äì570. Springer, 2017.
20. BerndFinkbeiner,CristopherHahn,MarvinStenger,andLeanderTentrup. RVHy-
per: A runtime veriÔ¨Åcation tool for temporal hyperproperties. In Proc. of the 24th
Int‚Äôl Conf. on Tools and Algorithms for the Construction and Analysis of Systems
(TACAS‚Äô18), Part II , volume 10806 of LNCS, pages 194‚Äì200. Springer, 2018.
21. Bernd Finkbeiner, Cristopher Hahn, Marvin Stenger, and Leander Tentrup. Mon-
itoring hyperproperties. Formal Methods in System Design , 54(3):336‚Äì363, 2019.
22. Bernd Finkbeiner, Cristopher Hahn, and Hazem Torfah. Model checking quanti-
tative hyperproperties. In Proc. of the 30th Int‚Äôl Conf. on Computer Aided Veri-
Ô¨Åcation (CAV‚Äô18), Part I , volume 10981 of LNCS, pages 144‚Äì163. Springer, 2018.
23. BerndFinkbeiner,ChristianM√ºller,HelmutSeidl,andEugeneZalinescu. Verifying
security policies in multi-agent workÔ¨Çows with loops. In Proc. of the 15th ACM
Conf. on Computer and Communications Security (CCS‚Äô17) ,pages633‚Äì645.ACM,
2017.
24. Bernd Finkbeiner, Markus N. Rabe, and C√©sar S√°nchez. Algorithms for model
checking HyperLTL and HyperCTL*. In Proc. of the 27th Int‚Äôl Conf. on Computer
Aided VeriÔ¨Åcation (CAV‚Äô15), Part I , volume 9206 of LNCS, pages 30‚Äì48. Springer,
2015.
25. Ohad Goudsmid, Orna Grumberg, and Sarai Sheinvald. Compositional model
checking for multi-properties. In Proc. of the 22nd Int‚Äôl Conf. on VeriÔ¨Åcation,
Model Checking, and Abstract Interpretation (VMCAI‚Äô21) , volume 12597 of LNCS,
pages 55‚Äì80. Springer, 2021.
26. O. Grumberg and D. E. Long. Model checking and modular veriÔ¨Åcation. ACM
Transactions on Programming Languages and Systems (TOPLAS) , 16(3):843‚Äì871,
1994.
27. Jens Oliver Gutsfeld, Markus M√ºller-Olm, and Christoph Ohrem. Automata
and Ô¨Åxpoints for asynchronous hyperproperties. Proc. ACM Program. Lang. ,
5(POPL):1‚Äì29, 2021.
28. Cristopher Hahn, Marvin Stenger, and Leander Tentrup. Constraint-based moni-
toring of hyperproperties. In Proc. of the 25th Int‚Äôl Conf. on Tools and Algorithms
for the Construction and Analysis of Systems (TACAS‚Äô19) ,volume11428of LNCS,
pages 115‚Äì131. Springer, 2019.
29. Tzu-Han Hsu, C√©sar S√°nchez, and Borzoo Bonakdarpour. Bounded model checking
for hyperproperties. In Proc. of the 27th Int‚Äôl Conf on Tools and Algorithms for
the Construction and Analysis of Systems (TACAS‚Äô21). Part I , volume 12651 of
LNCS, pages 94‚Äì112. Springer, 2021.
30. O.KupfermanandM.Y.Vardi. ModelCheckingofSafetyProperties. In Computer
Aided VeriÔ¨Åcation (CAV) , pages 172‚Äì183, 1999.EÔ¨Écient Loop Conditions for Bounded Model Checking Hyperproperties 19
31. Leonardo de Moura and Nikolaj Bj√∏rner. Z3: An eÔ¨Écient smt solver. In Inter-
national conference on Tools and Algorithms for the Construction and Analysis of
Systems, pages 337‚Äì340. Springer, 2008.
32. KedarSNamjoshiandLucasMTabajara. Witnessingsecurecompilation. In Inter-
national Conference on VeriÔ¨Åcation, Model Checking, and Abstract Interpretation ,
pages 1‚Äì22. Springer, 2020.
33. A. Pnueli. The temporal logic of programs. In Symposium on Foundations of
Computer Science (FOCS) , pages 46‚Äì57, 1977.
34. A. Pnueli. Applications of temporal logic to the speciÔ¨Åcation and veriÔ¨Åcation of
reactive systems: A survey of current trends. In Proc. Advanced School on Current
Trends in Concurrency , pages 510‚Äì584. Volume 224, LNCS, Springer, 1985.
35. Sandro Stucki, C√©sar S√°nchez, Gerardo Schneider, and Borzoo Bonakdarpour.
Graybox monitoring of hyperproperties. In Proc. of the 23rd Int‚Äôl Symposium
on Formal Methods (FM‚Äô19) , volume 11800 of LNCS, pages 406‚Äì424. Springer,
2019.
36. M.Y. Vardi and P. Wolper. Automata theoretic techniques for modal logic of
programs. Journal of Computer and System Sciences , 32:183‚Äì221, 1986.20 T.-H. Hsu et al.
A Proofs
A.1 Bounded Simulation
LetK1andK2be two Kripke structures over AP, and letk2N. Thebounded
simulation problem forK1;K2andkis to decide whether there exists a simula-
tion relation from K1toK2that uses at most kstates ofK2(note that in any
case, all of the reachable states of K1must be used in such a simulation). We
prove this problem to be NP-complete.
Theorem 2. The bounded simulation problem is NP-complete.
Proof.LetK1andK2be two Kripke structures with sets of states Q1andQ2,
respectively, and let k2N. A nondeterministic algorithm which guesses a set
Q0
2Q2of at most kstates, and searches for a simulation from K1toK2
reduced toQ0
2. Finding a simulation can be done in polynomial time, and so the
problem is in NP.
We prove NP-hardness by a reduction from the Vertex Cover problem. Given
a directed graph G=V;E;wherejEj=mand where V=fv1;:::vng, and
k2N, we construct two Kripke structures K1andK2, as follows.
K1is composed of mstates, where for every e2Ethere is a state labeled e,
and an additional initial state qlabeledq. The transitions are from qto all edge
states and vice versa.
K2is composed of mstates similarly labeled as the edge states of K1, and
additionalnstatesv1;:::vnall labeled q, all initial. From every vithere are
transitions to all edge states. From every edge state (vi;vj)there are transitions
toviandvj.
It is easy to see that K2can simulate K1using at most m+kstates iÔ¨ÄG
has a vertex cover of size at most k.
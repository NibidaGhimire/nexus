arXiv:2401.06378v1  [cs.DS]  12 Jan 2024New Lower Bounds in Merlin-Arthur Communication and Graph
Streaming Veriﬁcation
Prantar Ghosh* Vihan Shah†
Abstract
We show new lower bounds in the Merlin-Arthur (MA) communication model and the related an-
notated streaming or stream veriﬁcation model. The MA communication model is a n enhancement of
the classical communication model, where in addition to the usual players Alice and Bob, there is an
all-powerful but untrusted player Merlin who knows their in puts and tries to convince them about the
output. Most functions have MA protocols with total communi cation signiﬁcantly smaller than what
would be needed without Merlin. We focus on the online MA (OMA ) model, which is the MA analogue
of one-way communication, and introduce the notion of non-trivial-OMA complexity of a function. This
is the minimum total communication needed by any non-trivia l OMA protocol computing that func-
tion, where a trivial OMA protocol is one where Alice sends Bo b roughly as many bits as she would
have sent without Merlin. We prove a lower bound on the non-tr ivial-OMA complexity of a natural
function Equals-Index (basically the well-known Index problem on large domains) a nd identify it as a
canonical problem for proving strong lower bounds on this co mplexity: reductions from it (i) repro-
duce and/or improve upon the lower bounds for all functions t hat were previously known to have large
non-trivial-OMA complexity, (ii) exhibit the ﬁrst explici t functions whose non-trivial-OMA complexity
is superlinear, and even exponential, in their classical on e-way complexity, and (iii) show functions on
input size nfor which this complexity is as large as n/logn. While exhibiting a function with ω(√n)
(standard) OMA complexity is a longstanding open problem, w e did not even know of any function with
ω(√n)non-trivial-OMA complexity.
Next, we turn to the annotated streaming model, the Prover-V eriﬁer analogue of single-pass data
streaming. We reduce from Equals-Index to establish strong lower bounds on the non-trivial complexity
(for the analogous notion in this setting) of the fundamenta l streaming problem of counting distinct
items, as well as of graph problems such as k-connectivity (both vertex and edge versions) in a certain
edge update model that we call the support graph turnstile (SGT) model. To set the benchmark space
under which non-trivial annotated streaming schemes shoul d solve these problems, we design classical
streaming (sans Prover) algorithms for them under SGT strea ms by building strongℓ0-samplers that
are robust to such streams and might be of independent intere st. Finally, we exploit graph theoretic
properties to design efﬁcient schemes for k-connectivity on dynamic graph streams. This establishes
a conceptual separation between classical streaming and an notated streaming: the former can handle
certain turnstile and SGT streams almost as efﬁciently as dy namic streams, but the latter cannot.
*(prantar.ghosh@gmail.com) Department of Computer Scienc e, Georgetown University. Supported in part by NSF under awa rd
1918989. Part of this work was done while the author was at DIM ACS, Rutgers University, supported in part by a grant (82093 1)
to DIMACS from the Simons Foundation.
†(vihan.shah@uwaterloo.ca) Department of Computer Scienc e, University of Waterloo. Part of this work was done while th e
author was at Rutgers University and was supported in part by an NSF CAREER Grant CCF-2047061.
iContents
1 Introduction 1
1.1 Motivation and Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Our Results and Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4 Technical Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.5 Paper Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2 Models, Notation, and Terminology 12
2.1 Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2 Notation and Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3 Preliminaries 15
4 OMA Lower Bound for Equals-Index and its Implications 17
4.1 The Equals-Index Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.2 Implications of the Equals-Index Lower Bounds . . . . . . . . . . . . . . . . . . . . . . . 19
5 Classical Streaming Algorithms under SGT streams 24
5.1 Basic Tools: Non-Zero Detection and ℓ0-Sampling for Large Frequencies . . . . . . . . . . 24
5.2 Edge Connectivity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
6 Annotated Streaming Schemes for Dynamic Graph Streams 35
6.1 The Layering Lemma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
6.2 Vertex Connectivity Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
6.3 Edge Connectivity Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
7 Annotated Streaming Schemes for SGT Streams 41
ii1 Introduction
In the classical two-player communication model, the playe rs Alice and Bob each receive an input unknown
to the other player and exchange as few bits as possible to com pute a function of the inputs. In their seminal
paper on communication complexity classes, Babai, Frankl, and Simon [ BFS86 ] deﬁned the Merlin-Arthur
(MA) communication model, where there is also a “super-play er” Merlin, who knows the inputs of both
Alice and Bob (collectively “Arthur”) and hence, also knows the output. However, Merlin is not trusted, and
so he provides Arthur a “proof” that should be thought of as a h elp message. After receiving this message,
Alice and Bob communicate between themselves to verify its c orrectness. It turns out that for most well-
studied functions, the total communication needed between the players can be signiﬁcantly reduced with
the help of Merlin. This holds even in the most restrictive ve rsion of the MA model, where both Merlin
and Alice send just a single message to Bob, from which he must verify the solution. This is known as
theonline Merlin-Arthur (OMA) model. We focus on this setting and prove new lower boun ds that also
extend to a related stream-veriﬁcation model called annotated streaming [CCM09 ,CCMT14 ]. We discuss
the motivation and context of our results below.
1.1 Motivation and Context
Online Merlin-Arthur communication. The OMA complexity of a function is deﬁned as the total com-
munication between the players, i.e., the sum of the lengths of Merlin’s and Alice’s messages, in the optimal
protocol that minimizes this sum. In a protocol, we denote Me rlin’s message length by hcost (shorthand
forhelp cost ) and Alice’s message length by vcost (shorthand for veriﬁcation cost ), while the sum of their
message lengths is termed tcost (short for total cost ). Thus, the OMA complexity of a function is the
minimum tcost over all possible OMA protocols computing the function. Nat urally, a function with high
OMA complexity, possibly close to the input size N, is deemed “hard” in the OMA model. Over the
years, researchers have wondered what problems are hard in t his model [ BFS86 ,AW08 ,CCMT14 ,Gav21 ].
Surprisingly, Aaronson and Wigderson [ AW08 ] showed that even the “hardest” functions in classical com-
munication complexity, namely the disjointness and inner p roduct functions, have OMA complexity only
O(√
NlogN). Although the same authors showed (via a simple counting arg ument) the existence of func-
tions with OMA complexity Ω(N), exhibiting an explicit function even with OMA complexity ω(√
N)
remains a longstanding open problem.
Another notion of “hard functions” in this setting might be o nes that need large hcost in order to reduce
thevcost from what Alice would have already needed to send without Mer lin (i.e., in the classical one-way
communication model). This implies high OMA complexity of t hese functions relative to their classical one-
way complexity (which might be much smaller than the input si ze, rendering them nothard in the earlier
sense). Again, disjointness or inner product are not hard in this sense either: Aaronson and Wigderson’s
protocol shows that for these problems, hcost andvcost can be smoothly traded off while keeping the
product˜Θ(N). This means even a proof of size slightly larger than logNsufﬁces to reduce Alice’s message
size too(N), whereas she would need to communicate Ω(N)in the classical setting. Further, prior work has
shown that for many other hard functions in classical commun ication complexity, we can achieve the tradeoff
hcost·vcost=O(N)[CCMT14 ,CCGT14 ,CGT20 ], ruling them out from being hard in the OMA model.
Interestingly, there is a complementary general lower boun d that says that an OMA protocol solving any
functionfmust have hcost·vcost= Ω(R→(f))[BFS86 ], whereR→(f)is the one-way communication
complexity of f. Observe that this lower bound implies that the OMA complexi ty MA→(f)of the function
fmust be at least Ω(/radicalbig
R→(f)). Stronger lower bounds are hardly known, with a couple of exc eptions.1
Prior work has shown stronger lower bounds for the sparse version of the fundamental index prob-
1Indeed, these exceptions have R→(f) =o(N)and they do not break the√
N-barrier for OMA complexity.
1lem [ CCGT14 ], and testing connectivity and bipartiteness of the XOR of two graphs [ Tha16b ]. All these
functions have OMA complexity linear (or nearly linear) in t heir classical one-way complexity. This means
thetrivial OMA protocol, where Merlin sends an empty string (or a junk me ssage) while Alice and Bob (op-
timally) solve the problem on their own, is (nearly) as good a s any other protocol for the problem. Further,
since the lower bounds imply that an OMA protocol for any of th ese functions fmust have tcost˜Ω(R(f)),
it follows that reducing the vcost too(R→(f))necessitates hcost to be˜Ω(R→(f)). Hence, these problems
are hard in the second sense described above. Given this ray o f hope on identifying hard OMA problems,
we pursue this thread. In this work, we deﬁne the notion of non-trivial OMA complexity of a function fas
follows. Call an OMA protocol computing fasnon-trivial if its vcost iso(R→(f)). Then, the non-trivial
OMA complexity /hatwidestMA→(f)is the minimum tcost over all non-trivial protocols for f.
Observe that for functions fwith standard OMA complexity MA→(f) =o(R→(f)), we have /hatwidestMA→(f) =
MA→(f)(since the protocol minimizing tcost must be non-trivial); whereas if MA→(f) = Ω(R→(f)),
thenhcost dominates vcost in any non-trivial protocol for f, and/hatwidestMA→(f)essentially measures the min-
imum hcost required to achieve vcost =o(R→(f)). Thus, non-trivial OMA complexity formally captures
the “relative” notion of hardness discussed above. Notably , in terms of the input size N, the best-known
lower bound on /hatwidestMA→(f)is˜Ω(√
N)(since a bound better than ˜Ω(MA→(f))is unknown, and MA→(f)has
a longstanding√
N-barrier).
It is now natural to ask the following questions.
•Can we ﬁnd a single problem with high non-trivial OMA complex ity that can be used to prove strong
/hatwidestMA→lower bounds for multiple problems? It would then serve as a canonical hard function for OMA
in this sense.
•Can we exhibit an explicit function fwith/hatwidestMA→(f)(strongly) superlinear in R→(f)?This would
mean that the trivial OMA protocol is signiﬁcantly better than any non-trivial protocol in terms of
total communication.
•If the answer to the above question is “yes”, how large can thi s gap be—can it be exponential?
•Can we show an explicit function fwith/hatwidestMA→(f)(strongly) superlinear in√
Nfor input size N?
This would mean that while there is a strong√
N-barrier for MA→complexity [ Gav21 ], the situation
is not at all similar for /hatwidestMA→.
In this work, we answer all these questions in the afﬁrmative . We discuss these results in detail in
Section 1.2 .
Annotated Streaming. Next, we consider the analogous stream veriﬁcation or annotated streaming
model [ CCM09 ,CCMT14 ], where a space-restricted Veriﬁer and an all-powerful Pro ver with unlimited
space simultaneously receive a huge data stream. Following the input stream, the Prover (with knowledge
of the entire stream) and Veriﬁer (who could only store a summ ary) invoke a scheme where the Prover tries
to convince the Veriﬁer about the answer to an underlying pro blem, similar to the online MA model. The
total cost of a scheme is deﬁned as the sum of the number of bits communicated by the Prover ( hcost ) and
the number of bits of space used by the Veriﬁer ( vcost ). The non-trivial annotated-streaming complexity
of a function fis analogously deﬁned as the minimum total cost over all non- trivial schemes computing f,
where a trivial scheme is one that uses as much space (up to pol ylogarithmic factors) as is needed in classical
streaming (without Prover).
Since all known lower bounds in annotated streaming are prov en via reduction from problems in OMA
communication, our knowledge of lower bounds in the two mode ls are similar. We use our OMA results to
prove strong lower bounds on the non-trivial complexity in t his model as well. We show that fundamental
2data streaming problems such as counting distinct items have high non-trivial annotated streaming complex-
ity when frequencies can be huge. Further, we show that graph problems such as connectivity and more
generally k-connectivity have high non-trivial complexity under cert ain graph streams that we call support
graph turnstile (SGT) streams. It might be intuitive that these problems mig ht be hard in this model, even
with a Prover. Perhaps surprisingly, we show that in the clas sical (sans Prover) model, we can solve these
problems under SGT streams—featuring as large as exponenti al edge weights—almost as efﬁciently as un-
der standard (unweighted) graph streams. We do this by build ing strong ℓ0-samplers that can handle large
frequencies and might be of independent interest. These res ults set the stage for our lower bounds on non-
trivial complexity: they provide the benchmark space for an y non-trivial scheme solving these problems.
Our ﬁnal set of results give efﬁcient annotated streaming sc hemes for k-connectivity on (standard) dy-
namic graph streams. We exploit graph theoretic properties onk-connected graphs to come up with short
certiﬁcates for proving or disproving k-connectedness. This might be of independent interest in th e graph-
theoretic literature. Furthermore, these results establi sh a conceptual separation between classical streaming
and annotated streaming: in the former, graph connectivity problems have roughly the same complexity in
dynamic and SGT streams, whereas in the latter, they are much harder on SGT streams than on dynamic.
We discuss our annotated streaming results in detail in Section 1.2 .
Basic Terminology. For the remainder of Section 1, it helps to deﬁne some basic te rminology for ease of
presentation. Later, in Section 2 , we describe all notation and terminology in detail. An OMA p rotocol with
hcostO(h)(resp./tildewideO(h)) and vcostO(v)(resp./tildewideO(v)) is called an (h,v)-OMA-protocol (resp. [h,v]-OMA-
protocol). Analogously, an annotated streaming protocol i s called an (h,v)-scheme or an [h,v]-scheme. For
computing a function f, atrivial OMA protocol is one that has vcostΩ(R→(f)), and a trivial scheme
is one that uses veriﬁcation space ˜Ω(S(f)), whereS(f)is the classical streaming complexity of f(the
asymptotically optimal space for computing fin classical streaming). The “Index” communication proble m
and its variants come up frequently in our discussions. In th e standard version, Alice has a string x∈ {0,1}N
and Bob has an index j∈[N], where his goal is to output x[j], thejth bit ofx.
1.2 Our Results and Contributions
First, we deﬁne the Equals-Index (henceforth, EQ-IDX) problem, which is the basis of our lower bounds.
For arbitrary natural numbers pandq, in the EQ-IDXp,qcommunication problem, Alice holds strings
x1,...,x pwhere each xi∈ {0,1}q. Bob holds a string y∈ {0,1}qand an index j∈[p]. The goal is for
Bob to output whether xj=y. This problem can be interpreted as (a boolean version of) th e Index problem
on large domains: Alice has a p-length string over the domain {0,...,2q−1}(instead of just {0,1}). Bob
needs to verify whether the jth index of Alice’s string equals his value y.
Our main result on the non-trivial-OMA complexity of EQ-IDXis as follows.
Theorem 1. For anyp,qwithp= Ω(logq), we have /hatwidestMA→(EQ-IDXp,q) =ω(q)
Observe that qcan be as large as exp(Ω(p)). We also show that R→(EQ-IDXp,q)is onlyΘ(p+logq)
(Lemma 4.1 ). This immediately implies that the gap between /hatwidestMA→(f)andR→(f)(or MA→(f))can be
exponential.
Corollary 1.1. There is an explicit function fwith
/hatwidestMA→(f) = exp(Ω( MA→(f)))and/hatwidestMA→(f) = exp(Ω( R→(f))).
Conceptually, this means that the trivial protocol where Me rlin sends nothing and Alice and Bob solve
the problem on their own, is exponentially better (in terms o f total communication) than any other protocol2.
2Here, we are discounting clearly-suboptimal protocols whe re Alice sends ω(R→(f))bits or where Merlin sends a non-empty
message despite Alice sending Ω(R→(f))bits. Hence, “any other protocol” essentially means any non -trivial protocol.
3Recall that previously we did not know of any function fon input size Nwith/hatwidestMA→(f) = ˜ω(√
N).
While exhibiting a function fwith (standard) OMA complexity MA→(f) =ω(√
N)remains a longstanding
open problem, our results show that /hatwidestMA→complexity does not have such a barrier. In fact, Theorem 1
implies that it can be as large as N/logN.
Corollary 1.2. For anyC∈(√
N,N/logN), there is an explicit function fon input size Nwith
/hatwidestMA→(f) =ω(C).
Next, we turn to the related Sparse Index problem (henceforth SP-IDX). Chakrabarti et al. [ CCGT14 ]
deﬁned the SP-IDXm,N problem as the version of Index where Alice’s string is promi sed to have hamming
weight (i.e., number of 1’s) at most m. They identiﬁed SP-IDXm,Nform= logNas the ﬁrst problem whose
non-trivial OMA complexity is nearly as large as its one-way complexity.3Via reduction from EQ-IDX, we
improve upon [ CCGT14 ]’s lower bound for SP-IDXm,N (for anym). In particular, our improved lower
bound implies that SP-IDX with sparsity O(loglogN)has non-trivial-OMA complexity exponential in its
classical one-way complexity.
Corollary 1.3. Form= loglog N, we have /hatwidestMA→(SP-IDXm,N) =ω(logN), whereas R→(SP-IDXm,N) =
MA→(SP-IDXm,N) = Θ(loglog N).
We remark that en route to establishing the above result, we a lso improve upon [ CCGT14 ]’s upper bound
onR→(SP-IDXm,N)and settle its complexity in the classical one-way model (se eLemma 4.3 ).
The only other functions (to the best of our knowledge) that p rior work has shown to have OMA com-
plexity (nearly) linear in its one-way complexity are the XOR-CONNnand XOR-BIPnproblems [ Tha16b ]:
in these problems, Alice and Bob have one graph each on the sam e vertex set [n](hence, the input size
N= Θ(n2)), and they need to check connectivity and bipartiteness (re spectively) of the graph obtained by
XOR-ing their graphs, i.e., the graph induced by the symmetr ic difference of their edge sets. Thaler [ Tha16b ]
showed that each of these functions fhave MA→(f) = Ω(n) =˜Ω(R→(f)), which implies the same about
its/hatwidestMA→complexity. We reduce from EQ-IDXto reproduce this result, thus making a convincing case for
EQ-IDXbeing a canonical problem for establishing high /hatwidestMA→complexity.
Corollary 1.4. ( [Tha16b ], paraphrased) For f≡XOR-CONNnorf≡XOR-BIPn, we have
/hatwidestMA→(f) = Ω(R→(f)) = Ω(n).
We now turn to the annotated streaming model. Our OMA results can be used to prove lower bounds on
the total cost of any non-trivial scheme for certain problem s.
First, consider the fundamental distinct items problem (he nceforth, DIST-ITEMN,F) on turnstile streams,
where frequencies of elements from universe [N]get incremented and decremented, and we are promised
that the absolute value of the max-frequency is bounded abov e byF. At the end of the stream, we need to
output the number of elements with non-zero frequency. We sh ow a separation between classical streaming
and (non-trivial) annotated streaming complexities for th is problem, given as follows.
Theorem 2. There is a setting of Fsuch that DIST-ITEMN,Fcan be solved in /tildewideO(N)space in classical
streaming, but any non-trivial annotated streaming scheme for the problem must have total cost Ω(Npolylog(N)).
Next, we show a similar separation for graph streaming probl ems. We deﬁne a support graph turnstile
(SGT) stream to be one where an n-node graph is induced by the support of the edge-frequency v ector. The
3It follows implicitly from their result establishing MA→(SP-IDXlogN,N) =˜Ω(R→(SP-IDXlogN,N))
4parameter αof the SGT stream is the maximum possible absolute frequency . For the (undirected) graph
connectivity problem, where we need to check if all pairs of n odes are reachable from each other, and the k-
vertex-connectivity (resp. k-edge-connectivity) problem, where we need to check whethe r removal of some
k−1vertices (resp. edges) disconnects the graph, we show an /tildewideO(n)vsΩ(npolylog(n))separation between
classical streaming and non-trivial annotated streaming c omplexities of these problems under SGT streams.
Theorem 3. Under certain support graph turnstile streams on n-node graphs, connectivity can be solved
in/tildewideO(n)space by a classical streaming algorithm, whereas any non-t rivial annotated streaming scheme for
the problem must have total cost Ω(npolylog(n)).
Theorem 4. Under certain support graph turnstile streams on n-node graphs, k-vertex-connectivity and k-
edge-connectivity can be solved in /tildewideO(kn)space by a classical streaming algorithm, whereas any non-t rivial
annotated streaming scheme for the problem must have total c ostΩ(npolylog(n)).
We remark that while the classical streaming space bounds of /tildewideO(n)for connectivity and /tildewideO(kn)fork-
connectivity are known for standard dynamic graph streams [ AGM12 ,AS23 ] where edge multiplicities are 0
or1throughout the stream, it was not known whether the same can b e achieved for the harder SGT streams.
We establish these upper bounds by designing ℓ0-samplers that can handle frequency exponential in nwhile
incurring just polylogarithmic factors in space. These mig ht be of independent interest (see Lemma 5.4 ).
Finally, we design efﬁcient schemes for k-vertex-connectivity and k-edge-connectivity under standard
dynamic graphs streams. These schemes have total cost signi ﬁcantly smaller than the lower bound proven
for schemes processing SGT streams.
Theorem 5. Under dynamic graph streams on n-node graphs, there exists a [k·(h+kn),v]-scheme for
k-vertex-connectivity for any h,vsuch that h·v=n2. In particular, under such streams, the problem has
non-trivial annotated streaming schemes with total cost /tildewideO(k2n).
Theorem 6. Under dynamic graph streams on n-node graphs, there exists a [k2n+h,v]-scheme for k-edge-
connectivity for any h,vsuch that h·v=n2. In particular, under such streams, the problem has non-tri vial
annotated streaming schemes with total cost /tildewideO(k2n).
Theorem 7. Under dynamic graph streams on n-node graphs, there exists an [n,n]-scheme for k-edge-
connectivity (for any k). In particular, under such streams, the problem has non-tr ivial annotated streaming
schemes with total cost /tildewideO(n).
Contrast this with our results for annotated streaming unde r SGT streams, where the total cost for these
problems can be as large as Ω(npolylog(n)). Thus, we can see a conceptual separation between classical
streaming and annotated streaming: the former can tolerate SGT streams incurring negligible factors in
complexity over dynamic graph streams, whereas the latter i ncurs signiﬁcantly large factors for SGT streams
over dynamic.
1.3 Related Work
In their seminal paper, Babai, Frankl, and Simon [ BFS86 ] deﬁned communication classes similar to classes
in computational complexity; this included the Merlin-Art hur (MA) communication class, which essentially
deﬁned the Merlin-Arthur communication model. Klauck [ Kla03 ] proved that disjointness and inner prod-
uct have MA complexity Ω(√
N), which was surprisingly proven to be tight (up to logarithmi c factors)
by Aaronson and Wigderson [ AW08 ] who gave a protocol with total cost O(√NlogN). Chen [ Che20 ]
recently improved this bound to O(√Nlogloglog N). Chakrabarti et al. [ CCMT14 ] were the ﬁrst to con-
sider the online version of the MA model. They used it to show l ower bounds for annotated streaming
5schemes, as has been traditionally done by subsequent works . They proved that for any function f, an
[h,v]-OMA-protocol that computes it must have h·v≥R→(f). Further, for many problems including
frequency moments and subset checks, they gave annotated st reaming schemes (which imply OMA proto-
cols with the same bounds), achieving this smooth tradeoff. [CCGT14 ] were the ﬁrst to exhibit a problem,
namely sparse index, where such a tradeoff is not possible. I n fact, they showed that for sparse index
with sparsity logarithmic in the input size, the OMA complex ity is as large as the one-way communication
complexity. Later, Thaler [ Tha16b ] exhibited two more problems with this property: XOR-conne ctivity
and XOR-bipartiteness. The motivation was to show the exist ence of graph problems that provably need
semi-streaming schemes (an [n,n]-scheme for n-node graphs) to solve and that they are equally hard in the
annotated streaming model as in classical streaming.
An “augmented” version of the Equals-Index was studied by Ja yram and Woodruff [ JW13 ] in the classi-
cal communication model. They called it the “Augmented Inde x problem on large domains”: here Bob also
knows all the entries of Alice’s vector before his input inde x.
For the problem of computing distinct items, [ CCMT14 ] gave an (n2/3(logn)4/3,n2/3(logn)4/3)-
scheme, which was later simpliﬁed and improved to an (n2/3logn,n2/3logn)-scheme by [ Gho20 ]. Note
that both of these works assume that the stream length misO(N), whereNis the universe size. Our results
are for streams that are exponentially longer.
With the growing interest in graph streaming algorithms ove r the last couple of decades, much of the
recent literature on stream veriﬁcation has focused on grap h problems [ CMT13 ,CCGT14 ,ADRV16 ,Tha16b ,
CG19 ,CGT20 ]. Most of them design stream veriﬁcation protocols for inse rt-only or insert-delete graph
streams. For the graph connectivity problem on n-node graphs, [ CCMT14 ] gave an [h,v]-scheme for any
h,vwithh≥nandh·v=n2. For sparse graphs with medges, [ CCGT14 ] designed an [n+m/√v,v]-
scheme. As mentioned above, [ Tha16b ] studied the problem in the XOR-edge-update model and prove d
that any[h,v]-scheme must have (h+n)·v≥n2. A number of works [ CMT13 ,CG19 ,CGT20 ] studied
veriﬁcation schemes for shortest-path and s,t-connectivity related problems. No prior work on stream
veriﬁcation, however, studied the k-connectivity problem.
In the classical streaming model, [ AGM12 ] gave the ﬁrst algorithm for k-edge-connectivity in dynamic
streams using /tildewideO(kn)space. [ GMT15 ] gave the ﬁrst algorithm for k-vertex-connectivity in dynamic graph
streams, which was improved by a factor of kand made nearly optimal by [ AS23 ] using/tildewideO(kn)space.
[SW15 ] proved a lower bound of Ω(kn)bits for both problems, even for insertion-only streams (se e also
[AS23 ] for extending the lower bound for k-vertex-connectivity to multiple passes).
Other variants of stream veriﬁcation include a prescient setting where Prover knows the entire stream
upfront, i.e., before Veriﬁes sees it, and can send help mess ages accordingly [ CCMT14 ,CCGT14 ]. Versions
where Prover sends very large proofs have also been consider ed [KP13 ]. Natural generalizations to allow
multiple rounds of interaction between the Prover and Veriﬁ er have been investigated. These include Arthur-
Merlin streaming protocols of Gur and Raz [ GR13 ] and the streaming interactive proofs (SIP) of Cormode
et al. [ CTY11 ]. The latter setting was further studied by multiple works [ ADRV16 ,CCM+15,KP14 ]. Very
recently, the notion of streaming zero-knowledge proofs has been explored [ CDGH23 ]. For a more detailed
survey of this area, see [ Tha16a ].
1.4 Technical Overview
1.4.1 Communication Lower Bounds
The EQ-IDX lower bound. The basis of all our lower bounds is an OMA lower bound on the EQ-IDX
problem. Recall the classical Index problem IDXNwhere Alice has a string xof length Nand Bob has
an index j∈[N]such that he needs to know x[j]. Chakrabarti et al. [ CCMT14 ] showed that for any p,q
6withp·q=N, we can get a (q,p)-OMA-protocol as follows. The string xcan be partitioned into p
chunks of length qeach. Merlin sends Bob the purported chunk where jlies, thereby sending qbits. Again,
Alice sends Bob an Θ(1) -size equality sketch for each chunk, thereby sending Θ(p)bits. Using the relevant
sketch, Bob can ﬁgure out whether the chunk sent by Merlin is a ccurate and ﬁnd the solution if it is.
Note that from Alice’s perspective, the problem actually bo ils down to the following subproblem: Alice
has a string xpartitioned into chunks x1,...,x pand Bob has a string y; she needs to help him verify whether
yis identical to her kthchunk, where she doesn’t know k. Our main observation is that in the above protocol,
to solve this subproblem, she spends as many bits as she would have without Merlin:Θ(p)bits (we can show
that this is tight for the problem under classical one-way co mmunication). So now that Alice and Bob have
Merlin, why not take his help and improve this communication too(p)? If they could do this with at most
O(q)bits of help, then they would obtain an improved (q,o(p))-OMA protocol for IDXpq. But the known
lower bound for IDXpq[CCMT14 ] says that the product of hcost andvcost must beΩ(pq). Hence, Merlin
cannot bring down the vcost too(p)without sending ω(q)bits. Since Θ(p), as noted, is the communication
needed for the subproblem in the classical one-way model, we get that the non-trivial OMA complexity of
the subproblem is ω(q). Butqcan be much larger than p—even exponential in p. Hence, we identify a
problem whose non-trivial OMA complexity can be signiﬁcant ly larger than their one-way complexity. We
essentially abstract out this subproblem as the EQ-IDXp,qproblem and formalize the reduction.
The sparse index lower bound. Although this lower bound follows by a reduction from EQ-IDX, we
discuss it separately to point out the challenges in proving its non-trivial-OMA complexity. Recall that the
SP-IDXm,Nproblem is the version of IDXNwhere Alice’s string is promised to have at most m1’s. We prove
that/hatwidestMA→(SP-IDXloglogN,N)isΩ(logN), whileR→(SP-IDXloglogN,N) = Θ(loglog N), thus establishing
yet another exponential gap.
Let us discuss the classical one-way complexity ﬁrst. Chakr abarti et al. [ CCGT14 ] showed that for
anym,R→(SP-IDXm,N) =O(mlogm+logN), but it was not known to be tight. We improve it to a tight
bound of Θ(m+loglog N), and then setting m= loglog Ngives the desired bound. This improvement is
the most challenging part in this result. The protocol of [ CCGT14 ] works as follows. Alice picks a random
functionh: [N]→[m3]from a pairwise independent hash family and sends Bob halong with the set of at
mostmvaluesh(i)for each index iwhere her string has a 1. Bob checks if h(j)is in this set, where jis his
input index, and if so, announces the answer to be 1, and0otherwise. The protocol can err only if Alice has
a0at indexjbuth(j)collides with one of the m h(i)’s, which happens with low probability by pairwise
independence and union bound over the melements. The set can be expressed using O(mlogm)bits and
the function htakesO(logN)bits, giving their bound of O(mlogm+logN).
It is not hard to see that the logmfactor can be removed with a tighter analysis: we reduce the r ange
of the hash family from [m3]to[3m]. By pairwise independence, h(j)collides with a single h(i)with
probability 1/3m. Since we need to take union bound over at most msuchh(i)’s and are happy with
error probability at most 1/3, this family sufﬁces. Further, expressing the set of m h(i)’s then takes only
O(m)bits since Alice can simply send the set’s characteristic ve ctor of size 3m. It is, however, not clear
that we can reduce the additive O(logN)any further as it appears because the smallest known size of a
pairwise independent hash family with domain [N]isΩ(N). We observe that SP-IDXm,N actually has input
sizeO(/parenleftbigN
m/parenrightbig
). Hence, if we draw the hash function using public randomness , thus obtaining an O(m)-cost
public coin protocol, and then convert it to a private coin pr otocol using Newman’s theorem, we incur an
additive factor of O(loglog/parenleftbigN
m/parenrightbig
) =O(logm+ loglog N). Therefore, we prove that R→(SP-IDXm,N) =
O(m+ loglog N). The lower bounds of Ω(m)andΩ(loglog N)easily follow from well-known lower
bounds of the (standard) index and equality functions, esta blishing the tight bound of Θ(m+loglog N).
Using the above bound, we get that R→(SP-IDXm,N) = Θ(m)for anym≥loglogN, meaning that
any non-trivial protocol for the problem must have vcost=o(m). To prove that the non-trivial com-
7plexity/hatwidestMA→(SP-IDXloglogN,N) = Ω(log N), we reduce SP-IDXm,N from EQ-IDXp,qwithp=mand
q= log(N/m). Then, it follows that to obtain vcost=o(m), we need hcost ofΩ(q) = Ω(log( N/m)),
which isΩ(logN)form= loglog N. The reduction is very similar to the one in [ CCGT14 ]. They reduced
from IDX, while we reduce from EQ-IDX: we essentially modify their construction to ﬁt the structu re of the
EQ-IDXproblem.
Connectivity and Bipartite on XOR-graphs. Via reduction from EQ-IDX, we reproduce the lower bounds
for the other two problems that we know have high non-trivial OMA complexity. These are the XOR-CONNn
and XOR-BIPnproblems that ask whether the XOR of the graphs that Alice and Bob hold on the vertex set
[n]is connected and bipartite respectively. Our reduction is v ery similar to those by Thaler [ Tha16b ].
Although he reduced from IDXn2and we reduce from EQ-IDXn,n, our construction can be seen as adapting
his construction to the structure of the EQ-IDX problem. The reduction to XOR-CONN works as follows.
Given the input strings x1,...,x nwhere each xi∈ {0,1}n, Alice constructs a bipartite graph with nnodes
on each partite set: for each i∈[n], she sees xias the characteristic vector of the neighborhood of ℓi, the
ith vertex on the left. To ensure that her graph is connected, s he joins all vertices to a dummy vertex, say v.
Bob treats his input yas the characteristic vector of a set of edges incident to ℓj. Ifyis indeed identical to
xj, then XOR of these edges and the edge {(ℓj,v)}with the original graph must isolate ℓj. Otherwise, ℓj
must be adjacent to some vertex, say won the right, and w, in turn, is adjacent to v. Since all other vertices
are adjacent to v, this ensures that the graph is connected in this case. Thus w e can reduce XOR-CONNn
from EQ-IDXn,nand obtain the desired result on its non-trivial OMA complex ity.
For XOR-BIP, after constructing the same base bipartite graph using the xi’s, Alice joins only the vertices
on the right to the dummy vertex v. Bob constructs the same edge set using y. The XOR of these edges and
ℓj,vwith Alice’s graph creates a triangle if y/\⌉}atio\slash=xj: as before, ℓjmust be adjacent to some won the right,
and both of them are adjacent to v. Hence, in this case, the graph is not bipartite. If yis indeed identical
toxj, then adding vandℓjrespectively to the left and the right partite sets of the ori ginal graph gives a
bipartition of the XOR graph. Thus, XOR-BIPcan be used to solve EQ-IDXn,n, giving us the desired result.
1.4.2 Annotated Streaming Lower Bounds
We reduce from EQ-IDXto prove lower bounds on the non-trivial annotated streaming complexity of several
problems. It is deﬁned as the minimum tcost over all annotated streaming schemes that solve the problem
with space (i.e., vcost ) sublinear in its classical streaming complexity (ignorin g polylogarithmic factors).
Distinct Items. First, we consider the fundamental distinct items problem DIST-ITEMN,F, where we need
to count the number of items with non-zero frequency as eleme nts from the universe [N]get inserted and
deleted in a stream, and the absolute value of each frequency is bounded above by F. Let us ﬁrst see how we
can solve it in classical streaming. For each element, we kee p anon-zero detector , which, at the end of the
stream, reports whether or not the element has non-zero freq uency. In this work, we build such detectors,
each of which takes /tildewideO(loglogF)space. Thus, the problem can be solved using /tildewideO(NloglogF)space in
classical streaming. Therefore, even if we set F= exp(Npolylog(N)), we get that the classical streaming
complexity is /tildewideO(N). A lower bound of Ω(N)is easy to show. Hence, any non-trivial annotated streaming
scheme for the problem must have vcost=o(N). Then we reduce DIST-ITEMN,Ffrom EQ-IDXp,qfor
p=Nandq= logF, implying that any non-trivial scheme must have hcost= Ω(q) = Ω(log F). For
F= exp(Npolylog(N)), this gives a bound of Ω(Npolylog(N))on the hcost , and hence the tcost . Thus, we
see that for a certain setting of F, the non-trivial annotated streaming complexity of DIST-ITEMN,Fcan be
as large as Ω(Npolylog(N)), while the classical streaming complexity is only /tildewideO(N).
The reduction is straightforward: given the inputs x1,...,x N∈ {0,1}logFin the EQ-IDXN,logFprob-
lem, Alice treats the xis as binary representations0 of numbers in [0,F−1]and creates the stream-preﬁx
withxi+1insertions of the element i, for each i∈[N]. Bob appends to the stream y+1deletions of the
8elementj. It follows that this stream has Ndistinct items iff xj/\⌉}atio\slash=y.
Connectivity-related problems on SGT streams. We introduce the support graph turnstile model where
the input n-node graph is deﬁned by the support of the/parenleftbign
2/parenrightbig
-length frequency vector whose entries are in-
cremented or decremented by the stream tokens. We reduce glo bal connectivity and k-connecitivity (both
vertex and edge versions) under such streams from EQ-IDXto establish high non-trivial annotated streaming
complexity of those problems. To set the stage, we ﬁrst prove that in the classical streaming model, the
known upper bounds for these problems under insert-only or d ynamic streams can be matched under SGT
streams at the cost of just polylogarithmic factors. This me ans global connectivity under SGT streams can
be solved using /tildewideO(n)space and both k-vertex-connectivity and k-edge-connectivity can be solved in /tildewideO(kn)
space. The crucial tool we use here are the strong ℓ0samplers that we build in this paper. We give an
overview of this in the next subsection. Here, we discuss our reductions proving the non-trivial complexity
of these problems.
For connectivity, we reduce from EQ-IDXn,nlogF. Given her inputs x1,...,x n∈ {0,1}nlogF, Alice
constructs a bipartite graph with nnodes on each partite set. She treats each xiasnblocks of size logF
each, with each block being the binary representation of a nu mber in[0,F−1]. Denote the bth blockxi
byxi,b. Then for each i,b, she makes xi,b+1insertions of the edge between ith vertex on the left and the
bth vertex on the right. Thus, we get a complete bipartite grap h with each edge having a weight in [F]. Bob
then breaks yintonblocksy1,...,ynoflogFbits each. For each b∈[n], she deletes the edge between
thejth vertex on the left and bth vertex on the right yb+1times. Therefore, if y=xj, then the jth vertex
on the left gets isolated and the graph is not connected. Othe rwise, it must be connected to some node on
the right, and the rest of the graph is a complete bipartite gr aph. Hence, the graph is connected. It follows
that any non-trivial scheme, i.e., a scheme with vcost=o(n)necessiates hcost= Ω(nlogF). As before
settingF= exp(npolylogn), we get that the non-trivial streaming complexity of connec tivity can be as large
asΩ(npolylogn)while the classical streaming complexity is /tildewideO(n).
Fork-connectivity, we reduce from EQ-IDXkn2,logF. Given her inputs x1,...,x kn2∈ {0,1}logF, Alice
constructs a bipartite graph with knnodes on the left partite set and nnodes on the right partite set. She
treats each xi∈0,1logFas the binary representation of a number in [0,F−1]. Following some canonical
ordering of the kn2possible edges, she inserts the ith edgexi+ 1 times for each i∈[kn2]. Bob then
deletes the jth edgey+ 1 times. Thus, the resultant support graph is a complete bipar tite ifxj/\⌉}atio\slash=y.
Otherwise it’s a complete graph minus only the jth edge. It is easy to prove that the graph in the ﬁrst case is
k-vertex-connected as well as k-edge-connected, whereas the graph in the second case is not .
1.4.3 Classical Streaming Algorithms
Some of our algorithms for SGT streams follow by replacing th eℓ0-samplers in existing algorithms by
the newℓ0-samplers that we design in this work. However, an algorithm fork-edge-connectivity does
not immediately follow. So we design a new algorithm here, an d this is one of our signiﬁcant technical
contributions. Another key technical ingredient is our “la yering lemma” that we use to design efﬁcient
schemes for vertex connectivity on dynamic graphs. We discu ss these tools and techniques in detail below.
Strongℓ0-samplers. We design new ℓ0-samplers that can handle very large frequencies (hence cal led
strong) and still take polylog(n) space. This is helpful because SGT streams can have very larg e frequencies.
Standard ℓ0-samplers usually assume that the frequencies are poly(n) wherenis the universe size.
The main tool we use to design our sampler is our decision counter . These counters, given a stream of
insertions and deletions, can detect if the number of insert ions is exactly equal to the number of deletions
or not, using very little space. This even works when the diff erence between the number of insertions and
deletions is very large which is challenging to do in small sp ace deterministically. The idea is to maintain a
standard counter modulo a large random prime.
9We then use ideas from the sparse recovery and ℓ0-sampling literature to build the strong ℓ0-sampler.
We ﬁrst solve the problem when the non-zero support is 1using non-adaptive binary search.
The problem here is that we are given a stream of insertion and deletions over a universe of nelements
and promised that at the end of the stream, there is exactly on e element with a non-zero frequency. The goal
is to ﬁnd that element. The usual idea is to maintain one count er that keeps a track of the number of elements
(i.e. number of insertions minus deletions). Another count er is maintained which is used to ﬁnd the value
of the non-zero frequency element. When an insertion/delet ion for element iarrives it is scaled by iand
then added/subtracted from the counter. At the end of the str eam, this counter contains itimes frequency of
elementiand the other counter has just the frequency of element ithus recovering the non-zero frequency
elementi. This does not work when the frequencies are large so we have t o use non-adaptive binary search
to solve the problem which uses O(logn)counters to ﬁnd i.
In the case with no promise, we want to reduce to the support 1case. We do this by guessing the support
sizesin powers of 2and sampling the elements with probability 1/s. This means that for the correct guess
ofswe reduce to the support 1case with constant probability. We can repeat O(logn)times for high
probability.
Finally, we need to distinguish the support 1case from the cases where the support is not 1. This is
because we have many problems and only a few of them are the sup port1case and in others the support
can be0or larger than 1. We design a sketch for this by randomly partitioning the uni verse into many parts,
summing those parts up and checking how many parts are non-ze ro. The hope is that if there are at least 2
elements then multiple parts will become non-zero.indicat ing that the support is more than 1. If the non-zero
support is 1then exactly one part will be non-zero and if the non-zero sup port is0then all parts will be 0.
This happens with constant probability so we repeat O(logn)times for high probability. Putting everything
together gives us the strong ℓ0-sampler sketch.
Edge Connectivity. We give a randomized algorithm for getting a certiﬁcate (a sp anning subgraph with
the same answer to k-edge-connectivity) of k-edge-connectivity. The certiﬁcate is of size /tildewideO(kn), which
is optimal up to polylog factors. The certiﬁcate needs to be o f sizeΩ(kn)because every vertex needs to
have degree at least k. This algorithm can be easily converted into a dynamic strea ming algorithm using
the dynamic streaming spanning forest implementation of [ AGM12 ]. We also show that using our strong
ℓ0-samplers, the spanning forest streaming implementation o f [AGM12 ] can be extended to SGT streams in
/tildewideO(n)space. Using our certiﬁcate along with the spanning forest a lgorithm in SGT streams, we can solve
k-edge-connectivity in SGT streams in /tildewideO(kn)space.
[AGM12 ] also give an algorithm for k-edge-connectivity in dynamic streams using /tildewideO(kn)space. How-
ever, this algorithm cannot be extended to SGT streams by sim ply replacing their ℓ0-samplers with strong
ℓ0-samplers. Their certiﬁcate is kedge-disjoint spanning forests. On a high level, this does n ot work in SGT
streams because the spanning forests depend on each other (s ince they are edge-disjoint). In their algorithm,
after recovering one spanning forest T1ofGwe essentially need to delete the edges of T1fromGand then
recover a new spanning forest T2(to get a disjoint spanning forest). This is easy to do in dyna mic streams
because the frequencies of the edges of T1are exactly 1. So we can generate a new stream which is the
old stream appended with deletions of the edges of T1. ThenT2can be recovered from this new stream.
However, in SGT streams, the frequency of the edges of T1could be arbitrary, so we cannot easily generate
another stream that represents the graph G−T1(to do this we need to know the exact frequencies of all
edges inT1). This dependency between the spanning forests makes exten ding this algorithm difﬁcult. Our
algorithm, on the other hand, gets rid of this dependency and thus is extendable to SGT streams.
The randomized algorithm for getting a certiﬁcate of k-edge-connectivity is heavily inspired by the ran-
domized algorithm for getting a certiﬁcate of k-vertex-connectivity [ AS23 ]. In the randomized algorithm,
we independently sample every edge with probability 1/kand ﬁnd a spanning forest of the sampled sub-
10graph. The certiﬁcate then is a union of the spanning forests in/tildewideO(k)such independent iterations. The
analysis then shows that edges whose endpoints are not very w ell connected in the original graph exist in
the certiﬁcate, and pairs of vertices that are very well conn ected in the original graph are well connected in
the certiﬁcate. This is enough to prove that the certiﬁcate p reserves the answer to k-edge connectivity.
We also give an [n,n]-scheme for k-edge-connectivity in the annotated dynamic streaming mod el. We
achieve this by simulating the two-pass streaming algorith m for minimum-cut implied by [ RSW18 ]. During
the stream, the veriﬁer computes a cut sparsiﬁer of the graph . After the stream, the veriﬁer compresses the
vertices into supernodes (by compressing all large cuts) su ch that only the small cuts remain. The prover
then sends all the edges of this supernode graph ( [ RSW18 ] showed that there are only O(n)such edges).
The veriﬁer then can compute the exact mincut of the graph, th us solving k-edge-connectivity for all values
ofk.
Vertex connectivity. We also get an algorithm for k-vertex-connectivity in SGT streams in /tildewideO(kn)space
using the techniques used for edge connectivity. We use stro ngℓ0-samplers in the algorithm of [ AS23 ].
We also give an [k2n,n/k]-scheme for k-vertex-connectivity in the annotated dynamic streaming m odel.
The heart of the algorithm is what we call the layering lemma, which says that there exists a short proof (size
/tildewideO(kn)) to show that any arbitrary ﬁxed vertex has kvertex-disjoint paths to all other vertices. This proof
can also be veriﬁed in /tildewideO(n/k)space. Also, when proving this for rvertices, we can reuse space and thus
get a[r·kn,n/k]-scheme instead of a [rkn,rn/k ]-scheme. If we show the layering lemma for kvertices,
then using properties of k-vertex-connectivity, we can show that the graph is k-vertex-connected, giving the
desired bound. We also extend these ideas to k-edge-connectivity getting a [k2n,n/k2]-scheme.
We show that a short proof exists for the layering lemma using the probabilistic method. The idea is to
cleverly partition the vertices into lognlayers and show that vertices in the ﬁrst layer have kvertex-disjoint
paths to the special vertex. Then we inductively show that ve rtices in a layer have kvertex-disjoint path
to the previous layer. Using the properties of k-vertex-connectivity, this is enough to show that the speci al
vertex has kvertex-disjoint paths to all other vertices. The proof betw een any two layers is of size /tildewideO(kn),
giving us the desired bound. The veriﬁcation is more involve d, but the veriﬁer essentially checks just two
things using some tools. He ﬁrst checks whether the edges sen t by the prover belong to the input graph
(using a subset check). He then checks if what the prover sent are indeed vertex-disjoint paths (using a
duplicate-detection scheme).
We also give an [n2logα+k2n,1]-scheme for k-vertex-connectivity and k-edge-connectivity in the
annotated SGT streaming model with parameter α. The proof idea is the same as in dynamic streams, but
the veriﬁcation is more complicated because the frequencie s for the edges could be large or even negative.
The auxiliary information used for veriﬁcation adds an over head of/tildewideO(n2logα)bits in the proof. The
veriﬁcation follows the same steps as in the dynamic streami ng case, except the subset check is not easy to
do. So we came up with a different way to do the subset check, wh ich needs a large amount of auxiliary
information. One of the main ideas for this is to separate out the elements with positive and negative
frequencies and do a subset check for them separately.
1.5 Paper Organization
We start by deﬁning the models and notation in Section 2 . Then in Section 3 , we list all the facts we use
throughout the paper. In Section 4 , we introduce our central problem called Equals-Index and u se it to
prove lower bounds for different problems in MA communicati on complexity and annotated streaming.
Section 5 is our toolkit section where we start with our algorithm for t he strong ℓ0-samplers which can be of
independent interest. We then provide an algorithm for k-edge-connectivity in the classical setting as well
as in dynamic and SGT streaming which can be of independent in terest. The techniques in Section 5 can be
used to get SGT streaming algorithms for connectivity and k-veretex-connectivity. In Section 6 , we show
11annotated dynamic streaming schemes for k-vertex-connectivity and k-edge-connectivity. At the heart of
the proof for k-vertex-connectivity is the layering lemma, which can be of independent interest. Finally, in
Section 7 , we show an annotated SGT streaming scheme for k-vertex-connectivity.
2 Models, Notation, and Terminology
2.1 Models
We formally describe the various communication and streami ng models that we focus on in this paper and
deﬁne the notation and terminology in each model.
2.1.1 Communication Models
Classical Two-Party Communication. In the (randomized) two-party communication model introdu ced
by Yao [ Yao79 ], two players Alice and Bob possess inputs x∈ X andy∈ Y respectively. Their goal is
to compute f(x,y), wheref:X ×Y → { 0,1}. To this end, they use a communication protocol Πwhere
they toss some random coins and accordingly send messages to each other back and forth in rounds. The
protocolΠterminates when one of the players announces an output. In th is paper, we only focus on one-way
communication, i.e., when Πhas just a single round: Alice sends a single message to Bob, f rom which he
must declare the output. We now describe this variant of the m odel in more detail.
One-way randomized communication. In a private coin protocol, Alice’s coin tosses are private, i.e., she
draws a random string Rthat is unknown to Bob, and sends him a message msg as a function of (x,R).
In apublic coin protocol, the string Ris also known to Bob (without any communication). After rece iving
Alice’s message, Bob outputs a bit out(Π)as a function of (y,msg)(resp.(y,msg,R)) for private (resp.
public) coin protocols. We say that a protocol Πfor a function fhas error δif PrR[out(Π)/\⌉}atio\slash=f(x,y)]≤δ.
We say that a protocol Πsolves a function fif it has error δ≤1/3.
The communication cost CC (Π) of protocol Πis the maximum length of Alice’s message over all
possible(x,R). The randomized one-way communication complexity of a func tion is deﬁned as
R→(f) := min{CC(Π) : Π is a private coin protocol that solves f}
When public randomness is allowed, we denote this complexit y as
R→(pub)(f) := min{CC(Π) : Π is a public coin protocol that solves f}
Merlin-Arthur Communication. In the Merlin-Arthur (MA) communication model [ BFS86 ], we have
the usual two players Alice and Bob (collectively called “Ar thur”) with their inputs x∈ X andy∈ Y
respectively. They want to compute f(x,y), wheref:X × Y → { 0,1}. In addition, there is an all-
powerful player Merlin who knows the inputs xandy. Merlin is untrusted; he sends Alice and Bob a
“proof” of the solution, following which these two players i nteract between themselves to verify the proof.
In this paper, we focus on the online Merlin-Arthur (OMA) model which is an MA analog of the one-way
randomized communication model deﬁned above. We describe t his model in more detail.
Online Merlin-Arthur communication. An OMA protocol Πworks as follows. Merlin sends Bob a help
messageH. Then Alice generates a random string R, based on which she sends Bob a message msg . Bob
then outputs out(Π)∈ {0,1,⊥}as a function of (y,H,msg,R). An OMA protocol Πis said to have
completeness error δcand soundness error δsif the following conditions are satisﬁed.
• (Completeness) If f(x,y) = 1 , then there exists a function Hsuch that Pr R[out(Π)/\⌉}atio\slash= 1]≤δc
12• (Soundness) If f(x,y) = 0 , then∀H′:PrR[out(Π) = 1] ≤δs
We say that a protocol Πsolves a function fifΠhasδs,δc≤1/3for computing f.
For an OMA protocol Π, the help cost hcost(Π)is the maximum length of Hover all possible (x,y),
and the veriﬁcation cost vcost(Π)is the maximum number of bits sent by Alice over all possible (x,R).
Thetotal cost tcost(Π)is then deﬁned as hcost(Π)+ vcost(Π). The OMA-complexity of fis deﬁned as
MA→(f) := min{tcost(Π) : Π solvesf}.
Trivial OMA protocol. We say that an OMA protocol Πthat solves a function fistrivial ifvcost(Π) =
Ω(R→(f))and is non-trivial ifvcost(Π) =o(R→(f)).
Deﬁnition 2.1 (Non-trivial OMA complexity) .Thenon-trivial OMA complexity of a function fis
/hatwidestMA→(f) := min{tcost(Π) : Π is a non-trivial protocol that solves f}.
Note that, by deﬁnition, /hatwidestMA→(f)≥MA→(f). We also make the following observation.
Observation 2.2. If/hatwidestMA→(f) =ω(MA→(f)), then it must be that MA→(f) = Ω(R→(f)).
This is because if /hatwidestMA→(f)is larger than MA→(f), then the “optimal” protocol Πfor which MA→(f) =
tcost(Π)must be a trivial protocol. Hence, tcost(Π) = Ω( vcost(Π)) = Ω( R→(f))by deﬁnition.
2.1.2 Streaming Models
First, we deﬁne the different types of data streams that we co nsider in this paper.
Data Streams. A data stream of length mis deﬁned as a sequence σ:=/a\}brack⌉tl⌉{t(ai,∆i) :i∈[m]/a\}brack⌉tri}ht, where
ai∈[N]and∆iis an integer. The data stream deﬁnes a frequency vector f(σ) :=/a\}brack⌉tl⌉{tfreq(1),..., freq(N)/a\}brack⌉tri}ht,
where
freq(j) :=/summationdisplay
i∈[m]:ai=j∆i
is the frequency of element j∈[N]. In the streaming model, we need to compute some function of f(σ)for
an input stream σusing space sublinear in the input size, i.e., o(m)space.
Turnstile streams. If a stream is as deﬁned above, with no restriction on ∆iandf(σ), then we call it a turnstile
stream. Conceptually, turnstile streams allow frequencie s of elements to be incremented and decremented
arbitrarily with each update, and the frequency vector can h ave negative entries.
Insert-only streams. A data stream is called insert-only if ∆i>0for alli∈[m]. A well-studied special
case is the unit update model, where ∆i= 1for alli∈[m].
Insert-delete streams. We call a data stream an insert-delete stream if ∆i∈ {−1,1}for alli∈[m]and
freq(j)∈ {0,1}for allj∈[N]at all points during the stream. Conceptually, elements are either inserted
or deleted, frequency can be at most 1, and an element can be deleted only if its frequency is 1during the
update.
Graph Streams. A graph stream is a data stream whose frequency vector deﬁnes a graph. Here, N=/parenleftbign
2/parenrightbig
where[n]is the set of nodes of the graph. The frequency vector is index ed by pairs (u,v)∈/parenleftbig[n]
2/parenrightbig
(using a
canonical bijection from [N]to/parenleftbig[n]
2/parenrightbig
), and typically, freq (u,v)represents the weight of the edge {u,v}.
Dynamic graph streams. We call an insert-delete graph stream as a dynamic graph stre am. Conceptually,
the input graph is unweighted, and an edge can be deleted only if it is present in the graph during the update.
13We now introduce support graph turnstile (SGT) streams. Con ceptually, the graph is induced by the
support of the frequency vector of the input stream, which ma y be a turnstile stream.
Deﬁnition 2.3 (Support graph turnstile streams) .A turnstile stream σis called a support graph turnstile
stream if it is of the form /a\}brack⌉tl⌉{t(u,v)i,∆i) :i∈[m]/a\}brack⌉tri}ht, where(u,v)∈/parenleftbig[n]
2/parenrightbig
and the graph that it deﬁnes is given
byG= ([n],{(u,v) :freq(u,v)/\⌉}atio\slash= 0}).
Now we describe the streaming models that we study in this pap er.
Classical Streaming. In the classical streaming model, a (randomized) data strea ming algorithm Areads an
input stream σand needs to compute some function f(σ)of the stream. To this end, it maintains a summary
AR(σ)based on a random string Rand at the end of the stream, outputs out(A). The goal is to optimize
the space usage, i.e., the size of AR(σ). In this paper, we only consider algorithms that make a singl e pass
over the input stream. We say that a streaming algorithm Ahas errorδif PrR[out(A)/\⌉}atio\slash=f(σ)]≤δ. Further,
we say that an algorithm Asolves a function fif it has error ≤1/3. The maximum number of bits stored
byAover all possible inputs σis denoted by Space (A).
We deﬁne the classical streaming complexity of a function fas
S(f) := min{Space(A) :Asolvesf}
Annotated Streaming. In the annotated streaming model of [ CCM09 ], we have a space-bounded Veriﬁer
and an all-powerful Prover with unlimited space. Given an in put stream σ, ascheme for computing a function
f(σ)is a triple P= (H,A,out), whereHis a function that Prover uses to generate the help message or
proof-stream H(σ)that she sends Veriﬁer after the input stream, Ais a data streaming algorithm that Veriﬁer
runs onσusing a random string Rto produce a summary AR(σ), and outis an algorithm that Veriﬁer uses to
process the proof H(σ)and generate an output out(H(σ),AR(σ),R)∈range(f)∪{⊥} , where⊥denotes
rejection of the proof. Note that if the proof length |H(σ)|is larger than the memory of the Veriﬁer, then
outis a streaming algorithm that processes H(σ)as a stream and stores a summary subject to its memory.
A scheme P= (H,A,out)has completeness error δcand soundness error δsif it satisﬁes
• (completeness) ∀σ:PrR[out(H(σ),AR(σ),R)/\⌉}atio\slash=f(σ)]≤δc;
• (soundness) ∀σ,H′:PrR[out(H′,AR(σ),R)/∈ {f(σ),⊥}]≤δs.
We say that a scheme Psolves a function fifPhasδs,δc≤1/3for computing f.
Thehcost (short for “help cost”) of a scheme P= (H,A,out)is deﬁned as maxσ|H(σ)|, i.e., the max-
imum number of bits required to express a proof over all possi ble inputs σ. The vcost (short for “veriﬁcation
cost”) is the maximum bits of space used by the algorithms Aandoutrespectively, where the maximum is
taken over all possible (σ,R). The total cost tcost(P)is deﬁned as the sum hcost(P)+vcost(P).
Theannotated streaming complexity of a function fis deﬁned as
AS(f) := min{tcost(P) :Psolvesf}.
Trivial Scheme. We say that a scheme Pthat solves a function fistrivial ifvcost(P) =˜Ω(S(f)).
Deﬁnition 2.4 (Non-trivial Annotated Streaming complexity) .Thenon-trivial annotated streaming com-
plexity of a function fis
/hatwiderAS(f) := min{tcost(P) :Pis a non-trivial scheme that solves f}.
A scheme Pwith hcost(P) =O(h)andvcost(P) =O(v)is called an (h,v)-scheme. Again, if
hcost(P) =/tildewideO(h)andvcost(P) =/tildewideO(v), we callPan[h,v]-scheme.
142.2 Notation and Terminology
Basic Notation. We deﬁne some notation and terminology that we use throughou t the paper. All logarithms
are base2. The/tildewideO(.),˜Ω(.),˜ω(.)notation hides factors polylogarithmic in the input size. T he notation [k]for
a natural number kdenotes the set {1,...,k}. We use [a,b]for integers a < b to denote the set {a,...,b}.
For a string z∈[α]d, we use z[k]to denote the element at the kth index of z. We use the term “with
high probability" to mean with probability at least 1−1/poly(N) , whereNis the input size. Although
the standard notation to denote the input size in a communica tion problem is n, we useNinstead to avoid
confusion with the number of nodes (for which we use n).
Graph Notation. All graphs in this paper are simple and undirected. Given a gr aphG= (V,E), we usen
for its number of nodes |V|andmfor its number of edges |E|unless speciﬁed otherwise. The degree of a
vertexv∈Vis denoted by deg(v), andN(v)denotes its neighborhood. For a subset Fof edges in E, we
useV(F)to denote the vertices incident on F; similarly, for a set Uof vertices, E(U)denotes the edges
incident on U. We further use G[U]for any set Uof vertices to denote the induced subgraph of GonU. For
any two vertices s,t∈V, we say that a collection of s-tpaths are vertex-disjoint if they do not share any
vertices other than sandt.
3 Preliminaries
We use the following standard forms of Chernoff bounds.
Fact 3.1 (Chernoff bound; c.f. [ DP09 ]).SupposeX1,...,X maremindependent random variables with
range[0,b]each for some b≥1. LetX:=/summationtextm
i=1XiandµL≤E[X]≤µH. Then, for any ε >0,
Pr(X >(1+ε)·µH)≤exp/parenleftbigg
−ε2·µH
(3+ε)·b/parenrightbigg
and Pr(X <(1−ε)·µL)≤exp/parenleftbigg
−ε2·µL
(2+ε)·b/parenrightbigg
.
In certain places, we also use limited independence hash fun ctions in our algorithms to reduce their
space complexity.
Deﬁnition 3.2 (Limited-independence hash functions) .For integers n,m,k≥1, a family Hof hash func-
tions from [n]to[m]is called a k-wise independent hash function iff for any two k-subsetsa1,...,a k⊆[n]
andb1,...,bk⊆[m],
Pr
h∼H(h(a1) =b1∧···∧h(ak) =bk) =1
mk.
Roughly speaking, a k-wise independent hash function behaves like a totally rand om function when
considering at most kelements. When k= 2, we call it a pairwise independent hash family. We use the
following standard result for k-wise independent hash functions.
Fact 3.3 ( [MR95 ]).For integers n,m,k≥2, there is a k-wise independent hash function H={h: [n]→[m]}
so that sampling and storing a function h∈ H takesO(k·(logn+logm))bits of space.
We use the following basic communication complexity facts.
Fact 3.4 ( [KN97 ]).There is an O(1)-cost public random protocol for EQNfor anyNwith error probability
at most1/3.
Fact 3.5 (Equality [ KN97 ]).The one-way randomized communication complexity R→(EQN) = Ω(log N).
Fact 3.6 (Index [ Abl96 ]).The one-way randomized communication complexity R→(IDXN) = Ω(N).
15Fact 3.7 (Newman’s Theorem [ KN97 ]).For any function f:{0,1}N× {0,1}M→ {0,1}, a public
coin protocol with communication cost Cand error εcan be simulated by a private coin protocol with
communication cost at most O(C+log(N+M)+log(1 /δ))and error at most ε+δ.
We use a pseudorandom generator to reduce the space used by ou r random bits in certain algorithms.
The fact that we exploit is given below.
Fact 3.8 (PRG [ Nis90 ]).Any randomized algorithm that runs in Sspace and uses one-way access to R
random bits may be converted to an algorithm that uses O(SlogR)random bits and runs in O(SlogR)
space using a pseudorandom generator. For dynamic streamin g algorithms, the algorithm should be able to
access the random bits in a read-once manner for some permuta tion of the stream.
We often refer to the following generic lower bound in the OMA model as well as annotated streaming.
Fact 3.9 (General OMA lower bound, [ CCMT14 ]).For any function f, an(h,v)-OMA-procotol or an
(h,v)-schemeΠsolving it must have
h·v≥Ω(C)
whereC=R→(f)in caseΠis an OMA protocol, and C=S(f)(the streaming complexity of f) in case it
is an annotated streaming scheme.
The standard schemes below are often used as subroutines in o ur protocols.
Fact 3.10 (Subset-check and Intersection-count Scheme, [ CCMT14 ], [CGT20 ]).Given an insert-delete
stream of elements from sets X,Y⊆[N](interleaved arbitrarily), for any h,vwithh·v=N, there are
[h,v]-schemes for checking whether X⊆Yand for counting |X∩Y|.
Fact 3.11 (Duplicate-detection Scheme) .Given an insert-only stream of elements from the universe [N],
for anyh,vwithh·v=N, there is an [h,v]-scheme for checking whether all elements in the stream are
distinct.
We now mention an important proposition for edge and vertex c onnectivity. The ﬁrst is Menger’s theo-
rem which gives an equivalent deﬁnition of k-vertex-connectivity via vertex-disjoint paths.
Fact 3.12 (Menger’s Theorem; c.f. [ Wes01 , Theorem 17] ) .LetGbe an undirected graph and sandtbe
two vertices. Then the size of the minimum edge cut for sandtis equal to the maximum number of pairwise
edge-independent paths from stot. Ifs,tare non-adjacent then the size of the minimum vertex cut for s
andtis equal to the maximum number of vertex-disjoint paths betw eensandt.
Moreover, a graph is k-edge-connected (resp k-vertex-connected) iff every pair of vertices has kedge-
disjoint (resp vertex-disjoint) paths in between them.
We often use the following well-known sketch from the stream ing literature.
Fact 3.13 ( [AGM12 ]).There is an algorithm that given any n-vertex graph Gin a dynamic stream computes
a spanning forest TofGwith probability at least 1−n−10inO(nlog3(n))bits of space.
We give a new way to detect if two multi-sets are identical usi ngℓ0-samplers. The idea is to insert
elements of the ﬁrst multi-set into an ℓ0-sampler and delete elements of the second multi-set from th e
sampler, and at the end, check if the sampler is empty.
Proposition 3.14 (Equality-Detection Scheme) .Given an insert-only stream of elements of two multi-sets
A,B in any order (interleaved arbitrarily) from the universe [N], we can check if the two sets are identical
with probability 1−1/poly(N) in spacepolylog(N) .
164 OMA Lower Bound for Equals-Index and its Implications
4.1 The Equals-Index Problem
We formally deﬁne the EQ-IDXp,qcommunication game between two players Alice and Bob as foll ows.
Letpandqbe arbitrary integers. Alice gets pstringsx1,...,x psuch that xi∈ {0,1}qfor eachi∈[p].
Bob gets a string y∈ {0,1}qand an index j∈[p]. The output is 1ify=xj, and0otherwise.
First, let us show tight bounds on its one-way (Alice →Bob) randomized communication complexity.
Lemma 4.1. R→(EQ-IDXp,q) = Θ(p+logq)
Proof. First consider the following protocol using public randomn ess. For each i∈[p], Alice sends Bob
anO(1)-size equality sketch ( Fact 3.4 ) forxi. Bob uses only the jth sketch to check if xj=y. Thus,
Rpub(EQ-IDXp,q) =O(p). By Newman’s theorem ( Fact 3.7 ),R→(EQ-IDXp,q) =O(p+log(pq)) =O(p+
logq).
The lower bound R→(EQ-IDXp,q) = Ω(p+logq)easily follows from the facts that EQ-IDXp,1≡IDXp
and EQ-IDX1,q≡EQq. Therefore, we have
R→(EQ-IDXp,q)≥R→(EQ-IDXp,1) =R→(IDXp) = Ω(p)(Fact 3.6 ).
Again,R→(EQ-IDXp,q)≥R→(EQ-IDX1,q)≥Ω(logq)(Fact 3.5 ).
Now we prove an OMA lower bound for EQ-IDX.
Lemma 4.2. Any (h,v)-OMA-protocol solving EQ-IDXp,qmust have
(h+q)·v≥Ω(pq)
Proof. We show that given any (h,v)-OMA-protocol ΠforEQ-IDXp,q, we can design an (h+q,v)-OMA-
protocolΠ′forIDXpq. The lower bound of (h+q)·v≥Ω(pq)then immediately follows from the OMA
lower bound for IDXpq(Fact 3.6 ).
Suppose Alice and Bob have inputs x∈ {0,1}pqandk∈[pq]in the IDXpqproblem. Then the protocol
Π′is as follows. Alice partitions xintopchunksx1,...,x p, each of size q. Bob sets j=⌈k/p⌉. Merlin
sendsy∈ {0,1}qto Bob and claims that it equals xj. The players can now interpret (x1,...,x p)and(y,j)
as inputs to the EQ-IDXp,qproblem, and run the protocol Πto verify that yis indeed equal to xj. If the check
passes, then Bob knows x[k]since it lies in xj=y. If not, he outputs ⊥, i.e., rejects the proof.
We analyze the completeness and soundness errors of Π′. If Merlin is honest, then yis indeed xj, and
the protocol fails only if Bob rejects because the check in Πdoesn’t go through. The probability of this is
exactly the completeness error of Π. Hence, Π′has the same completeness error as Π. Again, if Merlin
is dishonest, then the protocol fails only when Bob outputs t he incorrect bit-value for x[k]. This happens
only when y/\⌉}atio\slash=xj, but the check passes in Π. This has the same probability as the soundness error of Π.
Therefore, Π′also has the same soundness error as Π. Thus, by deﬁnition, since Πsolves EQ-IDXp,q, the
protocolΠ′solves IDXp.
Finally, we analyze the cost of Π′. Merlin sends Bob yas well as his message due to Π. Thus,
hcost(Π′) =O(h+q). Alice sends Bob only her message due to Π, implying that vcost (Π′) =v. Thus,Π′
is an(h+q,v)-OMA-protocol as claimed. This completes the proof.
Our main result on the non-trivial OMA complexity /hatwidestMA→(EQ-IDXp,q)follows from the above two
lemmas.
Theorem 1. For anyp,qwithp= Ω(logq), we have /hatwidestMA→(EQ-IDXp,q) =ω(q)
17Proof. ByLemma 4.1 , we have R→(EQ-IDX) = Θ(p)for this setting of pandq. Therefore, any non-trivial
OMA protocol Πfor the problem must have vcost(Π) =o(p). But by Lemma 4.2 , ifhcost(Π) =O(q),
thenvcost(Π) = Ω( p). Therefore, hcost(Π)must beω(q), which means tcost(Π) =ω(q). Then, by
deﬁnition, /hatwidestMA→(EQ-IDX) =ω(q).
Corollary 1.1. There is an explicit function fwith
/hatwidestMA→(f) = exp(Ω( MA→(f)))and/hatwidestMA→(f) = exp(Ω( R→(f))).
Proof. Setf=EQ-IDXp,qwithp= lognandq=n/logn. Indeed, p≥logq. Hence, by Theorem 1 , we
have/hatwidestMA→(f) =ω(q) = exp(Ω( p)).
ByLemma 4.1 , we have R→(f) = Θ(p). Also, by deﬁnition MA→(f)≤R→(f) = Θ(p). Therefore,
the claimed result holds.
Corollary 1.2. For anyC∈(√
N,N/logN), there is an explicit function fon input size Nwith
/hatwidestMA→(f) =ω(C).
Proof. Setf=EQ-IDXp,qwithp=n/C andq=C. Sinceq=C≤n/logn, we have
p=n/C≥logn >logq
ByTheorem 1 ,/hatwidestMA→(f) =ω(C).
We also give a tight bound on the (standard) OMA complexity of EQ-IDXp,q.
Theorem 8. For anyp,qwithp≥logq, we have MA→(EQ-IDXp,q) = Θ(min {√pq,p}).
Proof. First, we prove the lower bound. Given an (h,v)-OMA-protocol for EQ-IDXp,q, ﬁrst consider the
case thath > q . Then, by Lemma 4.2 , we have h·v= Ω(pq), which means h+v= Ω(√pq). Otherwise,
i.e., ifh≤q, then by the same lemma, we have q·v= Ω(pq), which means v= Ω(p), and hence,
h+v= Ω(p). Therefore, we conclude
MA→(EQ-IDXp,q) = Ω(min {√pq,p}).
For the upper bound, we ﬁrst show that if q≤p, then we can design a (√pq,√pq)-OMA-protocol for
EQ-IDXp,q. Alice combines x1,...,x pinto a single pq-bit string x, and then again splits xinto√pqchunks
z1,...,z√pq, each of which has√pqbits. Observe that since q≤p, we have q≤√pq, and hence, xjlies
entirely in (the concatenation of) at most two consecutive c hunkszk◦zk+1. Merlin sends Bob zkandzk+1
that he claims are identical to z′
kandz′
k+1. This takes O(√pq)bits. If they are indeed as claimed, Bob
can determine whether y=xj. The problem now reduces to checking whether z′
k=zkandz′
k+1=zk+1
without Merlin. To this end, it sufﬁces to show that there exi sts a one-way randomized private-coin protocol
of costO(√pq). The protocol is very similar to the one mentioned in the proo f ofLemma 4.1 . AnO(√pq)
public-coin protocol can be obtained by having Alice send an O(1)-size equality sketch ( Fact 3.4 ) for each
zi, while Bob uses only zkandzk+1for the check. Newman’s theorem ( Fact 3.7 ) now gives a private-coin
protocol of cost O(√pq+log(pq)) =O(√pq). Therefore, we obtain an OMA protocol of total cost O(√pq)
forq≤p.
Finally, note that MA→(EQ-IDXp,q)is always trivially upper bounded by R→(EQ-IDXp,q), which, by
Lemma 4.1 , isO(p)for this setting of p≥logq. Hence, we can conclude that whenever p≥logq,
MA→(EQ-IDXp,q)≤O(min{√pq,p}).
184.2 Implications of the Equals-Index Lower Bounds
4.2.1 Sparse Index
Here, we consider the SP-IDXm,nproblem. This is the IDXnproblem with the promise that Alice’s string has
hamming weight m. First, we prove a tight bound on its randomized one-way comm unication complexity.
This tells us the benchmark for vcost of a non-trivial OMA protocol for the problem. It also improv es upon
the previously best-known upper bound of O(mlogm)proven by [ CCMT14 ].
Lemma 4.3. R→(SP-IDXm,n) = Θ(m+loglog n)
Proof. First, we describe a public-coin protocol for SP-IDXm,nwith cost O(m). Using public randomness,
Alice and Bob sample a function h: [n]→[3m]from a pairwise independent hash family H. Alice sends
Bob the3m-size characteristic vector of the set S={h(i) :x[i] = 1,i∈[n]}. Bob checks whether
h(j)∈S. If yes, he announces x[j] = 1 , and otherwise he announces x[j] = 0 . Observe that if x[j]is
indeed1, thenh(j)∈S, and Bob is always correct. Otherwise, if x[j]is actually 0, Bob errs only when
h(j) =h(i)for some iwithx[i] = 1 . Fix such an i. By pairwise independence of H, we have
Pr
h∈H[h(j) =h(i)] =1
3m.
By union bound over the mvaluesi∈Y, we get
Pr
h∈H[∃i∈Y:h(j) =h(i)] =1
3.
Thus, the error probability of the protocol is 1/3. Therefore, we get R→(pub)(SP-IDX) =O(m).
To get a private coin protocol, we appeal to Newman’s theorem (Fact 3.7 ) once again. To obtain a tight
bound, we need to have an appropriate interpretation of the p roblem. Observe that since the number of
possible inputs to Alice is/parenleftbign
m/parenrightbig
, we can interpret the domain of SP-IDXm,nas{0,1}log(n
m)× {0,1}logn.
Thus, by Fact 3.7 , we get
R→(SP-IDXm,n) =O/parenleftbigg
m+loglog/parenleftbiggn
m/parenrightbigg/parenrightbigg
=O(m+logm+loglog n) =O(m+loglog n)
For the lower bound part, an Ω(m)lower bound follows trivially by reduction from IDXm. Again,
anΩ(loglog n)lower bound follows since R→(SP-IDX1,n) = Ω(loglog n): this is because SP-IDX1,n≡
EQlogn. Hence, we also get
R→(SP-IDXm,n) = Ω(max {m,loglogn}) = Ω(m+loglog n)
This completes the proof.
Our next lemma proves a lower bound for any OMA protocol that s olves SP-IDX. We remark that the
proof is similar to the one by [ CCMT14 ], but they reduce from IDX, while we reduce from EQ-IDX. This
lets us improve upon the previous lower bound.
Lemma 4.4. Any(h,v)-OMA-protocol for SP-IDXm,nmust have
(h+log(n/m))·v≥Ω(mlog(n/m))
19Proof. We reduce from EQ-IDXp,q. Given any instance of this problem, we construct an instanc e of SP-IDXm,n
wherem=pandn= 2qp(hence,q= log(n/m)) such that an (h,v)-OMA-protocol that solves the
SP-IDXm,ninstance also solves the EQ-IDXp,qinstance (without any additional hcost or vcost). The lower
bound then follows from Lemma 4.2 .
Recall that Alice’s input to the EQ-IDXp,qproblem is (x1,...,x p), where each xi∈ {0,1}q. Alice
interprets each xias the binary representation of an integer in [0,2q−1]. She then constructs a string z
of length n= 2qpindexed by pairs (i,j)wherei∈[p]andj∈[0,2q−1]. For each i∈[p], she sets
z[i,xi] = 1 . She sets all the other bits of zto0. Sincezhas exactly p1’s, its hamming weight is m=p.
Again, Bob, who has inputs y∈ {0,1}qandj∈[p]toEQ-IDXp,q, setsk:= (j,y)interpreting yas an
integer in [0,2q−1]. Alice and Bob now solve SP-IDXm,nwith the inputs zandkrespectively. Indeed, by
construction, z[k] = 1 if and only if y=xj. Therefore, an (h,v)-OMA-protocol that solves SP-IDXm,ncan
be used to solve any instance of EQ-IDXp,qwithp=mandq= log(n/m).
Note that our bound is strictly better than Theorem 3.9 of [ CCMT14 ], which (essentially) says that an
(h,v)-OMA-protocol for SP-IDXm,nmust have (h+logn)·v≥Ω(mlog(n/m)); this inequality is trivially
implied by Lemma 4.4 . Further, our strengthening of the additive factor from logntolog(n/m), combined
with our tight classical one-way communication bound of SP-IDX, enables us to prove strong lower bounds
on its non-trivial OMA complexity as we show below.
Consider SP-IDXm,nform≥loglogn. By Lemma 4.3 , its one-way randomized communication com-
plexity is Θ(m). Therefore, any non-trivial OMA protocol for the problem mu st have vcost o(m). But by
Lemma 4.4 , for any(h,v)-OMA-protocol for SP-IDX,
h=O(log(n/m))⇒v= Ω(m)
Hence, any non-trivial OMA-protocol Πmust have hcost(Π) =ω(log(n/m)), which means /hatwidestMA→(SP-IDXm,n) =
Ω(log(n/m))whenever m≥loglogn. This gives us the following theorem.
Theorem 9. /hatwidestMA→(SP-IDXloglogn,n) = Ω(log n).
Proof. Follows from above along with the fact that for m= loglog n, we have Ω(log(n/m)) = Ω(log n).
Compare this with the fact that MA→(SP-IDXloglogn,n) =R→(SP-IDXloglogn,n) = Θ(loglog n).
Hence, we show an exponential separation between MA→and/hatwidestMA→complexity of SP-IDX with sparsity
loglogn.
4.2.2 Connectivity and Bipartite Testing
Now we show that the lower bounds for the only two other functi ons, which were known to have /hatwidestMA→and
MA→complexity (almost) as large as their R→complexity, can be derived by reduction from EQ-IDXand
applying Lemma 4.2 . These are XOR-Connectivity and XOR-Bipartiteness, as stu died in [ Tha16b ]. We
formally deﬁne the problems below.
XOR-CONNn: Alice and Bob have graphs GA= (V,EA)andGB= (V,EB)on the same set of nodes V
with|V|=n. The graph Gis deﬁned as (V,EA⊕EB). The goal is to determine whether Gis connected:
Bob needs to output 1if it is and 0otherwise.
XOR-BIPn: Alice and Bob have graphs GA= (V,EA)andGB= (V,EB)on the same set of nodes Vwith
|V|=n. The goal is to determine whether G:= (V,EA⊕EB)is bipartite: Bob needs to output 1if it is,
and0otherwise.
20As noted by [ Tha16b ], one can use a modiﬁed version of the connectivity and bipar titeness-sketches
by [AGM12 ] to obtain classical streaming /tildewideO(n)-space algorithms for the streaming versions of XOR-CONN
and XOR-BIPrespectively. These algorithms can, in turn, be used to obta in/tildewideO(n)-cost one-way randomized
protocols for these problems in the classical communicatio n model. This means R→(XOR-CONNn)and
R→(XOR-BIPn)are both /tildewideO(n). Well-known communication lower bounds for connectivity a nd bipartite-
ness also imply that R→(XOR-CONNn) =˜Θ(n)andR→(XOR-BIPn) =˜Θ(n)
[Tha16b ] showed that MA→(XOR-CONNn)and MA→(XOR-BIPn)areΩ(n). This follows from their
more general result:
Theorem 10 ( [Tha16b ], Theorem 4.1, restated) .Any(h,v)-OMA-protocol solving XOR-CONNnorXOR-BIPn
must have
(h+n)·v≥Ω(n2).
We prove that this theorem also follows by reduction from EQ-IDXn,n, thus adding to the usefulness of
EQ-IDXin proving strong MA→lower bounds.
Proof. First, we prove the result for XOR-CONN2n. The construction for XOR-BIP2nis very similar, and so
we simply mention the modiﬁcations for that case.
Given an instance of EQ-IDXn,n, Alice ﬁrst interprets her input (x1,...,x n)where each xi∈ {0,1}n
as the biadjacency matrix of a bipartite graph with nnodes on each side. To be precise, Alice constructs the
following bipartite graph. Let VL={u1,...,u n}andVR={v1,...,vn}. For each ℓ∈[n], Alice joins the
edges{{uℓ,vr}:xℓ[r] = 1,r∈[n]}. This completes the description of the graph GA= (V,EA)where
V=VL∪VR∪{s}andEAis the set of all edges added by Alice. Again, given his inputs y∈ {0,1}nand
j∈[n], Bob joins the edges {{uj,vr}:y[r] = 1,r∈[n]}. He then joins vertex sto all nodes in VL∪VR
exceptuj. This completes the description of the graph GB= (V,EB)whereEBis the set of all edges
added by Bob.
Observe that if yis indeed equal to xj, then the neighborhoods of the vertex ujinGAandGBare
identical by construction. Then, ujis an isolated vertex in G= (V,EA⊕EB), which means Gis not
connected. Again, if y/\⌉}atio\slash=xj, then there must exist r∈[n]such that y[r]/\⌉}atio\slash=xj[r]. By construction, exactly
one of the sets EAandEBhas the edge e:={uj,vr}, and hence e∈EA⊕EB. Therefore, in G, the node
ujis connected to vr, which in turn is connected to s. Observe that every other node w∈Vwithw/\⌉}atio\slash=uj
is connected to sinG: they are connected in EB, whileEAdoes not contain any such edge {s,w}. Thus,
sis connected to every other node in G, implying that Gis connected. Hence, Gis connected iff y/\⌉}atio\slash=xj.
Therefore, given an (h,v)-OMA-protocol for XOR-CONN2n, the players can run it for the constructed graph
G, and Bob can determine the output to EQ-IDXn,n.Lemma 4.2 now gives the desired result for XOR-CONN .
For XOR-BIP, the construction of the graphs GAandGBare the same, except Bob joins stoujand all
vertices in VRonly (instead of VL∪VR). Ifxj=y, then the neighborhoods of ujinGAandGBare the
same, except ujis also adjacent to sinGB. Hence, in G, the only edge incident on ujis{uj,s}. Therefore,
we can bipartition Ginto({s} ∪VL\ {uj},VR∪ {uj}). Observe that this is a valid bipartition since all
edges inGare between the left and right sides. Otherwise, if xj/\⌉}atio\slash=y, then by the same logic as in the case
ofXOR-CONN , there must exist r∈[n]such that {uj,vr} ∈G. Further, {s,vr},{uj,s} ∈Gsince these
edges are in GBbut notGA. Hence,Ghas a triangle in this case and is not bipartite. Thus, we conc lude that
Gis bipartite iff the answer to xj=y, which means an (h,v)-OMA-protocol for XOR-BIP2ncan be used to
determine the solution to any instance of EQ-IDXn,n. The result again follows from Lemma 4.2 .
21n n
uj
vr
......
(a)Alice uses xito construct the neighbor-
hood of vertex i.n n
uj
vrN(uj)
......
(b)Bob constructs N(uj)based on y.n n
uj
vr......
(c)Bob created an additional vertex and
connects all vertices except ujto it.
4.2.3 Distinct Items
Here, we discuss lower bounds for the well-studied distinct items problem in the turnstile model. We
formally deﬁne the problem as follows.
DIST-ITEMN,F: Given a turnstile stream of elements in [N]such that max{|freq(j)|:j∈[N]} ≤F, output
the number of items with non-zero frequency, i.e., |{j∈[N] :freq(j)/\⌉}atio\slash= 0}|
Lemma 4.5. Any(h,v)-scheme for DIST-ITEMN,Fmust have
(h+logF)·v≥Ω(NlogF)
Proof. Given an (h,v)-schemeAforDIST-ITEMN,F, we design an (h,v)-OMA-protocol for EQ-IDXN,logF.
In an instance of this problem, Alice has x1,...,x N, where each xi∈ {0,1}logF. She interprets each xi
as (the binary representation of) an integer in [0,F−1]and feeds xi+1insertions of the element itoA.
Observe that 1≤freq(i)≤Ffor eachiin the stream. Alice then sends Bob the memory state of A. Bob
has inputs y∈ {0,1}logFandj∈[N]. Again, he interprets yas an integer in [0,F−1]and continues
the run of Aby appending the stream with y+ 1deletions of the item j. Merlin sends Bob the proof that
the Prover would send in A. Bob can now run the veriﬁcation part of Aand get an output. If the answer
isn−1, then he announces that xj=y. Otherwise, he declares xj/\⌉}atio\slash=y. For the correctness, observe that
Alice added the item jto the stream xj+1times and Bob deleted it y+1times. Therefore, freq (j) = 0
iffxj=y. All other stream elements have frequency at least 1. Hence, the number of items with non-zero
frequency in the stream is N−1ifxj=y, andNotherwise.
Again, we need to prove a tight bound on the classical streami ng complexity of DIST-ITEM so that we
know what it means to be a non-trivial scheme for the problem. Using the non-zero detectors that we build
inSection 5.1 , we can design an efﬁcient classical streaming algorithm fo rDIST-ITEMN,Ffor largeF.
Lemma 4.6. There exists a classical streaming algorithm using O(NloglogF)space for DIST-ITEMN,F.
Again, any such algorithm needs Ω(N)space.
Proof. We can keep one non-zero detector given by Corollary 5.3 for each element in [N], and can ﬁgure
out the answer. by Corollary 5.3 , we need /tildewideO(NloglogF)space and this succeeds with probability 1−
1/polylog(F) by union bound over the Ndetectors. The lower bound follows by a simple reduction fro m
IDXN, even for insert-only streams: Alice inserts {i:xi= 1}and sends Bob the hamming weight of x.
Bob inserts jand checks whether or not the number of distinct elements in t he stream exceeds the hamming
weight of x. If yes,xj= 0, and if not xjmust be1.
22Given the above lemma, we can prove our lower bound on the non- trivial total cost of DIST-ITEMn,F.
Lemma 4.7. Any non-trivial scheme for DIST-ITEMN,FwithF≤exp(Npolylog(N))must have total cost
ω(logF).
Proof. ByLemma 4.6 , the classical streaming complexity of DIST-ITEMN,Fis˜Θ(N)forF≤exp(N˜Θ(1)).
Hence, any non-trivial scheme Πfor the problem must have vcost(Π) =o(N). By Lemma 4.5 ,hcost(Π) =
O(logF)implies vcost(Π) = Ω( N). Hence, hcost(Π) =ω(logF), which means tcost(Π) must be
ω(logF).
This establishes a separation between the classical stream ing complexity and the (non-trivial) annotated
streaming complexity of DIST-ITEM and proves Theorem 2 .
Theorem 2. There is a setting of Fsuch that DIST-ITEMN,Fcan be solved in /tildewideO(N)space in classical
streaming, but any non-trivial annotated streaming scheme for the problem must have total cost Ω(Npolylog(N)).
4.2.4 Connectivity Problems in Support Graph Turnstile Str eams
We ﬁrst make the following claim about classical streaming c omplexities of connectivity and k-connectivity.
Claim 4.8. In the classical streaming model under SGT streams, graph co nnectivity can be solved in /tildewideO(n)
space, and each of the k-vertex-connectivity and k-edge-connectivity problems can be solved in /tildewideO(kn)
space. These bounds match (up to polylogarithmic factors) t he space-bound known for each problem under
dynamic graph streams.
Proof. The upper bounds of connectivity and k-vertex-connectivity follow by using the [ AGM12 ] and
[AS23 ] algorithms respectively, and replacing their ℓ0samplers with our strong ℓ0samplers given by
Lemma 5.4 . For the k-edge connectivity problem, it is not clear that the algorit hm by [ AGM12 ] can be
implemented under SGT streams. So we design a new /tildewideO(kn)-spacek-edge-connectivity algorithm under
such streams, presented in Section 5.2 . The claim then follows.
We show a lower bound for connectivity in this model. First we prove the following lemma.
Lemma 4.9. Any(h,v)-scheme for connectivity satisﬁes (h+qn)·v≥n2·q. In particular, when q=
npolylog(n), forv=o(n)we needh≥npolylog(n).
The proof of this lemma is along the same lines as the proof of X OR-Connectivity except that we use
EQ-IDXn,qn. Alice and Bob construct the same graph, but now for each pair of vertices there could be
multiple edge insertions (up to 2q).
We now prove lower bounds for k-vertex-connectivity and k-edge-connectivity in this model.
Lemma 4.10. Any(h,v)-scheme for k-vertex-connectivity or k-edge-connectivity satisﬁes (h+q)·v≥kn·q.
In particular, when q= 2polylog(n), forv=o(kn)we needh≥2polylog(n).
Say that we are given an (h,v)-scheme for k-vertex-connectivity or k-edge-connectivity in the Support
Graph Turnstile streaming model. Given an instance of EQ-IDXkn,q, Alice constructs the following graph
stream. Let VL={u1,...,u n}andVR={v1,...,vk}. For each ℓ∈[kn], Alice inserts an edge between
theℓthpair of vertices xℓtimes. Given his inputs y∈ {0,1}qandj∈[kn], Bob creates the following graph
stream. Bob deletes an edge between the jthpair of vertices ytimes. Bob also adds an edge between every
pair of vertices except the jthpair. Alice runs the (h,v)-scheme on her graph stream and sends the memory
content to Bob, who then continues running the scheme on his g raph stream. Iff the graph is k-connected,
23then output 0for the EQ-IDXkn,qinstance and output 1otherwise. Note that the complete bipartite graph
isk-connected, but even if you remove one edge it is not k-connected. The correctness follows from the
following claim.
Claim 4.11. The graph formed by the stream is k-connected in the support graph turnstile model iff the
EQ-IDXkn,qinstance has value 0.
Proof. Consider the case when the EQ-IDXkn,qinstance has value 1. We have xj=y, so thejthpair of
vertices has yedge insertions and yedge deletions. This means that there is no edge between the jthpair of
vertices, implying that the support graph is not k-connected.
Now consider the case when the EQ-IDXkn,qinstance has value 0. We have xj/\⌉}atio\slash=y, so thejthpair
of vertices has a different number of edge insertions and edg e deletions. This implies that the jthpair of
vertices has a non-zero support implying that the jthedge exists. Every other pair of vertices has only
edge insertions, including exactly 1edge insertion by Bob. This implies that every other pair of v ertices
has a non-zero support implying that the edge exists. Thus, t he support graph is a complete bipartite graph
implying that the support graph is k-connected.
Claim 4.11 shows that this protocol solves EQ-IDXkn,q. We know by Lemma 4.2 that the following holds
for any protocol that solves EQ-IDXkn,q:
(h+q)·v≥kn·q.
The only help from Merlin is hbits for the (h,v)-scheme. The only communication from Alice is sending
the memory content that takes vbits of space. This bound implies that even if h=O(q),v= Ω(kn). So for
v=o(kn)we needh=ω(q). Settingq= 2polylog(n)implies that for v=o(kn)we needh≥2polylog(n).
However, using the strong ℓ0-Samplers gives us h= 0andv=/tildewideO(kn).
n k
u
v
......
(a)Alice adds xiedges for pair i.n k
u
v
......
(b)Bob deletes (u,v)ytimes and adds every other pair
once.
5 Classical Streaming Algorithms under SGT streams
5.1 Basic Tools: Non-Zero Detection and ℓ0-Sampling for Large Frequencies
In this section, we introduce an ℓ0-sampler that works when the entries in the vector are expone ntial in size.
5.1.1 Non-zero detection
Consider the following simple problem.
Problem 1. Given a stream containing +’s and−’s output whether the number of +’s is exactly equal to
the number of −’s or not. The promise is that the difference between the numb er of+’s and−’s is less than
αat the end of the stream.
24A simple solution to Problem 1 is to store a deterministic counter mod αwhich takes O(logα)bits of
space. It is easy to show that we cannot do better determinist ically.
Claim 5.1. Any deterministic algorithm for Problem 1 needslogαbits of space.
Proof. Assume towards a contradiction that there is a deterministi c algorithm that solves Problem 1 in less
thanlogαbits of space. Consider the different states of memory when w e have exactly i+’s in the input
stream. Since the memory used is less than logαbits, there exist iandj(wlogi < j ) such that the state of
memory after inserting itimes is the same as the state of memory after inserting jtimes. Now consider i
−’s appear in the stream after the +’s. In the case where there were i+’s, the answer is 0, but the answer in
the other case is 1. However, the algorithm cannot differentiate between the t wo cases because the memory
state was the same after seeing the +’s, giving us a contradiction.
Now the question is whether randomized algorithms can do bet ter.Claim 5.1 implies a lower bound
ofΩ(loglog α)bits for the private randomness communication complexity o f this problem. There exists a
randomized algorithm for this problem that uses O(loglogα)bits of space.
Lemma 5.2. There exists a randomized algorithm that solves Problem 1 with probability 1−1/polylog(α)
and usesO(loglogα)bits of space.
Proof. Letpbe a random prime within the ﬁrst polylog(α)primes. Storing ptakesO(loglogα)bits of
space by the prime density theorem. We store a counter mod pto solve Problem 1 .
Let the counter value be α′< α. We make a mistake if our counter is 0, which happens when pis a
factor ofα′. Observe that α′has at most logαprime factors because the product of all prime factors is at
mostα′< α and all prime factors are at least 2.
So the probability that pdividesα′is at most logα/polylog(α)implying that the probability of success
is at least 1−1/polylog(α).
If we just slightly change the proof and let pbe a random prime within the ﬁrst polylog(α)·poly(n)
primes, then we get the following:
Corollary 5.3. There exists a randomized algorithm that, given a parameter n, solves Problem 1 with
probability 1−1/polylog(α)·poly(n) and usesO(loglogα+logn)bits of space.
5.1.2 Strong ℓ0-samplers
In this subsection, we design an ℓ0-sampler that can handle large values. Let the universe of el ements be [n].
Consider the following problem:
Problem 2. Given a stream containing insertions and deletions of eleme nts in[n], output an element whose
frequency is non-zero. The promise is that the value of each c oordinate is between −αandαat the end of
the stream.
The input can be thought of as a vector, so we will go back and fo rth between thinking of the input
as a vector and a stream of elements. We know how to solve this p roblem using polylog(n) space when
α= poly(n) . We now use the decision counters from Section 5.1 to solve Problem 2 .
Lemma 5.4. There is a randomized algorithm that solves Problem 2 with probability 1−1/polylog(α)·
poly(n) and usespoly(loglog α+logn) bits of space.
25We ﬁrst solve the problem when the support size is 1. The idea is to compute inner products with vectors
that reveal the bits of the position of the non-zero element. This idea is called non-adaptive binary search.
Consider the set Aoflognvectors of size nwhere the ithvectorai(i∈ {0,1,...,logn−1}) is deﬁned
as the vector which has a 1at an index iff the ithbit of the index is 0. We can also describe it as follows:
The vector aiis made of n/2iblocks of size 2ieach. Alternately ﬁll the blocks with all 1’s and then all 0’s.
Soa0will be the vector 10repeating, a1will be the vector 1100 repeating, and alogn−1will be the vector
with1’s in the ﬁrst half and 0’s in the second half. We use the set Ato get the following lemma:
Lemma 5.5. There is a randomized algorithm that solves Problem 2 with the promise that the support size
is1with probability 1−1/polylog(α)·poly(n) and usesO(logn·loglogα+log2n)bits of space.
Consider the following algorithm for Lemma 5.5 :
Algorithm 1. A dynamic streaming algorithm for Problem 2 with support size 1.
Input: A vectorvspeciﬁed in a dynamic stream.
Output: The element with non-zero frequency.
During the stream:
1. Store inner products of the frequency vector with all vect ors in set Ausing the decision counters.
Post-Processing:
1. Letsbe thelognbit solution.
2. If the inner product with aiis0then setsi= 1, otherwise set si= 0.
3. Output sas the non-zero index (where i= 0is the least signiﬁcant bit).
We ﬁrst show that this algorithm can be implemented in small s pace.
Claim 5.6. The space taken by Algorithm 1 isO(logn·loglogα+log2n)bits.
Proof. We store logndecision counters, each taking O(logn+loglog α)bits. We do not store the vectors
aiexplicitly. When we get element ein the stream, we know which ai’s have a 1in position e, so we can
update those counters.
We now show that we can recover the correct non-zero index wit h high probability.
Claim 5.7. Algorithm 1 outputs the correct answer with probability 1−1/polylog(α)·poly(n) .
Proof. We ﬁrst condition on none of the decision counters failing. aiis a vector which has a 1at some
index iff the ithbit of the index is 0. If the inner product of the frequency vector and aiis1thenaiis
1on the non-zero index. This implies that the ithbit of the non-zero index is 0. Thus, the protocol is
deterministically correct after conditioning on none of th e decision counters failing. A union bound over the
failure probabilities of the counters concludes the proof.
Claim 5.6 andClaim 5.7 together prove Lemma 5.5 .
We also need an algorithm that can tell us whether we are in the support1case or not. The idea is to
partition the coordinates into 4parts randomly and check the sums of each part. If there are ma ny non-zero
26coordinates then the hope is that they are spread across mult iple partitions, making the sums in multiple
partitions non-zero. We use this idea to get the following le mma:
Lemma 5.8. There is a randomized algorithm that can detect whether or no t the support size is 1with
probability 1−1/polylog(α)·poly(n) and usesO((loglogα+logn)2)bits of space.
Consider the following algorithm for Lemma 5.8 :
Algorithm 2. A dynamic streaming algorithm for detecting a vector with su pport size 1.
Input: A vectorvspeciﬁed in a dynamic stream.
Output: Whether the support of non-zero elements in vis exactly 1or not.
Pre-processing:
1. Letr=O(logn+loglog α).
2. Create rindependent random partitions Vi
1,Vi
2,Vi
3,Vi
4(i∈[r]) where every element independently
belongs to Vi
jwith probability 1/4.
During the stream:
1. Store inner products zi
jof the frequency vector with the characteristic vectors of Vi
jusing the
decision counters for i∈randj∈[4].
Post-Processing:
1. If there exists isuch that more than one zi
jis non-zero or all zi
j’s are zero then output non-zero
support is not 1. Otherwise, output non-zero support is 1.
Claim 5.9. Algorithm 2 can identify whether the support of the non-zero elements is 1or not with probability
1−1/poly(n)·polylog(α).
Proof. We ﬁrst condition on the event that none of the counters fail. In the case the support is 1, exactly one
zi
jwill be non-zero for all i∈[r]. In the case the support is 0, allzi
j’s will be zero for all i∈[r].
Now consider the case where there are t >1non-zero elements. Let eande′be two different non-zero
elements. Consider the state of the inner products ˜zi
jwithout elements eande′.
• Case 1: If at least 2counters are zero then with probability at least 1/16,eande′are assigned to the
counters that are zero, making them non-zero. Thus, there ar e at least two non-zero counters.
• Case 2: If at least 3counters are non-zero then with probability at least 1/16,eande′are assigned to
the same non-zero counter. Thus, there are at least two non-z ero counters since two out of the three
remain unchanged.
In both cases, we are successful with probability at least 1/16. Thus, the probability we fail over all iteration
is(1−1/16)r≤exp(−r/16)≤1/poly(n)·polylog(α). A union bound over the failure probabilities of
the counters concludes the proof.
Claim 5.10. Algorithm 2 usesO((logn+loglog α)2)bits of space.
27Proof. There are 4r=O(logn+ loglog α)decision counters each taking O(logn+ loglog α)bits of
space.
Claim 5.9 andClaim 5.10 together prove Lemma 5.8 .
We now combine the ideas above to give the ﬁnal algorithm to so lveProblem 2 (for an arbitrary support
size). The idea is to reduce to the support size 1case. Let kbe the number of non-zero elements in the
frequency vector. If we sample 1/kfraction of the coordinates then with constant probability only one of
the non-zero elements lies in the support. By repeating this many times we can reduce to the support 1case
with high probability. We do not know kbut we can guess it to within a factor of 2by trying all powers of
2. Also, we can detect when the support size is exactly 1. Consider the ﬁnal algorithm:
Algorithm 3. A dynamic streaming algorithm for Problem 2 .
Input: A vectorvspeciﬁed in a dynamic stream.
Output: An element with non-zero frequency.
During the stream:
Fori= 0tologn:
Repeatr=O(logn+loglog α)times:
1. Sample every element independently with probability 1/2i.
2. Run Algorithm 1 andAlgorithm 2 on the sampled subset.
Post-Processing:
1. Find an iteration where Algorithm 2 returns non-zero support 1. If no such iteration exists output
“FAIL”.
2. Use the corresponding copy of Algorithm 1 to output the non-zero index.
The space used by Algorithm 3 ispoly(loglog α+logn) .
Claim 5.11. Algorithm 3 usesO(logn·(loglogα+logn)3)bits of space.
Proof. We userlogncopies of Algorithm 1 andAlgorithm 2 . A copy of Algorithm 1 takes space O(logn·
loglogα+log2n)bits of space. A copy of Algorithm 2 takes space O((loglogα+logn)2)bits of space.
Thus the total space taken is O(logn·(loglogα+logn)3)bits.
We now show the correctness of Algorithm 3 . We start by conditioning on the high probability events
of all copies of Algorithm 1 andAlgorithm 2 . Letkbe the size of the non-zero support of the input vector
v. Consider the iterations when i=i∗wherek≤1/p:= 2i∗≤2k. We need to show that with high
probability, in some iteration, exactly one element is samp led.
Claim 5.12. There is an iteration where exactly one element from the non- zero support is sampled with
probability 1−1/polylog(α)·poly(n) .
Proof. The claim is trivial when k= 1, so we consider k≥2. The probability that exactly one element is
sampled is:
Pr[exactly one element is sampled ] =k·p·(1−p)k−1
28≥k·1
2k·(1−1/k)k
≥1/16. (k≥2implies(1−1/k)k≥1/8)
We fail when this does not happen in any iteration. The probab ility of failure is:
Pr[failure]≤(1−1/16)r≤1/polylog(α)·poly(n).
Thus, there is an iteration where exactly one element from th e non-zero support is sampled with probability
1−1/polylog(α)·poly(n) .
This means that with high probability, there is an iteration where exactly one element from the non-zero
support is sampled. For this iteration with high probabilit y, the corresponding copy of Algorithm 2 will
output non-zero support 1, and the corresponding copy of Algorithm 1 will output the non-zero index. Also,
for all other iterations where the support size is not 1, the corresponding copy of Algorithm 2 will output
non-zero support is not 1with high probability. A union bound over the failure probab ilities of all copies of
Algorithm 2 andAlgorithm 1 proves the correctness of Algorithm 3 inLemma 5.4 .Claim 5.11 proves the
space bound of Algorithm 3 inLemma 5.4 . Therefore, we have proved Lemma 5.4 .
Note that the number of random bits used is more than the space bound. But we can ﬁx this by using
Nisan’s pseudorandom generator ( Fact 3.8 ). Using this increases the space by a factor of O(logn)and
makes the true randomness needed ﬁt in the space bound.
5.2 Edge Connectivity
A Certiﬁcate of Edge Connectivity We present a certiﬁcate of k-edge-connectivity in this section. Our
algorithm and analysis are very similar to the k-vertex connectivity algorithm of [ AS23 ].
Algorithm 4. An algorithm for computing a certiﬁcate of k-edge-connectivity.
Input: A graphG= (V,E)and an integer k.
Output: A certiﬁcate Hfork-edge-connectivity of G.
1. Fori= 1,2,...,r:= (200klnn)do the following:
• LetEibe a subset of Ewhere each edge is sampled independently with probability 1/k.
• LetGi= (V,Ei)be the subgraph of Gcontaining edges of Ei.
• Compute a spanning forest TiofGi.
2. Output H:=T1∪T2∪...∪Tras a certiﬁcate for k-edge-connectivity of G.
The algorithm of [ AS23 ] samples vertices with probability 1/kand stores spanning forests over the
sampled induced subgraph. The number of iteration in their a lgorithm is also larger by a factor of kbecause
in each iteration they are working with a smaller graph on rou ghlyn/k vertices.
The following theorem proves the main guarantee of this algo rithm.
Theorem 11. Given any graph G= (V,E)and any integer k≥1,Algorithm 4 outputs a certiﬁcate Hof
k-edge-connectivity of GwithO(kn·logn)edges with high probability.
The analysis in the proof of Theorem 11 is twofold. We ﬁrst show that pairs of vertices that are at
least2k-edge-connected in Gstayk-edge-connected in H. Secondly, we show that edges whose endpoints
29are not2k-edge-connected in Gwill be preserved in H. Putting these together, we then show that His a
certiﬁcate for k-edge-connectivity of Gand has at most /tildewideO(kn)edges.
We start by bounding the number of edges of the certiﬁcate H.
Lemma 5.13. The certiﬁcate HinAlgorithm 4 hasO(kn·logn)edges.
Proof. Each spanning forest Tihas at most n−1edges. Thus, the total number of edges in His at most
200knlnn.
We now prove the correctness of this algorithm in the followi ng lemma.
Lemma 5.14. Subgraph HofAlgorithm 4 is a certiﬁcate of k-edge-connectivity for Gwith high probability.
Lemma 5.14 will be proven in two steps. We ﬁrst show that every pair of ver tices that have at least 2k
edge-disjoint paths between them in Ghave at least kedge-disjoint paths in Hwith high probability.
Lemma 5.15. Every pair of vertices s,tinGthat have at least 2kedge-disjoint paths between them in G
have at least kedge-disjoint paths in Hwith high probability.
We then show that every edge whose endpoints have less than 2kedge-disjoint paths between them in
Gwill belong to Has well.
Lemma 5.16. Every edge (s,t)∈Gthat has less than 2kedge-disjoint paths between its endpoints in G
belongs to Halso with high probability.
The proofs of these lemmas appear in the next two subsections . We ﬁrst use these lemmas to prove
Lemma 5.14 and conclude the proof of Theorem 11 .
Proof of Lemma 5.14 .We ﬁrst condition on the events in Lemma 5.15 andLemma 5.16 both of which hap-
pen with high probability. We need to show that Hisk-edge-connected iff Gisk-edge-connected. If His
k-edge-connected then Gis alsok-edge-connected simply because His a subgraph of G.
We now assume towards a contradiction that Gisk-edge-connected, but His not. This means that there
is a cutSof size at most k−1, i.e. removing the set of edges Xgoing out of Sdisconnects H. SinceG
isk-edge-connected, the cut Shas at least kedges going out of it so deleting the set of edges Xcannot
disconnect Gand thusGhas an edge e= (s,t)betweenSandT:=V−S(seeFigure 3 ).
S T
t s Xe∈G−H
Figure 3: An illustration of the cut SinGandH. AfterXis deleted, there are no edges between SandTinH, while
Ghas at least one edge e= (s,t)betweenSandT, to ensure its k-edge-connectivity as |X|< k.
We now consider two cases.
30• Case 1: sandthave at least 2kedge-disjoint paths between them in G.
We have conditioned on the event in Lemma 5.15 , so we can say that sandthave at least kedge-
disjoint paths in H. Deleting Xcan destroy at most |X| ≤k−1of these paths in H. This implies
that there is still an s-tpath inH−Xand thus there is an edge between SandTinH−X, a
contradiction.
• Case 2: sandthave less than 2kedge-disjoint paths between them in G.
Since there are fewer than 2kedge-disjoint paths between sandtinG, by conditioning on the event
ofLemma 5.16 ,ewould be preserved in H, a contradiction with Hhaving no edge between SandT.
In conclusion, we get that His a certiﬁcate of k-edge-connectivity for Gwith high probability.
Theorem 11 now follows immediately from Lemma 5.13 andLemma 5.14 .
Before moving on from this section, we present the following corollary of Algorithm 4 that allows for
using this algorithm for some other related problems in dyna mic streams as well.
Corollary 5.17. The subgraph Houtput by Algorithm 4 with high probability satisﬁes the following guar-
antees:
(i)For any pair of vertices s,tinG, there are at least kedge-disjoint s-tpaths inGiff there at least k
edge-disjoint s-tpaths inH(this holds even if Gis notk-edge-connected).
(ii)Every cut of Hwith size less than kis a cut in Gwith size less than kand vice versa (this means all
cuts ofGare preserved in Hand no new ones are created as long as their size is less than k).
The proof of this corollary is identical to that of Lemma 5.14 and is thus omitted.
Proof of Lemma 5.15 .We prove Lemma 5.15 in this part following the same approach as in [ AS23 ]. For
this proof, without loss of generality, we can assume that k >1: fork= 1, each graph Giis the same as G
and thus the spanning forest computes an s-tpath which will be added to H, trivially implying the proof.
Fix any pair of vertices s,twith at least 2kedge-disjoint paths between them. We choose an arbitrary se t
Xofk−1edges, and the goal is to show that sandtremain connected in the graph H−Xwith very high
probability. We do so by showing that out of the at least kedge-disjoint paths between sandtinG−X,
with probability 1−n−Θ(k), at least one of them is entirely sampled as part of the subset ofGi’s fori∈[r]
that do not contain any edges from X. This will be sufﬁcient to prove the existence of an s-tpath inH−X.
A union bound over the/parenleftbign2
k−1/parenrightbig
choices of Xand/parenleftbign
2/parenrightbig
pairss,tconcludes the proof.
FixXas a set of k−1edges. Deﬁne:
I(X) :={i∈[r] :Ei∩X=∅}; (1)
that is, the indices of sampled graphs in G1,...,G rthat contain no edges from X. We ﬁrst argue that |I(X)|
is large with very high probability.
Claim 5.18. Pr(|I(X)| ≤r/8)≤n−5k.
Proof. Fix any index i∈[r]and an edge e∈X. The probability that eis not sampled in Eiis(1−1/k)by
deﬁnition and thus,
Pr(Ei∩X=∅) = (1−1/k)k−1≥1/4,
given that k >1(as argued earlier) and the sampling of edges being independ ent inEi. Therefore, we have,
E|I(X)|=r·(1−1/k)k−1≥r/4.
31By an application of the Chernoff bound ( Fact 3.1 ) withµL=r/4andε= 1/2, we have,
Pr[|I(X)| ≤r/8]≤exp(−r/4·1/10)< n−5k.
In the rest of the proof we condition on the event that |I(X)| ≥r/8. To continue, we need some
deﬁnitions. There are more than kedge-disjoint paths between sandtinG−Xsince there were 2kof them
inGand onlyk−1edges (set X) are deleted. Choose kof them arbitrarily denoted by P1(X),...,P k(X)
(seeFigure 4 for an illustration).
s tP2
...P1
Pk
Figure 4: An illustration of the kedge-disjoint s-tpathsP1(X),P2(X),...,P k(X). Note that the paths can share
vertices but are edge-disjoint.
We deﬁne the notion of “preserving” a path.
Deﬁnition 5.19. LetGX:=∪i∈I(X)Gibe the union of graphs indexed in Eq (1) . We say that a path Pin
G−Xispreserved inGXiff for every edge e∈P, there exists at least one i∈I(X)such that e∈Gi; in
other words, the entire path Pbelongs to GX.
We are going to show that with very high probability, at least one pathPj(X)forj∈[k]is preserved
byGX. Before that, we have the following claim that allows us to us e this property to conclude the proof.
Claim 5.20. If anys-tpathPj(X)forj∈[k]is preserved in GXthensandtare connected in H−X.
Proof. Given that P:=Pj(X)is preserved, we have that for any edge e= (u,v)∈P, there is some graph
Gifori∈I(X)that contains e. This means that u,vare connected in Giwhich in turn implies that the
spanning forest TiofGicontains a path between uandv. Moreover, since i∈I(X), we know that Giand
henceTicontain no edges of Xand thusuandvare connected in Ti−Xas well. Stitching together these
u-vpaths for every edge (u,v)∈Pthen gives us a walk between sandtinH−X, implying that sandt
are connected in H−X.
We will now prove that some path Pj(X)forj∈[k]is preserved with very high probability.
Claim 5.21. Conditioned on |I(X)| ≥r/8, we have the following:
Pr[Pj/\⌉}atio\slash⊆GXfor at least k/2values of j∈[k]]≤n−11k.
Proof. To start the proof, note that even conditioned on a choice of I(X), the edges in each path Pj(X)
appear independently in each graph Gifori∈I(X). This is because these paths do not intersect with X
and by the independence in sampling of each graph Gifori∈[r]. Moreover, given that these paths are
edge-disjoint, the choices of their edges across each graph Gifori∈[r], are independent. We crucially use
these properties in this proof.
Each edge in Pjis not present in Giwith probability (1−1/k)and hence is not present in GXwith
probability (1−1/k)|I(X)|. Hence, by the union bound,
Pr[Pj/\⌉}atio\slash⊆GX]≤ |Pj|·(1−1/k)|I(X)|≤n·(1−1/k)r/8≤n·exp(−200klnn/8k) =n−24.
32Finally, note that since the paths Pjforj∈[k]are edge-disjoint, the probability of the above event is
independent for each one. Thus,
Pr[Pj/\⌉}atio\slash⊆GXfor at least k/2values of j∈[k]]≤/parenleftbiggk
k/2/parenrightbigg/parenleftbig
n−24/parenrightbigk/2≤2k·n−12k≤n−11k.
As such, the entire path Pjwill lie inside GXfor at least k/2values of j∈[k]with very high probability.
By union bound over the events of Claims 5.18 and5.21, we have that there exists an index j∈[k]
such that the path Pj(X)is preserved in GX. Thus, by Claim 5.20 , for a ﬁxed choice of X, ands,t, the
probability that sandtare not connected in H−Xis at most n−11k. A union bound over the n2kchoices
ofXandn2choices of s,t, then implies that the probability that even one such choice ofXands,texists
is at most n−7k. This completes the proof of Lemma 5.15 .
Proof of Lemma 5.16 .We now prove Lemma 5.16 . For this proof also, without loss of generality, we can
assume that k >1: fork= 1, each graph Giis the same as Gand thus the spanning forest uses the only
s-tpath, namely, the edge (s,t)(assandtcan only be 1-connected through the edge (s,t)) which will be
added toH, thus trivially implying the proof. We now consider the main case.
Fix any pair of vertices s,t∈Gwhich have less than 2kedge-disjoint paths between them. We know
that deleting some set Xof at most 2k−1edges should disconnect sandt. For any i∈[r], we call the graph
Gigood if it samples the edge (s,t)and does not sample any edge from X. See Figure 5 for an illustration.
Gi∗
t s
Xe
S T
Figure 5: An illustration of a good graph Gi∗wherein the edge e= (s,t)is sampled and all the edges in set Xare
not. Thus, none of the s-tpaths, except for the edge e, exist in Gi∗. Therefore, the spanning forest Ti∗necessarily
contains the edge e= (s,t).
We have,
Pr[Giis good]≥1/k·(1−1/k)2k−1≥1/8k. (ask≥2so(1−1/k)2k−1≥(1/2)3)
Given the independence of choices of Gifori∈[r], we have,
Pr[NoGiis good]≤(1−1/8k)r≤exp(−200klnn/8k) =n−25.
Therefore, there is a graph Gi∗fori∗∈[r]where(s,t)is sampled but Xis not (see Figure 5 ). This
means that the spanning forest Ti∗has to contain the edge (s,t)as there is no other path between sandt
(we have effectively “deleted” Xby not sampling it). Thus, the edge (s,t)belongs to Hwith probability at
least1−n−25. A union bound over all possible pairs s,t∈Gconcludes the proof.
33The SGT Streaming Algorithm We present our single pass SGT streaming algorithm for k-edge-connectivity
in this section. The parameter for SGT streaming is αi.e. the frequencies are bounded between −αandα.
We note that the /tildewideO(·)notation will hide lognandloglogαfactors. The algorithm outputs a certiﬁcate of
k-edge-connectivity for the input graph at the end of the stre am. Thus, by the deﬁnition of the certiﬁcate,
to know whether or not the input graph is k-edge-connected, it sufﬁces to test if the certiﬁcate is k-edge-
connected, which can be done at the end of the stream using any ofﬂine algorithm. Consider the following
theorem:
Theorem 12. There is a randomized SGT streaming algorithm that given an i ntegerk≥1before the
stream and a graph G= (V,E)in the stream, outputs a certiﬁcate Hofk-edge-connectivity of Gwith high
probability using /tildewideO(kn)bits of space.
This algorithm is just an implementation of Algorithm 4 in SGT streams. We ﬁx the edge sets Eiin
Algorithm 4 before the stream so the only thing we need to specify is how we compute the spanning forests
during the stream. We compute a spanning forest TiofGiin the stream using the dynamic streaming
algorithm in Fact 3.13 with strong ℓ0-samplers ( Section 5.1.2 ). After the stream, we output the certiﬁcate
H. This completes the description of the streaming algorithm .
We start by bounding the space of this algorithm.
Lemma 5.22. This algorithm uses /tildewideO(kn)bits of space.
Proof. During the stream, we run a spanning forest algorithm for eac h graphGifori∈[r]. The algorithm
ofFact 3.13 with strong ℓ0-samplers takes at most /tildewideO(n)bits of space. So the total space taken is /tildewideO(r·n) =
/tildewideO(kn)bits.
We are now ready to prove Theorem 12 .
Proof of Theorem 12 .ByLemma 5.22 , this algorithm uses /tildewideO(kn)bits of space. The algorithm is also cor-
rect with high probability by Theorem 11 . Moreover, none of the spanning forest algorithms of Fact 3.13 fail
with high probability (by a union bound over the failure prob abilities of the rspanning forest algorithms).
The strong ℓ0-samplers work in the SGT model because they can handle large values and they do not
distinguish between different non-zero values (even negat ive values). Also, adding the samplers for the
neighborhood of vertices in a component gives a sampler for t he edges going out of the component because
the internal edges cancel out (similar to traditional ℓ0-samplers). Finally, we do not subtract edges from
samplers to delete edges because to delete an edge, we need to know the exact frequency of the edge (this
was the problem with the original dynamic streaming algorit hm for edge connectivity [ AGM12 ]). Thus,
the streaming algorithm uses /tildewideO(kn)bits of space and, by union bound, with high probability outp uts a
certiﬁcate of k-edge-connectivity.
Note that the number of random bits used is more than the space bound. But we can ﬁx this by using
Nisan’s pseudorandom generator ( Fact 3.8 ). Using this increases the space by a factor of O(logn)and
makes the true randomness needed ﬁt in the space bound.
We also note that using the strong ℓ0-samplers we get a /tildewideO(n)space algorithm for connectivity and a
/tildewideO(kn)space algorithm for k-vertex-connectivity in the SGT streaming model.
346 Annotated Streaming Schemes for Dynamic Graph Streams
6.1 The Layering Lemma
In this subsection, we prove some simple properties of k-connected graphs and prove important lemmas
called layering lemmas for vertex and edge connectivity.
6.1.1 Properties of k-connected graphs
Claim 6.1. LetGbek-vertex-connected. Consider a new vertex vand attach it to ≥karbitrary vertices of
Gand call this new graph G′. ThenG′isk-vertex-connected.
Proof. Consider a vertex cut Xof size at most k−1.Xcannot disconnect any pair of vertices in Gsince
Gisk-vertex-connected. If vis isolated on one side of the cut then it must have a neighbor o n the other side
sinceXhas at most k−1vertices and vhas≥kneighbors.
Claim 6.2. LetG= (V,E)be a graph and let T⊆Vbe a set of vertices. We know that there are at least k
vertex-disjoint (edge-disjoint) paths from every vertex o fTto a special vertex t/\⌉}atio\slash∈T. If a vertex v/\⌉}atio\slash∈T∪{t}
haskvertex-disjoint (edge-disjoint) paths to Tthen there are kvertex-disjoint (edge-disjoint) paths between
vandt.
Proof. Consider any vertex cut Xof size at most k−1. We will show that vandtare connected after
deletingX.Xhas at most k−1vertices so there is a path PfromvtoTthat has no vertices of X. Let
t′∈Tbe the vertex path Pends on. We know that there are kvertex-disjoint paths between t′andt(by
assumption) thus after deleting Xthere is at least one path that has no vertices of X. This means that after
deletingXthere is a path from vtotviat′implying that there are kvertex-disjoint paths between vandt.
Claim 6.3. LetG= (V,E)be a graph and let Xbe a ﬁxed minimum vertex cut of G. If there is a vertex
t∈V−X, such that there are kvertex-disjoint paths from ttovfor allv∈V−{t}thenGisk-vertex-
connected (in other words |X| ≥k).
Proof. Assume towards a contradiction that the vertex cut Xhas size at most k−1. LetTbe a connected
component containing tafterXis deleted and let S:=V−X−T. Consider an arbitrary vertex sinS. We
know that there are kvertex disjoint paths between sandt. So deleting k−1vertices cannot disconnect v
andti, giving us a contradiction.
Corollary 6.4. LetG= (V,E)be a graph and let t1,t2,...,tk∈Vbe ﬁxed vertices. If for all i,Ghask
vertex-disjoint paths from titovfor allv∈V−{ti}thenGisk-vertex-connected.
Proof. Assume towards a contradiction that there is a vertex cut Xof size at most k−1that when deleted
disconnects the graph. There is a tithat is not in Xsince there are kspecial vertices and |X| ≤k−1.
Applying Claim 6.3 withXandtiimplies that |X| ≥k, giving us a contradiction. Thus, Gisk-vertex-
connected.
6.1.2 The Layering Lemma
In this subsection, we prove our layering lemmas for vertex a nd edge connectivity that will be useful in our
algorithms. We will show complete proofs for vertex-connec tivity and then only mention the differences
for edge-connectivity because the proofs are very similar. Consider the following lemmas that show short
proofs for k disjoint paths from a ﬁxed vertex to all other ver tices.
35Lemma 6.5. LetG= (V,E)be ak-vertex-connected graph, and let t∈Vbe an arbitrary vertex. There is
a/tildewideO(kn)size proof which shows that there are kvertex-disjoint paths from ttovfor allv∈V−{t}.
Lemma 6.6. LetG= (V,E)be ak-edge-connected graph, and let t∈Vbe an arbitrary vertex. There is
a/tildewideO(k2n)size proof which shows that there are kedge-disjoint paths from ttovfor allv∈V−{t}.
We will show that a short proof exists using the probabilisti c method. We ﬁrst set up the structure of
the proof. Note that we will write disjoint paths without spe cifying edge-disjoint or vertex-disjoint to mean
either of those because the layering structure for both is th e same. We want a proof that shows that the
special vertex thaskdisjoint paths to all vertices in V− {t}. The idea is to ﬁrst build a set of vertices
T0and show that every vertex in T0haskdisjoint paths to t. The next step is to inductively build sets
T1,T2,...Tℓand show that every vertex in Tihaskdisjoint paths to the set Ti−1. Using Claim 6.2 , this
shows that every vertex in Tihaskdisjoint paths to t(since every vertex in Ti−1haskdisjoint paths to t).
We keep doing this till we cover all the vertices using the set sTiand thus, everyone has kdisjoint paths to
t. This proves the correctness of Lemma 6.5 andLemma 6.6 .
We now show how these sets are constructed and bound the proof size. Let ℓ:= log(n/k). Fori∈
[0,ℓ], letTL
i,TR
ibe the sets where every vertex is independently sampled with probability pi:=k
n·2i.
Ti=TL
i∪TR
i. Note that we sample all vertices in Tℓ, so we cover all the vertices. Also, note that it is okay
if a vertex is sampled in multiple Ti’s. The expected size of Tiis2i+1kfor alli∈[0,ℓ]. We will now show
that for any vertex, the proof for kdisjoint paths to Tiis small in expectation.
Claim 6.7. For any vertex vthe proof for kdisjoint paths to Titakes size at mostn
2iwords in expectation.
Proof. Consider the vertex vand itskdisjoint paths P1,P2,...PktoTL
i(this exists because the graph is k-
connected). For any path Pj, we truncate it at the ﬁrst occurrence of a vertex from TR
i(since we want paths
toTi=TL
i∪TR
i). We now use the randomness of TR
i. Every vertex on Pjis independently sampled in TR
i
with probability pi=k
n·2i. Thus, in expectation, the truncated length of Pjis at most1
pi=n
k·2i. Therefore,
in expectation, the kdisjoint paths to Titogether have size at mostn
2i(by linearity of expectation).
This means that in expectation, the total proof size for k-vertex-connectivity is O(knlog(n/k))words.
Claim 6.8. The expected total proof size for k-vertex-connectivity is O(knlog(n/k))words.
Proof. The proof of kvertex-disjoint paths for a ﬁxed vertex in T0takes size at most O(n)words because
the summed length of all paths is O(n)(any vertex belongs to at most one vertex-disjoint path). Th is gives
a total expected size of O(kn)words for all vertices in T0. The proof for vertices in Ti+1takes size at most
n
2i(byClaim 6.7 ) which gives a total expected size of 2i+2k·n
2i= 4knwords for all vertices in Ti+1. We
haveℓ= log(n/k)setsTiimplying the claim.
Claim 6.9. The expected total proof size for k-edge-connectivity is O(k2nlog(n/k))words.
Proof. The only difference from the proof of Claim 6.8 is that the proof for vertices in T0takes size at most
O(kn)since each path can be of size at most n. This happens because edge-disjoint paths can use the same
vertices. This gives us an overall proof size of O(k2nlog(n/k))words.
If we can show that vertices T0havekedge-disjoint paths to tin smaller space then we can improve the
overall proof size (since this is the main bottleneck). For i nstance, if the graph has a subgraph on O(k)ver-
tices that is k-edge-connected then that set could be T0and the overall proof size would be O(knlog(n/k))
(this would increase the veriﬁcation space by an additive O(k2)words).
36Proof of Lemmas 6.5 and6.6.We have proved the correctness and the size bounds in expecta tion. There
must be some random string that achieves a proof size of at mos t the expected size (by deﬁnition) imply-
ing that there exists a proof of size O(knlog(n/k))words for k-vertex-connectivity and a proof of size
O(k2nlog(n/k))words for k-edge-connectivity (which an all powerful prover can ﬁnd). Thus, the prover
sends this proof to the veriﬁer.
We now show that the prover can send some auxiliary informati on so that the veriﬁer can verify the
proof.
Claim 6.10. The layering proof of Lemma 6.5 fork-vertex-connectivity can be veriﬁed using a [kn+h,v]-
scheme for any h,vsuch that h·v=n2.
Proof. The prover sends kvertex-disjoint paths for each vertex using the layering id ea mentioned above
(Lemma 6.5 ). There are three things that need to be veriﬁed. First, all t he edges that the prover sends should
be a part of the input graph. Second, the edges sent by the prov er should form paths. Finally, the paths for a
vertex should be vertex disjoint.
The prover sends a list of all edges used in the proof along wit h their multiplicities in /tildewideO(kn)space. It
is easy to do a subset check for the edges (ignoring multiplic ities) using an [h,v]-scheme since there are at
mostn2edges ( Fact 3.10 ). The problem now is to check if the prover was truthful about the multiplicities,
which can be done using the ℓ0-sampler trick using /tildewideO(1)space ( Proposition 3.14 ). The veriﬁer can maintain
anℓ0-sampler where he inserts all edges along with their multipl icities when they are provided upfront. He
then deletes all edges used in the proof of kvertex-disjoint paths for each vertex. Finally, he checks w hether
the sampler is empty. If it is not then the two sets of edges are not the same and thus, the veriﬁer catches the
lying prover. The probability of failure is at most 1−1/poly(n) .
The prover will send the edges of the paths one path at a time, s o it is easy to verify that the edges form a
path. Finally, we need to verify that the paths for every vert ex are vertex disjoint. For this, the prover sends
the vertices he is going to use in the proof upfront in increas ing order. The veriﬁer can verify this in /tildewideO(1)
space by just checking the increasing order. The problem now is to check if the prover lied so we can run
an equality check on the stream of vertices sent upfront and t he vertices used in the proof. This can be done
using the ℓ0-sampler trick in /tildewideO(1)veriﬁcation space ( Proposition 3.14 ). We have to do this for all vertices
so the worry is that the proof size or veriﬁcation space might blow up. Since the auxiliary information is
just repeating the vertices used in the proof in sorted order , adding this auxiliary information can at most
double the space used. Also, the space on the veriﬁer side is /tildewideO(1)words for each vertex, but this space can
be reused implying /tildewideO(1)words of veriﬁcation space for the entire disjointness chec k.
Therefore, the proof along with the auxiliary information t akes size /tildewideO(kn) +/tildewideO(h)bits and can be
veriﬁed in /tildewideO(v)+/tildewideO(1)bits of space, proving the [kn+h,v]-scheme.
Claim 6.11. The layering proof of Lemma 6.6 for edge-connectivity can be veriﬁed using a [k2n+h,v]-
scheme for any h,vsuch that h·v=n2.
The proof is almost identical with the only difference being that the proof for k-edge-connectivity is of
size/tildewideO(k2n)opposed to /tildewideO(kn)fork-vertex-connectivity.
Corollary 6.12. LetG= (V,E)be ak-vertex-connected graph and let t1,t2,...,tr∈Vbe arbitrary
distinct vertices. There is a [r·(kn+h),v]-scheme for all h,vsuch that h·v=n2, which shows that for
alli∈[r]there are kvertex-disjoint paths from titovfor allv∈V−{ti}.
Proof. If the prover repeats Claim 6.10 rtimes and the veriﬁer reuses his space then the proof size blo ws up
by a factor of rbut we only get an additional rwords in the veriﬁcation space. Once the proof for a vertex
37has been veriﬁed, the memory can be emptied and reused becaus e the veriﬁer only has to remember that the
proof has been veriﬁed for that particular vertex. So the ver iﬁer just remembers the vertices t1,t2,...,tr
and checks if they are distinct. But the distinctness check c an be done more efﬁciently.
The veriﬁer keeps a counter which he increments after he has v eriﬁed the proof for a vertex. After
the entire proof is sent the veriﬁer checks if the counter rea chedr. The only thing left to do is check the
distinctness. In parallel, the veriﬁer runs an [h,v]-scheme ( h·v≥n) for duplicate check ( Fact 3.11 ). Thus
the additional space usage is only /tildewideO(1)+/tildewideO(v)bits.
We now show that Lemma 6.5 andClaim 6.10 work even when tis a set of vertices (of size at least k)
instead of a single vertex.
Corollary 6.13. LetG= (V,E)be ak-vertex-connected graph and let T⊆Vbe an arbitrary set of
vertices with |T| ≥k. There is a [kn+h,v]-scheme for any h,vsuch that h·v=n2, which shows that
there are kvertex-disjoint paths from the set Ttovfor allv∈V−T.
Proof. Create a new graph G′by introducing a new vertex tand connecting it to all vertices in T. We know
byClaim 6.1 thatG′isk-vertex-connected. We can now apply Lemma 6.5 andClaim 6.10 for vertex tand
this gives us a proof of kvertex-disjoint paths from tto all vertices in V−{t}.
Letvbe a vertex in V−T.vhaskvertex-disjoint paths to t. The last edges of all these paths are from
N(t) =Ttotimplying that vhaskvertex-disjoint paths to the set T.
We get a similar corollary for k-edge-connectivity.
Corollary 6.14. LetG= (V,E)be ak-edge-connected graph and let T⊆Vbe an arbitrary set of vertices
with|T| ≥k. There is a [k2n+h,v]-scheme for any h,vsuch that h·v=n2, which shows that there are
kedge-disjoint paths from the set Ttovfor allv∈V−T.
6.2 Vertex Connectivity Schemes
In this section, we discuss schemes for k-vertex-connectivity.
Theorem 5. Under dynamic graph streams on n-node graphs, there exists a [k·(h+kn),v]-scheme for
k-vertex-connectivity for any h,vsuch that h·v=n2. In particular, under such streams, the problem has
non-trivial annotated streaming schemes with total cost /tildewideO(k2n).
We start by showing a very simple [n2k,n]-scheme.
6.2.1 Simple Algorithm
Assume that the graph G= (V,E)isk-vertex-connected. The simple algorithm is to ﬁx kspecial vertices
t1,t2,...tkand show that all other vertices have kvertex-disjoint paths to each tifori∈[k]. This is enough
to show that the graph is k-vertex-connected (by Corollary 6.4 )
We know that showing kvertex-disjoint paths between two vertices takes O(n)proof size (any vertex
can belong to at most one vertex-disjoint path). We can check if the edges used in the proof belong to the
graph using an [n,n]-scheme ( Fact 3.10 ). Thus showing that all vertices have kvertex-disjoint paths to each
tihas a[kn2,n]-scheme.
If the graph is not k-vertex-connected then the prover can send the vertex cut Xalong with a connected
component Sthat is formed after deleting Xin/tildewideO(n)space. The veriﬁer then has to check whether there are
any edges between SandT:=V−X−S. So the only allowed edges are within S, withinTor incident
onX. The veriﬁer constructs a graph G′in a streaming fashion with all such edges and then checks if t he
38edges in input graph are a subset of G′. This can be done using an [h,v]-scheme for subset check for any
h,vsuch that h·v=n2(Fact 3.10 ). We use a [kn,n/k]-scheme to conclude the simple scheme.
We now improve this algorithm using the layering lemma ( Lemma 6.5 ) and give a [k·(h+kn),v]-
scheme.
6.2.2 Layering Algorithm
If the graph G= (V,E)is notk-vertex-connected, then we can use the proof of the simple al gorithm which
has an[n+h,v]-scheme. In the other case, the issue with the simple algorit hm was that the proofs for all
the vertices were of size O(n). The goal would be to reduce the proof sizes for some vertices .
Proof of Theorem 5 .Fixkarbitrary vertices t1,t2,...,tk. Use Corollary 6.12 to get a proof of kvertex-
disjoint paths from tito every vertex in V− {ti}for alli∈[k]. Thus, the proof size for all titogether is
/tildewideO(k·(h+kn))words and can be veriﬁed using /tildewideO(v)space for any h,vsuch that h·v=n2. This is a valid
proof by Corollary 6.4 which shows that Gisk-vertex-connected. Thus, we get a [k·(h+kn),v]-scheme
fork-vertex-connectivity for any h,vsuch that h·v=n2, proving Theorem 5 .
Notice that the product of the proof size and the veriﬁcation space iskn2(whenh≥kn) which seems
suboptimal. There are two relaxations that can drop this ext ra factor of k. We show them in the next two
subsections.
6.2.3 Distinguishing between kand2kvertex-connectivity
In this subsection, we give a [kn+h,v]-scheme for any h,v such that h·v=n2, for distinguishing
between vertex-connectivity < k and≥2k. This is the promised-gap k-vertex-connectivity problem with
ε= 1[AS23 ,GMT15 ].
Lemma 6.15. Under dynamic graph streams on n-node graphs, there exists an [kn+h,v]-scheme for
distinguishing between vertex-connectivity < kand≥2k, for anyh,vsuch that h·v=n2.
Proof. If the graph G= (V,E)is notk-vertex-connected we can use the [n+h,v]-scheme of the simple
algorithm where h·v=n2.
If the graph G= (V,E)is2k-vertex-connected then we ﬁx two disjoint sets TLandTRcontaining 2k
arbitrary vertices each. We use Corollary 6.13 to show2kvertex-disjoint paths from every vertex in V−TL
to the set TL. This can be done using a [kn+h,v]-scheme for any h,vsuch that h·v=n2. We do the
same for TR. This is enough to show that Gis at least k-vertex-connected ( Claim 6.16 ) implying that Gis
2k-vertex-connected (promise).
Claim 6.16. The proof shows that Gis at least k-vertex-connected.
Proof. Assume towards a contradiction that there is a vertex cut Xof size< k. We will show that all the
vertices are connected after deleting Ximplying that Gis at least k-vertex-connected.
Consider two arbitrary vertices u,v∈TL. The proof for TRshows that each of u,vhave2kvertex-
disjoint paths to TR.Xhas at most k−1vertices so each of u,vreach at least k+1vertices in TRafter
deletingX. By the pigeonhole principle there is a vertex t∈TRwhich both uandvcan reach implying
that there is a path between uandvafter deleting X. Thus, any pair of vertices in TLare connected after X
is deleted.
Consider any arbitrary vertex s∈V−TL.shas2kvertex-disjoint paths to TLso after deleting X
there is a vertex u∈TLthat it can reach. Thus, that after Xis deleted, all vertices can reach TLandTLis
connected implying that G−Xis connected giving a contradiction.
396.2.4 A scheme in the AM model
In this subsection, we give a [kn+h,v]-scheme for k-vertex-connectivity using public randomness and
achieve a smooth tradeoff too (similar to the promised-gap k-vertex-connectivity problem). This is the AM
model in stream veriﬁcation.
Lemma 6.17. Under dynamic graph streams on n-node graphs, there exists an [kn+h,v]-AM-scheme for
k-vertex-connectivity for any h,vsuch that h·v=n2.
Proof. If the graph G= (V,E)is notk-vertex-connected we can use the [n+h,v]-scheme of the simple
algorithm where h·v=n2.
In the other case, we ﬁx Xas the lexicographically ﬁrst minimum vertex cut (we do not k nowXbut it
is ﬁxed). The prover now samples ℓ= 2lognverticest1,t2,...,tℓuniformly at random using the public
randomness. Use Corollary 6.12 to get a proof of kvertex-disjoint paths from tito every vertex in V−{ti}
for alli∈[ℓ]. This gives a [kn+h,v]-scheme.
We now prove the correctness of this scheme. If |X| ≥2k, then we can use the proof of Lemma 6.15 .
Thus,|X|<2kimplying V−XhasΩ(n)vertices (assuming k <0.49n). This means that with high
probability, there is an i∗∈[ℓ]such that ti∗∈V−X.Claim 6.3 shows that the graph is k-vertex-connected.
This concludes the proof, and we have shown that the graph is k-vertex-connected using a [kn+h,v]-scheme
for anyh,vsuch that h·v=n2.
6.3 Edge Connectivity Schemes
In this section, we discuss algorithms for k-edge-connectivity.
Theorem 6. Under dynamic graph streams on n-node graphs, there exists a [k2n+h,v]-scheme for k-edge-
connectivity for any h,vsuch that h·v=n2. In particular, under such streams, the problem has non-tri vial
annotated streaming schemes with total cost /tildewideO(k2n).
Theorem 7. Under dynamic graph streams on n-node graphs, there exists an [n,n]-scheme for k-edge-
connectivity (for any k). In particular, under such streams, the problem has non-tr ivial annotated streaming
schemes with total cost /tildewideO(n).
6.3.1 Showing the graph is not k-edge-connected
Consider the case where the edge connectivity is < k. The prover sends the k−1edges whose deletion
disconnects the graph and also sends one side Sof this cut. The veriﬁer ﬁrst checks if the edges the prover
sent were indeed part of the stream by running an [h,v]-scheme for subset check ( Fact 3.10 ) for any h,v
such that h,v=n2. The veriﬁer also has to check that there are no other edges be tweenSandT:=V−S.
So the only allowed edges are within S, withinTor thek−1edges sent by the prover. The veriﬁer constructs
a graphG′in a streaming fashion with all such edges and then checks if t he edges in input graph are a subset
ofG′. This can be done using an [h,v]-scheme for subset check for any h,vsuch that h·v=n2(Fact 3.10 ).
This gives an [n+h,v]-scheme.
6.3.2[n,n]-scheme for k-edge-connectivity
We now give the algorithm for when the edge connectivity is ≥k. We give a scheme independent of k
that works for any k(this is basically solving minimum-cut). The idea is to simu late the 2-pass streaming
algorithm for minimum-cut implied by [ RSW18 ].
Proof of Theorem 7 .The veriﬁer when looking at the stream computes a 1+εcut sparsiﬁer of the graph for
ε= 0.01and stores all vertex degrees. This can be done in space /tildewideO(n/ε2) =/tildewideO(n)[AGM12 ].
40The veriﬁer then ﬁnds all the 1+εapproximate mincuts using the cut sparsiﬁer. Compress all v ertices
that are on the same side of all of these cuts into supernodes. This graph of supernodes preserves all small
cuts. The prover then sends the edges that go between the supe rnodes. [ RSW18 ] proves that there are only
O(n)edges between the supernodes. So the veriﬁer can store all of these edges and compute the minimum
cut out of all these cuts. The veriﬁer compares the size of thi s minimum-cut to the minimum degree and
outputs the smaller of the two thus giving the exact mincut.
The veriﬁer also needs to run a subset check ( Fact 3.10 ) to check whether the edges the prover sent
belong to the graph. This can be done using an [n,n]-scheme. Note that, the prover does not have to send
all edges; just enough to make all cuts of size ≥kso it is okay if the prover does not send all edges (thus a
subset check is enough).
6.3.3 Layering Algorithm
If the graph G= (V,E)is notk-edge-connected, then we can use the proof of the simple algo rithm which
has an[n+h,v]-scheme.
Proof of Theorem 6 .Fix an arbitrary vertex t. Use Claim 6.11 to get a proof of kedge-disjoint paths from t
to every vertex in V−{t}. Thus, the proof size is /tildewideO(h+k2n)words and can be veriﬁed using /tildewideO(v)space
for anyh,vsuch that h·v=n2. This is a valid proof which shows that Gisk-edge-connected. Say Ghas
a cutSof size at most k−1. LetT:=V−Sbe the other side of the cut containing t(wlog). There is a
vertexs∈Sthat haskedge-disjoint paths to tgiving a contradiction. Thus, we get a [h+k2n,v]-scheme
fork-edge-connectivity for any h,vsuch that h·v=n2.
7 Annotated Streaming Schemes for SGT Streams
Thek-connectivity algorithms for dynamic streams do not work fo r SGT streams because the veriﬁcation
fails when the input graph can have large frequencies for the edges. Also, the frequencies can be negative. So
the proof using the layering lemma remains the same but the au xiliary information and veriﬁcation changes.
We prove the following algorithm for k-connectivity in SGT streams with parameter α:
Lemma 7.1. Under SGT streams with parameter α, there exists a [n2logα+k2n,1]-scheme for k-vertex-
connectivity and k-edge-connectivity.
Proof. Fork-vertex-connectivity ﬁx karbitrary vertices t1,t2,...,tk. Use Corollary 6.12 to get a proof of
kvertex-disjoint paths from tito every vertex in V− {ti}for alli∈[k]. Fork-edge-connectivity ﬁx a
vertextand use Lemma 6.6 to et a proof for kedge-disjoint paths from tto every vertex in V−{t}. Thus,
the proof sizes are /tildewideO(k2n)words.
We now describe how the veriﬁcation works. There are three th ings that need to be veriﬁed. First, all
the edges that the prover sends should be a part of the input gr aph. Second, the edges sent by the prover
should form paths. Third, the paths for a vertex should be ver tex (edge) disjoint.
We can verify the second and third case like we did for dynamic streams. The prover will send the edges
of the paths one path at a time, so it is easy to verify that the e dges form a path. To verify the disjoint paths
the prover sends the vertices (edges) he is going to use in the proof in sorted order and then sends the proof.
This only increases the proof size by a constant factor. It is easy to verify that the vertices (edges) arriving in
sorted order are distinct in /tildewideO(1)space. The only thing left to do is check if the vertices (edge s) sent upfront
are the same as the ones used in the proof of disjoint paths. We do this by running an equality check using
theℓ0-sampler trick using /tildewideO(1)space ( Proposition 3.14 ). When we get the vertices upfront we add them to
anℓ0-sampler and when we see them in the proof we subtract them fro m the sampler. If there is nothing left
41in the sampler in the end, then the two multi-sets of vertices are identical. Since the ﬁrst one had distinct
elements, so did the second one. The blow-up in proof size is a t most a factor of 2because the auxiliary
information just contains the vertices used in the proof. Al so, the space on the veriﬁer side is /tildewideO(1)words
for each vertex, but this space can be reused and thus, it ﬁts i n our budget of /tildewideO(1)words.
We now come to the hardest part which is verifying that the edg es used in the proof indeed belong to the
input graph. The prover initially sends a list of all edges of the input graph along with their multiplicities
sorted by sign (ﬁrst sends all the positive frequency edges a nd then the negative frequency edges). For
technical reasons, the prover scales the multiplicities by n2. It is easy to do a multi-set equality check for
these edges with multiplicities sent upfront and the edges f rom the input stream using the ℓ0-sampler trick
in/tildewideO(1)veriﬁcation space ( Proposition 3.14 ).
In parallel, we create a sampler for the positive edges and an other for the negative edges and insert the
edges the prover sent upfront into the appropriate sampler a ccording to the sign. During the proof, we ask
the prover to also mention the sign of each edge and we subtrac t it from the appropriate sampler. This
increases the proof size by a constant factor. After the proo f, the prover sends a list of all the remaining
edges i.e. edges not used in the proof along with their residu al multiplicities (the residual multiplicities take
the scaling by n2into account). We use ℓ0-sampler trick ( Proposition 3.14 ) to check the equality of the
multi-sets, the set of positive edges send upfront and the po sitive edges used in the proof plus the residual
positive edges using /tildewideO(1)space. We do the same for the negative edges.
The correctness is as follows. The prover cannot lie about th e signs or multiplicities when the edges
are sent upfront because we run an equality check with the inp ut stream. If the prover ever lies about a
sign during the proof (or in while sending the residual edges ) then the edge gets subtracted from the wrong
sampler. This sampler has a negative frequency on the coordi nate corresponding to that edge which can only
decrease later (because we are only subtracting edges) impl ying that the sampler check will fail.
If the prover lies about the multiplicities in the residual e dges then the equality check will fail. Thus, we
just have two separate equality check problems. The scaling byn2ensures that an edge can be used multiple
times during the proof (it can be used at most kn≤n2times). Ignoring the residual multiplicities we are
just performing a subset check.
The space used by the veriﬁer is just /tildewideO(1)words. The proof size, ignoring the edges sent upfront and
the residual edges, is /tildewideO(k2n). The edges sent upfront and the residual edges take size O(n2log(n2α)) =
/tildewideO(n2logα). The probability of failure is at most 1/poly(n) (by union bounding over the polynomially
many failure probabilities of 1/poly(n) ). Therefore, the proof along with the auxiliary informatio n takes
size/tildewideO(n2logα+k2n)and can be veriﬁed in /tildewideO(1)space, proving the lemma.
Acknowledgements
We are extremely grateful to Sepehr Assadi for many helpful c onversations regarding the project. Prantar
Ghosh would also like to thank Amit Chakrabarti and Justin Th aler for insightful discussions. Finally, we
thank the anonymous reviewers of ITCS 2024 for their many det ailed comments and suggestions that helped
with improving the presentation of the paper.
42References
[Abl96] Farid Ablayev. Lower bounds for one-way probabilis tic communication complexity and their
application to space complexity. Theoretical Computer Science , 175(2):139–159, 1996. 15
[ADRV16] Amirali Abdullah, Samira Daruki, Chitradeep Dutt a Roy, and Suresh Venkatasubramanian.
Streaming veriﬁcation of graph properties. In Proc. 27th International Symposium on Algo-
rithms and Computation , pages 3:1–3:14, 2016. 6
[AGM12] Kook Jin Ahn, Sudipto Guha, and Andrew McGregor. Ana lyzing graph structure via linear
measurements. In Proc. 23rd Annual ACM-SIAM Symposium on Discrete Algorithm s, pages
459–467, 2012. 5,6,10,16,21,23,34,40
[AS23] Sepehr Assadi and Vihan Shah. Tight bounds for vertex connectivity in dynamic streams. In
Symposium on Simplicity in Algorithms (SOSA) , pages 213–227. SIAM, 2023. 5,6,10,11,23,
29,31,39
[AW08] Scott Aaronson and Avi Wigderson. Algebrization: A n ew barrier in complexity theory. In
Proc. 40th Annual ACM Symposium on the Theory of Computing , pages 731–740, 2008. 1,5
[BFS86] László Babai, Péter Frankl, and Janos Simon. Comple xity classes in communication complexity
theory. In Proc. 27th Annual IEEE Symposium on Foundations of Computer Science , pages
337–347, 1986. 1,5,12
[CCGT14] Amit Chakrabarti, Graham Cormode, Navin Goyal, an d Justin Thaler. Annotations for sparse
data streams. In Proc. 25th Annual ACM-SIAM Symposium on Discrete Algorithm s, pages
687–706, 2014. 1,2,4,6,7,8
[CCM09] Amit Chakrabarti, Graham Cormode, and Andrew McGre gor. Annotations in data streams. In
Proc. 36th International Colloquium on Automata, Language s and Programming , pages 222–
234, 2009. 1,2,14
[CCM+15] Amit Chakrabarti, Graham Cormode, Andrew McGregor, Jus tin Thaler, and Suresh Venkata-
subramanian. Veriﬁable stream computation and Arthur-Mer lin communication. In Proc. 30th
Annual IEEE Conference on Computational Complexity , pages 217–243, 2015. 6
[CCMT14] Amit Chakrabarti, Graham Cormode, Andrew McGrego r, and Justin Thaler. Annotations in
data streams. ACM Trans. Alg. , 11(1):Article 7, 2014. 1,2,5,6,7,16,19,20
[CDGH23] Graham Cormode, Marcel Dall’Agnol, Tom Gur, and Ch ris Hickey. Streaming zero-knowledge
proofs. CoRR , abs/2301.02161, 2023. 6
[CG19] Amit Chakrabarti and Prantar Ghosh. Streaming veriﬁ cation of graph computations via graph
structure. In Proc. 33rd International Workshop on Randomization and App roximation Tech-
niques in Computer Science , pages 70:1–70:20, 2019. 6
[CGT20] Amit Chakrabarti, Prantar Ghosh, and Justin Thaler . Streaming veriﬁcation for graph problems:
Optimal tradeoffs and nonlinear sketches. To appear in RANDOM , 2020. 1,6,16
[Che20] Lijie Chen. On the hardness of approximate and exact (bichromatic) maximum inner product.
Theory Comput. , 16:1–50, 2020. 5
43[CMT13] Graham Cormode, Michael Mitzenmacher, and Justin T haler. Streaming graph computations
with a helpful advisor. Algorithmica , 65(2):409–442, 2013. 6
[CTY11] Graham Cormode, Justin Thaler, and Ke Yi. Verifying computations with streaming interactive
proofs. Proc. VLDB Endowment , 5(1):25–36, 2011. 6
[DP09] Devdatt P Dubhashi and Alessandro Panconesi. Concentration of measure for the analysis
of randomized algorithms . Cambridge University Press, 2009. 15
[Gav21] Dmitry Gavinsky. The layer complexity of arthur-me rlin-like communication. Theory Comput. ,
17:1–28, 2021. 1,2
[Gho20] Prantar Ghosh. New veriﬁcation schemes for frequen cy-based functions on data streams. In
40th IARCS Annual Conference on Foundations of Software Tec hnology and Theoretical Com-
puter Science, FSTTCS 2020, December 14-18, 2020, BITS Pila ni, K K Birla Goa Campus,
Goa, India (Virtual Conference) , volume 182 of LIPIcs , pages 22:1–22:15. Schloss Dagstuhl -
Leibniz-Zentrum für Informatik, 2020. 6
[GMT15] Sudipto Guha, Andrew McGregor, and David Tench. Ver tex and hyperedge connectivity in
dynamic graph streams. In Proceedings of the 34th ACM SIGMOD-SIGACT-SIGAI Symposium
on Principles of Database Systems , pages 241–247, 2015. 6,39
[GR13] Tom Gur and Ran Raz. Arthur–Merlin streaming complex ity. In Proc. 40th International
Colloquium on Automata, Languages and Programming , pages 528–539, 2013. 6
[JW13] T. S. Jayram and David P. Woodruff. Optimal bounds for johnson-lindenstrauss transforms and
streaming problems with subconstant error. ACM Trans. Algorithms , 9(3):26:1–26:17, 2013. 6
[Kla03] Hartmut Klauck. Rectangle size bounds and threshol d covers in communication complexity. In
Proc. 18th Annual IEEE Conference on Computational Complex ity, pages 118–134, 2003. 5
[KN97] Eyal Kushilevitz and Noam Nisan. Communication Complexity . Cambridge University Press,
Cambridge, 1997. 15,16
[KP13] Hartmut Klauck and Ved Prakash. Streaming computati ons with a loquacious prover. In Proc.
4th Conference on Innovations in Theoretical Computer Scie nce, pages 305–320, 2013. 6
[KP14] Hartmut Klauck and Ved Prakash. An improved interact ive streaming algorithm for the distinct
elements problem. In Automata, Languages, and Programming - 41st International Colloquium
(ICALP) , volume 8572 of LNCS , pages 919–930, 2014. 6
[MR95] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms . Cambridge University
Press, 1995. 15
[Nis90] Noam Nisan. Pseudorandom generators for space-bou nded computation. In Proc. 22nd Annual
ACM Symposium on the Theory of Computing , pages 204–212, 1990. 16
[RSW18] Aviad Rubinstein, Tselil Schramm, and S. Matthew We inberg. Computing exact minimum cuts
without knowing the graph. In Anna R. Karlin, editor, 9th Innovations in Theoretical Com-
puter Science, ITCS 2018 , Leibniz International Proceedings in Informatics, LIPIc s, Germany,
January 2018. Schloss Dagstuhl- Leibniz-Zentrum fur Infor matik GmbH, Dagstuhl Publishing.
11,40,41
44[SW15] Xiaoming Sun and David P Woodruff. Tight bounds for gr aph problems in insertion streams. In
Approximation, Randomization, and Combinatorial Optimiz ation. Algorithms and Techniques
(APPROX/RANDOM 2015) . Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2015 .6
[Tha16a] Justin Thaler. Data stream veriﬁcation. In Encyclopedia of Algorithms , pages 494–499.
Springer Berlin Heidelberg, 2016. 6
[Tha16b] Justin Thaler. Semi-streaming algorithms for ann otated graph streams. In Proc. 43rd Interna-
tional Colloquium on Automata, Languages and Programming , pages 59:1–59:14, 2016. 2,4,
6,8,20,21
[Wes01] Douglas Brent West. Introduction to graph theory , volume 2. Prentice hall Upper Saddle
River, 2001. 16
[Yao79] Andrew C. Yao. Some complexity questions related to distributive computing. In Proc. 11th
Annual ACM Symposium on the Theory of Computing , pages 209–213, 1979. 12
45
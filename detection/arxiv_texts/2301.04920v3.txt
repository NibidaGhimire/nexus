On the Validity of Consensus (Extended Version)
Pierre Civit
Sorbonne University
FranceSeth Gilbert
NUS Singapore
SingaporeRachid Guerraoui
École Polytechnique Fédérale de
Lausanne (EPFL)
Switzerland
Jovan Komatovic
École Polytechnique Fédérale de
Lausanne (EPFL)
SwitzerlandManuel Vidigueira
École Polytechnique Fédérale de
Lausanne (EPFL)
Switzerland
ABSTRACT
The Byzantine consensus problem involves 𝑛processes, out of
which𝑡<𝑛could be faulty and behave arbitrarily. Three properties
characterize consensus: (1) termination, requiring correct (non-
faulty) processes to eventually reach a decision, (2) agreement,
preventing them from deciding different values, and (3) validity,
precluding “unreasonable” decisions. But, what is a reasonable
decision? Strong validity, a classical property, stipulates that, if all
correct processes propose the same value, only that value can be
decided. Weak validity, another established property, stipulates that,
if all processes are correct and they propose the same value, that
value must be decided. The space of possible validity properties is
vast. Yet, their impact on consensus algorithms remains unclear.
This paper addresses the question of which validity properties
allow Byzantine consensus to be solvable in a general partially
synchronous model, and at what cost. First, we determine the nec-
essary and sufficient conditions for a validity property to make the
consensus problem solvable; we say that such validity properties
aresolvable . Notably, we prove that, if 𝑛≤3𝑡, all solvable validity
properties are trivial (there exists an always-admissible decision).
Furthermore, we show that, with any non-trivial (and solvable)
validity property, consensus requires Ω(𝑡2)messages. This extends
the seminal Dolev-Reischuk bound, originally proven for strong
validity, to allnon-trivial validity properties. Lastly, we give a Byzan-
tine consensus algorithm, we call Universal , for anysolvable (and
non-trivial) validity property. Importantly, Universal incurs𝑂(𝑛2)
message complexity. Thus, together with our lower bound, Uni-
versal implies a fundamental result in partial synchrony: with
𝑡∈Ω(𝑛), the message complexity of all (non-trivial) consensus
variants is Θ(𝑛2).
CCS CONCEPTS
•Computing methodologies →Distributed algorithms .
KEYWORDS
Byzantine consensus, Solvability, Message complexity, Lower bound
1 INTRODUCTION
Consensus [ 62] is the cornerstone of state machine replication
(SMR) [ 1,9,10,25,58,59,69,74,92], as well as various distributed
algorithms [ 14,47,51,52]. Recently, it has received a lot of atten-
tion with the advent of blockchain systems [ 6,7,21,33,35,50,67].
The consensus problem is posed in a system of 𝑛processes, out ofwhich𝑡<𝑛can be faulty , and the rest correct . Each correct process
proposes a value, and consensus enables correct processes to de-
cide on a common value. In this paper, we consider Byzantine [ 62]
consensus, where faulty processes can behave arbitrarily. While
the exact definition of the problem might vary, two properties are
always present: (1) termination , requiring correct processes to even-
tually decide, and (2) agreement , preventing them from deciding
different values. It is not hard to devise an algorithm that satisfies
only these two properties: every correct process decides the same,
predetermined value. However, this algorithm is vacuous. To pre-
clude such trivial solutions and render consensus meaningful, an
additional property is required – validity – defining which decisions
are admissible.
The many faces of validity. The literature contains many flavors
of validity [ 2,5,28,29,35,46,57,71,88,89,93]. One of the most
studied properties is Strong Validity [5,28,35,57], stipulating that,
if all correct processes propose the same value, only that value can
be decided. Another common property is Weak Validity [28,29,93],
affirming that, if all processes are correct and propose the same
value, that value must be decided. While validity may appear as an
inconspicuous property, its exact definition has a big impact on our
understanding of consensus algorithms. For example, the seminal
Dolev-Reischuk bound [ 39] states that any solution to consensus
with Strong Validity incurs a quadratic number of messages; it was
recently proven that the bound is tight [ 28,64,75]. In contrast,
while there have been several improvements to the performance
of consensus with Weak Validity over the last 40 years [ 28,64,93],
the (tight) lower bound on message complexity remains unknown.
(Although the bound is conjectured to be the same as for Strong Va-
lidity , this has yet to be formally proven.) Many other fundamental
questions remain unanswered:
•What does it take for a specific validity property to make
consensus solvable?
•What are the (best) upper and lower bounds on the mes-
sage complexity of consensus with any specific validity
property?
•Is there a hierarchy of validity properties (e.g., a “strongest”
validity property)?
To the best of our knowledge, no in-depth study of the validity
property has ever been conducted, despite its importance and the
emerging interest from the research community [3, 31].
Contributions. We propose a precise mathematical formalism for
the analysis of validity properties. We define a validity property as
1arXiv:2301.04920v3  [cs.DC]  26 Jun 2023Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
a mapping from assignments of proposals into admissible decisions.
Although simple, our formalism enables us to determine the exact
impact of validity on the solvability and complexity of consensus
in the classical partially synchronous model [ 42], and answer the
aforementioned open questions. Namely, we provide the following
contributions:
•We classify all validity properties into solvable and unsolv-
able ones. (If a validity property makes consensus solvable,
we say that the property itself is solvable .) Specifically, for
𝑛≤3𝑡, we show that only trivial validity properties (for
which there exists an always-admissible decision) are solv-
able. In the case of 𝑛>3𝑡, we define the similarity condition ,
which we prove to be necessary and sufficient for a validity
property to be solvable.
•We prove that all non-trivial (and solvable) validity proper-
ties require Ω(𝑡2)exchanged messages. This result extends
the Dolev-Reischuk bound [ 39], proven only for Strong Va-
lidity , toall“reasonable” validity properties.
•Finally, we present Universal , a consensus algorithm for
all solvable (and non-trivial) validity properties. Assuming
a public-key infrastructure, Universal exchanges𝑂(𝑛2)
messages. Thus, together with our lower bound, Universal
implies a fundamental result in partial synchrony: given
𝑡∈Ω(𝑛), all (non-trivial) consensus variants have Θ(𝑛2)
message complexity. Figure 1 summarizes our findings.
trivial non-trivialsolvableValidity
properties  
Figure 1: Illustration of our results: (1) with 𝑛≤3𝑡, all solvable
validity properties are trivial; (2) the exact set of solvable validity
properties (as determined by our necessary and sufficient
conditions); (3) all non-trivial (and solvable) validity properties
require Ω(𝑡2)exchanged messages; (4) for any non-trivial (and
solvable) validity property, there exists a consensus algorithm with
𝑂(𝑛2)message complexity.
Technical overview. In our formalism, we use the notion of an
input configuration that denotes an assignment of proposals to
correct processes. For example,
(𝑃1,𝑣),(𝑃2,𝑣),(𝑃3,𝑣)
represents
an input configuration by which (1) only processes 𝑃1,𝑃2, and𝑃3
are correct, and (2) processes 𝑃1,𝑃2, and𝑃3propose𝑣.
First, we define a similarity relation between input configura-
tions: two input configurations are similar if and only if (1) they
have (at least) one process in common, and (2) for every commonprocess, the process’s proposal is identical in both input configura-
tions. For example, an input configuration 𝑐=
(𝑃1,0),(𝑃2,1)is
similar to𝑐′=
(𝑃1,0),(𝑃3,0)
, but not to
(𝑃1,0),(𝑃2,0)
. We ob-
serve that all similar input configurations must have an admissible
value in common; we call this canonical similarity . Let us illustrate
why a common admissible value must exist. Consider the afore-
mentioned similar input configurations 𝑐=
(𝑃1,0),(𝑃2,1)and
𝑐′=
(𝑃1,0),(𝑃3,0)
. If there is no common admissible value for 𝑐
and𝑐′, consensus cannot be solved: process 𝑃1cannot distinguish (1)
an execution in which 𝑃2is correct, and 𝑃3is faulty and silent, from
(2) an execution in which 𝑃2is faulty, but behaves correctly, and 𝑃3
is correct, but slow. Thus, 𝑃1cannot conclude whether it needs to
decide an admissible value for 𝑐or for𝑐′. Canonical similarity is a
critical intermediate result that we use extensively throughout the
paper (even if it does not directly imply any of our results).
In our proof of triviality with 𝑛≤3𝑡, we intertwine the classical
partitioning argument [ 63] with our canonical similarity result.
Namely, we show that, for any input configuration, there exists
an execution in which the same value 𝑥is decided, making 𝑥an
always-admissible value. For our lower bound, while following the
idea of the original proof [ 4,39], we rely on canonical similarity to
prove the bound for all solvable and non-trivial validity properties.
Finally, we design Universal by relying on vector consensus [ 34,
40,82,91], a problem in which processes agree on the proposals of
𝑛−𝑡processes: when a correct process decides a vector vecof𝑛−𝑡
proposals (from vector consensus), it decides from Universal the
common admissible value for all input configurations similar to vec.
For example, consider an execution which corresponds to an input
configuration 𝑐. If, in this execution, a correct process decides a
vector vecfrom vector consensus, it is guaranteed that vecis similar
to𝑐(the proposals of correct processes are identical in 𝑐and in
vec). Hence, deciding (from Universal ) the common admissible
value for all input configurations similar to vecguarantees that the
decided value is admissible according to 𝑐.
Roadmap. We provide an overview of related work in §2. In
§3, we specify the system model (§3.1), define the consensus prob-
lem (§3.2), describe our formalism for validity properties (§3.3),
and present canonical similarity (§3.4). We define the necessary
conditions for the solvability of validity properties in §4. In §5,
we prove a quadratic lower bound on message complexity for all
non-trivial (and solvable) validity properties (§5.1), and introduce
Universal , a general consensus algorithm for any solvable (and
non-trivial) validity property (§5.2). We conclude the paper in §6.
The appendix contains (1) omitted proofs and algorithms, and (2)
a proposal for how to extend our formalism to accommodate for
blockchain-specific validity properties.
2 RELATED WORK
Solvability of consensus. The consensus problem has been thor-
oughly investigated in a variety of system settings and failure mod-
els. It has been known (for long) that consensus can be solved in
a synchronous setting, both with crash [ 23,68,84] and arbitrary
failures [ 5,60,75,84,86]. In an asynchronous environment, how-
ever, consensus cannot be solved deterministically even if a single
process can fail, and it does so only by crashing; this is the seminal
FLP impossibility result [45].
2On the Validity of Consensus (Extended Version)
A traditional way of circumventing the FLP impossibility result
israndomization [8,11,12,43,66], where termination of consensus
is not ensured deterministically. Another well-established approach
to bypass the FLP impossibility is to strengthen the communication
model with partial synchrony [42]: the communication is asynchro-
nous until some unknown time, and then it becomes synchronous.
The last couple of decades have produced many partially synchro-
nous consensus algorithms [22, 25, 28, 29, 35, 42, 61, 64, 68, 93].
Another line of research has consisted in weakening the def-
inition of consensus to make it deterministically solvable under
asynchrony. In the condition-based approach [ 77], the specification
of consensus is relaxed to require termination only if the assignment
of proposals satisfies some predetermined conditions. The efficiency
of this elegant approach has been studied further in [ 79]. Moreover,
the approach is extended to the synchronous setting [ 78,94], as
well as to the 𝑘-set agreement problem [53, 80].
Solvability of general decision problems. A distributed decision
problem has been defined in [ 30,56,73] as a mapping from input
assignments to admissible decisions. Our validity formalism is of the
same nature, and it is inspired by the aforementioned specification
of decision problems.
The solvability of decision problems has been thoroughly stud-
ied in asynchronous, crash-prone settings. It was shown in [ 76]
that the FLP impossibility result [ 45] can be extended to many
decision problems. In [ 17], the authors defined the necessary and
sufficient conditions for a decision problem to be asynchronously
solvable with a single crash failure. The asynchronous solvability
of problems in which crash failures occur at the very beginning
of an execution was studied in [ 90]. The necessary and sufficient
conditions for a decision problem to be asynchronously solvable (as-
suming a crash-prone setting) in a randomized manner were given
in [27]. The topology-based approach on studying the solvability
of decision problems in asynchrony has proven to be extremely
effective, both for crash [ 54,55,85] and arbitrary failures [ 54,73].
Our results follow the same spirit as many of these approaches;
however, we study the deterministic solvability and complexity of
all consensus variants in a partially synchronous environment.
Validity of consensus. Various validity properties have been as-
sociated with the consensus problem (beyond the aforementioned
Strong Validity andWeak Validity ).Correct-Proposal Validity [46,88]
states that a value decided by a correct process must have been
proposed by a correct process. Median Validity [89] is a validity
property proposed in the context of synchronous consensus, re-
quiring the decision to be close to the median of the proposals of
correct processes. Interval Validity [71], on the other hand, requires
the decision to be close to the 𝑘-th smallest proposal of correct
processes. The advent of blockchain technologies has resurged the
concept of External Validity [22,24,93]. This property requires the
decided value to satisfy a predetermined predicate, typically assert-
ing whether the decided value follows the rules of a blockchain
system (e.g., no double-spending). (This paper considers a simple
formalism to express basic validity properties and derive our re-
sults. To express External Validity , which is out of the scope of the
paper, we propose an incomplete extension of our formalism in
Appendix C, and leave its realization for future work.) Convex-Hull
Validity , which states that the decision must belong to the convexhull of the proposals made by the correct processes, is employed
in approximate agreement [ 2,48,49,72]. We underline that the
approximate agreement problem is not covered in this paper since
the problem allows correct processes to disagree as long as their
decisions are “close” to each other. In our paper, we do study (in
a general manner) the utilization of Convex-Hull Validity in the
classical consensus problem (in which the correct processes are
required to “exactly” agree).
In interactive consistency [ 13,44,70], correct processes agree
on the proposals of all correct processes. Given that the problem
is impossible in a non-synchronous setting, a weaker variant has
been considered: vector consensus [ 15,34,40,41,82,91]. Here,
processes need to agree on a vector of proposals which does not
necessarily include the proposals of allcorrect processes. Inter-
active consistency and vector consensus can be seen as specific
consensus problems with a validity property requiring that, if a de-
cided vector contains a proposal 𝑣of a correct process, that correct
process has indeed proposed 𝑣. The design of Universal , our gen-
eral consensus algorithm for any solvable (and non-trivial) validity
property, demonstrates that any non-trivial flavor of consensus
which is solvable in partial synchrony can be solved using vector
consensus (see §5.2).
3 PRELIMINARIES
In this section, we present the computational model (§3.1), recall
the consensus problem (§3.2), formally define validity properties
(§3.3), and introduce canonical similarity (§3.4).
3.1 Computational Model
Processes. We consider a system Π={𝑃1,𝑃2,...,𝑃𝑛}of𝑛pro-
cesses; each process is a deterministic state machine. At most 𝑡
(0<𝑡<𝑛) processes can be faulty : those processes can exhibit
arbitrary behavior. A non-faulty process is said to be correct . Pro-
cesses communicate by exchanging messages over an authenticated
point-to-point network. The communication network is reliable : if
a correct process sends a message to a correct process, the message
is eventually received. Each process has its own local clock, and no
process can take infinitely many computational steps in finite time.
Executions. Given an algorithm A,execs(A) denotes the set of
all executions ofA. Furthermore, CorrA(E)denotes the set of
correct processes in an execution E∈ execs(A). We say that an
executionE∈execs(A) iscanonical if and only if no faulty process
takes any computational step in E; note that faulty processes do
not send any message in a canonical execution. Moreover, observe
that any execution Ewith CorrA(E)=Πis canonical.
Partial synchrony. We consider the standard partially synchro-
nous model [ 42]. For every execution of the system, there exists a
Global Stabilization Time (GST) and a positive duration 𝛿such that
message delays are bounded by 𝛿after GST. GST is not known to
the processes, whereas 𝛿is. We assume that all correct processes
start executing their local algorithm before or at GST. Local clocks
may drift arbitrarily before GST, but do not drift thereafter.
We remark that (almost) all results presented in the paper hold
even if𝛿is unknown. Namely, the classification of all validity prop-
erties remains the same: if a validity property is solvable (resp.,
3Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
unsolvable) with known 𝛿, then the validity property is solvable
(resp., unsolvable) with unknown 𝛿. Moreover, the quadratic lower
bound on the message complexity trivially extends to the model in
which𝛿is unknown. However, the question of whether the bound
is tight when 𝛿is unknown does remain open.
Cryptographic primitives. In one variant of the Universal al-
gorithm, we assume a public-key infrastructure (PKI). In fact, this
variant relies on a closed-box consensus algorithm which internally
utilizes a PKI. In a PKI, every process knows the public key of every
other process, and, when needed, processes sign messages using
digital signatures. We denote by ⟨𝑚⟩𝜎𝑖a message𝑚signed by the
process𝑃𝑖. Crucially, faulty processes cannot forge signatures of
correct processes.
Message complexity. LetAbe any algorithm and let E∈execs(A)
be any execution of A. The message complexity of Eis the number
of messages sent by correct processes during [GST,∞).
The message complexity ofAis defined as
max
E∈execs(A)
message complexity of E
.
3.2 Consensus
We denote byV𝐼the (potentially infinite) set of values processes can
propose, and byV𝑂the (potentially infinite) set of values processes
can decide. Consensus1exposes the following interface:
•request propose(𝑣∈V𝐼): a process proposes a value 𝑣.
•indication decide(𝑣′∈V𝑂): a process decides a value 𝑣′.
A correct process proposes exactly once, and it decides at most
once. Consensus requires the following properties:
•Termination: Every correct process eventually decides.
•Agreement: No two correct processes decide different val-
ues.
If the consensus problem was completely defined by Termination
andAgreement , a trivial solution would exist: processes decide on a
default value. Therefore, the specification of consensus additionally
includes a validity property, which connects the proposals of correct
processes to admissible decisions, precluding the aforementioned
trivial solutions.
3.3 Validity
In a nutshell, our specification of a validity property includes a set
of assignments of proposals to correct processes, and, for each such
assignment, a corresponding set of admissible decisions.
We start by defining a process-proposal pair as a pair(𝑃,𝑣), where
(1)𝑃∈Πis a process, and (2) 𝑣∈V𝐼is a proposal. Given a process-
proposal pair pp=(𝑃,𝑣),proposal(pp)=𝑣denotes the proposal
associated with pp.
Aninput configuration is a tuple
pp1,pp2,...,pp𝑥
of𝑥process-
proposal pairs, where (1) 𝑛−𝑡≤𝑥≤𝑛, and (2) every process-
proposal pair is associated with a distinct process. Intuitively, an
input configuration represents an assignment of proposals to cor-
rect processes. For example,
(𝑃1,𝑣),(𝑃2,𝑣),(𝑃3,𝑣),(𝑃4,𝑣),(𝑃5,𝑣)
is an input configuration describing an execution in which (1) only
processes𝑃1,𝑃2,𝑃3,𝑃4and𝑃5are correct, and (2) all of them pro-
pose the same value 𝑣.
1In the paper, we use “consensus” and “Byzantine consensus” interchangeably.We denote byIthe set of all input configurations. Furthermore,
for every𝑥∈[𝑛−𝑡,𝑛],I𝑥⊂I denotes the set of input config-
urations with exactly𝑥process-proposal pairs. For every input
configuration 𝑐∈I, we denote by 𝑐[𝑖]the process-proposal pair
associated with process 𝑃𝑖; if such a process-proposal pair does not
exist,𝑐[𝑖]=⊥. Lastly,𝜋(𝑐)={𝑃𝑖∈Π|𝑐[𝑖]≠⊥}denotes the set
of all processes included in 𝑐.
Given (1) an execution Eof an algorithmA, whereAexposes
thepropose(·)/decide(·)interface, and (2) an input configuration
𝑐∈I, we say thatEcorresponds to𝑐(input _conf(E)=𝑐) if and
only if (1)𝜋(𝑐)=CorrA(E), and (2) for every process 𝑃𝑖∈𝜋(𝑐),
𝑃𝑖’s proposal inEisproposal(𝑐[𝑖]).
Finally, we define a validity property valas a function val:I→
2V𝑂such that, for every input configuration 𝑐∈I,val(c)≠∅.
An algorithmA, whereAexposes the propose(·)/decide(·)in-
terface, satisfies a validity property valif and only if, in any ex-
ecutionE ∈ execs(A), no correct process decides a value 𝑣′∉
val input _conf(E). That is, an algorithm satisfies a validity prop-
erty if and only if correct processes decide only admissible values.
Traditional properties in our formalism. To illustrate the expres-
siveness of our formalism, we describe how it can be used for Strong
Validity ,Weak Validity andCorrect-Proposal Validity . For all of them,
V𝐼=V𝑂.Weak Validity can be expressed as
val(𝑐)=(
{𝑣},if(𝜋(𝑐)=Π)∧(∀𝑃𝑖∈𝜋(𝑐):proposal(𝑐[𝑖])=𝑣)
V𝑂,otherwise,
whereas Strong Validity can be expressed as
val(𝑐)=(
{𝑣},if∀𝑃𝑖∈𝜋(𝑐):proposal(𝑐[𝑖])=𝑣
V𝑂,otherwise.
Finally, Correct-Proposal Validity can be expressed as
val(𝑐)={𝑣|∃𝑃𝑖∈𝜋(𝑐):proposal(𝑐[𝑖])=𝑣}.
Consensus algorithms. An algorithmAsolves consensus with a
validity property valif and only if the following holds:
• A exposes the propose(·)/decide(·)interface, and
• A satisfies Termination ,Agreement andval.
Lastly, we define the notion of a solvable validity property.
Definition 1 (Solvable validity property) .We say that a validity
property valissolvable if and only if there exists an algorithm
which solves consensus with val.
3.4 Canonical Similarity
In this subsection, we introduce canonical similarity , a crucial in-
termediate result. In order to do so, we first establish an important
relation between input configurations, that of similarity .
Similarity. We define the similarity relation (“ ∼”) between input
configurations:
∀𝑐1,𝑐2∈I:𝑐1∼𝑐2⇐⇒
(𝜋(𝑐1)∩𝜋(𝑐2)≠∅)∧(∀𝑃𝑖∈𝜋(𝑐1)∩𝜋(𝑐2):𝑐1[𝑖]=𝑐2[𝑖]).
In other words, 𝑐1is similar to 𝑐2if and only if (1) 𝑐1and𝑐2have
(at least) one process in common, and (2) for every common process,
the process’s proposal is identical in both input configurations. For
4On the Validity of Consensus (Extended Version)
example, when 𝑛=3and𝑡=1,𝑐=
(𝑃1,0),(𝑃2,1),(𝑃3,0)
is simi-
lar to
(𝑃1,0),(𝑃3,0)
, whereas𝑐is not similar to
(𝑃1,0),(𝑃2,0)
.
Note that the similarity relation is symmetric (for every pair 𝑐1,𝑐2∈
I,𝑐1∼𝑐2⇔𝑐2∼𝑐1) and reflexive (for every 𝑐∈I,𝑐∼𝑐).
For every input configuration 𝑐∈I, we define sim(𝑐):
sim(𝑐)={𝑐′∈I|𝑐′∼𝑐}.
The result. LetAbe an algorithm which solves consensus with
some validity property val. Our canonical similarity result states
that, in any canonical execution which corresponds to some input
configuration 𝑐,Acan only decide a value which is admissible for
allinput configurations similar to 𝑐. Informally, the reason is that
correct processes cannot distinguish silent faulty processes from
slow correct ones.
Lemma 1 (Canonical similarity) .Letvalbe any solvable validity
property and letAbe any algorithm which solves the consensus
problem with val. LetE∈ execs(A) be any (potentially infinite)
canonical execution and let input _conf(E)=𝑐, for some input
configuration 𝑐∈I. If a value 𝑣′∈V𝑂is decided by a correct
process inE, then𝑣′∈Ñ
𝑐′∈sim(𝑐)val(𝑐′).
Proof. We prove the lemma by contradiction. Suppose that
𝑣′∉Ñ
𝑐′∈sim(𝑐)val(𝑐′). Hence, there exists an input configuration
𝑐′∈sim(𝑐)such that𝑣′∉val(𝑐′). IfEis infinite, letE𝑃←E .
Otherwise, letE𝑃denote any infinite continuation of Esuch that (1)
E𝑃is canonical, and (2) input _conf(E𝑃)=𝑐. Let𝑃be any process
such that𝑃∈𝜋(𝑐′)∩𝜋(𝑐); such a process exists as 𝑐′∼𝑐. AsA
satisfies Termination andAgreement ,E𝑃is an infinite execution,
and𝑃is correct inE𝑃,𝑃decides𝑣′inE𝑃. LetSdenote the set of
all processes which take a computational step in E𝑃until𝑃decides
𝑣′; note thatS⊆𝜋(𝑐)and𝑃∈S.
In the next step, we construct another execution E′∈execs(A)
such that input _conf(E′)=𝑐′:
(1)E′is identical toE𝑃until process 𝑃decides𝑣′.
(2)All processes not in 𝜋(𝑐′)are faulty inE′(they might be-
have correctly until 𝑃has decided), and all processes in
𝜋(𝑐′)are correct inE′.
(3)After𝑃has decided, processes in 𝜋(𝑐′)\S “wake up” with
the proposals specified in 𝑐′.
(4)GST is set to after all processes in 𝜋(𝑐′)have taken a com-
putational step.
For every process 𝑃𝑖∈ S∩𝜋(𝑐′), the proposal of 𝑃𝑖inE′is
proposal(𝑐′[𝑖]); recall that 𝑐′[𝑖]=𝑐[𝑖]as𝑐′∼𝑐andS ⊆𝜋(𝑐).
Moreover, for every process 𝑃𝑗∈𝜋(𝑐′)\S , the proposal of 𝑃𝑗in
E′isproposal(𝑐′[𝑗])(due to the step 3 of the construction). Hence,
input _conf(E′)=𝑐′. Furthermore, process 𝑃, which is correct in
E′, decides𝑣′(due to the step 1 of the construction). As 𝑣′∉val(𝑐′),
we reach a contradiction with the fact that Asatisfies val, which
proves the lemma. □
We underline that Lemma 1 does not rely on anyassumptions
on𝑛and𝑡. In other words, Lemma 1 is applicable to any algorithm
irrespectively of the parameters 𝑛and𝑡(as long as 0<𝑡<𝑛).4 NECESSARY SOLVABILITY CONDITIONS
This section gives the necessary conditions for the solvability of
validity properties. We start by focusing on the case of 𝑛≤3𝑡:
we prove that, if 𝑛≤3𝑡, all solvable validity properties are trivial
(§4.1). Then, we consider the case of 𝑛>3𝑡: we define the similarity
condition, and prove its necessity for solvability (§4.2).
4.1 Triviality of Solvable Validity Properties if
𝑛≤3𝑡
Some validity properties, such as Weak Validity andStrong Validity ,
are known to be unsolvable with 𝑛≤3𝑡[42,83]. This seems to
imply a split of validity properties depending on the resilience
threshold. We prove that such a split indeed exists for 𝑛≤3𝑡,
and, importantly, that it applies to allsolvable validity properties.
Implicitly, this means that there is no “useful” relaxation of the
validity property that can tolerate 𝑡≥⌈𝑛/3⌉failures. Concretely,
we prove the following theorem:
Theorem 1. If any validity property valis solvable with 𝑛≤3𝑡,
then the validity property is trivial, i.e., there exists a value 𝑣′∈V𝑂
such that𝑣′∈Ñ
𝑐∈Ival(𝑐).
Before presenting the proof of the theorem, we introduce the
compatibility relation between input configurations, which we use
throughout this subsection.
Compatibility. We define the compatibility relation (“ ⋄”) between
input configurations:
∀𝑐1,𝑐2∈I:𝑐1⋄𝑐2⇐⇒
 |𝜋(𝑐1)∩𝜋(𝑐2)|≤𝑡∧ 𝜋(𝑐1)\𝜋(𝑐2)≠∅∧ 𝜋(𝑐2)\𝜋(𝑐1)≠∅.
That is,𝑐1is compatible with 𝑐2if and only if (1) there are at most
𝑡processes in common, (2) there exists a process which belongs to
𝑐1and does not belong to 𝑐2, and (3) there exists a process which
belongs to𝑐2and does not belong to 𝑐1. For example, when 𝑛=3
and𝑡=1,𝑐=
(𝑃1,0),(𝑃2,0)
is compatible with
(𝑃1,1),(𝑃3,1)
,
whereas𝑐is not compatible with
(𝑃1,1),(𝑃2,1),(𝑃3,1)
. Observe
that the compatibility relation is symmetric and irreflexive.
Proof of Theorem 1. Throughout the rest of the subsection, we
fix any validity property valwhich is solvable with 𝑛≤3𝑡; our aim
is to prove the triviality of val. Moreover:
•We assume that 𝑛≤3𝑡.
•We fix any algorithm Awhich solves consensus with val.
•We fix any input configuration base∈I𝑛−𝑡with exactly
𝑛−𝑡process-proposal pairs.
•We fix any infinite canonical execution Ebase∈execs(A)
such that input _conf(Ebase)=base. AsAsatisfies Termi-
nation andval, andEbaseis infinite, some value 𝑣base∈
val(base)is decided by a correct process in Ebase.
First, we show that only 𝑣basecan be decided in any canonical
execution which corresponds to any input configuration compatible
with base. If a value different from 𝑣baseis decided, we can apply
the classical partitioning argument [ 62]: the adversary causes a dis-
agreement by partitioning processes into two disagreeing groups.
Lemma 2. Let𝑐∈Ibe any input configuration such that 𝑐⋄base.
LetE𝑐∈execs(A) be any (potentially infinite) canonical execution
5Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
such that input _conf(E𝑐)=𝑐. If a value𝑣𝑐∈V𝑂is decided by a
correct process inE𝑐, then𝑣𝑐=𝑣base.
Proof. By contradiction, suppose that some value 𝑣𝑐≠𝑣base
is decided by a correct process in E𝑐. Since𝑐⋄base, there exists a
process𝑄∈𝜋(𝑐)\𝜋(base). IfE𝑐is infinite, letE𝑄
𝑐←E𝑐. Otherwise,
letE𝑄
𝑐be an infinite canonical continuation of E𝑐. The following
holds for process 𝑄: (1)𝑄decides𝑣𝑐inE𝑄
𝑐(asAsatisfies Agreement
and Termination ), and (2)𝑄is silent inEbase. Let𝑡𝑄denote the
time at which 𝑄decides inE𝑄
𝑐. Similarly, there exists a process
𝑃∈𝜋(base)\𝜋(𝑐); note that (1) 𝑃decides𝑣baseinEbase, and (2)𝑃
is silent inE𝑄
𝑐. Let𝑡𝑃denote the time at which 𝑃decides inEbase.
In the next step, we construct an execution E∈ execs(A) by
“merging”EbaseandE𝑄
𝑐:
(1)We separate processes into 4 groups: (1) group 𝐴=𝜋(base)\
𝜋(𝑐), (2) group𝐵=𝜋(base)∩𝜋(𝑐), (3) group𝐶=𝜋(𝑐)\
𝜋(base), and (4) group 𝐷=Π\(𝐴∪𝐵∪𝐶).
(2)Processes in 𝐵behave towards processes in 𝐴as inEbase,
and towards processes in 𝐶as inE𝑄
𝑐.
(3)Communication between groups 𝐴and𝐶is delayed until
after time max(𝑡𝑃,𝑡𝑄).
(4)Processes in group 𝐷“wake up” at time 𝑇𝐷>max(𝑡𝑃,𝑡𝑄)
(with any proposals), and behave correctly throughout the
entire execution.
(5) We set GST to after 𝑇𝐷.
The following holds for E:
•Processes in Π\𝐵are correct inE. In other words, only
processes in 𝐵are faulty inE. Recall that|𝐵|≤𝑡asbase⋄𝑐.
•Process𝑄, which is correct in E, cannot distinguish Efrom
E𝑄
𝑐until after time max(𝑡𝑃,𝑡𝑄). Hence, process 𝑄decides
𝑣𝑐inE.
•Process𝑃, which is correct in E, cannot distinguish Efrom
Ebaseuntil after time max(𝑡𝑃,𝑡𝑄). Hence, process 𝑃decides
𝑣base≠𝑣𝑐inE.
Therefore, we reach a contradiction with the fact that Asatisfies
Agreement . Thus,𝑣𝑐=𝑣base. □
Observe that the proposals of an input configuration compatible
with base do not influence the decision: given an input configuration
𝑐∈I,𝑐⋄base, only𝑣basecan be decided in any canonical execution
which corresponds to 𝑐,irrespectively of the proposals.
Next, we prove a direct consequence of Lemma 2: for every input
configuration 𝑐𝑛∈I𝑛, there exists an infinite execution E𝑛such
that (1)E𝑛corresponds to 𝑐𝑛, and (2)𝑣baseis decided inE𝑛.
Lemma 3. For any input configuration 𝑐𝑛∈I𝑛, there exists an
infinite executionE𝑛∈execs(A) such that (1) input _conf(E𝑛)=
𝑐𝑛, and (2)𝑣baseis decided inE𝑛.
Proof. Fix any input configuration 𝑐𝑛∈I𝑛. We construct an
input configuration 𝑐𝑛−𝑡∈I𝑛−𝑡:
(1)For every process 𝑃𝑖∉𝜋(base), we include a process-
proposal pair(𝑃𝑖,𝑣)in𝑐𝑛−𝑡such that𝑣=proposal(𝑐𝑛[𝑖]).
Note that there are 𝑡such processes as|𝜋(base)|=𝑛−𝑡.
(2)We include any 𝑛−2𝑡process-proposal pairs (𝑃𝑖,𝑣)in𝑐𝑛−𝑡
such that (1) 𝑃𝑖∈𝜋(base), and (2)𝑣=proposal(𝑐𝑛[𝑖]). That
is, we “complete” 𝑐𝑛−𝑡(constructed in the step 1) with 𝑛−2𝑡process-proposal pairs such that the process is “borrowed”
from base, and its proposal is “borrowed” from 𝑐𝑛.
Observe that 𝑐𝑛−𝑡⋄base as (1)|𝜋(𝑐𝑛−𝑡)∩𝜋(base)|≤𝑡(𝑛−2𝑡≤𝑡
when𝑛≤3𝑡), (2) there exists a process 𝑃∈𝜋(base)\𝜋(𝑐𝑛−𝑡)
(while constructing 𝑐𝑛−𝑡, we excluded 𝑡>0processes from base;
step 2), and (3) there exists a process 𝑄∈𝜋(𝑐𝑛−𝑡)\𝜋(base)(we
included𝑡>0processes in cn−twhich are not in base; step 1).
LetE𝑛−𝑡∈execs(A) denote any infinite canonical execution
such that input _conf(E𝑛−𝑡)=𝑐𝑛−𝑡. AsAsatisfies Termination ,
some value is decided by correct processes in E𝑛−𝑡; due to Lemma 2,
that value is 𝑣base. Finally, we are able to construct an infinite
executionE𝑛∈execs(A) such that (1) input _conf(E𝑛)=𝑐𝑛, and
(2)𝑣baseis decided inE𝑛:
(1) All processes are correct in E𝑛.
(2)Until some correct process 𝑃∈𝜋(𝑐𝑛−𝑡)decides𝑣base,E𝑛
is identical toE𝑛−𝑡. LetSdenote the set of all processes
which take a computational step in E𝑛−𝑡until𝑃decides
𝑣base; note thatS⊆𝜋(𝑐𝑛−𝑡)and𝑃∈S.
(3)Afterwards, every process 𝑄∉S“wakes up” with the
proposal specified in 𝑐𝑛.
(4) GST occurs after all processes have taken a step.
Therefore,𝑣baseis indeed decided in E𝑛andinput _conf(E𝑛)=𝑐𝑛,
which concludes the proof. □
We are now ready to prove that valis trivial. We do so by showing
that, for any input configuration 𝑐∈I,𝑣base∈val(𝑐).
Lemma 4. Validity property valis trivial.
Proof. We fix any input configuration 𝑐∈I. Let us distinguish
two possible scenarios:
•Let𝑐∈I𝑛. There exists an infinite execution E𝑐∈execs(A)
such that (1) input _conf(E𝑐)=𝑐, and (2)𝑣baseis decided
inE𝑐(by Lemma 3). AsAsatisfies val,𝑣base∈val(𝑐).
•Let𝑐∉I𝑛. We construct an input configuration 𝑐𝑛∈I𝑛in
the following way:
(1) Let𝑐𝑛←𝑐.
(2)For every process 𝑃∉𝜋(𝑐),(𝑃,any proposal)is in-
cluded in𝑐𝑛.
Due to the construction of 𝑐𝑛,𝑐𝑛∼𝑐. By Lemma 3, there
exists an infinite execution E𝑛∈execs(A) such that (1)
input _conf(E𝑛)=𝑐𝑛, and (2)𝑣baseis decided inE𝑛;E𝑛is a
canonical execution as all processes are correct. Therefore,
canonical similarity ensures that 𝑣base∈val(𝑐)(Lemma 1).
In both possible cases, 𝑣base∈val(𝑐). Thus, the theorem. □
Lemma 4 concludes the proof of Theorem 1, as Lemma 4 proves
thatval, any solvable validity property with 𝑛≤3𝑡, is trivial. Fig-
ure 2 depicts the proof of Theorem 1. Since this subsection shows
that consensus cannot be useful when 𝑛≤3𝑡, the rest of the paper
focuses on the case of 𝑛>3𝑡.
Remark. As Theorem 1 shows, any validity property which is
solvable with 𝑛≤3𝑡is trivial. However, we now strengthen the
aforementioned necessary condition for solvable validity properties
with𝑛≤3𝑡.
6On the Validity of Consensus (Extended Version)
Lemma 2base
Lemma 3  Lemma 4  All input  
configurations0 0 0 0A A A AA A A A A A
A A A A
A A A AA A A A A ALemma 4 
Lemma 4
 
Figure 2: Theorem 1: Overview of the proof in the case of 𝑛=6,
𝑡=2, and base=
(𝑃1,0),(𝑃2,0),(𝑃3,0),(𝑃4,0)
.
Theorem 2. If any validity property valis solvable with 𝑛≤3𝑡,
then there exists a finite procedure always _admissible which returns
a value𝑣′∈V𝑂such that𝑣′∈Ñ
𝑐∈Ival(𝑐).
Proof. We prove the theorem by contradiction. Hence, sup-
pose that there exists a validity property valwhich is solvable
with𝑛≤3𝑡, and that there does not exist a finite procedure
always _admissible which returns a value 𝑣′∈V𝑂such that𝑣′∈Ñ
𝑐∈Ival(𝑐). Asvalis solvable, there exists an algorithm Awhich
solves consensus with val.
Let us fix any input configuration base∈ I𝑛−𝑡(as done in
the proof of Theorem 1). Moreover, let 𝑣basebe the value decided
inany infinite canonical execution Ebase∈execs(A) such that
input _conf(Ebase)=base; observe that the prefix of Ebaseis fi-
nite as processes can take only finitely many steps in finite time.
As proven in the proof of Theorem 1, 𝑣base∈val(𝑐), for any in-
put configuration 𝑐∈I. Hence, there exists a finite procedure
always _admissible which returns a value admissible according to
all input configurations ( Ais such a procedure). Thus, we reach a
contradiction, which concludes the proof. □
Theorem 2 states that, if a validity property is solvable with
𝑛≤3𝑡, not only that the property is trivial (as proven by Theo-
rem 1), but there exists a finite procedure which retrieves an always-
admissible value. Thus, Theorem 2 strictly extends Theorem 1. Ob-
serve that, if 𝑛≤3𝑡and a validity property is associated with
a finite procedure always _admissible which retrieves an always-
admissible value, solving consensus with that specific properties
is trivial: each process immediately decides the value returned by
always _admissible . Thus, an existence of the always _admissible
procedure is a necessary and sufficient condition for solvable valid-
ity properties with 𝑛≤3𝑡.
4.2 Similarity Condition: Necessary Solvability
Condition
This subsection defines the similarity condition, and proves its
necessity for solvable validity properties.
Definition 2 (Similarity condition) .A validity property valsatis-
fies the similarity condition (C𝑆, in short) if and only if there exists
a Turing-computable function Λ:I𝑛−𝑡→V𝑂such that:
∀𝑐∈I𝑛−𝑡:Λ(𝑐)∈Ù
𝑐′∈sim(𝑐)val(𝑐′).
C𝑆states that, for every input configuration 𝑐∈I𝑛−𝑡, there ex-
ists a Turing-computable function Λ(𝑐)which retrieves a commonadmissible decision among all input configurations similar to 𝑐.2
The necessity ofC𝑆follows from the canonical similarity result: in
any infinite canonical execution, a common admissible value must
be decided (Lemma 1).
Theorem 3. Any solvable validity property satisfies C𝑆.
Proof. By the means of contradiction, let there exist a valid-
ity property valsuch that (1) valdoes not satisfyC𝑆, and (2) val
is solvable. LetAbe any algorithm which solves the Byzantine
consensus problem with val. Asvaldoes not satisfyC𝑆, there does
not exist a Turing-computable function Λ:I𝑛−𝑡→V𝑂such that,
for every input configuration 𝑐∈I𝑛−𝑡,Λ(𝑐)∈Ñ
𝑐′∈sim(𝑐)val(𝑐′).
Fix any input configuration 𝑐∈I𝑛−𝑡for which Λ(𝑐)is not de-
fined or not Turing-computable. Let E𝑐∈execs(A) be an infinite
canonical execution such that (1) input _conf(E𝑐)=𝑐, (2) the sys-
tem is synchronous from the very beginning ( GST=0), and (3)
the message delays are exactly 𝛿. In other words,E𝑐unfolds in a
“lock-step” manner. As Asatisfies Termination andE𝑐is an infinite
execution, some value 𝑣𝑐∈V𝑂is decided by a correct process in
E𝑐; observe that the prefix of E𝑐in which𝑣𝑐is decided is finite as
processes take only finitely many steps in finite time. By canonical
similarity (Lemma 1), 𝑣𝑐∈Ñ
𝑐′∈sim(𝑐)val(𝑐′). Hence, Λ(𝑐)is defined
(Λ(𝑐)=𝑣𝑐) and Turing-computable ( Acomputes it). Therefore, we
reach a contradiction with the fact that Λ(𝑐)is not defined or not
Turing-computable, which concludes the proof. □
Notice that, for proving the necessity of C𝑆(Theorem 3), we do
not rely on the 𝑛>3𝑡assumption. Thus,C𝑆is necessary for allsolv-
able validity properties (irrespectively of the resilience threshold).
However, as proven in §4.1, C𝑆is not sufficient when 𝑛≤3𝑡: e.g.,
Weak Validity satisfiesC𝑆, but it is unsolvable with 𝑛≤3𝑡[42,83].
(Observe that any solvable validity property with 𝑛≤3𝑡satisfies
C𝑆.)
5 LOWER BOUND & GENERAL ALGORITHM
First, we show that any non-trivial and solvable validity property
requires Ω(𝑡2)messages to be exchanged (§5.1). Then, we present
Universal , a general algorithm that, if 𝑛>3𝑡, solves consensus
with any validity property which satisfies C𝑆(§5.2). Thus, Univer-
salproves the sufficiency of C𝑆when𝑛>3𝑡.
5.1 Lower Bound on Message Complexity
In this subsection, we prove the following theorem:
Theorem 4. If an algorithm solves consensus with a non-trivial
validity property, the message complexity of the algorithm is Ω(𝑡2).
Theorem 4 extends the seminal Dolev-Reischuk bound [ 39],
proven only for consensus with Strong Validity , to all non-trivial
consensus variants. To prove Theorem 4, we intertwine the idea of
the original proof [39] with canonical similarity (Lemma 1).
2A function is Turing-computable if there exists a finite procedure to compute it.
7Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Proof of Theorem 4. In our proof, we show that any algorithm
which solves Byzantine consensus with a non-trivial validity prop-
erty has a synchronous execution in which correct processes send
more than(𝑡
2)2messages. Hence, throughout the entire subsection,
we fix a non-trivial and solvable validity property val. Moreover,
we fixA, an algorithm which solves Byzantine consensus with val.
Asvalis a non-trivial validity property, 𝑛>3𝑡(§4.1).
Next, we define a specific infinite execution Ebase∈execs(A):
(1) GST =0. That is, the system is synchronous throughout
the entire execution.
(2)All processes are separated into two disjoint groups: (1)
group𝐴, with|𝐴|=𝑛−⌈𝑡
2⌉, and (2) group 𝐵, with|𝐵|=⌈𝑡
2⌉.
(3)All processes in the group 𝐴are correct, whereas all pro-
cesses in the group 𝐵are faulty.
(4)We fix any value 𝑣∗∈V𝐼. For every correct process 𝑃𝐴∈𝐴,
the proposal of 𝑃𝐴inEbaseis𝑣∗.
(5)For every faulty process 𝑃𝐵∈𝐵,𝑃𝐵behaves correctly in
Ebasewith its proposal being 𝑣∗, except that (1) 𝑃𝐵ignores
the first⌈𝑡
2⌉messages received from other processes, and
(2)𝑃𝐵omits sending messages to other processes in 𝐵.
To prove Theorem 4, it suffices to show that the message complexity
ofEbaseis greater than(⌈𝑡
2⌉)2. By contradiction, let the correct
processes (processes in 𝐴) send≤(⌈𝑡
2⌉)2messages inEbase.
The first step of our proof shows that, given that correct pro-
cesses send≤(⌈𝑡
2⌉)2messages inEbase, there must exist a process
𝑄∈𝐵which can correctly decide some value 𝑣𝑄∈V𝑂without
receiving anymessage from any other process. We prove this claim
using the pigeonhole principle.
Lemma 5. There exist a value 𝑣𝑄∈V𝑂and a process 𝑄∈𝐵such
that𝑄has a correct local behavior 𝛽𝑄in which (1) 𝑄decides𝑣𝑄,
and (2)𝑄receives no messages from other processes.
Proof. By assumption, correct processes (i.e., processes in the
group𝐴) send≤(⌈𝑡
2⌉)2messages inEbase. Therefore, due to the
pigeonhole principle, there exists a process 𝑄∈𝐵which receives
at most⌈𝑡
2⌉messages (from other processes) in Ebase. Recall that 𝑄
behaves correctly in Ebasewith its proposal being 𝑣∗∈V𝐼, except
that (1)𝑄ignores the first⌈𝑡
2⌉messages received from other pro-
cesses, and (2) 𝑄does not send any messages to other processes in
the group𝐵. We denote by 𝑆𝑄the set of processes, not including
𝑄, which send messages to 𝑄inEbase;|𝑆𝑄|≤⌈𝑡
2⌉.
Next, we construct an infinite execution E′
base. ExecutionE′
base
is identical toEbase, except that:
(1)Processes in(𝐴∪{𝑄})\𝑆𝑄are correct; other processes are
faulty. That is, we make 𝑄correct inE′
base, and we make
all processes in 𝑆𝑄faulty inE′
base.
(2)Processes in 𝐵\{𝑄}behave exactly as in Ebase. Moreover,
processes in 𝑆𝑄behave exactly as in Ebase, except that they
do not send any message to 𝑄.
Due to the construction of E′
base, process𝑄does not receive any
message (from any other process) in E′
base. As𝑄is correct inE′
base
andAsatisfies Termination ,𝑄decides some value 𝑣𝑄∈V𝑂inE′
base.
Thus,𝑄has a correct local behavior 𝛽𝑄in which it decides 𝑣𝑄∈V𝑂
without having received messages from other processes. □The previous proof concerns deterministic protocols and uses a
deterministic adversarial strategy. We invite the reader to Appen-
dix A for a remark on non-determinism.
In the second step of our proof, we show that there exists an
infinite execution in which (1) 𝑄is faulty and silent, and (2) correct
processes decide some value 𝑣≠𝑣𝑄.
Lemma 6. There exists an infinite execution E𝑣such that (1) 𝑄
is faulty and silent in E𝑣, and (2) a value 𝑣≠𝑣𝑄is decided by a
correct process.
Proof. Asvalis a non-trivial validity property, there exists an
input configuration 𝑐∌𝑣𝑄∈Isuch that𝑣𝑄∉val(𝑐∌𝑣𝑄); recall that
𝑣𝑄is the value that 𝑄can correctly decide without having received
any message from any other process (Lemma 5). We consider two
possible cases:
•Let𝑄∉𝜋(𝑐∌𝑣𝑄). Thus,E𝑣is any infinite canonical exe-
cution which corresponds to 𝑐∌𝑣𝑄. As𝑣𝑄∉val(𝑐∌𝑣𝑄), the
value decided inE𝑣must be different from 𝑣𝑄(asAsatisfies
val).
•Let𝑄∈𝜋(𝑐∌𝑣𝑄). We construct an input configuration
𝑐∌𝑄∈Isuch that𝑄∉𝜋(𝑐∌𝑄):
(1) Let𝑐∌𝑄←𝑐∌𝑣𝑄.
(2)We remove(𝑄,·)from𝑐∌𝑄. That is, we remove 𝑄’s
process-proposal pair from 𝑐∌𝑄.
(3)If|𝜋(𝑐∌𝑣𝑄)|=𝑛−𝑡, we add(𝑍,any proposal)to𝑐∌𝑄,
where𝑍is any process such that 𝑍∉𝜋(𝑐∌𝑣𝑄); note
that such a process 𝑍exists as𝑡>0.
Due to the construction of 𝑐∌𝑄,𝑐∌𝑄∼𝑐∌𝑣𝑄. Indeed, (1)
𝜋(𝑐∌𝑄)∩𝜋(𝑐∌𝑣𝑄)≠∅(as𝑛−𝑡−1>0when𝑛>3𝑡and
𝑡>0), and (2) for every process 𝑃∈𝜋(𝑐∌𝑄)∩𝜋(𝑐∌𝑣𝑄), the
proposal of 𝑃is identical in 𝑐∌𝑄and𝑐∌𝑣𝑄.
In this case,E𝑣is any infinite canonical execution such
thatinput _conf(E𝑣)=𝑐∌𝑄. AsAsatisfies Termination and
E𝑣is infinite, some value 𝑣∈V𝑂is decided by a correct
process inE𝑣. As𝑐∌𝑄∼𝑐∌𝑣𝑄,𝑣∈val(𝑐∌𝑣𝑄)(by canonical
similarity; Lemma 1). Finally, 𝑣≠𝑣𝑄as (1)𝑣∈val(𝑐∌𝑣𝑄),
and (2)𝑣𝑄∉val(𝑐∌𝑣𝑄).
The lemma holds as its statement is true in both possible cases. □
As we have shown the existence of E𝑣(Lemma 6), we can “merge”
E𝑣with the valid local behavior 𝛽𝑄in which𝑄decides𝑣𝑄without
having received any message (Lemma 5). Hence, we can construct
an execution in which Aviolates Agreement . Thus, correct pro-
cesses must send more than (⌈𝑡
2⌉)2∈Ω(𝑡2)messages inEbase.
Lemma 7. The message complexity of Ebaseis greater than(⌈𝑡
2⌉)2.
Proof. By Lemma 5, there exists a local behavior 𝛽𝑄of process
𝑄in which𝑄decides a value 𝑣𝑄without having received any
message (from any other process). Let 𝑡𝑄denote the time at which
𝑄decides𝑣𝑄in𝛽𝑄. Moreover, there exists an infinite execution E𝑣
in which (1) 𝑄is faulty and silent, and (2) correct processes decide
a value𝑣≠𝑣𝑄(by Lemma 6). Let 𝑡𝑣denote the time at which a
correct process decides 𝑣≠𝑣𝑄inE𝑣.
We now construct an execution Ein the following way:
(1)Processes in CorrA(E𝑣)∪{𝑄}are correct inE. All other
processes are faulty.
(2)All messages from and to 𝑄are delayed until after max(𝑡𝑄,𝑡𝑣).
8On the Validity of Consensus (Extended Version)
(3) Process 𝑄exhibits the local behavior 𝛽𝑄.
(4)Until max(𝑡𝑄,𝑡𝑣), no process in CorrA(E𝑣)can distinguish
EfromE𝑣.
(5)GST is set to after max(𝑡𝑄,𝑡𝑣)(and after all correct pro-
cesses from the CorrA(E𝑣)∪{𝑄}set have taken a step).
As no process in CorrA(E𝑣)can distinguishEfromE𝑣until time
max(𝑡𝑄,𝑡𝑣),𝑣≠𝑣𝑄is decided by a correct process in E. Moreover,
𝑄decides𝑣𝑄inEas it exhibits 𝛽𝑄(step 3 of the construction).
Thus, Agreement is violated inE, which contradicts the fact that A
satisfies Agreement . Hence, the starting assumption is not correct:
inEbase, correct processes send more than (⌈𝑡
2⌉)2messages. □
The following subsection shows that the quadratic bound on
message complexity is tight with 𝑡∈Ω(𝑛):Universal exchanges
𝑂(𝑛2)messages when relying on a PKI. We underline that our
lower bound holds even for algorithms which employ digital signa-
tures. Achieving the optimal quadratic message complexity without
relying on digital signatures remains an important open question.
5.2 General Algorithm Universal : Similarity
Condition is Sufficient if 𝑛>3𝑡
In this subsection, we show that C𝑆is sufficient for a validity prop-
erty to be solvable when 𝑛>3𝑡. Furthermore, we prove that, assum-
ing a PKI, the quadratic lower bound (§5.1) is tight with 𝑡∈Ω(𝑛).
In brief, we prove the following theorem:
Theorem 5. Let𝑛>3𝑡, and let valbe any validity property
which satisfiesC𝑆. Then, valis solvable. Moreover, assuming a public-
key infrastructure, there exists an algorithm which solves Byzantine
consensus with val, and has𝑂(𝑛2)message complexity.
To prove Theorem 5, we present Universal , an algorithm which
solves the Byzantine consensus problem with anyvalidity prop-
erty satisfyingC𝑆, given that 𝑛>3𝑡. In other words, Universal
solves consensus with any solvable and non-trivial validity prop-
erty. Notably, assuming a PKI, Universal achieves𝑂(𝑛2)message
complexity, making it optimal (when 𝑡∈Ω(𝑛)) according to our
quadratic lower bound.
To construct Universal , we rely on vector consensus [ 34,40,
82,91] (see §5.2.1), a problem which requires correct processes
to agree on the proposals of 𝑛−𝑡processes. Specifically, when a
correct process decides a vector vecof𝑛−𝑡proposals (from vector
consensus), it decides from Universal the common admissible
value for all input configurations similar to vec, i.e., the process
decides Λ(vec). Note that the idea of solving consensus from vector
consensus is not novel [ 15,35,81]. For some validity properties it
is even natural, such as Strong Validity (choose the most common
value) or Weak Validity (choose any value). However, thanks to the
necessity ofC𝑆(§4.2), anysolvable consensus variant can reuse
this simple algorithmic design.
In this subsection, we first recall vector consensus (§5.2.1). Then,
we utilize vector consensus to construct Universal (§5.2.2). Through-
out the entire subsection, 𝑛>3𝑡.
5.2.1 Vector Consensus. In essence, vector consensus allows each
correct process to infer the proposals of 𝑛−𝑡(correct or faulty)
processes. Formally, correct processes agree on input configurations
(of vector consensus) with exactly 𝑛−𝑡process-proposal pairs:V𝑂=I𝑛−𝑡. Let us precisely define Vector Validity , the validity
property of vector consensus:
•Vector Validity: Let a correct process decide vector∈V𝑂,
which contains exactly 𝑛−𝑡process-proposal pairs, such
that (1)(𝑃,𝑣)belongs to vector , for some process 𝑃∈Π
and some value 𝑣∈V𝐼, and (2)𝑃is a correct process. Then,
𝑃proposed𝑣to vector consensus.
Intuitively, Vector Validity states that, if a correct process “concludes”
that a value 𝑣was proposed by a process 𝑃and𝑃is correct, then
𝑃’s proposal was indeed 𝑣.
We provide two implementations of vector consensus: (1) a non-
authenticated implementation (without any cryptographic primi-
tives), and (2) an authenticated implementation (with digital signa-
tures). We give the pseudocode of the non-authenticated variant
in Appendix B.2. The pseudocode of the authenticated variant is
presented in Algorithm 1. This variant relies on Quad , a Byzantine
consensus algorithm recently introduced in [ 28]; we briefly discuss
Quad below.
Quad .In essence, Quad is a partially-synchronous, “leader-
based” Byzantine consensus algorithm, which achieves 𝑂(𝑛2)mes-
sage complexity. Internally, Quad relies on a PKI.3Formally, Quad
is concerned with two sets: (1) VQuad , a set of values, and (2)
PQuad , a set of proofs. In Quad , processes propose and decide
value-proof pairs. There exists a function verify :VQuad×PQuad→
{true,false}. Importantly,PQuad is not known a-priori: it is only
assumed that, if a correct process proposes a pair (𝑣∈V Quad,Σ∈
PQuad), then verify(𝑣,Σ)=true.Quad guarantees the following:
if a correct process decides a pair (𝑣,Σ), then verify(𝑣,Σ)=true. In
other words, correct processes decide only valid value-proof pairs.
(See [28] for the full details on Quad .)
In our authenticated implementation of vector consensus (Algo-
rithm 1), we rely on a specific instance of Quad where (1)VQuad=
I𝑛−𝑡(processes propose to Quad the input configurations of vec-
tor consensus), and (2) PQuad is a set of𝑛−𝑡proposal messages
(sent by processes in vector consensus). Finally, given an input
configuration vector∈V Quad and a set of messages Σ∈P Quad ,
verify(vector,Σ)=trueif and only if, for every process-proposal
pair(𝑃𝑗,𝑣𝑗)which belongs to vector ,⟨proposal,𝑣𝑗⟩𝜎𝑗∈Σ(i.e.,
every process-proposal pair of vector is accompanied by a properly
signed proposal message).
Description of authenticated vector consensus (Algorithm 1). When
a correct process 𝑃𝑖proposes a value 𝑣∈V𝐼to vector consensus
(line 8), the process broadcasts a signed proposal message (line 9).
Once𝑃𝑖receives𝑛−𝑡proposal messages (line 14), 𝑃𝑖constructs
an input configuration vector (line 15), and a proof Σ(line 16) from
the received proposal messages. Moreover, 𝑃𝑖proposes(vector,Σ)
toQuad (line 17). Finally, when 𝑃𝑖decides a pair(vector′,Σ′)from
Quad (line 18),𝑃𝑖decides vector′from vector consensus (line 19).
The message complexity of Algorithm 1 is 𝑂(𝑛2)as (1) processes
only broadcast proposal messages, and (2) the message complexity
ofQuad is𝑂(𝑛2). We delegate the full proof of the correctness and
complexity of Algorithm 1 to Appendix B.1.
3In fact, Quad relies on a threshold signature scheme [ 87], and not on a PKI. However,
by inserting digital signatures in place of threshold signatures, Quad is modified to
accommodate for a PKI only while preserving its quadratic message complexity.
9Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Algorithm 1 Authenticated Vector Consensus: Pseudocode (for
process𝑃𝑖)
1:Uses:
2: Best-Effort Broadcast [ 23],instance beb⊲no guarantees with faulty sender
3: Quad [28], instance quad
4:upon init:
5: Integer received _proposals𝑖←0 ⊲the number of received proposals
6: Map(Process→V𝐼)proposals𝑖←empty ⊲received proposals
7: Map(Process→Message)messages𝑖←empty ⊲received messages
8:upon propose(𝑣∈V𝐼):
9: invoke beb.broadcast ⟨proposal,𝑣⟩𝜎𝑖⊲broadcast a signed proposal
10:upon reception of Message𝑚=⟨proposal,𝑣𝑗∈V𝐼⟩𝜎𝑗from process 𝑃𝑗and
received _proposals𝑖<𝑛−𝑡:
11: received _proposals𝑖←received _proposals𝑖+1
12: proposals𝑖[𝑃𝑗]←𝑣𝑗
13: messages𝑖[𝑃𝑗]←𝑚
14: ifreceived _proposals𝑖=𝑛−𝑡: ⊲able to propose to Quad
15: Input _Configuration vector←constructed from proposals𝑖
16: Proof Σ←allproposal messages from messages𝑖
17: invoke quad.propose (vector,Σ)
18:upon quad.decide (Input _Configuration vector′,Proof Σ′):
19: trigger decide(vector′)
5.2.2 Universal .We construct Universal (Algorithm 2) directly
from vector consensus. When a correct process 𝑃𝑖proposes to
Universal (line 3), the proposal is forwarded to vector consensus
(line 4). Once 𝑃𝑖decides an input configuration vector from vector
consensus (line 5), 𝑃𝑖decides Λ(vector)(line 6).
Note that our implementation of Universal (Algorithm 2) is
independent of the actual implementation of vector consensus.
Thus, by employing our authenticated implementation of vector
consensus (Algorithm 1), we obtain a general consensus algorithm
with𝑂(𝑛2)message complexity. On the other hand, by employ-
ing a non-authenticated implementation of vector consensus (see
Appendix B.2), we obtain a non-authenticated version of Univer-
sal, which implies that any validity property which satisfies C𝑆is
solvable even in a non-authenticated setting (if 𝑛>3𝑡).
Algorithm 2 Universal : Pseudocode (for process 𝑃𝑖)
1:Uses:
2: Vector Consensus, instance vec_cons
3:upon propose(𝑣∈V𝐼):
4: invoke vec_cons.propose(𝑣)
5:upon vec_cons.decide(Input _Configuration vector):
6: trigger decide Λ(vector)
Finally, we show that Universal (Algorithm 2) is a general
Byzantine consensus algorithm and that its authenticated variant
achieves𝑂(𝑛2)message complexity, which proves Theorem 5.
Lemma 8. Letvalbe any validity property which satisfies C𝑆, and
let𝑛>3𝑡.Universal solves Byzantine consensus with val. More-
over, if Universal employs Algorithm 1 as its vector consensus
building block, the message complexity of Universal is𝑂(𝑛2).
Proof. Termination andAgreement ofUniversal follow from
Termination andAgreement of vector consensus, respectively. More-
over, the message complexity of Universal is identical to the mes-
sage complexity of its vector consensus building block.
Finally, we prove that Universal satisfies val. Consider any
executionEofUniversal ; letinput _conf(E)=𝑐∗, for some inputconfiguration 𝑐∗∈I. Moreover, let vector∈I𝑛−𝑡be the input
configuration correct processes decide from vector consensus in
E(line 5). As vector consensus satisfies Vector Validity , we have
that, for every process 𝑃∈𝜋(𝑐∗)∩𝜋(vector),𝑃’s proposals in 𝑐∗
andvector are identical. Hence, vector∼𝑐∗. Therefore, Λ(vector)∈
val(𝑐∗)(by the definition of the Λfunction). Thus, valis satisfied
byUniversal . □
AsUniversal (Algorithm 2) solves the Byzantine consensus
problem with any validity property which satisfies C𝑆(Lemma 8) if
𝑛>3𝑡,C𝑆is sufficient for solvable validity properties when 𝑛>3𝑡.
Lastly, as Universal relies on vector consensus, we conclude that
Vector Validity is astrongest validity property. That is, a consensus
solution to any solvable variant of the validity property can be
obtained (with no additional cost) from vector consensus.
A note on the communication complexity of vector consensus.
While the version of Universal which employs Algorithm 1 (as its
vector consensus building block) has optimal message complexity,
its communication complexity is 𝑂(𝑛3)asQuad ’s communication
complexity is 𝑂(𝑛3)when proofs are of linear size.4This presents a
linear gap to the lower bound for communication complexity (also
Ω(𝑛2), implied by Theorem 4), and to known optimal solutions for
some validity properties (e.g., Strong Validity , proven to be Θ(𝑛2)
[28,64]). At first glance, this seems like an issue inherent to vec-
tor consensus: the decided vectors are linear in size, suggesting
that the linear gap could be inevitable. However, this is not the
case. In Appendix B.3, we give a vector consensus algorithm with
𝑂(𝑛2log𝑛)communication complexity, albeit with exponential la-
tency.5Is it possible to construct vector consensus with subcubic
communication and polynomial latency? This is an important open
question, as positive answers would lead to (practical) performance
improvements of all consensus variants.
6 CONCLUDING REMARKS
This paper studies the validity property of partially synchronous
Byzantine consensus. Namely, we mathematically formalize valid-
ity properties, and give the necessary and sufficient conditions for
a validity property to be solvable (i.e., for the existence of an algo-
rithm which solves a consensus problem defined with that validity
property, in addition to Agreement andTermination ). Moreover, we
prove a quadratic lower bound on the message complexity for all
non-trivial (and solvable) validity properties. Previously, this bound
was mainly known for Strong Validity . Lastly, we introduce Uni-
versal , a general algorithm for consensus with any solvable (and
non-trivial) validity property; assuming a PKI, Universal achieves
𝑂(𝑛2)message complexity, showing that the aforementioned lower
bound is tight (with 𝑡∈Ω(𝑛)).
A natural extension of this work is its adaptation to synchronous
environments. Similarly, can we extend our results to randomized
protocols? Furthermore, investigating consensus variants in which
“exact” agreement among correct processes is not required (such
4The communication complexity denotes the number of sent words, where a word
contains a constant number of values and signatures.
5Both our authenticated (Algorithm 1) and our non-authenticated (see Appendix B.2)
variants of vector consensus have linear latency, which implies linear latency of
Universal when employing any of these two algorithms.
10On the Validity of Consensus (Extended Version)
as approximate [ 2,48,49,72] or𝑘-set [ 18,37,38,68] agreement)
constitutes another important research direction for the future.
Finally, we restate the question posed at the end of §5.2. Is it
possible to solve vector consensus with 𝑜(𝑛3)exchanged bits and
polynomial latency? Recall that, due to the design of Universal
(§5.2), any (non-trivial) consensus variant can be solved using vec-
tor consensus without additional cost. Therefore, an upper bound
on the complexity of vector consensus is an upper bound on the
complexity of any consensus variant. Hence, lowering the 𝑂(𝑛3)
communication complexity of vector consensus (while preserv-
ing polynomial latency) constitutes an important future research
direction.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments.
We also thank our colleagues Nirupam Gupta, Matteo Monti, Rafael
Pinot and Pierre-Louis Roman for the helpful discussions and com-
ments. This work was funded in part by the Hasler Foundation
(#21084), the Singapore grant MOE-T2EP20122-0014, and the ARC
Future Fellowship program (#180100496).
REFERENCES
[1] Michael Abd-El-Malek, Gregory R Ganger, Garth R Goodson, Michael K Reiter,
and Jay J Wylie. 2005. Fault-Scalable Byzantine Fault-Tolerant Services. ACM
SIGOPS Operating Systems Review 39, 5 (2005), 59–74.
[2] Ittai Abraham, Yonatan Amit, and Danny Dolev. 2004. Optimal Resilience Asyn-
chronous Approximate Agreement. In Principles of Distributed Systems, 8th Inter-
national Conference, OPODIS 2004, Grenoble, France, December 15-17, 2004, Revised
Selected Papers (Lecture Notes in Computer Science, Vol. 3544) , Teruo Higashino
(Ed.). Springer, 229–239. https://doi.org/10.1007/11516798_17
[3]Ittai Abraham and Cristian Cachin. [n. d.]. What about Validity? https://
decentralizedthoughts.github.io/2022-12-12-what-about-validity/.
[4] Ittai Abraham, T.-H. Hubert Chan, Danny Dolev, Kartik Nayak, Rafael Pass, Ling
Ren, and Elaine Shi. 2019. Communication Complexity of Byzantine Agreement,
Revisited. In Proceedings of the 2019 ACM Symposium on Principles of Distributed
Computing, PODC 2019, Toronto, ON, Canada, July 29 - August 2, 2019 , Peter
Robinson and Faith Ellen (Eds.). ACM, 317–326. https://doi.org/10.1145/3293611.
3331629
[5]Ittai Abraham, Srinivas Devadas, Kartik Nayak, and Ling Ren. 2017. Brief An-
nouncement: Practical Synchronous Byzantine Consensus. In 31st International
Symposium on Distributed Computing (DISC 2017) . Schloss Dagstuhl-Leibniz-
Zentrum fuer Informatik.
[6] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegel-
man. 2016. Solida: A Blockchain Protocol Based on Reconfigurable Byzantine
Consensus. arXiv preprint arXiv:1612.02916 (2016).
[7] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegelman.
2016. Solidus: An Incentive-compatible Cryptocurrency Based on Permissionless
Byzantine Consensus. CoRR, abs/1612.02916 (2016).
[8] Ittai Abraham, Dahlia Malkhi, and Alexander Spiegelman. 2019. Asymptotically
Optimal Validated Asynchronous Byzantine Agreement. In Proceedings of the
2019 ACM Symposium on Principles of Distributed Computing . 337–346.
[9]Atul Adya, William Bolosky, Miguel Castro, Gerald Cermak, Ronnie Chaiken,
John Douceur, Jon Howell, Jacob Lorch, Marvin Theimer, and Roger Wattenhofer.
2002.{FARSITE}: Federated, Available, and Reliable Storage for an Incom-
pletely Trusted Environment. In 5th Symposium on Operating Systems Design
and Implementation (OSDI 02) .
[10] Yair Amir, Claudiu Danilov, Jonathan Kirsch, John Lane, Danny Dolev, Cristina
Nita-Rotaru, Josh Olsen, and David Zage. 2006. Scaling Byzantine Fault-Tolerant
Replication to Wide Area Networks. In International Conference on Dependable
Systems and Networks (DSN’06) . IEEE, 105–114.
[11] James Aspnes. 2003. Randomized Protocols for Asynchronous Consensus. Dis-
tributed Computing 16, 2 (2003), 165–175.
[12] Michael Ben-Or. 1983. Another Advantage of Free Choice: Completely Asyn-
chronous Agreement Protocols (Extended Abstract). In Proceedings of the Second
Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing,
Montreal, Quebec, Canada, August 17-19, 1983 , Robert L. Probert, Nancy A. Lynch,
and Nicola Santoro (Eds.). ACM, 27–30. https://doi.org/10.1145/800221.806707
[13] Michael Ben-Or and Ran El-Yaniv. 2003. Resilient-optimal interactive consistency
in constant time. Distributed Computing 16, 4 (2003), 249–262.[14] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. 2019. Completeness
Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation. In
Providing Sound Foundations for Cryptography: On the Work of Shafi Goldwasser
and Silvio Micali . 351–371.
[15] Michael Ben-Or, Boaz Kelmer, and Tal Rabin. 1994. Asynchronous Secure Com-
putations with Optimal Resilience (Extended Abstract). In Proceedings of the
Thirteenth Annual ACM Symposium on Principles of Distributed Computing, Los
Angeles, California, USA, August 14-17, 1994 , James H. Anderson, David Peleg, and
Elizabeth Borowsky (Eds.). ACM, 183–192. https://doi.org/10.1145/197917.198088
[16] Amey Bhangale, Chen-Da Liu-Zhang, Julian Loss, and Kartik Nayak. 2022.
Efficient Adaptively-Secure Byzantine Agreement for Long Messages. In Ad-
vances in Cryptology - ASIACRYPT 2022 - 28th International Conference on the
Theory and Application of Cryptology and Information Security, Taipei, Tai-
wan, December 5-9, 2022, Proceedings, Part I (Lecture Notes in Computer Sci-
ence, Vol. 13791) , Shweta Agrawal and Dongdai Lin (Eds.). Springer, 504–525.
https://doi.org/10.1007/978-3-031-22963-3_17
[17] Ofer Biran, Shlomo Moran, and Shmuel Zaks. 1990. A Combinatorial Character-
ization of the Distributed 1-Solvable Tasks. Journal of algorithms 11, 3 (1990),
420–440.
[18] Zohir Bouzid, Damien Imbs, and Michel Raynal. 2016. A necessary condition
for Byzantine k-set agreement. Inf. Process. Lett. 116, 12 (2016), 757–759. https:
//doi.org/10.1016/j.ipl.2016.06.009
[19] Elette Boyle, Ran Cohen, and Aarushi Goel. 2021. Breaking the 𝑜(√𝑛)-bit barrier:
Byzantine agreement with polylog bits per party. In Proceedings of the 2021 ACM
Symposium on Principles of Distributed Computing . 319–330.
[20] Gabriel Bracha. 1987. Asynchronous Byzantine Agreement Protocols. Inf. Com-
put.75, 2 (1987), 130–143.
[21] Ethan Buchman. 2016. Tendermint: Byzantine Fault Tolerance in the Age of
Blockchains . Ph. D. Dissertation. University of Guelph.
[22] Ethan Buchman, Jae Kwon, and Zarko Milosevic. 2019. The latest gossip on BFT
consensus . Technical Report 1807.04938. arXiv.
[23] Christian Cachin, Rachid Guerraoui, and Luís Rodrigues. 2011. Introduction
to Reliable and Secure Distributed Programming . Springer Science & Business
Media.
[24] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. 2001. Secure
and Efficient Asynchronous Broadcast Protocols. In Advances in Cryptology -
CRYPTO 2001, 21st Annual International Cryptology Conference, Santa Barbara,
California, USA, August 19-23, 2001, Proceedings (Lecture Notes in Computer Science,
Vol. 2139) , Joe Kilian (Ed.). Springer, 524–541. https://doi.org/10.1007/3-540-
44647-8_31
[25] Miguel Castro and Barbara Liskov. 2002. Practical Byzantine Fault Tolerance
and Proactive Recovery. ACM Transactions on Computer Systems 20, 4 (2002).
[26] Annick Chopard, Martin Hirt, and Chen-Da Liu-Zhang. 2021. On
Communication-Efficient Asynchronous MPC with Adaptive Security. In The-
ory of Cryptography - 19th International Conference, TCC 2021, Raleigh, NC,
USA, November 8-11, 2021, Proceedings, Part II (Lecture Notes in Computer
Science, Vol. 13043) , Kobbi Nissim and Brent Waters (Eds.). Springer, 35–65.
https://doi.org/10.1007/978-3-030-90453-1_2
[27] Benny Chor and Lior Moscovici. 1989. Solvability in Asynchronous Environments
(Extended Abstract). In 30th Annual Symposium on Foundations of Computer
Science, Research Triangle Park, North Carolina, USA, 30 October - 1 November
1989. IEEE Computer Society, 422–427. https://doi.org/10.1109/SFCS.1989.63513
[28] Pierre Civit, Muhammad Ayaz Dzulfikar, Seth Gilbert, Vincent Gramoli, Rachid
Guerraoui, Jovan Komatovic, and Manuel Vidigueira. 2022. Byzantine Consensus
isΘ(𝑛2): The Dolev-Reischuk Bound is Tight even in Partial Synchrony!. In
36th International Symposium on Distributed Computing (DISC 2022) (Leibniz
International Proceedings in Informatics (LIPIcs), Vol. 246) , Christian Scheideler
(Ed.). Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl, Germany,
14:1–14:21. https://doi.org/10.4230/LIPIcs.DISC.2022.14
[29] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2021. Polygraph: Accountable
Byzantine Agreement. In Proceedings of the 41st IEEE International Conference on
Distributed Computing Systems (ICDCS’21) .
[30] Pierre Civit, Seth Gilbert, Vincent Gramoli, Rachid Guerraoui, Jovan Komatovic,
Zarko Milosevic, and Adi Seredinschi. 2022. Crime and Punishment in Distributed
Byzantine Decision Tasks. In 42nd IEEE International Conference on Distributed
Computing Systems, ICDCS 2022, Bologna, Italy, July 10-13, 2022 . IEEE, 34–44.
https://doi.org/10.1109/ICDCS54860.2022.00013
[31] Shir Cohen, Idit Keidar, and Oded Naor. 2021. Byzantine Agreement with Less
Communication: Recent Advances. SIGACT News 52, 1 (2021), 71–80. https:
//doi.org/10.1145/3457588.3457600
[32] Shir Cohen, Idit Keidar, and Alexander Spiegelman. 2020. Not a coinci-
dence: Sub-quadratic asynchronous byzantine agreement whp. arXiv preprint
arXiv:2002.06545 (2020).
[33] Miguel Correia. 2019. From Byzantine Consensus to Blockchain Consensus. In
Essentials of Blockchain Technology . Chapman and Hall/CRC, 41–80.
[34] Miguel Correia, Nuno Ferreira Neves, and Paulo Veríssimo. 2006. From Con-
sensus to Atomic Broadcast: Time-Free Byzantine-Resistant Protocols without
11Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Signatures. Comput. J. 49, 1 (2006), 82–96.
[35] Tyler Crain, Vincent Gramoli, Mikel Larrea, and Michel Raynal. 2018. DBFT:
Efficient Leaderless Byzantine Consensus and its Applications to Blockchains.
InProceedings of the 17th IEEE International Symposium on Network Computing
and Applications (NCA’18) . IEEE.
[36] Sourav Das, Zhuolun Xiang, and Ling Ren. 2021. Asynchronous Data Dissemi-
nation and its Applications. In Proceedings of the 2021 ACM SIGSAC Conference
on Computer and Communications Security . 2705–2721.
[37] Carole Delporte-Gallet, Hugues Fauconnier, Michel Raynal, and Mouna Safir.
2022. Optimal Algorithms for Synchronous Byzantine k-Set Agreement. In
Stabilization, Safety, and Security of Distributed Systems - 24th International Sym-
posium, SSS 2022, Clermont-Ferrand, France, November 15-17, 2022, Proceedings
(Lecture Notes in Computer Science, Vol. 13751) , Stéphane Devismes, Franck Petit,
Karine Altisen, Giuseppe Antonio Di Luna, and Antonio Fernández Anta (Eds.).
Springer, 178–192. https://doi.org/10.1007/978-3-031-21017-4_12
[38] Carole Delporte-Gallet, Hugues Fauconnier, and Mouna Safir. 2020. Byzantine
k-Set Agreement. In Networked Systems - 8th International Conference, NETYS
2020, Marrakech, Morocco, June 3-5, 2020, Proceedings (Lecture Notes in Computer
Science, Vol. 12129) , Chryssis Georgiou and Rupak Majumdar (Eds.). Springer,
183–191. https://doi.org/10.1007/978-3-030-67087-0_12
[39] Danny Dolev and Rüdiger Reischuk. 1985. Bounds on Information Exchange for
Byzantine Agreement. Journal of the ACM (JACM) 32, 1 (1985), 191–204.
[40] Assia Doudou and André Schiper. 1998. Muteness Detectors for Consensus with
Byzantine Processes. In Proceedings of the Seventeenth Annual ACM Symposium
on Principles of Distributed Computing, PODC ’98, Puerto Vallarta, Mexico, June
28 - July 2, 1998 , Brian A. Coan and Yehuda Afek (Eds.). ACM, 315. https:
//doi.org/10.1145/277697.277772
[41] Sisi Duan, Xin Wang, and Haibin Zhang. 2023. Practical Signature-Free Asyn-
chronous Common Subset in Constant Time. Cryptology ePrint Archive (2023).
[42] C. Dwork, N. Lynch, and L. Stockmeyer. 1988. Consensus in the Presence of
Partial Synchrony. Journal of the Association for Computing Machinery, Vol. 35,
No. 2, pp.288-323 (1988).
[43] Paul Ezhilchelvan, Achour Mostefaoui, and Michel Raynal. 2001. Random-
ized Multivalued Consensus. In Fourth IEEE International Symposium on Object-
Oriented Real-Time Distributed Computing. ISORC 2001 . IEEE, 195–200.
[44] Michael J Fischer and Nancy A Lynch. 1981. A Lower Bound for the Time to Assure
Interactive Consistency . Technical Report. GEORGIA INST OF TECH ATLANTA
SCHOOL OF INFORMATION AND COMPUTER SCIENCE.
[45] Michael J Fischer, Nancy A Lynch, and Michael S Paterson. 1985. Impossibility
of Distributed Consensus with One Faulty Process. Journal of the ACM (JACM)
32, 2 (1985), 374–382.
[46] Matthias Fitzi and Juan A Garay. 2003. Efficient Player-Optimal Protocols for
Strong and Differential Consensus. In Proceedings of the twenty-second annual
symposium on Principles of distributed computing . 211–220.
[47] Zvi Galil, Stuart Haber, and Moti Yung. 1987. Cryptographic Computation:
Secure Fault-Tolerant Protocols and the Public-Key Model. In Conference on the
Theory and Application of Cryptographic Techniques . Springer, 135–155.
[48] Diana Ghinea, Chen-Da Liu-Zhang, and Roger Wattenhofer. 2022. Optimal
Synchronous Approximate Agreement with Asynchronous Fallback. In PODC
’22: ACM Symposium on Principles of Distributed Computing, Salerno, Italy, July
25 - 29, 2022 , Alessia Milani and Philipp Woelfel (Eds.). ACM, 70–80. https:
//doi.org/10.1145/3519270.3538442
[49] Diana Ghinea, Chen-Da Liu-Zhang, and Roger Wattenhofer. 2023. Multidimen-
sional Approximate Agreement with Asynchronous Fallback. Cryptology ePrint
Archive (2023).
[50] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles (Shanghai,
China) (SOSP ’17) . Association for Computing Machinery, New York, NY, USA,
51–68. https://doi.org/10.1145/3132747.3132757
[51] Seth Gilbert, Nancy A Lynch, and Alexander A Shvartsman. 2010. Rambo: A Ro-
bust, Reconfigurable Atomic Memory Service for Dynamic Networks. Distributed
Computing 23, 4 (2010), 225–272.
[52] Rachid Guerraoui and André Schiper. 2001. The Generic Consensus Service.
IEEE Trans. Software Eng. 27, 1 (2001), 29–41. https://doi.org/10.1109/32.895986
[53] Attiya Hagit and Avidor Zvi. 2002. Wait-Free n-Set Consensus When Inputs
Are Restricted. In International Symposium on Distributed Computing . Springer,
326–338.
[54] Maurice Herlihy, Dmitry N. Kozlov, and Sergio Rajsbaum. 2013. Distributed
Computing Through Combinatorial Topology . Morgan Kaufmann. https://store.
elsevier.com/product.jsp?isbn=9780124045781
[55] Maurice Herlihy and Nir Shavit. 1993. The Asynchronous Computability The-
orem for𝑡-Resilient Tasks. In Proceedings of the Twenty-Fifth Annual ACM
Symposium on Theory of Computing, May 16-18, 1993, San Diego, CA, USA ,
S. Rao Kosaraju, David S. Johnson, and Alok Aggarwal (Eds.). ACM, 111–120.
https://doi.org/10.1145/167088.167125
[56] Maurice Herlihy and Nir Shavit. 1999. The Topological Structure of Asynchro-
nous Computability. J. ACM 46, 6 (1999), 858–923. https://doi.org/10.1145/331524.331529
[57] Kim P. Kihlstrom, Louise E. Moser, and Peter M. Melliar-Smith. 2003. Byzantine
Fault Detectors for Solving Consensus. British Computer Society (2003).
[58] Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen Clement, and Edmund
Wong. 2007. Zyzzyva: Speculative Byzantine Fault Tolerance. In Proceedings of
twenty-first ACM SIGOPS symposium on Operating systems principles . 45–58.
[59] Ramakrishna Kotla and Michael Dahlin. 2004. High Throughput Byzantine Fault
Tolerance. In International Conference on Dependable Systems and Networks, 2004 .
IEEE, 575–584.
[60] Dariusz R Kowalski and Achour Mostéfaoui. 2013. Synchronous Byzantine
Agreement with Nearly a Cubic Number of Communication Bits. In Proceedings
of the 2013 ACM symposium on Principles of distributed computing . 84–91.
[61] Leslie Lamport. 2001. Paxos Made Simple. ACM SIGACT News (Distributed
Computing Column) 32, 4 (Whole Number 121, December 2001) (2001), 51–58.
[62] Leslie Lamport, Robert Shostak, and Marshall Pease. 1982. The Byzantine Gen-
erals Problem. ACM Transactions on Programming Languages and Systems 4, 3
(1982), 382–401.
[63] Leslie Lamport, Robert Shostak, and Marshall Pease. 2019. The Byzantine Gener-
als Problem. In Concurrency: the works of leslie lamport . 203–226.
[64] Andrew Lewis-Pye. 2022. Quadratic worst-case message complexity for State Ma-
chine Replication in the partial synchrony model. arXiv preprint arXiv:2201.01107
(2022).
[65] Benoît Libert, Marc Joye, and Moti Yung. 2014. Born and Raised Distributively:
Fully Distributed Non-Interactive Adaptively-Secure Threshold Signatures with
Short Shares. In Proceedings of the 2014 ACM symposium on Principles of dis-
tributed computing . 303–312.
[66] Yuan Lu, Zhenliang Lu, Qiang Tang, and Guiling Wang. 2020. Dumbo-MVBA:
Optimal Multi-Valued Validated Asynchronous Byzantine Agreement, Revisited.
InPODC ’20: ACM Symposium on Principles of Distributed Computing, Virtual
Event, Italy, August 3-7, 2020 , Yuval Emek and Christian Cachin (Eds.). ACM,
129–138. https://doi.org/10.1145/3382734.3405707
[67] Loi Luu, Viswesh Narayanan, Kunal Baweja, Chaodong Zheng, Seth Gilbert, and
Prateek Saxena. 2015. SCP: A Computationally-Scalable Byzantine Consensus
Protocol For Blockchains. Cryptology ePrint Archive (2015).
[68] Nancy A Lynch. 1996. Distributed Algorithms . Elsevier.
[69] Dahlia Malkhi, Kartik Nayak, and Ling Ren. 2019. Flexible Byzantine Fault
Tolerance. In Proceedings of the 2019 ACM SIGSAC conference on computer and
communications security . 1041–1053.
[70] Stathis Maneas, Nikos Chondros, Panos Diamantopoulos, Christos Patsonakis,
and Mema Roussopoulos. 2021. On achieving interactive consistency in real-
world distributed systems. J. Parallel and Distrib. Comput. 147 (2021), 220–235.
[71] Darya Melnyk and Roger Wattenhofer. 2018. Byzantine Agreement with Interval
Validity. In 2018 IEEE 37th Symposium on Reliable Distributed Systems (SRDS) .
IEEE, 251–260.
[72] Hammurabi Mendes and Maurice Herlihy. 2013. Multidimensional Approximate
Agreement in Byzantine Asynchronous Systems. In Symposium on Theory of
Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013 , Dan Boneh,
Tim Roughgarden, and Joan Feigenbaum (Eds.). ACM, 391–400. https://doi.org/
10.1145/2488608.2488657
[73] Hammurabi Mendes, Christine Tasson, and Maurice Herlihy. 2014. Distributed
Computability in Byzantine Asynchronous Systems. In Symposium on Theory
of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014 , David B.
Shmoys (Ed.). ACM, 704–713. https://doi.org/10.1145/2591796.2591853
[74] Atsuki Momose and Ling Ren. 2021. Multi-Threshold Byzantine Fault Tolerance.
InProceedings of the 2021 ACM SIGSAC Conference on Computer and Communi-
cations Security . 1686–1699.
[75] Atsuki Momose and Ling Ren. 2021. Optimal Communication Complexity of Au-
thenticated Byzantine Agreement. In 35th International Symposium on Distributed
Computing, DISC 2021, October 4-8, 2021, Freiburg, Germany (Virtual Conference)
(LIPIcs, Vol. 209) , Seth Gilbert (Ed.). Schloss Dagstuhl - Leibniz-Zentrum für
Informatik, 32:1–32:16. https://doi.org/10.4230/LIPIcs.DISC.2021.32
[76] Shlomo Moran and Yaron Wolfstahl. 1987. Extended Impossibility Results for
Asynchronous Complete Networks. Inform. Process. Lett. 26, 3 (1987), 145–151.
[77] Achour Mostefaoui, Sergio Rajsbaum, and Michel Raynal. 2003. Conditions on
Input Vectors for Consensus Solvability in Asynchronous Distributed Systems.
Journal of the ACM (JACM) 50, 6 (2003), 922–954.
[78] Achour Mostefaoui, Sergio Rajsbaum, and Michel Raynal. 2003. Using Conditions
to Expedite Consensus in Synchronous Distributed Systems. In International
Symposium on Distributed Computing . Springer, 249–263.
[79] Achour Mostefaoui, Sergio Rajsbaum, Michel Raynal, and Matthieu Roy. 2001. A
Hierarchy of Conditions for Consensus Solvability. In Proceedings of the twentieth
annual ACM symposium on Principles of distributed computing . 151–160.
[80] Achour Mostéfaoui, Sergio Rajsbaum, Michel Raynal, and Matthieu Roy. 2002.
Condition-Based Protocols for Set Agreement Problems. In International Sympo-
sium on Distributed Computing . Springer, 48–62.
[81] Achour Mostefaoui, Michel Raynal, and Frédéric Tronel. 2000. From Binary
Consensus to Multivalued Consensus in asynchronous message-passing systems.
Inform. Process. Lett. 73, 5-6 (2000), 207–212.
12On the Validity of Consensus (Extended Version)
[82] Nuno Ferreira Neves, Miguel Correia, and Paulo Verissimo. 2005. Solving Vector
Consensus with a Wormhole. IEEE Transactions on Parallel and Distributed
Systems 16, 12 (2005), 1120–1131.
[83] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. 1980. Reaching
Agreement in the Presence of Faults. J. ACM 27, 2 (1980), 228–234. https:
//doi.org/10.1145/322186.322188
[84] Michel Raynal. 2002. Consensus in Synchronous Systems: A Concise Guided
Tour. In 2002 Pacific Rim International Symposium on Dependable Computing,
2002. Proceedings. IEEE, 221–228.
[85] Vikram Saraph, Maurice Herlihy, and Eli Gafni. 2018. An Algorithmic Approach
to the Asynchronous Computability Theorem. J. Appl. Comput. Topol. 1, 3-4
(2018), 451–474. https://doi.org/10.1007/s41468-018-0014-4
[86] Ulrich Schmid and Bettina Weiss. 2004. Synchronous Byzantine Agreement
under Hybrid Process and Link Failures. (2004).
[87] Victor Shoup. 2000. Practical Threshold Signatures. In Advances in Cryptology
- EUROCRYPT 2000, International Conference on the Theory and Application of
Cryptographic Techniques, Bruges, Belgium, May 14-18, 2000, Proceeding (Lecture
Notes in Computer Science, Vol. 1807) , Bart Preneel (Ed.). Springer, 207–220. https:
//doi.org/10.1007/3-540-45539-6_15
[88] Hin-Sing Siu, Yeh-Hao Chin, and Wei-Pang Yang. 1998. Reaching strong consen-
sus in the presence of mixed failure types. Information Sciences 108, 1-4 (1998),
157–180.
[89] David Stolz and Roger Wattenhofer. 2016. Byzantine Agreement with Median
Validity. In 19th International Conference on Principles of Distributed Systems
(OPODIS 2015) , Vol. 46. Schloss Dagstuhl–Leibniz-Zentrum für Informatik GmbH,
22.
[90] Gadi Taubenfeld, Shmuel Katz, and Shlomo Moran. 1989. Initial Failures in
Distributed Computations. International Journal of Parallel Programming 18, 4
(1989), 255–276.
[91] Nitin H Vaidya and Vijay K Garg. 2013. Byzantine Vector Consensus in Complete
Graphs. In Proceedings of the 2013 ACM symposium on Principles of distributed
computing . 65–73.
[92] Giuliana Santos Veronese, Miguel Correia, Alysson Neves Bessani, Lau Cheuk
Lung, and Paulo Verissimo. 2011. Efficient Byzantine Fault-Tolerance. IEEE Trans.
Comput. 62, 1 (2011), 16–30.
[93] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT Consensus with Linearity and Responsiveness. In
Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing .
347–356.
[94] Yoav Zibin. 2003. Condition-Based Consensus in Synchronous Systems. In
International Symposium on Distributed Computing . Springer, 239–248.
A REMARK ON NON-DETERMINISM
The reader might be aware of several randomized protocols that
achieve expected sub-quadratic communication with a negligible
probability of failure [ 4,16,19,26,32]. This might seem at odds
with our lower bound (Theorem 4). However, this is not the case.
When proving Lemma 5, we show that the adversary has a (de-
terministic) strategy given any deterministic protocol. In particular,
the deterministic strategy of the adversary described in the construc-
tion ofEbase(including GST=0) resolves the pure non-determinism
(e.g., network scheduling) and thus deterministically implies Ebase
and the associated set 𝑆𝑄(similarly forE′
base). However, we did
not demonstrate that an adversary always has a pair of strategies
for every randomized protocol such that the lemma would hold
with a non-negligible probability. Hence, there is no contradiction
whatsoever with the aforementioned randomized protocols.
Extending Theorem 4 to the randomized case with an adaptive
adversary (in the same vein as [4]) is left for future work.
BVECTOR CONSENSUS: PROOFS & OMITTED
ALGORITHMS
In Appendix B.1, we prove the correctness and complexity of our
authenticated implementation of vector consensus (Algorithm 1).
We dedicate Appendix B.2 to a non-authenticated implementationof vector consensus. Finally, in Appendix B.3, we give an imple-
mentation of vector consensus with 𝑂(𝑛2log𝑛)communication
complexity. Throughout the entire section, 𝑛>3𝑡.
B.1 Authenticated Implementation
(Algorithm 1): Proofs
We start this subsection with some clarifications about Quad [28],
a Byzantine consensus algorithm utilized in Algorithm 1. Then, we
prove the correctness and complexity of Algorithm 1.
A note on Quad .In §5.2.1, we claim that Quad satisfies the follow-
ing validity property: if a correct process decides a value-proof pair
(𝑣,Σ), then verify(𝑣,Σ)=true. Technically speaking, the authors of
Quad only consider Weak Validity , i.e., they do not claim that the
their protocol satisfies the aforementioned validity property. How-
ever, modifying their protocol to accommodate for the aforemen-
tioned property is trivial: each correct process simply discards each
message which contains a pair (𝑣,Σ)for which verify(𝑣,Σ)=false.
Another subtle remark is that the authors of Quad prove its
message and latency complexity assuming that all correct processes
start executing Quad by GST. In Algorithm 1, this might not be
the case: correct processes might receive 𝑛−𝑡proposal messages
atGST+𝛿(line 14), and thus start executing Quad atGST+𝛿
(line 17). Nevertheless, it is easy to show that Quad ensures the
stated complexity even if all correct processes start executing the
algorithm by time GST+𝛿. Not only that, even if correct processes
do not start executing Quad within𝛿time after GST, but they all
start executing the algorithm within 𝛿time from each other (after
GST), the message complexity remains quadratic and the latency
remains linear (measured from the time the first correct process
starts executing Quad ).
Correctness & complexity. First, we prove the correctness.
Theorem 6. Algorithm 1 is correct.
Proof. Agreement follows directly from the fact that Quad sat-
isfies Agreement .Termination follows from (1) Termination ofQuad ,
and (2) the fact that, eventually, all correct processes receive 𝑛−𝑡
proposal messages (as there are at least 𝑛−𝑡correct processes).
We now prove that Algorithm 1 satisfies Vector Validity . Let a
correct process 𝑃decide vector′∈I𝑛−𝑡from vector consensus
(line 19). Hence, 𝑃has decided(vector′,Σ′)from Quad , where (1)
Σ′is some proof, and (2) verify(vector′,Σ′)=true (due to the spec-
ification of Quad ). Furthermore, if there exists a process-proposal
pair(𝑃,𝑣∈V𝐼)invector′, where𝑃is a correct process, a properly
signed proposal message belongs to Σ′. As correct processes send
proposal messages only for their proposals (line 9), 𝑣was indeed
proposed by 𝑃. Thus, the theorem. □
Finally, we prove the complexity.
Theorem 7. The message complexity of Algorithm 1 is 𝑂(𝑛2).
Proof. The message complexity of the specific instance of Quad
utilized in Algorithm 1 is 𝑂(𝑛2). Additionally, correct processes
exchange𝑂(𝑛2)proposal messages. Thus, the message complexity
is𝑂(𝑛2)+𝑂(𝑛2)=𝑂(𝑛2). □
13Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
B.2 Non-Authenticated Implementation:
Pseudocode & Proofs
We now present a non-authenticated implementation (Algorithm 3)
of vector consensus. The design of Algorithm 3 follows the reduc-
tion from binary consensus to multivalued consensus (e.g., [ 35]).
Namely, we use the following two building blocks in Algorithm 3:
(1)Byzantine Reliable Broadcast [ 20,23]: This primitive allows
processes to disseminate information in a reliable manner.
Formally, Byzantine reliable broadcast exposes the follow-
ing interface: (1) request broadcast(𝑚), and (2) indication
deliver(𝑚′). The primitive satisfies the following proper-
ties:
•Validity: If a correct process 𝑃broadcasts a message
𝑚,𝑃eventually delivers 𝑚.
•Consistency: No two correct processes deliver different
messages.
•Integrity: Every correct process delivers at most one
message. Moreover, if a correct process delivers a mes-
sage𝑚from a process 𝑃and𝑃is correct, then 𝑃broad-
cast𝑚.
•Totality: If a correct process delivers a message, every
correct process delivers a message.
In Algorithm 3, we use a non-authenticated implementa-
tion [20] of the Byzantine reliable broadcast primitive.
(2)Binary DBFT [ 35], a non-authenticated algorithm which
solves the Byzantine consensus problem with Strong Validity .
Let us briefly explain how Algorithm 3 works; we focus on a
correct process 𝑃𝑖. First,𝑃𝑖reliably broadcasts its proposal (line 10).
Once𝑃𝑖delivers a proposal of some process 𝑃𝑗(line 11),𝑃𝑖proposes
1to the corresponding DBFT instance (line 15). Eventually, 𝑛−𝑡
DBFT instances decide 1(line 16). Once that happens, 𝑃𝑖proposes
0to all DBFT instances to which 𝑃𝑖has not proposed (line 20).
When all DBFT instances have decided (line 21), 𝑃𝑖decides an input
configuration associated with the first 𝑛−𝑡processes whose DBFT
instances decided 1(constructed at line 22).
Theorem 8. Algorithm 3 is correct.
Proof. We start by proving Termination of Algorithm 3. Even-
tually, at least 𝑛−𝑡DBFT instances decide 1due to the fact that (1)
no correct process proposes 0to any DBFT instance unless 𝑛−𝑡
DBFT instances have decided 1(line 16), and (2) all correct processes
eventually propose 1to the DBFT instances which correspond to
the correct processes (unless 𝑛−𝑡DBFT instances have already
decided 1). When𝑛−𝑡DBFT instances decide 1(line 16), each
correct process proposes to all instances to which it has not yet
proposed (line 20). Hence, eventually all DBFT instances decide,
and (at least) 𝑛−𝑡DBFT instances decide 1. Therefore, the rule at
line 21 eventually activates at every correct process, which implies
that every correct process eventually decides (line 23).
Next, we prove Vector Validity . If a correct process 𝑃decides
an input configuration with a process-proposal pair (𝑄,𝑣),𝑃has
delivered a proposal message from 𝑄(line 11). If𝑄is correct, due
to integrity of the reliable broadcast primitive, 𝑄’s proposal was
indeed𝑣.Finally, Agreement follows from (1) Agreement of DBFT, and (2)
consistency of the reliable broadcast primitive. Therefore, Algo-
rithm 3 is correct. □
The main downside of Algorithm 3 is that its message complex-
ity is𝑂(𝑛4). Therefore, non-authenticated version of Universal
has𝑂(𝑛4)message complexity, which is not optimal according to
our lower bound (§5.1). Interestingly, as Algorithm 3 shows that
vector consensus can be solved using consensus with Strong Va-
lidity ,Strong Validity is “another” strongest validity property: a
solution to consensus with Strong Validity yields a solution to any
non-trivial consensus variant (although with additional cost).
B.3 Implementation with 𝑂(𝑛2log𝑛)
Communication: Pseudocode & Proofs
In this subsection, we give an implementation of vector consensus
with𝑂(𝑛2log𝑛)communication complexity, which comes within
a logarithmic factor of the lower bound (§5.1). This implementation
represents a near-linear communication improvement over Algo-
rithm 1 (§5.2), which achieves 𝑂(𝑛3)communication complexity.
We note that the following solution is highly impractical due to its
exponential latency. However, our solution does represent a step
towards closing the existing gap in the communication complexity
of consensus with non-trivial (and solvable) validity properties.
Threshold signatures. For this implementation, we assume a (𝑘,𝑛)-
threshold signature scheme [ 65], where𝑘=𝑛−𝑡. In a threshold
signature scheme, each process holds a distinct private key, and
there exists a single public key. Each process 𝑃𝑖can use its private
key to produce a (partial) signature of a message 𝑚. Moreover, a
signature can be verified by other processes. Finally, a set of signa-
tures for a message 𝑚from𝑘(the threshold) distinct processes can
be combined into a single threshold signature for 𝑚, which proves
that𝑘processes have signed 𝑚.
Hash functions. We denote by hash(·)a collision-resistant hash
function.
B.3.1 Vector Dissemination. First, we formally define the vector
dissemination problem, which plays the crucial role in our vector
consensus algorithm with improved communication complexity. In
this problem, each correct process disseminates a vector of exactly
𝑛−𝑡values, and all correct processes eventually acquire (1) a
hash of some disseminated vector, and (2) a threshold signature for
that hash. Formally, the vector dissemination problem exposes the
following interface:
•request disseminate(Vector vec): a process disseminates a
vector vec.
•indication acquire(Hash _Value𝐻,T_Signature tsig): a pro-
cess acquires a hash value 𝐻′and a threshold signature tsig.
The following properties are required:
•Termination: Every correct process eventually acquires a
hash-signature pair.
•Integrity: If a correct process acquires a hash-signature pair
(𝐻,tsig), then verify _sig(𝐻,tsig)=true.
•Redundancy: Let a correct process cache (i.e., store in its
local memory) a threshold signature tsigfor some hash
14On the Validity of Consensus (Extended Version)
Algorithm 3 Non-Authenticated Vector Consensus: Pseudocode (for process 𝑃𝑖)
1:Uses:
2: Non-Authenticated Byzantine Reliable Broadcast [20], instance brb
3: Binary DBFT [35], instances dbft[1], ...,dbft[𝑛] ⊲one instance of the binary DBFT algorithm per process
4:upon init:
5: Map(Process→V𝐼)proposals𝑖←empty ⊲received proposals
6: Boolean dbft_proposing𝑖=true ⊲is𝑃𝑖still proposing 1s to the DBFT instances
7: Map(Process→Boolean)dbft_proposed𝑖←{false,for every Process}
8: Integer dbft_decisions𝑖←0 ⊲the number of the DBFT instances which have decided
9:upon propose(𝑣∈V𝐼):
10: invoke brb.broadcast ⟨proposal,𝑣⟩⊲broadcast a proposal
11:upon reception of Message𝑚=⟨proposal,𝑣𝑗∈V𝐼⟩from process 𝑃𝑗: ⊲delivered from brb
12: proposals𝑖[𝑃𝑗]←𝑣𝑗
13: ifdbft_proposing𝑖=true:
14: dbft_proposed𝑖[𝑃𝑗]← true
15: invoke dbft[𝑗].propose(1)
16:upon𝑛−𝑡DBFT instances have decided 1 (for the first time):
17: dbft_proposing𝑖←false
18: forevery Process𝑃𝑗such that dbft_proposed𝑖[𝑃𝑗]=false :
19: dbft_proposed𝑖[𝑃𝑗]← true
20: invoke dbft[𝑗].propose(0)
21:upon all DBFT instances decided, and, for the first 𝑛−𝑡processes𝑃𝑗such that dbft[𝑗]decided 1,proposals𝑖[𝑃𝑗]≠⊥:
22: Input _Configuration vector←input configuration with 𝑛−𝑡process-proposal pairs corresponding to the first 𝑛−𝑡DBFT instances which decided 1
23: trigger decide(vector)
value𝐻. Then, (at least) 𝑡+1correct processes have cached
a vector vecsuch that hash(vec)=𝐻.
Slow broadcast. In order to solve the vector dissemination prob-
lem, we present a simple algorithm (Algorithm 4) which implements
slow broadcast . In slow broadcast, each process disseminates its vec-
tor in “one-by-one” fashion, with a “waiting step” between any two
sending events. Specifically, process 𝑃1broadcasts its vector by (1)
sending the vector to 𝑃1(line 3), and then waiting 𝛿time (line 4),
(2) sending the vector to 𝑃2(line 3), and then waiting 𝛿time (line 4),
etc. Process 𝑃2broadcasts its vector in the same manner, but it
waits𝛿·𝑛time (line 4). Crucially, if the system is synchronous,
the waiting time of 𝑃2is (roughly) sufficient for 𝑃1tocompletely
disseminate its vector. This holds for any two processes 𝑃𝑖and𝑃𝑗
with𝑖<𝑗.
Algorithm 4 Slow Broadcast: Pseudocode (for process 𝑃𝑖)
1:upon broadcast(Vector vec):
2: for each Process𝑃𝑗:
3: send⟨slow_broadcast ,vec⟩to𝑃𝑗
4: wait for𝛿·𝑛(𝑖−1)time
5:upon reception of⟨slow_broadcast ,Vector vec′⟩from process 𝑃𝑗:
6: trigger deliver(vec′,𝑃𝑗)
Algorithm description. Our solution is given in Algorithm 5. We
explain it from the perspective of a correct process 𝑃𝑖.
When𝑃𝑖starts disseminating its vector vec(line 8),𝑃𝑖stores
its hash (line 9) and slow-broadcasts the vector (line 10). Once 𝑃𝑖
receives stored messages from 𝑛−𝑡distinct processes (line 17),
𝑃𝑖combines the received partial signatures into a threshold signa-
ture (line 18). Then, 𝑃𝑖broadcasts (using the best-effort broadcast
primitive) the signature (line 19).
Whenever𝑃𝑖receives a threshold signature (line 21), 𝑃𝑖checks
whether the signature is valid (line 22). If it is, 𝑃𝑖rebroadcasts the
signature (line 23), acquires a hash value and the signature (line 24),
and stops participating (i.e., sending and processing messages) invector dissemination (line 25). Observe that, once 𝑃𝑖stops partic-
ipating in vector dissemination (line 25), it stops participating in
slow broadcast, as well.
Correctness & complexity. We start by proving redundancy.
Lemma 9. Algorithm 5 satisfies redundancy.
Proof. Let a correct process cache a threshold signature tsig′
for some hash value 𝐻′. Hence,𝑛−𝑡processes have (partially)
signed𝐻′. Among these 𝑛−𝑡processes, at least 𝑡+1are correct
(as𝑛>3𝑡). Before signing 𝐻′(line 15), all these correct processes
cache a vector vec′(line 14), where hash(vec′)=𝐻′. □
The following lemma proves that, if a correct process 𝑃𝑖starts the
dissemination of its vector at time 𝑡𝑖, then every correct process ac-
quires a hash value and a threshold signature by time max(GST,𝑡𝑖)+
𝛿·𝑛𝑖+3𝛿. We emphasize that the max(GST,𝑡𝑖)+𝛿·𝑛𝑖+3𝛿time is
not tight; we choose it for simplicity of presentation.
Lemma 10. If a correct process 𝑃𝑖starts the dissemination of its
vector at time 𝑡𝑖, every correct process acquires a hash value and a
threshold signature by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+3𝛿.
Proof. We separate the proof into two cases:
•There exists a correct process which acquires a hash-signature
pair by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+2𝛿. In this case, the state-
ment of the lemma holds as every correct process acquires
a pair by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+3𝛿due to the “rebroad-
casting step” (line 23).
•There does not exist a correct process which acquires a hash-
signature pair by time 𝑇=max(GST,𝑡𝑖)+𝛿·𝑛𝑖+2𝛿. Hence,
no process stops participating in vector dissemination by
time𝑇, i.e., no process executes line 25 by time 𝑇. Every
correct process receives a slow_broadcast message from
process𝑃𝑖by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+𝛿.
Thus, by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+2𝛿,𝑃𝑖receives𝑛−𝑡partial
signatures (line 17). Finally, by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+3𝛿,
15Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Algorithm 5 Vector Dissemination: Pseudocode (for process 𝑃𝑖)
1:Uses:
2: Best-Effort Broadcast [23], instance beb ⊲broadcast with no guarantees if the sender is faulty
3: Slow Broadcast, instance slow ⊲see Algorithm 4
4:upon init:
5: Hash _Value𝐻𝑖←⊥ ⊲hash of the message 𝑃𝑖slow-broadcasts
6: Map(Hash _Value→Vector)vectors𝑖←empty ⊲received vectors
7: Set(Process)disseminated 𝑖←empty ⊲processes who have disseminated a vector
8:upon disseminate(Vector vec):
9:𝐻𝑖←hash(vec)
10: invoke slow.broadcast(vec)
11:upon slow.deliver(Vector vec′,Process𝑃𝑗):
12: if𝑃𝑗∉disseminated 𝑖:
13: disseminated 𝑖←disseminated 𝑖∪{𝑃𝑗}
14: vectors𝑖[hash(vec′)]← vec′⊲cache vec′
15: send⟨stored,hash(vec′),partially _sign𝑖 hash(vec′)⟩to𝑃𝑗 ⊲acknowledge the reception by sending a partial signature to 𝑃𝑗
16:⊲acknowledgements are received
17:upon reception of Message𝑚𝑗=⟨stored,Hash _Value𝐻′,P_Signature psig⟩such that𝐻′=𝐻𝑖from𝑛−𝑡distinct processes:
18: T_Signature tsig←combine {psig|psig is a signature received in the stored messages}
19: invoke beb.broadcast ⟨confirm,𝐻𝑖,tsig⟩⊲disseminate the threshold signature
20:⊲a threshold signature is received
21:upon reception of Message𝑚=⟨confirm,Hash _Value𝐻′,T_Signature tsig′⟩:
22: iftsig′is a valid(𝑛−𝑡)-threshold signature for 𝐻′: ⊲check that the threshold signature is valid
23: invoke beb.broadcast ⟨confirm,𝐻′,tsig′⟩⊲rebroadcast the threshold signature
24: trigger acquire(𝐻′,tsig′)
25: stop participating in vector dissemination (and slow broadcast)
every correct process receives a confirm message from 𝑃𝑖
(line 21), and acquires a hash-signature pair (line 24). In
this case, the statement of the lemma holds.
The lemma holds as its statement is satisfies in both cases. □
The next lemma proves that Algorithm 5 satisfies termination.
Lemma 11. Algorithm 5 satisfies termination.
Proof. Follows directly from Lemma 10. □
Next, we prove integrity.
Lemma 12. Algorithm 5 satisfies integrity.
Proof. Follows from the check at line 22. □
Therefore, Algorithm 5 solves the vector dissemination problem.
Theorem 9. Algorithm 5 is correct.
Lastly, we prove that the communication complexity of Algo-
rithm 5 is𝑂(𝑛2). Recall that the communication complexity denotes
the number of words sent by correct processes at and after GST,
where a word consists of a constant number of values, hashes and
signatures.
Theorem 10. Let no correct process start the dissemination of its
vector after time GST+𝛿. Then, the communication complexity of
Algorithm 5 is 𝑂(𝑛2).
Proof. Let𝑖be the minimum index such that (1) process 𝑃𝑖is
correct, and (2) 𝑃𝑖sends a slow_broadcast message at some time
≥GST. If𝑖does not exist, the lemma trivially holds.
Let𝑡𝑖denote the time at which 𝑃𝑖starts the dissemination of its
vector (line 8). By assumption, 𝑡𝑖≤GST+𝛿. Every correct process
acquires a hash-signature pair by time max(GST,𝑡𝑖)+𝛿·𝑛𝑖+3𝛿(by
Lemma 10). Thus, as 𝑡𝑖≤GST+𝛿, every correct process acquires a
hash-signature pair by time GST+𝛿·𝑛𝑖+4𝛿. Moreover, by timeGST+𝛿·𝑛𝑖+4𝛿, all correct processes stop sending slow_broadcast
messages (due to line 25).
Let𝑃𝑗be a correct process such that 𝑗>𝑖. Due to the slow
broadcast primitive (Algorithm 4), 𝑃𝑗has a “waiting step” of (at
least)𝛿·𝑛𝑖time (after GST). Therefore, during the [GST,GST+𝛿·
𝑛𝑖+4𝛿]period,𝑃𝑗can send only 𝑂(1)slow_broadcast messages.
Thus, at most one correct process (i.e., 𝑃𝑖) sends more than 𝑂(1)
slow_broadcast messages during the [GST,GST+𝛿·𝑛𝑖+4𝛿]
period; that process sends at most 𝑛slow_broadcast messages.
As each message is of size 𝑂(𝑛)(since it carries a vector of 𝑛−𝑡
values), the communication complexity of Algorithm 5 is 𝑂(𝑛)·
𝑂(1)·𝑂(𝑛)+1·𝑂(𝑛)·𝑂(𝑛)=𝑂(𝑛2). □
B.3.2 Vector Consensus with 𝑂(𝑛2log𝑛)Communication Complex-
ity.Finally, we are ready to present our vector consensus algorithm
(Algorithm 6) with subcubic communication complexity. Our al-
gorithm consists of three building blocks: (1) vector dissemination
(Appendix B.3.1), (2) Quad (§5.2.1), and (3) add [36], an algorithm
for asynchronous data dissemination. In Algorithm 6, we rely on
a specific instance of Quad in which (1) each proposal value is
a hash value, and (2) given a hash value 𝐻and a Quad ’s proof
Σ,verify(𝐻,Σ)=trueif and only if Σis a valid(𝑛−𝑡)-threshold
signature for 𝐻. Below, we briefly explain add.
add.This algorithm solves the data dissemination [36] problem
defined in the following way. Let 𝑀be a data blob which is an input
of (at least) 𝑡+1correct processes; other correct processes have
⊥as their input. The data dissemination problem requires every
correct process to eventually output 𝑀, and no other message. The
key feature of add is that it solves the problem with 𝑂(𝑛2log𝑛)
communication complexity. (For the full details on add, see [36].)
Algorithm description. We give the description of Algorithm 6
from the perspective of a correct process 𝑃𝑖. When𝑃𝑖proposes
its value (line 10), it disseminates the value (using the best-effort
16On the Validity of Consensus (Extended Version)
broadcast primitive) to all processes (line 11). Once 𝑃𝑖receives
proposals of 𝑛−𝑡distinct processes (line 16), it constructs an input
configuration (line 17), and starts disseminating it (line 18).6
When𝑃𝑖acquires a hash value 𝐻and a threshold signature
tsig(line 19),𝑃𝑖proposes(𝐻,tsig)toQuad (line 21). Observe that
verify(𝐻,tsig)=true(due to the integrity property of vector dis-
semination). Once 𝑃𝑖decides from Quad (line 22), it starts add
(line 24). Specifically, 𝑃𝑖checks whether it has cached an input
configuration whose hash value is 𝐻′(line 23). If so, 𝑃𝑖inputs the
input configuration to add; otherwise, 𝑃𝑖inputs⊥. Once𝑃𝑖outputs
an input configuration from add (line 25), it decides it (line 26).
Correctness & complexity. We start by proving that (1) all correct
processes eventually output a non- ⊥value from add, and (2) no
two correct processes output different values from add.
Lemma 13. The following holds:
•Every correct process eventually outputs a non- ⊥value
from add(line 25); moreover, the output value was an input
(toadd) of a correct process.
•No two correct processes output different input configura-
tions from add (line 25).
Proof. First, every correct process broadcasts its proposal (line
11). Thus, every correct process eventually receives 𝑛−𝑡proposals
(line 16), and starts the dissemination of an input configuration
(line 18). Due to the termination property of vector dissemination
(Lemma 11), every correct process acquires a hash-signature pair
(line 19). Hence, every correct process eventually proposes to Quad
(line 21). Due to Termination ofQuad , every correct process eventu-
ally decides from Quad (line 22), and starts executing add (line 24).
As the pair decided from Quad (recall that Quad satisfies Agree-
ment ) includes a threshold signature, at least 𝑡+1correct processes
have cached an input configuration whose hash value is decided
from Quad (by redundancy of vector dissemination). Therefore,
all of these correct processes input the same non- ⊥value to add
(line 24); let that value be vec. Moreover, no correct process inputs
a different non-⊥value to add. Therefore, the conditions required
byadd are met, which implies that all correct processes eventually
output vec≠⊥from add (line 25). □
The following theorem proves that Algorithm 6 is correct.
Theorem 11. Algorithm 6 is correct.
Proof. Agreement andTermination follow from Lemma 13.
It is left to prove Vector Validity . Letvec′be an input configuration
of𝑛−𝑡proposals decided by a correct process (line 26). Hence,
vec′is an input (to add) of a correct process (by Lemma 13), which
implies that some correct process has previously cached vec′. Before
a correct process caches a vector (Algorithm 5), it verifies that
it is associated with corresponding proposal messages; we omit
this check for brevity. As correct processes only send proposal
messages for their proposals (line 11), Vector Validity is satisfied. □
Lastly, we show the communication complexity of Algorithm 6.
Theorem 12. The communication complexity of Algorithm 6 is
𝑂(𝑛2log𝑛).
6Recall that this input configuration is actually a vector of 𝑛−𝑡values.Proof. The communication complexity of a single best-effort
broadcast instance is 𝑂(𝑛). Every correct process starts the dissemi-
nation of its vector by time GST+𝛿(as every correct process receives
𝑛−𝑡proposals by this time). Thus, the communication complexity of
vector dissemination is 𝑂(𝑛2)(by Theorem 10). The communication
complexity of Quad is𝑂(𝑛2). Moreover, the communication com-
plexity of addis𝑂(𝑛2log𝑛)(see [ 36]). As Algorithm 6 is a composi-
tion of the aforementioned building blocks, its communication com-
plexity is𝑛·𝑂(𝑛)+𝑂(𝑛2)+𝑂(𝑛2)+𝑂(𝑛2log𝑛)=𝑂(𝑛2log𝑛).□
C EXTENDED FORMALISM
In this section, we give intuition behind an extension of our formal-
ism which is suitable for the analysis of blockchain-specific validity
properties, such as External Validity [22,24,93].External Validity
stipulates that any decided value must satisfy a predetermined log-
ical predicate. However, the “difficulty” of this property is that the
logical predicate (usually) verifies a cryptographic proof, which
processes might not know a priori (see Appendix C.1).
In a nutshell, we make our original formalism more expressive
by (1) making the input ( V𝐼) and output (V𝑂) spaces “unknown”
to the processes, and (2) taking into account “proposals” of faulty
processes. In the rest of the paper:
•We refer to the formalism introduced in the main body of
the paper as the “original formalism”.
•We refer to the formalism we introduce below as the “ex-
tended formalism”.
We start by giving an intuition behind our extended formalism
(Appendix C.1). Then, we introduce some preliminaries (Appen-
dix C.2). Finally, we (incompletely) define our extended formalism
(Appendix C.3).
C.1 Intuition
In the original formalism, processes know the entire input space
V𝐼and the entire output space V𝑂. That is, processes are able to
“produce” any value which belongs to V𝐼orV𝑂. However, this
assumption limits the expressiveness of our formalism as it is im-
possible to describe a Byzantine consensus problem in which input
or output spaces are not a priori known. Let us give an example.
Imagine a committee-based blockchain which establishes two
roles:
•Clients are the users of the blockchain. They issue signed
transactions to the blockchain.
•Servers are the operating nodes of the blockchain. Servers
receive signed transactions issued by the clients, and solve
the Byzantine consensus problem to agree on the exact
order the transactions are processed.
As the servers propose transactions signed by the clients and they do
not have access to the private keys of the clients, the servers do not
know the input space V𝐼nor the output space V𝑂of the Byzantine
consensus problem. Hence, our original formalism cannot describe
the Byzantine consensus problem in the core of the aforementioned
blockchain.
Extended vs. original formalism. As highlighted above, the main
difference between the two formalisms is that the extended one
allows us to specify the “knowledge level” of the input and out-
put spaces. In the extended formalism, a process is able to “learn”
17Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Algorithm 6 𝑂(𝑛2log𝑛)Vector Consensus: Pseudocode (for process 𝑃𝑖)
1:Uses:
2: Best-Effort Broadcast [23], instance beb ⊲broadcast with no guarantees if the sender is faulty
3: Vector Dissemination, instance disseminator ⊲see Algorithm 5
4: Quad [28], instance quad
5: add [36], instance add
6:upon init:
7: Integer received _proposals𝑖←0 ⊲the number of received proposals
8: Map(Process→V𝐼)proposals𝑖←empty ⊲received proposals
9: Map(Process→Message)messages𝑖←empty ⊲received proposal messages
10:upon propose(𝑣∈V𝐼):
11: invoke beb.broadcast ⟨proposal,𝑣⟩𝜎𝑖⊲broadcast a signed proposal
12:upon reception of Message𝑚=⟨proposal,𝑣𝑗∈V𝐼⟩𝜎𝑗from process 𝑃𝑗andreceived _proposals𝑖<𝑛−𝑡:
13: received _proposals𝑖←received _proposals𝑖+1
14: proposals𝑖[𝑃𝑗]←𝑣𝑗
15: messages𝑖[𝑃𝑗]←𝑚
16: ifreceived _proposals𝑖=𝑛−𝑡: ⊲received𝑛−𝑡proposals; can start disseminating
17: Input _Configuration vector←input configuration constructed from proposals𝑖
18: invoke disseminator .disseminate(vector)
19:upon disseminator .acquire (Hash _Value H,T_Signature tsig):
20: ifhave not yet proposed to Quad :
21: invoke quad.propose (H,tsig)
22:upon quad.decide (Hash _Value H′,T_Signature tsig′):
23: Input _Configuration vector′←a cached vector whose hash value is 𝐻′⊲can be⊥
24: invoke add.input(vector′)
25:upon add.output Input _Configuration vector′′:
26: trigger decide(vector′′)
output values by observing input values. That is, we define a dis-
covery function that defines which output values are learned given
observed input values. In the committee-based blockchain example,
once a server observes signed (by the issuing clients) transactions
tx1andtx2, it learns the following output values: (1) tx1, (2)tx2, (3)
tx1||tx2, and (4) tx2||tx1.7
The second difference between the original and the extended
formalism is that the extended formalism takes into account “pro-
posals” of the faulty processes. Indeed, the original formalism does
not enable us to define which values are admissible given the adver-
sary’s knowledge of the input space. Think of the aforementioned
example with a blockchain system. If no process (correct or faulty)
obtains a transaction tx,txcannot be decided. However, even if
only a faulty process obtains a transaction tx,txcould still be an
admissible decision. This scenario can be described by the extended
formalism, and not by the original one.
C.2 Preliminaries
We denote byV𝐼the input space of Byzantine consensus. Similarly,
V𝑂denotes the output space.
Membership functions. We define two membership functions :
•valid _input :{0,1}∗→{true,false}: specifies whether a
bit-sequence belongs to the input space V𝐼.
•valid _output :{0,1}∗→{true,false}: specifies whether a
bit-sequence belongs to the output space V𝑂.
We assume that each process has access to these two functions.
That is, each process can verify whether an arbitrary sequence of
bits belongs to the input ( V𝐼) or output (V𝑂) space. In the case
of a committee-based blockchain (Appendix C.1), the membership
functions are signature-verification functions.
7We denote by “||” the concatenation operation.Discovery function. We define a function discover :2V𝐼→2V𝑂.
Given a set of proposals 𝑉𝐼⊆V𝐼,discover(𝑉𝐼)⊆V𝑂specifies the
set of decisions which are “discoverable” by 𝑉𝐼. We assume that
each process has access to the discover(·)function. Moreover, for
any two sets 𝑉1
𝐼,𝑉2
𝐼with𝑉1
𝐼⊆𝑉2
𝐼,discover(𝑉1
𝐼)⊆discover(𝑉2
𝐼); in
other words, “knowledge” of the output space can only be improved
upon learning more input values.
Let us take a look at the committee-based blockchain example
again (Appendix C.1). If a server obtains a proposal tx, it learns tx
as a potential decision. We model this “deduction” concept using
thediscover(·)function: discover {tx}={tx}.
Adversary pool. Given an execution E,P(E)⊆V 𝐼defines the
adversary pool inE. Informally, the adversary pool represents the
input values the adversary “knows”. In the example of a committee-
based blockchain (Appendix C.1), the adversary pool is a set of
signed transactions which the adversary “learns” from the clients.
We underline that the adversary pool is an abstract concept.
Specifically, the adversary pool represents the “starting knowledge”
the adversary has. However, the notion of the “starting knowledge”
must be precisely defined once all particularities of the exact con-
sidered system are taken into account. Due to sophisticated details
(such as the aforementioned one), we believe that a formalism suit-
able for blockchain-specific validity properties deserves its own
standalone paper.
C.3 Validity
We start by restating the definition of process-proposal pairs. A
process-proposal pair is a pair(𝑃,𝑣), where (1)𝑃∈Πis a process, and
(2)𝑣∈V𝐼is a proposal. Given a process-proposal pair pp=(𝑃,𝑣),
proposal(pp)=𝑣denotes the proposal associated with pp.
18On the Validity of Consensus (Extended Version)
Aninput configuration is a tuple
pp1,pp2,...,pp𝑥,𝜌
of𝑥process-
proposal pairs and a set 𝜌⊆V𝐼, where (1)𝑛−𝑡≤𝑥≤𝑛, (2) every
process-proposal pair is associated with a distinct process, and (3)
if𝑥=𝑛,𝜌=∅. Intuitively, an input configuration represents an
assignment of proposals to correct processes, as well as a “part”
of the input space known to the adversary. For example, an input
configuration
(𝑃1,𝑣),(𝑃2,𝑣),(𝑃3,𝑣),{𝑣,𝑣′,𝑣′′}describes an exe-
cution in which (1) only processes 𝑃1,𝑃2, and𝑃3are correct, (2)
processes𝑃1,𝑃2, and𝑃3propose the same value 𝑣, and (3) faulty
processes know only 𝑣,𝑣′, and𝑣′′.
We denote byIthe set of all input configurations. For every
input configuration 𝑐∈I, we denote by 𝑐[𝑖]the process-proposal
pair associated with process 𝑃𝑖; if such a process-proposal pair
does not exist, 𝑐[𝑖]=⊥. Moreover, we define by pool(𝑐)the set
of input values associated with 𝑐(the “𝜌” field of𝑐). Next,𝜋(𝑐)=
{𝑃𝑖∈Π|𝑐[𝑖]≠⊥}denotes the set of all processes included in
𝑐. Finally, correct _proposals(𝑐)={𝑣∈V𝐼|∃𝑖∈ [1,𝑛]:𝑐[𝑖]≠
⊥∧proposal(𝑐[𝑖])=𝑣}denotes the set of all proposals of correct
processes (as specified by 𝑐).
Given (1) an execution E∈execs(A), whereAis an algorithm
with the propose(·)/decide(·)interface, and (2) an input configura-
tion𝑐∈I, we say thatEcorresponds to𝑐(input _conf(E)=𝑐) if and
only if (1)𝜋(𝑐)=CorrA(E), (2) for every process 𝑃𝑖∈CorrA(E),
𝑃𝑖’s proposal inEisproposal(𝑐[𝑖]), and (3)P(E) =pool(𝑐).
A validity property valis a function val:I→ 2V𝑂such that, for
every input configuration 𝑐∈I,val(c)≠∅. AlgorithmA, where
Aexposes the propose(·)/decide(·)interface, satisfies a validity
property valif and only if, in any execution E ∈ execs(A), no
correct process decides a value 𝑣′∉val input _conf(E). That is,
an algorithm satisfies a validity property if and only if correct
processes decide only admissible values.
Assumptions on executions. Lastly, we introduce two assumptions
that conclude our proposal for the extended formalism.
Assumption 1. For every execution Eof any algorithmAwhich
solves the Byzantine consensus problem with some validity prop-
erty, if a correct process 𝑃decides a value 𝑣′∈V𝑂inE, then𝑣′∈
discover correct _proposals(𝑐)∪pool(𝑐), where input _conf(E)=
𝑐.
Assumption 1 states that correct processes can only decide values
which are “discoverable” using all the proposals of correct processes
and the knowledge of the adversary. For example, if every correct
process proposes the same value 𝑣∈V𝐼and the adversary pool
contains only 𝑣′∈V𝐼, then a correct process can only decide a
value from discover({𝑣,𝑣′}).
Next, we introduce an assumption concerned only with the
canonical executions (executions in which faulty processes do not
take any computational step).
Assumption 2. For every canonical execution Eof any algorithm
Awhich solves the Byzantine consensus problem with some valid-
ity property, if a correct process 𝑃decides a value 𝑣′∈V𝑂inE, then
𝑣′∈discover correct _proposals(𝑐), where input _conf(E)=𝑐.
Intuitively, Assumption 2 states that, if faulty processes are silent,
correct processes can only decide values which can be discoveredusing their own proposals. In other words, correct processes can-
not use “hidden” proposals (possessed by the silent adversary) to
discover a decision.
Finally, we underline that these two assumptions do not com-
pletely prevent “unreasonable” executions. For example, given these
two assumptions, a (correct or faulty) process is still able to send a
message with a value which cannot be discovered using the pro-
posals of correct processes and the adversary pool. Hence, an as-
sumption that prevents such an execution should be introduced.
Thus, due to the complexity of the extended formalism, we leave
it out of this paper. In the future, we will focus on this interesting
and important problem.
19
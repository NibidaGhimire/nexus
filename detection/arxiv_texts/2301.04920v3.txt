On the Validity of Consensus (Extended Version)
Pierre Civit
Sorbonne University
FranceSeth Gilbert
NUS Singapore
SingaporeRachid Guerraoui
Ã‰cole Polytechnique FÃ©dÃ©rale de
Lausanne (EPFL)
Switzerland
Jovan Komatovic
Ã‰cole Polytechnique FÃ©dÃ©rale de
Lausanne (EPFL)
SwitzerlandManuel Vidigueira
Ã‰cole Polytechnique FÃ©dÃ©rale de
Lausanne (EPFL)
Switzerland
ABSTRACT
The Byzantine consensus problem involves ğ‘›processes, out of
whichğ‘¡<ğ‘›could be faulty and behave arbitrarily. Three properties
characterize consensus: (1) termination, requiring correct (non-
faulty) processes to eventually reach a decision, (2) agreement,
preventing them from deciding different values, and (3) validity,
precluding â€œunreasonableâ€ decisions. But, what is a reasonable
decision? Strong validity, a classical property, stipulates that, if all
correct processes propose the same value, only that value can be
decided. Weak validity, another established property, stipulates that,
if all processes are correct and they propose the same value, that
value must be decided. The space of possible validity properties is
vast. Yet, their impact on consensus algorithms remains unclear.
This paper addresses the question of which validity properties
allow Byzantine consensus to be solvable in a general partially
synchronous model, and at what cost. First, we determine the nec-
essary and sufficient conditions for a validity property to make the
consensus problem solvable; we say that such validity properties
aresolvable . Notably, we prove that, if ğ‘›â‰¤3ğ‘¡, all solvable validity
properties are trivial (there exists an always-admissible decision).
Furthermore, we show that, with any non-trivial (and solvable)
validity property, consensus requires Î©(ğ‘¡2)messages. This extends
the seminal Dolev-Reischuk bound, originally proven for strong
validity, to allnon-trivial validity properties. Lastly, we give a Byzan-
tine consensus algorithm, we call Universal , for anysolvable (and
non-trivial) validity property. Importantly, Universal incursğ‘‚(ğ‘›2)
message complexity. Thus, together with our lower bound, Uni-
versal implies a fundamental result in partial synchrony: with
ğ‘¡âˆˆÎ©(ğ‘›), the message complexity of all (non-trivial) consensus
variants is Î˜(ğ‘›2).
CCS CONCEPTS
â€¢Computing methodologies â†’Distributed algorithms .
KEYWORDS
Byzantine consensus, Solvability, Message complexity, Lower bound
1 INTRODUCTION
Consensus [ 62] is the cornerstone of state machine replication
(SMR) [ 1,9,10,25,58,59,69,74,92], as well as various distributed
algorithms [ 14,47,51,52]. Recently, it has received a lot of atten-
tion with the advent of blockchain systems [ 6,7,21,33,35,50,67].
The consensus problem is posed in a system of ğ‘›processes, out ofwhichğ‘¡<ğ‘›can be faulty , and the rest correct . Each correct process
proposes a value, and consensus enables correct processes to de-
cide on a common value. In this paper, we consider Byzantine [ 62]
consensus, where faulty processes can behave arbitrarily. While
the exact definition of the problem might vary, two properties are
always present: (1) termination , requiring correct processes to even-
tually decide, and (2) agreement , preventing them from deciding
different values. It is not hard to devise an algorithm that satisfies
only these two properties: every correct process decides the same,
predetermined value. However, this algorithm is vacuous. To pre-
clude such trivial solutions and render consensus meaningful, an
additional property is required â€“ validity â€“ defining which decisions
are admissible.
The many faces of validity. The literature contains many flavors
of validity [ 2,5,28,29,35,46,57,71,88,89,93]. One of the most
studied properties is Strong Validity [5,28,35,57], stipulating that,
if all correct processes propose the same value, only that value can
be decided. Another common property is Weak Validity [28,29,93],
affirming that, if all processes are correct and propose the same
value, that value must be decided. While validity may appear as an
inconspicuous property, its exact definition has a big impact on our
understanding of consensus algorithms. For example, the seminal
Dolev-Reischuk bound [ 39] states that any solution to consensus
with Strong Validity incurs a quadratic number of messages; it was
recently proven that the bound is tight [ 28,64,75]. In contrast,
while there have been several improvements to the performance
of consensus with Weak Validity over the last 40 years [ 28,64,93],
the (tight) lower bound on message complexity remains unknown.
(Although the bound is conjectured to be the same as for Strong Va-
lidity , this has yet to be formally proven.) Many other fundamental
questions remain unanswered:
â€¢What does it take for a specific validity property to make
consensus solvable?
â€¢What are the (best) upper and lower bounds on the mes-
sage complexity of consensus with any specific validity
property?
â€¢Is there a hierarchy of validity properties (e.g., a â€œstrongestâ€
validity property)?
To the best of our knowledge, no in-depth study of the validity
property has ever been conducted, despite its importance and the
emerging interest from the research community [3, 31].
Contributions. We propose a precise mathematical formalism for
the analysis of validity properties. We define a validity property as
1arXiv:2301.04920v3  [cs.DC]  26 Jun 2023Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
a mapping from assignments of proposals into admissible decisions.
Although simple, our formalism enables us to determine the exact
impact of validity on the solvability and complexity of consensus
in the classical partially synchronous model [ 42], and answer the
aforementioned open questions. Namely, we provide the following
contributions:
â€¢We classify all validity properties into solvable and unsolv-
able ones. (If a validity property makes consensus solvable,
we say that the property itself is solvable .) Specifically, for
ğ‘›â‰¤3ğ‘¡, we show that only trivial validity properties (for
which there exists an always-admissible decision) are solv-
able. In the case of ğ‘›>3ğ‘¡, we define the similarity condition ,
which we prove to be necessary and sufficient for a validity
property to be solvable.
â€¢We prove that all non-trivial (and solvable) validity proper-
ties require Î©(ğ‘¡2)exchanged messages. This result extends
the Dolev-Reischuk bound [ 39], proven only for Strong Va-
lidity , toallâ€œreasonableâ€ validity properties.
â€¢Finally, we present Universal , a consensus algorithm for
all solvable (and non-trivial) validity properties. Assuming
a public-key infrastructure, Universal exchangesğ‘‚(ğ‘›2)
messages. Thus, together with our lower bound, Universal
implies a fundamental result in partial synchrony: given
ğ‘¡âˆˆÎ©(ğ‘›), all (non-trivial) consensus variants have Î˜(ğ‘›2)
message complexity. Figure 1 summarizes our findings.
trivial non-trivialsolvableValidity
properties  
Figure 1: Illustration of our results: (1) with ğ‘›â‰¤3ğ‘¡, all solvable
validity properties are trivial; (2) the exact set of solvable validity
properties (as determined by our necessary and sufficient
conditions); (3) all non-trivial (and solvable) validity properties
require Î©(ğ‘¡2)exchanged messages; (4) for any non-trivial (and
solvable) validity property, there exists a consensus algorithm with
ğ‘‚(ğ‘›2)message complexity.
Technical overview. In our formalism, we use the notion of an
input configuration that denotes an assignment of proposals to
correct processes. For example,
(ğ‘ƒ1,ğ‘£),(ğ‘ƒ2,ğ‘£),(ğ‘ƒ3,ğ‘£)
represents
an input configuration by which (1) only processes ğ‘ƒ1,ğ‘ƒ2, andğ‘ƒ3
are correct, and (2) processes ğ‘ƒ1,ğ‘ƒ2, andğ‘ƒ3proposeğ‘£.
First, we define a similarity relation between input configura-
tions: two input configurations are similar if and only if (1) they
have (at least) one process in common, and (2) for every commonprocess, the processâ€™s proposal is identical in both input configura-
tions. For example, an input configuration ğ‘=
(ğ‘ƒ1,0),(ğ‘ƒ2,1)is
similar toğ‘â€²=
(ğ‘ƒ1,0),(ğ‘ƒ3,0)
, but not to
(ğ‘ƒ1,0),(ğ‘ƒ2,0)
. We ob-
serve that all similar input configurations must have an admissible
value in common; we call this canonical similarity . Let us illustrate
why a common admissible value must exist. Consider the afore-
mentioned similar input configurations ğ‘=
(ğ‘ƒ1,0),(ğ‘ƒ2,1)and
ğ‘â€²=
(ğ‘ƒ1,0),(ğ‘ƒ3,0)
. If there is no common admissible value for ğ‘
andğ‘â€², consensus cannot be solved: process ğ‘ƒ1cannot distinguish (1)
an execution in which ğ‘ƒ2is correct, and ğ‘ƒ3is faulty and silent, from
(2) an execution in which ğ‘ƒ2is faulty, but behaves correctly, and ğ‘ƒ3
is correct, but slow. Thus, ğ‘ƒ1cannot conclude whether it needs to
decide an admissible value for ğ‘or forğ‘â€². Canonical similarity is a
critical intermediate result that we use extensively throughout the
paper (even if it does not directly imply any of our results).
In our proof of triviality with ğ‘›â‰¤3ğ‘¡, we intertwine the classical
partitioning argument [ 63] with our canonical similarity result.
Namely, we show that, for any input configuration, there exists
an execution in which the same value ğ‘¥is decided, making ğ‘¥an
always-admissible value. For our lower bound, while following the
idea of the original proof [ 4,39], we rely on canonical similarity to
prove the bound for all solvable and non-trivial validity properties.
Finally, we design Universal by relying on vector consensus [ 34,
40,82,91], a problem in which processes agree on the proposals of
ğ‘›âˆ’ğ‘¡processes: when a correct process decides a vector vecofğ‘›âˆ’ğ‘¡
proposals (from vector consensus), it decides from Universal the
common admissible value for all input configurations similar to vec.
For example, consider an execution which corresponds to an input
configuration ğ‘. If, in this execution, a correct process decides a
vector vecfrom vector consensus, it is guaranteed that vecis similar
toğ‘(the proposals of correct processes are identical in ğ‘and in
vec). Hence, deciding (from Universal ) the common admissible
value for all input configurations similar to vecguarantees that the
decided value is admissible according to ğ‘.
Roadmap. We provide an overview of related work in Â§2. In
Â§3, we specify the system model (Â§3.1), define the consensus prob-
lem (Â§3.2), describe our formalism for validity properties (Â§3.3),
and present canonical similarity (Â§3.4). We define the necessary
conditions for the solvability of validity properties in Â§4. In Â§5,
we prove a quadratic lower bound on message complexity for all
non-trivial (and solvable) validity properties (Â§5.1), and introduce
Universal , a general consensus algorithm for any solvable (and
non-trivial) validity property (Â§5.2). We conclude the paper in Â§6.
The appendix contains (1) omitted proofs and algorithms, and (2)
a proposal for how to extend our formalism to accommodate for
blockchain-specific validity properties.
2 RELATED WORK
Solvability of consensus. The consensus problem has been thor-
oughly investigated in a variety of system settings and failure mod-
els. It has been known (for long) that consensus can be solved in
a synchronous setting, both with crash [ 23,68,84] and arbitrary
failures [ 5,60,75,84,86]. In an asynchronous environment, how-
ever, consensus cannot be solved deterministically even if a single
process can fail, and it does so only by crashing; this is the seminal
FLP impossibility result [45].
2On the Validity of Consensus (Extended Version)
A traditional way of circumventing the FLP impossibility result
israndomization [8,11,12,43,66], where termination of consensus
is not ensured deterministically. Another well-established approach
to bypass the FLP impossibility is to strengthen the communication
model with partial synchrony [42]: the communication is asynchro-
nous until some unknown time, and then it becomes synchronous.
The last couple of decades have produced many partially synchro-
nous consensus algorithms [22, 25, 28, 29, 35, 42, 61, 64, 68, 93].
Another line of research has consisted in weakening the def-
inition of consensus to make it deterministically solvable under
asynchrony. In the condition-based approach [ 77], the specification
of consensus is relaxed to require termination only if the assignment
of proposals satisfies some predetermined conditions. The efficiency
of this elegant approach has been studied further in [ 79]. Moreover,
the approach is extended to the synchronous setting [ 78,94], as
well as to the ğ‘˜-set agreement problem [53, 80].
Solvability of general decision problems. A distributed decision
problem has been defined in [ 30,56,73] as a mapping from input
assignments to admissible decisions. Our validity formalism is of the
same nature, and it is inspired by the aforementioned specification
of decision problems.
The solvability of decision problems has been thoroughly stud-
ied in asynchronous, crash-prone settings. It was shown in [ 76]
that the FLP impossibility result [ 45] can be extended to many
decision problems. In [ 17], the authors defined the necessary and
sufficient conditions for a decision problem to be asynchronously
solvable with a single crash failure. The asynchronous solvability
of problems in which crash failures occur at the very beginning
of an execution was studied in [ 90]. The necessary and sufficient
conditions for a decision problem to be asynchronously solvable (as-
suming a crash-prone setting) in a randomized manner were given
in [27]. The topology-based approach on studying the solvability
of decision problems in asynchrony has proven to be extremely
effective, both for crash [ 54,55,85] and arbitrary failures [ 54,73].
Our results follow the same spirit as many of these approaches;
however, we study the deterministic solvability and complexity of
all consensus variants in a partially synchronous environment.
Validity of consensus. Various validity properties have been as-
sociated with the consensus problem (beyond the aforementioned
Strong Validity andWeak Validity ).Correct-Proposal Validity [46,88]
states that a value decided by a correct process must have been
proposed by a correct process. Median Validity [89] is a validity
property proposed in the context of synchronous consensus, re-
quiring the decision to be close to the median of the proposals of
correct processes. Interval Validity [71], on the other hand, requires
the decision to be close to the ğ‘˜-th smallest proposal of correct
processes. The advent of blockchain technologies has resurged the
concept of External Validity [22,24,93]. This property requires the
decided value to satisfy a predetermined predicate, typically assert-
ing whether the decided value follows the rules of a blockchain
system (e.g., no double-spending). (This paper considers a simple
formalism to express basic validity properties and derive our re-
sults. To express External Validity , which is out of the scope of the
paper, we propose an incomplete extension of our formalism in
Appendix C, and leave its realization for future work.) Convex-Hull
Validity , which states that the decision must belong to the convexhull of the proposals made by the correct processes, is employed
in approximate agreement [ 2,48,49,72]. We underline that the
approximate agreement problem is not covered in this paper since
the problem allows correct processes to disagree as long as their
decisions are â€œcloseâ€ to each other. In our paper, we do study (in
a general manner) the utilization of Convex-Hull Validity in the
classical consensus problem (in which the correct processes are
required to â€œexactlyâ€ agree).
In interactive consistency [ 13,44,70], correct processes agree
on the proposals of all correct processes. Given that the problem
is impossible in a non-synchronous setting, a weaker variant has
been considered: vector consensus [ 15,34,40,41,82,91]. Here,
processes need to agree on a vector of proposals which does not
necessarily include the proposals of allcorrect processes. Inter-
active consistency and vector consensus can be seen as specific
consensus problems with a validity property requiring that, if a de-
cided vector contains a proposal ğ‘£of a correct process, that correct
process has indeed proposed ğ‘£. The design of Universal , our gen-
eral consensus algorithm for any solvable (and non-trivial) validity
property, demonstrates that any non-trivial flavor of consensus
which is solvable in partial synchrony can be solved using vector
consensus (see Â§5.2).
3 PRELIMINARIES
In this section, we present the computational model (Â§3.1), recall
the consensus problem (Â§3.2), formally define validity properties
(Â§3.3), and introduce canonical similarity (Â§3.4).
3.1 Computational Model
Processes. We consider a system Î ={ğ‘ƒ1,ğ‘ƒ2,...,ğ‘ƒğ‘›}ofğ‘›pro-
cesses; each process is a deterministic state machine. At most ğ‘¡
(0<ğ‘¡<ğ‘›) processes can be faulty : those processes can exhibit
arbitrary behavior. A non-faulty process is said to be correct . Pro-
cesses communicate by exchanging messages over an authenticated
point-to-point network. The communication network is reliable : if
a correct process sends a message to a correct process, the message
is eventually received. Each process has its own local clock, and no
process can take infinitely many computational steps in finite time.
Executions. Given an algorithm A,execs(A) denotes the set of
all executions ofA. Furthermore, CorrA(E)denotes the set of
correct processes in an execution Eâˆˆ execs(A). We say that an
executionEâˆˆexecs(A) iscanonical if and only if no faulty process
takes any computational step in E; note that faulty processes do
not send any message in a canonical execution. Moreover, observe
that any execution Ewith CorrA(E)=Î is canonical.
Partial synchrony. We consider the standard partially synchro-
nous model [ 42]. For every execution of the system, there exists a
Global Stabilization Time (GST) and a positive duration ğ›¿such that
message delays are bounded by ğ›¿after GST. GST is not known to
the processes, whereas ğ›¿is. We assume that all correct processes
start executing their local algorithm before or at GST. Local clocks
may drift arbitrarily before GST, but do not drift thereafter.
We remark that (almost) all results presented in the paper hold
even ifğ›¿is unknown. Namely, the classification of all validity prop-
erties remains the same: if a validity property is solvable (resp.,
3Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
unsolvable) with known ğ›¿, then the validity property is solvable
(resp., unsolvable) with unknown ğ›¿. Moreover, the quadratic lower
bound on the message complexity trivially extends to the model in
whichğ›¿is unknown. However, the question of whether the bound
is tight when ğ›¿is unknown does remain open.
Cryptographic primitives. In one variant of the Universal al-
gorithm, we assume a public-key infrastructure (PKI). In fact, this
variant relies on a closed-box consensus algorithm which internally
utilizes a PKI. In a PKI, every process knows the public key of every
other process, and, when needed, processes sign messages using
digital signatures. We denote by âŸ¨ğ‘šâŸ©ğœğ‘–a messageğ‘šsigned by the
processğ‘ƒğ‘–. Crucially, faulty processes cannot forge signatures of
correct processes.
Message complexity. LetAbe any algorithm and let Eâˆˆexecs(A)
be any execution of A. The message complexity of Eis the number
of messages sent by correct processes during [GST,âˆ).
The message complexity ofAis defined as
max
Eâˆˆexecs(A)
message complexity of E
.
3.2 Consensus
We denote byVğ¼the (potentially infinite) set of values processes can
propose, and byVğ‘‚the (potentially infinite) set of values processes
can decide. Consensus1exposes the following interface:
â€¢request propose(ğ‘£âˆˆVğ¼): a process proposes a value ğ‘£.
â€¢indication decide(ğ‘£â€²âˆˆVğ‘‚): a process decides a value ğ‘£â€².
A correct process proposes exactly once, and it decides at most
once. Consensus requires the following properties:
â€¢Termination: Every correct process eventually decides.
â€¢Agreement: No two correct processes decide different val-
ues.
If the consensus problem was completely defined by Termination
andAgreement , a trivial solution would exist: processes decide on a
default value. Therefore, the specification of consensus additionally
includes a validity property, which connects the proposals of correct
processes to admissible decisions, precluding the aforementioned
trivial solutions.
3.3 Validity
In a nutshell, our specification of a validity property includes a set
of assignments of proposals to correct processes, and, for each such
assignment, a corresponding set of admissible decisions.
We start by defining a process-proposal pair as a pair(ğ‘ƒ,ğ‘£), where
(1)ğ‘ƒâˆˆÎ is a process, and (2) ğ‘£âˆˆVğ¼is a proposal. Given a process-
proposal pair pp=(ğ‘ƒ,ğ‘£),proposal(pp)=ğ‘£denotes the proposal
associated with pp.
Aninput configuration is a tuple
pp1,pp2,...,ppğ‘¥
ofğ‘¥process-
proposal pairs, where (1) ğ‘›âˆ’ğ‘¡â‰¤ğ‘¥â‰¤ğ‘›, and (2) every process-
proposal pair is associated with a distinct process. Intuitively, an
input configuration represents an assignment of proposals to cor-
rect processes. For example,
(ğ‘ƒ1,ğ‘£),(ğ‘ƒ2,ğ‘£),(ğ‘ƒ3,ğ‘£),(ğ‘ƒ4,ğ‘£),(ğ‘ƒ5,ğ‘£)
is an input configuration describing an execution in which (1) only
processesğ‘ƒ1,ğ‘ƒ2,ğ‘ƒ3,ğ‘ƒ4andğ‘ƒ5are correct, and (2) all of them pro-
pose the same value ğ‘£.
1In the paper, we use â€œconsensusâ€ and â€œByzantine consensusâ€ interchangeably.We denote byIthe set of all input configurations. Furthermore,
for everyğ‘¥âˆˆ[ğ‘›âˆ’ğ‘¡,ğ‘›],Iğ‘¥âŠ‚I denotes the set of input config-
urations with exactlyğ‘¥process-proposal pairs. For every input
configuration ğ‘âˆˆI, we denote by ğ‘[ğ‘–]the process-proposal pair
associated with process ğ‘ƒğ‘–; if such a process-proposal pair does not
exist,ğ‘[ğ‘–]=âŠ¥. Lastly,ğœ‹(ğ‘)={ğ‘ƒğ‘–âˆˆÎ |ğ‘[ğ‘–]â‰ âŠ¥}denotes the set
of all processes included in ğ‘.
Given (1) an execution Eof an algorithmA, whereAexposes
thepropose(Â·)/decide(Â·)interface, and (2) an input configuration
ğ‘âˆˆI, we say thatEcorresponds toğ‘(input _conf(E)=ğ‘) if and
only if (1)ğœ‹(ğ‘)=CorrA(E), and (2) for every process ğ‘ƒğ‘–âˆˆğœ‹(ğ‘),
ğ‘ƒğ‘–â€™s proposal inEisproposal(ğ‘[ğ‘–]).
Finally, we define a validity property valas a function val:Iâ†’
2Vğ‘‚such that, for every input configuration ğ‘âˆˆI,val(c)â‰ âˆ….
An algorithmA, whereAexposes the propose(Â·)/decide(Â·)in-
terface, satisfies a validity property valif and only if, in any ex-
ecutionE âˆˆ execs(A), no correct process decides a value ğ‘£â€²âˆ‰
val input _conf(E). That is, an algorithm satisfies a validity prop-
erty if and only if correct processes decide only admissible values.
Traditional properties in our formalism. To illustrate the expres-
siveness of our formalism, we describe how it can be used for Strong
Validity ,Weak Validity andCorrect-Proposal Validity . For all of them,
Vğ¼=Vğ‘‚.Weak Validity can be expressed as
val(ğ‘)=(
{ğ‘£},if(ğœ‹(ğ‘)=Î )âˆ§(âˆ€ğ‘ƒğ‘–âˆˆğœ‹(ğ‘):proposal(ğ‘[ğ‘–])=ğ‘£)
Vğ‘‚,otherwise,
whereas Strong Validity can be expressed as
val(ğ‘)=(
{ğ‘£},ifâˆ€ğ‘ƒğ‘–âˆˆğœ‹(ğ‘):proposal(ğ‘[ğ‘–])=ğ‘£
Vğ‘‚,otherwise.
Finally, Correct-Proposal Validity can be expressed as
val(ğ‘)={ğ‘£|âˆƒğ‘ƒğ‘–âˆˆğœ‹(ğ‘):proposal(ğ‘[ğ‘–])=ğ‘£}.
Consensus algorithms. An algorithmAsolves consensus with a
validity property valif and only if the following holds:
â€¢ A exposes the propose(Â·)/decide(Â·)interface, and
â€¢ A satisfies Termination ,Agreement andval.
Lastly, we define the notion of a solvable validity property.
Definition 1 (Solvable validity property) .We say that a validity
property valissolvable if and only if there exists an algorithm
which solves consensus with val.
3.4 Canonical Similarity
In this subsection, we introduce canonical similarity , a crucial in-
termediate result. In order to do so, we first establish an important
relation between input configurations, that of similarity .
Similarity. We define the similarity relation (â€œ âˆ¼â€) between input
configurations:
âˆ€ğ‘1,ğ‘2âˆˆI:ğ‘1âˆ¼ğ‘2â‡â‡’
(ğœ‹(ğ‘1)âˆ©ğœ‹(ğ‘2)â‰ âˆ…)âˆ§(âˆ€ğ‘ƒğ‘–âˆˆğœ‹(ğ‘1)âˆ©ğœ‹(ğ‘2):ğ‘1[ğ‘–]=ğ‘2[ğ‘–]).
In other words, ğ‘1is similar to ğ‘2if and only if (1) ğ‘1andğ‘2have
(at least) one process in common, and (2) for every common process,
the processâ€™s proposal is identical in both input configurations. For
4On the Validity of Consensus (Extended Version)
example, when ğ‘›=3andğ‘¡=1,ğ‘=
(ğ‘ƒ1,0),(ğ‘ƒ2,1),(ğ‘ƒ3,0)
is simi-
lar to
(ğ‘ƒ1,0),(ğ‘ƒ3,0)
, whereasğ‘is not similar to
(ğ‘ƒ1,0),(ğ‘ƒ2,0)
.
Note that the similarity relation is symmetric (for every pair ğ‘1,ğ‘2âˆˆ
I,ğ‘1âˆ¼ğ‘2â‡”ğ‘2âˆ¼ğ‘1) and reflexive (for every ğ‘âˆˆI,ğ‘âˆ¼ğ‘).
For every input configuration ğ‘âˆˆI, we define sim(ğ‘):
sim(ğ‘)={ğ‘â€²âˆˆI|ğ‘â€²âˆ¼ğ‘}.
The result. LetAbe an algorithm which solves consensus with
some validity property val. Our canonical similarity result states
that, in any canonical execution which corresponds to some input
configuration ğ‘,Acan only decide a value which is admissible for
allinput configurations similar to ğ‘. Informally, the reason is that
correct processes cannot distinguish silent faulty processes from
slow correct ones.
Lemma 1 (Canonical similarity) .Letvalbe any solvable validity
property and letAbe any algorithm which solves the consensus
problem with val. LetEâˆˆ execs(A) be any (potentially infinite)
canonical execution and let input _conf(E)=ğ‘, for some input
configuration ğ‘âˆˆI. If a value ğ‘£â€²âˆˆVğ‘‚is decided by a correct
process inE, thenğ‘£â€²âˆˆÃ‘
ğ‘â€²âˆˆsim(ğ‘)val(ğ‘â€²).
Proof. We prove the lemma by contradiction. Suppose that
ğ‘£â€²âˆ‰Ã‘
ğ‘â€²âˆˆsim(ğ‘)val(ğ‘â€²). Hence, there exists an input configuration
ğ‘â€²âˆˆsim(ğ‘)such thatğ‘£â€²âˆ‰val(ğ‘â€²). IfEis infinite, letEğ‘ƒâ†E .
Otherwise, letEğ‘ƒdenote any infinite continuation of Esuch that (1)
Eğ‘ƒis canonical, and (2) input _conf(Eğ‘ƒ)=ğ‘. Letğ‘ƒbe any process
such thatğ‘ƒâˆˆğœ‹(ğ‘â€²)âˆ©ğœ‹(ğ‘); such a process exists as ğ‘â€²âˆ¼ğ‘. AsA
satisfies Termination andAgreement ,Eğ‘ƒis an infinite execution,
andğ‘ƒis correct inEğ‘ƒ,ğ‘ƒdecidesğ‘£â€²inEğ‘ƒ. LetSdenote the set of
all processes which take a computational step in Eğ‘ƒuntilğ‘ƒdecides
ğ‘£â€²; note thatSâŠ†ğœ‹(ğ‘)andğ‘ƒâˆˆS.
In the next step, we construct another execution Eâ€²âˆˆexecs(A)
such that input _conf(Eâ€²)=ğ‘â€²:
(1)Eâ€²is identical toEğ‘ƒuntil process ğ‘ƒdecidesğ‘£â€².
(2)All processes not in ğœ‹(ğ‘â€²)are faulty inEâ€²(they might be-
have correctly until ğ‘ƒhas decided), and all processes in
ğœ‹(ğ‘â€²)are correct inEâ€².
(3)Afterğ‘ƒhas decided, processes in ğœ‹(ğ‘â€²)\S â€œwake upâ€ with
the proposals specified in ğ‘â€².
(4)GST is set to after all processes in ğœ‹(ğ‘â€²)have taken a com-
putational step.
For every process ğ‘ƒğ‘–âˆˆ Sâˆ©ğœ‹(ğ‘â€²), the proposal of ğ‘ƒğ‘–inEâ€²is
proposal(ğ‘â€²[ğ‘–]); recall that ğ‘â€²[ğ‘–]=ğ‘[ğ‘–]asğ‘â€²âˆ¼ğ‘andS âŠ†ğœ‹(ğ‘).
Moreover, for every process ğ‘ƒğ‘—âˆˆğœ‹(ğ‘â€²)\S , the proposal of ğ‘ƒğ‘—in
Eâ€²isproposal(ğ‘â€²[ğ‘—])(due to the step 3 of the construction). Hence,
input _conf(Eâ€²)=ğ‘â€². Furthermore, process ğ‘ƒ, which is correct in
Eâ€², decidesğ‘£â€²(due to the step 1 of the construction). As ğ‘£â€²âˆ‰val(ğ‘â€²),
we reach a contradiction with the fact that Asatisfies val, which
proves the lemma. â–¡
We underline that Lemma 1 does not rely on anyassumptions
onğ‘›andğ‘¡. In other words, Lemma 1 is applicable to any algorithm
irrespectively of the parameters ğ‘›andğ‘¡(as long as 0<ğ‘¡<ğ‘›).4 NECESSARY SOLVABILITY CONDITIONS
This section gives the necessary conditions for the solvability of
validity properties. We start by focusing on the case of ğ‘›â‰¤3ğ‘¡:
we prove that, if ğ‘›â‰¤3ğ‘¡, all solvable validity properties are trivial
(Â§4.1). Then, we consider the case of ğ‘›>3ğ‘¡: we define the similarity
condition, and prove its necessity for solvability (Â§4.2).
4.1 Triviality of Solvable Validity Properties if
ğ‘›â‰¤3ğ‘¡
Some validity properties, such as Weak Validity andStrong Validity ,
are known to be unsolvable with ğ‘›â‰¤3ğ‘¡[42,83]. This seems to
imply a split of validity properties depending on the resilience
threshold. We prove that such a split indeed exists for ğ‘›â‰¤3ğ‘¡,
and, importantly, that it applies to allsolvable validity properties.
Implicitly, this means that there is no â€œusefulâ€ relaxation of the
validity property that can tolerate ğ‘¡â‰¥âŒˆğ‘›/3âŒ‰failures. Concretely,
we prove the following theorem:
Theorem 1. If any validity property valis solvable with ğ‘›â‰¤3ğ‘¡,
then the validity property is trivial, i.e., there exists a value ğ‘£â€²âˆˆVğ‘‚
such thatğ‘£â€²âˆˆÃ‘
ğ‘âˆˆIval(ğ‘).
Before presenting the proof of the theorem, we introduce the
compatibility relation between input configurations, which we use
throughout this subsection.
Compatibility. We define the compatibility relation (â€œ â‹„â€) between
input configurations:
âˆ€ğ‘1,ğ‘2âˆˆI:ğ‘1â‹„ğ‘2â‡â‡’
 |ğœ‹(ğ‘1)âˆ©ğœ‹(ğ‘2)|â‰¤ğ‘¡âˆ§ ğœ‹(ğ‘1)\ğœ‹(ğ‘2)â‰ âˆ…âˆ§ ğœ‹(ğ‘2)\ğœ‹(ğ‘1)â‰ âˆ….
That is,ğ‘1is compatible with ğ‘2if and only if (1) there are at most
ğ‘¡processes in common, (2) there exists a process which belongs to
ğ‘1and does not belong to ğ‘2, and (3) there exists a process which
belongs toğ‘2and does not belong to ğ‘1. For example, when ğ‘›=3
andğ‘¡=1,ğ‘=
(ğ‘ƒ1,0),(ğ‘ƒ2,0)
is compatible with
(ğ‘ƒ1,1),(ğ‘ƒ3,1)
,
whereasğ‘is not compatible with
(ğ‘ƒ1,1),(ğ‘ƒ2,1),(ğ‘ƒ3,1)
. Observe
that the compatibility relation is symmetric and irreflexive.
Proof of Theorem 1. Throughout the rest of the subsection, we
fix any validity property valwhich is solvable with ğ‘›â‰¤3ğ‘¡; our aim
is to prove the triviality of val. Moreover:
â€¢We assume that ğ‘›â‰¤3ğ‘¡.
â€¢We fix any algorithm Awhich solves consensus with val.
â€¢We fix any input configuration baseâˆˆIğ‘›âˆ’ğ‘¡with exactly
ğ‘›âˆ’ğ‘¡process-proposal pairs.
â€¢We fix any infinite canonical execution Ebaseâˆˆexecs(A)
such that input _conf(Ebase)=base. AsAsatisfies Termi-
nation andval, andEbaseis infinite, some value ğ‘£baseâˆˆ
val(base)is decided by a correct process in Ebase.
First, we show that only ğ‘£basecan be decided in any canonical
execution which corresponds to any input configuration compatible
with base. If a value different from ğ‘£baseis decided, we can apply
the classical partitioning argument [ 62]: the adversary causes a dis-
agreement by partitioning processes into two disagreeing groups.
Lemma 2. Letğ‘âˆˆIbe any input configuration such that ğ‘â‹„base.
LetEğ‘âˆˆexecs(A) be any (potentially infinite) canonical execution
5Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
such that input _conf(Eğ‘)=ğ‘. If a valueğ‘£ğ‘âˆˆVğ‘‚is decided by a
correct process inEğ‘, thenğ‘£ğ‘=ğ‘£base.
Proof. By contradiction, suppose that some value ğ‘£ğ‘â‰ ğ‘£base
is decided by a correct process in Eğ‘. Sinceğ‘â‹„base, there exists a
processğ‘„âˆˆğœ‹(ğ‘)\ğœ‹(base). IfEğ‘is infinite, letEğ‘„
ğ‘â†Eğ‘. Otherwise,
letEğ‘„
ğ‘be an infinite canonical continuation of Eğ‘. The following
holds for process ğ‘„: (1)ğ‘„decidesğ‘£ğ‘inEğ‘„
ğ‘(asAsatisfies Agreement
and Termination ), and (2)ğ‘„is silent inEbase. Letğ‘¡ğ‘„denote the
time at which ğ‘„decides inEğ‘„
ğ‘. Similarly, there exists a process
ğ‘ƒâˆˆğœ‹(base)\ğœ‹(ğ‘); note that (1) ğ‘ƒdecidesğ‘£baseinEbase, and (2)ğ‘ƒ
is silent inEğ‘„
ğ‘. Letğ‘¡ğ‘ƒdenote the time at which ğ‘ƒdecides inEbase.
In the next step, we construct an execution Eâˆˆ execs(A) by
â€œmergingâ€EbaseandEğ‘„
ğ‘:
(1)We separate processes into 4 groups: (1) group ğ´=ğœ‹(base)\
ğœ‹(ğ‘), (2) groupğµ=ğœ‹(base)âˆ©ğœ‹(ğ‘), (3) groupğ¶=ğœ‹(ğ‘)\
ğœ‹(base), and (4) group ğ·=Î \(ğ´âˆªğµâˆªğ¶).
(2)Processes in ğµbehave towards processes in ğ´as inEbase,
and towards processes in ğ¶as inEğ‘„
ğ‘.
(3)Communication between groups ğ´andğ¶is delayed until
after time max(ğ‘¡ğ‘ƒ,ğ‘¡ğ‘„).
(4)Processes in group ğ·â€œwake upâ€ at time ğ‘‡ğ·>max(ğ‘¡ğ‘ƒ,ğ‘¡ğ‘„)
(with any proposals), and behave correctly throughout the
entire execution.
(5) We set GST to after ğ‘‡ğ·.
The following holds for E:
â€¢Processes in Î \ğµare correct inE. In other words, only
processes in ğµare faulty inE. Recall that|ğµ|â‰¤ğ‘¡asbaseâ‹„ğ‘.
â€¢Processğ‘„, which is correct in E, cannot distinguish Efrom
Eğ‘„
ğ‘until after time max(ğ‘¡ğ‘ƒ,ğ‘¡ğ‘„). Hence, process ğ‘„decides
ğ‘£ğ‘inE.
â€¢Processğ‘ƒ, which is correct in E, cannot distinguish Efrom
Ebaseuntil after time max(ğ‘¡ğ‘ƒ,ğ‘¡ğ‘„). Hence, process ğ‘ƒdecides
ğ‘£baseâ‰ ğ‘£ğ‘inE.
Therefore, we reach a contradiction with the fact that Asatisfies
Agreement . Thus,ğ‘£ğ‘=ğ‘£base. â–¡
Observe that the proposals of an input configuration compatible
with base do not influence the decision: given an input configuration
ğ‘âˆˆI,ğ‘â‹„base, onlyğ‘£basecan be decided in any canonical execution
which corresponds to ğ‘,irrespectively of the proposals.
Next, we prove a direct consequence of Lemma 2: for every input
configuration ğ‘ğ‘›âˆˆIğ‘›, there exists an infinite execution Eğ‘›such
that (1)Eğ‘›corresponds to ğ‘ğ‘›, and (2)ğ‘£baseis decided inEğ‘›.
Lemma 3. For any input configuration ğ‘ğ‘›âˆˆIğ‘›, there exists an
infinite executionEğ‘›âˆˆexecs(A) such that (1) input _conf(Eğ‘›)=
ğ‘ğ‘›, and (2)ğ‘£baseis decided inEğ‘›.
Proof. Fix any input configuration ğ‘ğ‘›âˆˆIğ‘›. We construct an
input configuration ğ‘ğ‘›âˆ’ğ‘¡âˆˆIğ‘›âˆ’ğ‘¡:
(1)For every process ğ‘ƒğ‘–âˆ‰ğœ‹(base), we include a process-
proposal pair(ğ‘ƒğ‘–,ğ‘£)inğ‘ğ‘›âˆ’ğ‘¡such thatğ‘£=proposal(ğ‘ğ‘›[ğ‘–]).
Note that there are ğ‘¡such processes as|ğœ‹(base)|=ğ‘›âˆ’ğ‘¡.
(2)We include any ğ‘›âˆ’2ğ‘¡process-proposal pairs (ğ‘ƒğ‘–,ğ‘£)inğ‘ğ‘›âˆ’ğ‘¡
such that (1) ğ‘ƒğ‘–âˆˆğœ‹(base), and (2)ğ‘£=proposal(ğ‘ğ‘›[ğ‘–]). That
is, we â€œcompleteâ€ ğ‘ğ‘›âˆ’ğ‘¡(constructed in the step 1) with ğ‘›âˆ’2ğ‘¡process-proposal pairs such that the process is â€œborrowedâ€
from base, and its proposal is â€œborrowedâ€ from ğ‘ğ‘›.
Observe that ğ‘ğ‘›âˆ’ğ‘¡â‹„base as (1)|ğœ‹(ğ‘ğ‘›âˆ’ğ‘¡)âˆ©ğœ‹(base)|â‰¤ğ‘¡(ğ‘›âˆ’2ğ‘¡â‰¤ğ‘¡
whenğ‘›â‰¤3ğ‘¡), (2) there exists a process ğ‘ƒâˆˆğœ‹(base)\ğœ‹(ğ‘ğ‘›âˆ’ğ‘¡)
(while constructing ğ‘ğ‘›âˆ’ğ‘¡, we excluded ğ‘¡>0processes from base;
step 2), and (3) there exists a process ğ‘„âˆˆğœ‹(ğ‘ğ‘›âˆ’ğ‘¡)\ğœ‹(base)(we
includedğ‘¡>0processes in cnâˆ’twhich are not in base; step 1).
LetEğ‘›âˆ’ğ‘¡âˆˆexecs(A) denote any infinite canonical execution
such that input _conf(Eğ‘›âˆ’ğ‘¡)=ğ‘ğ‘›âˆ’ğ‘¡. AsAsatisfies Termination ,
some value is decided by correct processes in Eğ‘›âˆ’ğ‘¡; due to Lemma 2,
that value is ğ‘£base. Finally, we are able to construct an infinite
executionEğ‘›âˆˆexecs(A) such that (1) input _conf(Eğ‘›)=ğ‘ğ‘›, and
(2)ğ‘£baseis decided inEğ‘›:
(1) All processes are correct in Eğ‘›.
(2)Until some correct process ğ‘ƒâˆˆğœ‹(ğ‘ğ‘›âˆ’ğ‘¡)decidesğ‘£base,Eğ‘›
is identical toEğ‘›âˆ’ğ‘¡. LetSdenote the set of all processes
which take a computational step in Eğ‘›âˆ’ğ‘¡untilğ‘ƒdecides
ğ‘£base; note thatSâŠ†ğœ‹(ğ‘ğ‘›âˆ’ğ‘¡)andğ‘ƒâˆˆS.
(3)Afterwards, every process ğ‘„âˆ‰Sâ€œwakes upâ€ with the
proposal specified in ğ‘ğ‘›.
(4) GST occurs after all processes have taken a step.
Therefore,ğ‘£baseis indeed decided in Eğ‘›andinput _conf(Eğ‘›)=ğ‘ğ‘›,
which concludes the proof. â–¡
We are now ready to prove that valis trivial. We do so by showing
that, for any input configuration ğ‘âˆˆI,ğ‘£baseâˆˆval(ğ‘).
Lemma 4. Validity property valis trivial.
Proof. We fix any input configuration ğ‘âˆˆI. Let us distinguish
two possible scenarios:
â€¢Letğ‘âˆˆIğ‘›. There exists an infinite execution Eğ‘âˆˆexecs(A)
such that (1) input _conf(Eğ‘)=ğ‘, and (2)ğ‘£baseis decided
inEğ‘(by Lemma 3). AsAsatisfies val,ğ‘£baseâˆˆval(ğ‘).
â€¢Letğ‘âˆ‰Iğ‘›. We construct an input configuration ğ‘ğ‘›âˆˆIğ‘›in
the following way:
(1) Letğ‘ğ‘›â†ğ‘.
(2)For every process ğ‘ƒâˆ‰ğœ‹(ğ‘),(ğ‘ƒ,any proposal)is in-
cluded inğ‘ğ‘›.
Due to the construction of ğ‘ğ‘›,ğ‘ğ‘›âˆ¼ğ‘. By Lemma 3, there
exists an infinite execution Eğ‘›âˆˆexecs(A) such that (1)
input _conf(Eğ‘›)=ğ‘ğ‘›, and (2)ğ‘£baseis decided inEğ‘›;Eğ‘›is a
canonical execution as all processes are correct. Therefore,
canonical similarity ensures that ğ‘£baseâˆˆval(ğ‘)(Lemma 1).
In both possible cases, ğ‘£baseâˆˆval(ğ‘). Thus, the theorem. â–¡
Lemma 4 concludes the proof of Theorem 1, as Lemma 4 proves
thatval, any solvable validity property with ğ‘›â‰¤3ğ‘¡, is trivial. Fig-
ure 2 depicts the proof of Theorem 1. Since this subsection shows
that consensus cannot be useful when ğ‘›â‰¤3ğ‘¡, the rest of the paper
focuses on the case of ğ‘›>3ğ‘¡.
Remark. As Theorem 1 shows, any validity property which is
solvable with ğ‘›â‰¤3ğ‘¡is trivial. However, we now strengthen the
aforementioned necessary condition for solvable validity properties
withğ‘›â‰¤3ğ‘¡.
6On the Validity of Consensus (Extended Version)
Lemma 2base
Lemma 3  Lemma 4  All input  
configurations0 0 0 0A A A AA A A A A A
A A A A
A A A AA A A A A ALemma 4 
Lemma 4
 
Figure 2: Theorem 1: Overview of the proof in the case of ğ‘›=6,
ğ‘¡=2, and base=
(ğ‘ƒ1,0),(ğ‘ƒ2,0),(ğ‘ƒ3,0),(ğ‘ƒ4,0)
.
Theorem 2. If any validity property valis solvable with ğ‘›â‰¤3ğ‘¡,
then there exists a finite procedure always _admissible which returns
a valueğ‘£â€²âˆˆVğ‘‚such thatğ‘£â€²âˆˆÃ‘
ğ‘âˆˆIval(ğ‘).
Proof. We prove the theorem by contradiction. Hence, sup-
pose that there exists a validity property valwhich is solvable
withğ‘›â‰¤3ğ‘¡, and that there does not exist a finite procedure
always _admissible which returns a value ğ‘£â€²âˆˆVğ‘‚such thatğ‘£â€²âˆˆÃ‘
ğ‘âˆˆIval(ğ‘). Asvalis solvable, there exists an algorithm Awhich
solves consensus with val.
Let us fix any input configuration baseâˆˆ Iğ‘›âˆ’ğ‘¡(as done in
the proof of Theorem 1). Moreover, let ğ‘£basebe the value decided
inany infinite canonical execution Ebaseâˆˆexecs(A) such that
input _conf(Ebase)=base; observe that the prefix of Ebaseis fi-
nite as processes can take only finitely many steps in finite time.
As proven in the proof of Theorem 1, ğ‘£baseâˆˆval(ğ‘), for any in-
put configuration ğ‘âˆˆI. Hence, there exists a finite procedure
always _admissible which returns a value admissible according to
all input configurations ( Ais such a procedure). Thus, we reach a
contradiction, which concludes the proof. â–¡
Theorem 2 states that, if a validity property is solvable with
ğ‘›â‰¤3ğ‘¡, not only that the property is trivial (as proven by Theo-
rem 1), but there exists a finite procedure which retrieves an always-
admissible value. Thus, Theorem 2 strictly extends Theorem 1. Ob-
serve that, if ğ‘›â‰¤3ğ‘¡and a validity property is associated with
a finite procedure always _admissible which retrieves an always-
admissible value, solving consensus with that specific properties
is trivial: each process immediately decides the value returned by
always _admissible . Thus, an existence of the always _admissible
procedure is a necessary and sufficient condition for solvable valid-
ity properties with ğ‘›â‰¤3ğ‘¡.
4.2 Similarity Condition: Necessary Solvability
Condition
This subsection defines the similarity condition, and proves its
necessity for solvable validity properties.
Definition 2 (Similarity condition) .A validity property valsatis-
fies the similarity condition (Cğ‘†, in short) if and only if there exists
a Turing-computable function Î›:Iğ‘›âˆ’ğ‘¡â†’Vğ‘‚such that:
âˆ€ğ‘âˆˆIğ‘›âˆ’ğ‘¡:Î›(ğ‘)âˆˆÃ™
ğ‘â€²âˆˆsim(ğ‘)val(ğ‘â€²).
Cğ‘†states that, for every input configuration ğ‘âˆˆIğ‘›âˆ’ğ‘¡, there ex-
ists a Turing-computable function Î›(ğ‘)which retrieves a commonadmissible decision among all input configurations similar to ğ‘.2
The necessity ofCğ‘†follows from the canonical similarity result: in
any infinite canonical execution, a common admissible value must
be decided (Lemma 1).
Theorem 3. Any solvable validity property satisfies Cğ‘†.
Proof. By the means of contradiction, let there exist a valid-
ity property valsuch that (1) valdoes not satisfyCğ‘†, and (2) val
is solvable. LetAbe any algorithm which solves the Byzantine
consensus problem with val. Asvaldoes not satisfyCğ‘†, there does
not exist a Turing-computable function Î›:Iğ‘›âˆ’ğ‘¡â†’Vğ‘‚such that,
for every input configuration ğ‘âˆˆIğ‘›âˆ’ğ‘¡,Î›(ğ‘)âˆˆÃ‘
ğ‘â€²âˆˆsim(ğ‘)val(ğ‘â€²).
Fix any input configuration ğ‘âˆˆIğ‘›âˆ’ğ‘¡for which Î›(ğ‘)is not de-
fined or not Turing-computable. Let Eğ‘âˆˆexecs(A) be an infinite
canonical execution such that (1) input _conf(Eğ‘)=ğ‘, (2) the sys-
tem is synchronous from the very beginning ( GST=0), and (3)
the message delays are exactly ğ›¿. In other words,Eğ‘unfolds in a
â€œlock-stepâ€ manner. As Asatisfies Termination andEğ‘is an infinite
execution, some value ğ‘£ğ‘âˆˆVğ‘‚is decided by a correct process in
Eğ‘; observe that the prefix of Eğ‘in whichğ‘£ğ‘is decided is finite as
processes take only finitely many steps in finite time. By canonical
similarity (Lemma 1), ğ‘£ğ‘âˆˆÃ‘
ğ‘â€²âˆˆsim(ğ‘)val(ğ‘â€²). Hence, Î›(ğ‘)is defined
(Î›(ğ‘)=ğ‘£ğ‘) and Turing-computable ( Acomputes it). Therefore, we
reach a contradiction with the fact that Î›(ğ‘)is not defined or not
Turing-computable, which concludes the proof. â–¡
Notice that, for proving the necessity of Cğ‘†(Theorem 3), we do
not rely on the ğ‘›>3ğ‘¡assumption. Thus,Cğ‘†is necessary for allsolv-
able validity properties (irrespectively of the resilience threshold).
However, as proven in Â§4.1, Cğ‘†is not sufficient when ğ‘›â‰¤3ğ‘¡: e.g.,
Weak Validity satisfiesCğ‘†, but it is unsolvable with ğ‘›â‰¤3ğ‘¡[42,83].
(Observe that any solvable validity property with ğ‘›â‰¤3ğ‘¡satisfies
Cğ‘†.)
5 LOWER BOUND & GENERAL ALGORITHM
First, we show that any non-trivial and solvable validity property
requires Î©(ğ‘¡2)messages to be exchanged (Â§5.1). Then, we present
Universal , a general algorithm that, if ğ‘›>3ğ‘¡, solves consensus
with any validity property which satisfies Cğ‘†(Â§5.2). Thus, Univer-
salproves the sufficiency of Cğ‘†whenğ‘›>3ğ‘¡.
5.1 Lower Bound on Message Complexity
In this subsection, we prove the following theorem:
Theorem 4. If an algorithm solves consensus with a non-trivial
validity property, the message complexity of the algorithm is Î©(ğ‘¡2).
Theorem 4 extends the seminal Dolev-Reischuk bound [ 39],
proven only for consensus with Strong Validity , to all non-trivial
consensus variants. To prove Theorem 4, we intertwine the idea of
the original proof [39] with canonical similarity (Lemma 1).
2A function is Turing-computable if there exists a finite procedure to compute it.
7Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Proof of Theorem 4. In our proof, we show that any algorithm
which solves Byzantine consensus with a non-trivial validity prop-
erty has a synchronous execution in which correct processes send
more than(ğ‘¡
2)2messages. Hence, throughout the entire subsection,
we fix a non-trivial and solvable validity property val. Moreover,
we fixA, an algorithm which solves Byzantine consensus with val.
Asvalis a non-trivial validity property, ğ‘›>3ğ‘¡(Â§4.1).
Next, we define a specific infinite execution Ebaseâˆˆexecs(A):
(1) GST =0. That is, the system is synchronous throughout
the entire execution.
(2)All processes are separated into two disjoint groups: (1)
groupğ´, with|ğ´|=ğ‘›âˆ’âŒˆğ‘¡
2âŒ‰, and (2) group ğµ, with|ğµ|=âŒˆğ‘¡
2âŒ‰.
(3)All processes in the group ğ´are correct, whereas all pro-
cesses in the group ğµare faulty.
(4)We fix any value ğ‘£âˆ—âˆˆVğ¼. For every correct process ğ‘ƒğ´âˆˆğ´,
the proposal of ğ‘ƒğ´inEbaseisğ‘£âˆ—.
(5)For every faulty process ğ‘ƒğµâˆˆğµ,ğ‘ƒğµbehaves correctly in
Ebasewith its proposal being ğ‘£âˆ—, except that (1) ğ‘ƒğµignores
the firstâŒˆğ‘¡
2âŒ‰messages received from other processes, and
(2)ğ‘ƒğµomits sending messages to other processes in ğµ.
To prove Theorem 4, it suffices to show that the message complexity
ofEbaseis greater than(âŒˆğ‘¡
2âŒ‰)2. By contradiction, let the correct
processes (processes in ğ´) sendâ‰¤(âŒˆğ‘¡
2âŒ‰)2messages inEbase.
The first step of our proof shows that, given that correct pro-
cesses sendâ‰¤(âŒˆğ‘¡
2âŒ‰)2messages inEbase, there must exist a process
ğ‘„âˆˆğµwhich can correctly decide some value ğ‘£ğ‘„âˆˆVğ‘‚without
receiving anymessage from any other process. We prove this claim
using the pigeonhole principle.
Lemma 5. There exist a value ğ‘£ğ‘„âˆˆVğ‘‚and a process ğ‘„âˆˆğµsuch
thatğ‘„has a correct local behavior ğ›½ğ‘„in which (1) ğ‘„decidesğ‘£ğ‘„,
and (2)ğ‘„receives no messages from other processes.
Proof. By assumption, correct processes (i.e., processes in the
groupğ´) sendâ‰¤(âŒˆğ‘¡
2âŒ‰)2messages inEbase. Therefore, due to the
pigeonhole principle, there exists a process ğ‘„âˆˆğµwhich receives
at mostâŒˆğ‘¡
2âŒ‰messages (from other processes) in Ebase. Recall that ğ‘„
behaves correctly in Ebasewith its proposal being ğ‘£âˆ—âˆˆVğ¼, except
that (1)ğ‘„ignores the firstâŒˆğ‘¡
2âŒ‰messages received from other pro-
cesses, and (2) ğ‘„does not send any messages to other processes in
the groupğµ. We denote by ğ‘†ğ‘„the set of processes, not including
ğ‘„, which send messages to ğ‘„inEbase;|ğ‘†ğ‘„|â‰¤âŒˆğ‘¡
2âŒ‰.
Next, we construct an infinite execution Eâ€²
base. ExecutionEâ€²
base
is identical toEbase, except that:
(1)Processes in(ğ´âˆª{ğ‘„})\ğ‘†ğ‘„are correct; other processes are
faulty. That is, we make ğ‘„correct inEâ€²
base, and we make
all processes in ğ‘†ğ‘„faulty inEâ€²
base.
(2)Processes in ğµ\{ğ‘„}behave exactly as in Ebase. Moreover,
processes in ğ‘†ğ‘„behave exactly as in Ebase, except that they
do not send any message to ğ‘„.
Due to the construction of Eâ€²
base, processğ‘„does not receive any
message (from any other process) in Eâ€²
base. Asğ‘„is correct inEâ€²
base
andAsatisfies Termination ,ğ‘„decides some value ğ‘£ğ‘„âˆˆVğ‘‚inEâ€²
base.
Thus,ğ‘„has a correct local behavior ğ›½ğ‘„in which it decides ğ‘£ğ‘„âˆˆVğ‘‚
without having received messages from other processes. â–¡The previous proof concerns deterministic protocols and uses a
deterministic adversarial strategy. We invite the reader to Appen-
dix A for a remark on non-determinism.
In the second step of our proof, we show that there exists an
infinite execution in which (1) ğ‘„is faulty and silent, and (2) correct
processes decide some value ğ‘£â‰ ğ‘£ğ‘„.
Lemma 6. There exists an infinite execution Eğ‘£such that (1) ğ‘„
is faulty and silent in Eğ‘£, and (2) a value ğ‘£â‰ ğ‘£ğ‘„is decided by a
correct process.
Proof. Asvalis a non-trivial validity property, there exists an
input configuration ğ‘âˆŒğ‘£ğ‘„âˆˆIsuch thatğ‘£ğ‘„âˆ‰val(ğ‘âˆŒğ‘£ğ‘„); recall that
ğ‘£ğ‘„is the value that ğ‘„can correctly decide without having received
any message from any other process (Lemma 5). We consider two
possible cases:
â€¢Letğ‘„âˆ‰ğœ‹(ğ‘âˆŒğ‘£ğ‘„). Thus,Eğ‘£is any infinite canonical exe-
cution which corresponds to ğ‘âˆŒğ‘£ğ‘„. Asğ‘£ğ‘„âˆ‰val(ğ‘âˆŒğ‘£ğ‘„), the
value decided inEğ‘£must be different from ğ‘£ğ‘„(asAsatisfies
val).
â€¢Letğ‘„âˆˆğœ‹(ğ‘âˆŒğ‘£ğ‘„). We construct an input configuration
ğ‘âˆŒğ‘„âˆˆIsuch thatğ‘„âˆ‰ğœ‹(ğ‘âˆŒğ‘„):
(1) Letğ‘âˆŒğ‘„â†ğ‘âˆŒğ‘£ğ‘„.
(2)We remove(ğ‘„,Â·)fromğ‘âˆŒğ‘„. That is, we remove ğ‘„â€™s
process-proposal pair from ğ‘âˆŒğ‘„.
(3)If|ğœ‹(ğ‘âˆŒğ‘£ğ‘„)|=ğ‘›âˆ’ğ‘¡, we add(ğ‘,any proposal)toğ‘âˆŒğ‘„,
whereğ‘is any process such that ğ‘âˆ‰ğœ‹(ğ‘âˆŒğ‘£ğ‘„); note
that such a process ğ‘exists asğ‘¡>0.
Due to the construction of ğ‘âˆŒğ‘„,ğ‘âˆŒğ‘„âˆ¼ğ‘âˆŒğ‘£ğ‘„. Indeed, (1)
ğœ‹(ğ‘âˆŒğ‘„)âˆ©ğœ‹(ğ‘âˆŒğ‘£ğ‘„)â‰ âˆ…(asğ‘›âˆ’ğ‘¡âˆ’1>0whenğ‘›>3ğ‘¡and
ğ‘¡>0), and (2) for every process ğ‘ƒâˆˆğœ‹(ğ‘âˆŒğ‘„)âˆ©ğœ‹(ğ‘âˆŒğ‘£ğ‘„), the
proposal of ğ‘ƒis identical in ğ‘âˆŒğ‘„andğ‘âˆŒğ‘£ğ‘„.
In this case,Eğ‘£is any infinite canonical execution such
thatinput _conf(Eğ‘£)=ğ‘âˆŒğ‘„. AsAsatisfies Termination and
Eğ‘£is infinite, some value ğ‘£âˆˆVğ‘‚is decided by a correct
process inEğ‘£. Asğ‘âˆŒğ‘„âˆ¼ğ‘âˆŒğ‘£ğ‘„,ğ‘£âˆˆval(ğ‘âˆŒğ‘£ğ‘„)(by canonical
similarity; Lemma 1). Finally, ğ‘£â‰ ğ‘£ğ‘„as (1)ğ‘£âˆˆval(ğ‘âˆŒğ‘£ğ‘„),
and (2)ğ‘£ğ‘„âˆ‰val(ğ‘âˆŒğ‘£ğ‘„).
The lemma holds as its statement is true in both possible cases. â–¡
As we have shown the existence of Eğ‘£(Lemma 6), we can â€œmergeâ€
Eğ‘£with the valid local behavior ğ›½ğ‘„in whichğ‘„decidesğ‘£ğ‘„without
having received any message (Lemma 5). Hence, we can construct
an execution in which Aviolates Agreement . Thus, correct pro-
cesses must send more than (âŒˆğ‘¡
2âŒ‰)2âˆˆÎ©(ğ‘¡2)messages inEbase.
Lemma 7. The message complexity of Ebaseis greater than(âŒˆğ‘¡
2âŒ‰)2.
Proof. By Lemma 5, there exists a local behavior ğ›½ğ‘„of process
ğ‘„in whichğ‘„decides a value ğ‘£ğ‘„without having received any
message (from any other process). Let ğ‘¡ğ‘„denote the time at which
ğ‘„decidesğ‘£ğ‘„inğ›½ğ‘„. Moreover, there exists an infinite execution Eğ‘£
in which (1) ğ‘„is faulty and silent, and (2) correct processes decide
a valueğ‘£â‰ ğ‘£ğ‘„(by Lemma 6). Let ğ‘¡ğ‘£denote the time at which a
correct process decides ğ‘£â‰ ğ‘£ğ‘„inEğ‘£.
We now construct an execution Ein the following way:
(1)Processes in CorrA(Eğ‘£)âˆª{ğ‘„}are correct inE. All other
processes are faulty.
(2)All messages from and to ğ‘„are delayed until after max(ğ‘¡ğ‘„,ğ‘¡ğ‘£).
8On the Validity of Consensus (Extended Version)
(3) Process ğ‘„exhibits the local behavior ğ›½ğ‘„.
(4)Until max(ğ‘¡ğ‘„,ğ‘¡ğ‘£), no process in CorrA(Eğ‘£)can distinguish
EfromEğ‘£.
(5)GST is set to after max(ğ‘¡ğ‘„,ğ‘¡ğ‘£)(and after all correct pro-
cesses from the CorrA(Eğ‘£)âˆª{ğ‘„}set have taken a step).
As no process in CorrA(Eğ‘£)can distinguishEfromEğ‘£until time
max(ğ‘¡ğ‘„,ğ‘¡ğ‘£),ğ‘£â‰ ğ‘£ğ‘„is decided by a correct process in E. Moreover,
ğ‘„decidesğ‘£ğ‘„inEas it exhibits ğ›½ğ‘„(step 3 of the construction).
Thus, Agreement is violated inE, which contradicts the fact that A
satisfies Agreement . Hence, the starting assumption is not correct:
inEbase, correct processes send more than (âŒˆğ‘¡
2âŒ‰)2messages. â–¡
The following subsection shows that the quadratic bound on
message complexity is tight with ğ‘¡âˆˆÎ©(ğ‘›):Universal exchanges
ğ‘‚(ğ‘›2)messages when relying on a PKI. We underline that our
lower bound holds even for algorithms which employ digital signa-
tures. Achieving the optimal quadratic message complexity without
relying on digital signatures remains an important open question.
5.2 General Algorithm Universal : Similarity
Condition is Sufficient if ğ‘›>3ğ‘¡
In this subsection, we show that Cğ‘†is sufficient for a validity prop-
erty to be solvable when ğ‘›>3ğ‘¡. Furthermore, we prove that, assum-
ing a PKI, the quadratic lower bound (Â§5.1) is tight with ğ‘¡âˆˆÎ©(ğ‘›).
In brief, we prove the following theorem:
Theorem 5. Letğ‘›>3ğ‘¡, and let valbe any validity property
which satisfiesCğ‘†. Then, valis solvable. Moreover, assuming a public-
key infrastructure, there exists an algorithm which solves Byzantine
consensus with val, and hasğ‘‚(ğ‘›2)message complexity.
To prove Theorem 5, we present Universal , an algorithm which
solves the Byzantine consensus problem with anyvalidity prop-
erty satisfyingCğ‘†, given that ğ‘›>3ğ‘¡. In other words, Universal
solves consensus with any solvable and non-trivial validity prop-
erty. Notably, assuming a PKI, Universal achievesğ‘‚(ğ‘›2)message
complexity, making it optimal (when ğ‘¡âˆˆÎ©(ğ‘›)) according to our
quadratic lower bound.
To construct Universal , we rely on vector consensus [ 34,40,
82,91] (see Â§5.2.1), a problem which requires correct processes
to agree on the proposals of ğ‘›âˆ’ğ‘¡processes. Specifically, when a
correct process decides a vector vecofğ‘›âˆ’ğ‘¡proposals (from vector
consensus), it decides from Universal the common admissible
value for all input configurations similar to vec, i.e., the process
decides Î›(vec). Note that the idea of solving consensus from vector
consensus is not novel [ 15,35,81]. For some validity properties it
is even natural, such as Strong Validity (choose the most common
value) or Weak Validity (choose any value). However, thanks to the
necessity ofCğ‘†(Â§4.2), anysolvable consensus variant can reuse
this simple algorithmic design.
In this subsection, we first recall vector consensus (Â§5.2.1). Then,
we utilize vector consensus to construct Universal (Â§5.2.2). Through-
out the entire subsection, ğ‘›>3ğ‘¡.
5.2.1 Vector Consensus. In essence, vector consensus allows each
correct process to infer the proposals of ğ‘›âˆ’ğ‘¡(correct or faulty)
processes. Formally, correct processes agree on input configurations
(of vector consensus) with exactly ğ‘›âˆ’ğ‘¡process-proposal pairs:Vğ‘‚=Iğ‘›âˆ’ğ‘¡. Let us precisely define Vector Validity , the validity
property of vector consensus:
â€¢Vector Validity: Let a correct process decide vectorâˆˆVğ‘‚,
which contains exactly ğ‘›âˆ’ğ‘¡process-proposal pairs, such
that (1)(ğ‘ƒ,ğ‘£)belongs to vector , for some process ğ‘ƒâˆˆÎ 
and some value ğ‘£âˆˆVğ¼, and (2)ğ‘ƒis a correct process. Then,
ğ‘ƒproposedğ‘£to vector consensus.
Intuitively, Vector Validity states that, if a correct process â€œconcludesâ€
that a value ğ‘£was proposed by a process ğ‘ƒandğ‘ƒis correct, then
ğ‘ƒâ€™s proposal was indeed ğ‘£.
We provide two implementations of vector consensus: (1) a non-
authenticated implementation (without any cryptographic primi-
tives), and (2) an authenticated implementation (with digital signa-
tures). We give the pseudocode of the non-authenticated variant
in Appendix B.2. The pseudocode of the authenticated variant is
presented in Algorithm 1. This variant relies on Quad , a Byzantine
consensus algorithm recently introduced in [ 28]; we briefly discuss
Quad below.
Quad .In essence, Quad is a partially-synchronous, â€œleader-
basedâ€ Byzantine consensus algorithm, which achieves ğ‘‚(ğ‘›2)mes-
sage complexity. Internally, Quad relies on a PKI.3Formally, Quad
is concerned with two sets: (1) VQuad , a set of values, and (2)
PQuad , a set of proofs. In Quad , processes propose and decide
value-proof pairs. There exists a function verify :VQuadÃ—PQuadâ†’
{true,false}. Importantly,PQuad is not known a-priori: it is only
assumed that, if a correct process proposes a pair (ğ‘£âˆˆV Quad,Î£âˆˆ
PQuad), then verify(ğ‘£,Î£)=true.Quad guarantees the following:
if a correct process decides a pair (ğ‘£,Î£), then verify(ğ‘£,Î£)=true. In
other words, correct processes decide only valid value-proof pairs.
(See [28] for the full details on Quad .)
In our authenticated implementation of vector consensus (Algo-
rithm 1), we rely on a specific instance of Quad where (1)VQuad=
Iğ‘›âˆ’ğ‘¡(processes propose to Quad the input configurations of vec-
tor consensus), and (2) PQuad is a set ofğ‘›âˆ’ğ‘¡proposal messages
(sent by processes in vector consensus). Finally, given an input
configuration vectorâˆˆV Quad and a set of messages Î£âˆˆP Quad ,
verify(vector,Î£)=trueif and only if, for every process-proposal
pair(ğ‘ƒğ‘—,ğ‘£ğ‘—)which belongs to vector ,âŸ¨proposal,ğ‘£ğ‘—âŸ©ğœğ‘—âˆˆÎ£(i.e.,
every process-proposal pair of vector is accompanied by a properly
signed proposal message).
Description of authenticated vector consensus (Algorithm 1). When
a correct process ğ‘ƒğ‘–proposes a value ğ‘£âˆˆVğ¼to vector consensus
(line 8), the process broadcasts a signed proposal message (line 9).
Onceğ‘ƒğ‘–receivesğ‘›âˆ’ğ‘¡proposal messages (line 14), ğ‘ƒğ‘–constructs
an input configuration vector (line 15), and a proof Î£(line 16) from
the received proposal messages. Moreover, ğ‘ƒğ‘–proposes(vector,Î£)
toQuad (line 17). Finally, when ğ‘ƒğ‘–decides a pair(vectorâ€²,Î£â€²)from
Quad (line 18),ğ‘ƒğ‘–decides vectorâ€²from vector consensus (line 19).
The message complexity of Algorithm 1 is ğ‘‚(ğ‘›2)as (1) processes
only broadcast proposal messages, and (2) the message complexity
ofQuad isğ‘‚(ğ‘›2). We delegate the full proof of the correctness and
complexity of Algorithm 1 to Appendix B.1.
3In fact, Quad relies on a threshold signature scheme [ 87], and not on a PKI. However,
by inserting digital signatures in place of threshold signatures, Quad is modified to
accommodate for a PKI only while preserving its quadratic message complexity.
9Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Algorithm 1 Authenticated Vector Consensus: Pseudocode (for
processğ‘ƒğ‘–)
1:Uses:
2: Best-Effort Broadcast [ 23],instance bebâŠ²no guarantees with faulty sender
3: Quad [28], instance quad
4:upon init:
5: Integer received _proposalsğ‘–â†0 âŠ²the number of received proposals
6: Map(Processâ†’Vğ¼)proposalsğ‘–â†empty âŠ²received proposals
7: Map(Processâ†’Message)messagesğ‘–â†empty âŠ²received messages
8:upon propose(ğ‘£âˆˆVğ¼):
9: invoke beb.broadcast âŸ¨proposal,ğ‘£âŸ©ğœğ‘–âŠ²broadcast a signed proposal
10:upon reception of Messageğ‘š=âŸ¨proposal,ğ‘£ğ‘—âˆˆVğ¼âŸ©ğœğ‘—from process ğ‘ƒğ‘—and
received _proposalsğ‘–<ğ‘›âˆ’ğ‘¡:
11: received _proposalsğ‘–â†received _proposalsğ‘–+1
12: proposalsğ‘–[ğ‘ƒğ‘—]â†ğ‘£ğ‘—
13: messagesğ‘–[ğ‘ƒğ‘—]â†ğ‘š
14: ifreceived _proposalsğ‘–=ğ‘›âˆ’ğ‘¡: âŠ²able to propose to Quad
15: Input _Configuration vectorâ†constructed from proposalsğ‘–
16: Proof Î£â†allproposal messages from messagesğ‘–
17: invoke quad.propose (vector,Î£)
18:upon quad.decide (Input _Configuration vectorâ€²,Proof Î£â€²):
19: trigger decide(vectorâ€²)
5.2.2 Universal .We construct Universal (Algorithm 2) directly
from vector consensus. When a correct process ğ‘ƒğ‘–proposes to
Universal (line 3), the proposal is forwarded to vector consensus
(line 4). Once ğ‘ƒğ‘–decides an input configuration vector from vector
consensus (line 5), ğ‘ƒğ‘–decides Î›(vector)(line 6).
Note that our implementation of Universal (Algorithm 2) is
independent of the actual implementation of vector consensus.
Thus, by employing our authenticated implementation of vector
consensus (Algorithm 1), we obtain a general consensus algorithm
withğ‘‚(ğ‘›2)message complexity. On the other hand, by employ-
ing a non-authenticated implementation of vector consensus (see
Appendix B.2), we obtain a non-authenticated version of Univer-
sal, which implies that any validity property which satisfies Cğ‘†is
solvable even in a non-authenticated setting (if ğ‘›>3ğ‘¡).
Algorithm 2 Universal : Pseudocode (for process ğ‘ƒğ‘–)
1:Uses:
2: Vector Consensus, instance vec_cons
3:upon propose(ğ‘£âˆˆVğ¼):
4: invoke vec_cons.propose(ğ‘£)
5:upon vec_cons.decide(Input _Configuration vector):
6: trigger decide Î›(vector)
Finally, we show that Universal (Algorithm 2) is a general
Byzantine consensus algorithm and that its authenticated variant
achievesğ‘‚(ğ‘›2)message complexity, which proves Theorem 5.
Lemma 8. Letvalbe any validity property which satisfies Cğ‘†, and
letğ‘›>3ğ‘¡.Universal solves Byzantine consensus with val. More-
over, if Universal employs Algorithm 1 as its vector consensus
building block, the message complexity of Universal isğ‘‚(ğ‘›2).
Proof. Termination andAgreement ofUniversal follow from
Termination andAgreement of vector consensus, respectively. More-
over, the message complexity of Universal is identical to the mes-
sage complexity of its vector consensus building block.
Finally, we prove that Universal satisfies val. Consider any
executionEofUniversal ; letinput _conf(E)=ğ‘âˆ—, for some inputconfiguration ğ‘âˆ—âˆˆI. Moreover, let vectorâˆˆIğ‘›âˆ’ğ‘¡be the input
configuration correct processes decide from vector consensus in
E(line 5). As vector consensus satisfies Vector Validity , we have
that, for every process ğ‘ƒâˆˆğœ‹(ğ‘âˆ—)âˆ©ğœ‹(vector),ğ‘ƒâ€™s proposals in ğ‘âˆ—
andvector are identical. Hence, vectorâˆ¼ğ‘âˆ—. Therefore, Î›(vector)âˆˆ
val(ğ‘âˆ—)(by the definition of the Î›function). Thus, valis satisfied
byUniversal . â–¡
AsUniversal (Algorithm 2) solves the Byzantine consensus
problem with any validity property which satisfies Cğ‘†(Lemma 8) if
ğ‘›>3ğ‘¡,Cğ‘†is sufficient for solvable validity properties when ğ‘›>3ğ‘¡.
Lastly, as Universal relies on vector consensus, we conclude that
Vector Validity is astrongest validity property. That is, a consensus
solution to any solvable variant of the validity property can be
obtained (with no additional cost) from vector consensus.
A note on the communication complexity of vector consensus.
While the version of Universal which employs Algorithm 1 (as its
vector consensus building block) has optimal message complexity,
its communication complexity is ğ‘‚(ğ‘›3)asQuad â€™s communication
complexity is ğ‘‚(ğ‘›3)when proofs are of linear size.4This presents a
linear gap to the lower bound for communication complexity (also
Î©(ğ‘›2), implied by Theorem 4), and to known optimal solutions for
some validity properties (e.g., Strong Validity , proven to be Î˜(ğ‘›2)
[28,64]). At first glance, this seems like an issue inherent to vec-
tor consensus: the decided vectors are linear in size, suggesting
that the linear gap could be inevitable. However, this is not the
case. In Appendix B.3, we give a vector consensus algorithm with
ğ‘‚(ğ‘›2logğ‘›)communication complexity, albeit with exponential la-
tency.5Is it possible to construct vector consensus with subcubic
communication and polynomial latency? This is an important open
question, as positive answers would lead to (practical) performance
improvements of all consensus variants.
6 CONCLUDING REMARKS
This paper studies the validity property of partially synchronous
Byzantine consensus. Namely, we mathematically formalize valid-
ity properties, and give the necessary and sufficient conditions for
a validity property to be solvable (i.e., for the existence of an algo-
rithm which solves a consensus problem defined with that validity
property, in addition to Agreement andTermination ). Moreover, we
prove a quadratic lower bound on the message complexity for all
non-trivial (and solvable) validity properties. Previously, this bound
was mainly known for Strong Validity . Lastly, we introduce Uni-
versal , a general algorithm for consensus with any solvable (and
non-trivial) validity property; assuming a PKI, Universal achieves
ğ‘‚(ğ‘›2)message complexity, showing that the aforementioned lower
bound is tight (with ğ‘¡âˆˆÎ©(ğ‘›)).
A natural extension of this work is its adaptation to synchronous
environments. Similarly, can we extend our results to randomized
protocols? Furthermore, investigating consensus variants in which
â€œexactâ€ agreement among correct processes is not required (such
4The communication complexity denotes the number of sent words, where a word
contains a constant number of values and signatures.
5Both our authenticated (Algorithm 1) and our non-authenticated (see Appendix B.2)
variants of vector consensus have linear latency, which implies linear latency of
Universal when employing any of these two algorithms.
10On the Validity of Consensus (Extended Version)
as approximate [ 2,48,49,72] orğ‘˜-set [ 18,37,38,68] agreement)
constitutes another important research direction for the future.
Finally, we restate the question posed at the end of Â§5.2. Is it
possible to solve vector consensus with ğ‘œ(ğ‘›3)exchanged bits and
polynomial latency? Recall that, due to the design of Universal
(Â§5.2), any (non-trivial) consensus variant can be solved using vec-
tor consensus without additional cost. Therefore, an upper bound
on the complexity of vector consensus is an upper bound on the
complexity of any consensus variant. Hence, lowering the ğ‘‚(ğ‘›3)
communication complexity of vector consensus (while preserv-
ing polynomial latency) constitutes an important future research
direction.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments.
We also thank our colleagues Nirupam Gupta, Matteo Monti, Rafael
Pinot and Pierre-Louis Roman for the helpful discussions and com-
ments. This work was funded in part by the Hasler Foundation
(#21084), the Singapore grant MOE-T2EP20122-0014, and the ARC
Future Fellowship program (#180100496).
REFERENCES
[1] Michael Abd-El-Malek, Gregory R Ganger, Garth R Goodson, Michael K Reiter,
and Jay J Wylie. 2005. Fault-Scalable Byzantine Fault-Tolerant Services. ACM
SIGOPS Operating Systems Review 39, 5 (2005), 59â€“74.
[2] Ittai Abraham, Yonatan Amit, and Danny Dolev. 2004. Optimal Resilience Asyn-
chronous Approximate Agreement. In Principles of Distributed Systems, 8th Inter-
national Conference, OPODIS 2004, Grenoble, France, December 15-17, 2004, Revised
Selected Papers (Lecture Notes in Computer Science, Vol. 3544) , Teruo Higashino
(Ed.). Springer, 229â€“239. https://doi.org/10.1007/11516798_17
[3]Ittai Abraham and Cristian Cachin. [n. d.]. What about Validity? https://
decentralizedthoughts.github.io/2022-12-12-what-about-validity/.
[4] Ittai Abraham, T.-H. Hubert Chan, Danny Dolev, Kartik Nayak, Rafael Pass, Ling
Ren, and Elaine Shi. 2019. Communication Complexity of Byzantine Agreement,
Revisited. In Proceedings of the 2019 ACM Symposium on Principles of Distributed
Computing, PODC 2019, Toronto, ON, Canada, July 29 - August 2, 2019 , Peter
Robinson and Faith Ellen (Eds.). ACM, 317â€“326. https://doi.org/10.1145/3293611.
3331629
[5]Ittai Abraham, Srinivas Devadas, Kartik Nayak, and Ling Ren. 2017. Brief An-
nouncement: Practical Synchronous Byzantine Consensus. In 31st International
Symposium on Distributed Computing (DISC 2017) . Schloss Dagstuhl-Leibniz-
Zentrum fuer Informatik.
[6] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegel-
man. 2016. Solida: A Blockchain Protocol Based on Reconfigurable Byzantine
Consensus. arXiv preprint arXiv:1612.02916 (2016).
[7] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegelman.
2016. Solidus: An Incentive-compatible Cryptocurrency Based on Permissionless
Byzantine Consensus. CoRR, abs/1612.02916 (2016).
[8] Ittai Abraham, Dahlia Malkhi, and Alexander Spiegelman. 2019. Asymptotically
Optimal Validated Asynchronous Byzantine Agreement. In Proceedings of the
2019 ACM Symposium on Principles of Distributed Computing . 337â€“346.
[9]Atul Adya, William Bolosky, Miguel Castro, Gerald Cermak, Ronnie Chaiken,
John Douceur, Jon Howell, Jacob Lorch, Marvin Theimer, and Roger Wattenhofer.
2002.{FARSITE}: Federated, Available, and Reliable Storage for an Incom-
pletely Trusted Environment. In 5th Symposium on Operating Systems Design
and Implementation (OSDI 02) .
[10] Yair Amir, Claudiu Danilov, Jonathan Kirsch, John Lane, Danny Dolev, Cristina
Nita-Rotaru, Josh Olsen, and David Zage. 2006. Scaling Byzantine Fault-Tolerant
Replication to Wide Area Networks. In International Conference on Dependable
Systems and Networks (DSNâ€™06) . IEEE, 105â€“114.
[11] James Aspnes. 2003. Randomized Protocols for Asynchronous Consensus. Dis-
tributed Computing 16, 2 (2003), 165â€“175.
[12] Michael Ben-Or. 1983. Another Advantage of Free Choice: Completely Asyn-
chronous Agreement Protocols (Extended Abstract). In Proceedings of the Second
Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing,
Montreal, Quebec, Canada, August 17-19, 1983 , Robert L. Probert, Nancy A. Lynch,
and Nicola Santoro (Eds.). ACM, 27â€“30. https://doi.org/10.1145/800221.806707
[13] Michael Ben-Or and Ran El-Yaniv. 2003. Resilient-optimal interactive consistency
in constant time. Distributed Computing 16, 4 (2003), 249â€“262.[14] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. 2019. Completeness
Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation. In
Providing Sound Foundations for Cryptography: On the Work of Shafi Goldwasser
and Silvio Micali . 351â€“371.
[15] Michael Ben-Or, Boaz Kelmer, and Tal Rabin. 1994. Asynchronous Secure Com-
putations with Optimal Resilience (Extended Abstract). In Proceedings of the
Thirteenth Annual ACM Symposium on Principles of Distributed Computing, Los
Angeles, California, USA, August 14-17, 1994 , James H. Anderson, David Peleg, and
Elizabeth Borowsky (Eds.). ACM, 183â€“192. https://doi.org/10.1145/197917.198088
[16] Amey Bhangale, Chen-Da Liu-Zhang, Julian Loss, and Kartik Nayak. 2022.
Efficient Adaptively-Secure Byzantine Agreement for Long Messages. In Ad-
vances in Cryptology - ASIACRYPT 2022 - 28th International Conference on the
Theory and Application of Cryptology and Information Security, Taipei, Tai-
wan, December 5-9, 2022, Proceedings, Part I (Lecture Notes in Computer Sci-
ence, Vol. 13791) , Shweta Agrawal and Dongdai Lin (Eds.). Springer, 504â€“525.
https://doi.org/10.1007/978-3-031-22963-3_17
[17] Ofer Biran, Shlomo Moran, and Shmuel Zaks. 1990. A Combinatorial Character-
ization of the Distributed 1-Solvable Tasks. Journal of algorithms 11, 3 (1990),
420â€“440.
[18] Zohir Bouzid, Damien Imbs, and Michel Raynal. 2016. A necessary condition
for Byzantine k-set agreement. Inf. Process. Lett. 116, 12 (2016), 757â€“759. https:
//doi.org/10.1016/j.ipl.2016.06.009
[19] Elette Boyle, Ran Cohen, and Aarushi Goel. 2021. Breaking the ğ‘œ(âˆšğ‘›)-bit barrier:
Byzantine agreement with polylog bits per party. In Proceedings of the 2021 ACM
Symposium on Principles of Distributed Computing . 319â€“330.
[20] Gabriel Bracha. 1987. Asynchronous Byzantine Agreement Protocols. Inf. Com-
put.75, 2 (1987), 130â€“143.
[21] Ethan Buchman. 2016. Tendermint: Byzantine Fault Tolerance in the Age of
Blockchains . Ph. D. Dissertation. University of Guelph.
[22] Ethan Buchman, Jae Kwon, and Zarko Milosevic. 2019. The latest gossip on BFT
consensus . Technical Report 1807.04938. arXiv.
[23] Christian Cachin, Rachid Guerraoui, and LuÃ­s Rodrigues. 2011. Introduction
to Reliable and Secure Distributed Programming . Springer Science & Business
Media.
[24] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. 2001. Secure
and Efficient Asynchronous Broadcast Protocols. In Advances in Cryptology -
CRYPTO 2001, 21st Annual International Cryptology Conference, Santa Barbara,
California, USA, August 19-23, 2001, Proceedings (Lecture Notes in Computer Science,
Vol. 2139) , Joe Kilian (Ed.). Springer, 524â€“541. https://doi.org/10.1007/3-540-
44647-8_31
[25] Miguel Castro and Barbara Liskov. 2002. Practical Byzantine Fault Tolerance
and Proactive Recovery. ACM Transactions on Computer Systems 20, 4 (2002).
[26] Annick Chopard, Martin Hirt, and Chen-Da Liu-Zhang. 2021. On
Communication-Efficient Asynchronous MPC with Adaptive Security. In The-
ory of Cryptography - 19th International Conference, TCC 2021, Raleigh, NC,
USA, November 8-11, 2021, Proceedings, Part II (Lecture Notes in Computer
Science, Vol. 13043) , Kobbi Nissim and Brent Waters (Eds.). Springer, 35â€“65.
https://doi.org/10.1007/978-3-030-90453-1_2
[27] Benny Chor and Lior Moscovici. 1989. Solvability in Asynchronous Environments
(Extended Abstract). In 30th Annual Symposium on Foundations of Computer
Science, Research Triangle Park, North Carolina, USA, 30 October - 1 November
1989. IEEE Computer Society, 422â€“427. https://doi.org/10.1109/SFCS.1989.63513
[28] Pierre Civit, Muhammad Ayaz Dzulfikar, Seth Gilbert, Vincent Gramoli, Rachid
Guerraoui, Jovan Komatovic, and Manuel Vidigueira. 2022. Byzantine Consensus
isÎ˜(ğ‘›2): The Dolev-Reischuk Bound is Tight even in Partial Synchrony!. In
36th International Symposium on Distributed Computing (DISC 2022) (Leibniz
International Proceedings in Informatics (LIPIcs), Vol. 246) , Christian Scheideler
(Ed.). Schloss Dagstuhl â€“ Leibniz-Zentrum fÃ¼r Informatik, Dagstuhl, Germany,
14:1â€“14:21. https://doi.org/10.4230/LIPIcs.DISC.2022.14
[29] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2021. Polygraph: Accountable
Byzantine Agreement. In Proceedings of the 41st IEEE International Conference on
Distributed Computing Systems (ICDCSâ€™21) .
[30] Pierre Civit, Seth Gilbert, Vincent Gramoli, Rachid Guerraoui, Jovan Komatovic,
Zarko Milosevic, and Adi Seredinschi. 2022. Crime and Punishment in Distributed
Byzantine Decision Tasks. In 42nd IEEE International Conference on Distributed
Computing Systems, ICDCS 2022, Bologna, Italy, July 10-13, 2022 . IEEE, 34â€“44.
https://doi.org/10.1109/ICDCS54860.2022.00013
[31] Shir Cohen, Idit Keidar, and Oded Naor. 2021. Byzantine Agreement with Less
Communication: Recent Advances. SIGACT News 52, 1 (2021), 71â€“80. https:
//doi.org/10.1145/3457588.3457600
[32] Shir Cohen, Idit Keidar, and Alexander Spiegelman. 2020. Not a coinci-
dence: Sub-quadratic asynchronous byzantine agreement whp. arXiv preprint
arXiv:2002.06545 (2020).
[33] Miguel Correia. 2019. From Byzantine Consensus to Blockchain Consensus. In
Essentials of Blockchain Technology . Chapman and Hall/CRC, 41â€“80.
[34] Miguel Correia, Nuno Ferreira Neves, and Paulo VerÃ­ssimo. 2006. From Con-
sensus to Atomic Broadcast: Time-Free Byzantine-Resistant Protocols without
11Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Signatures. Comput. J. 49, 1 (2006), 82â€“96.
[35] Tyler Crain, Vincent Gramoli, Mikel Larrea, and Michel Raynal. 2018. DBFT:
Efficient Leaderless Byzantine Consensus and its Applications to Blockchains.
InProceedings of the 17th IEEE International Symposium on Network Computing
and Applications (NCAâ€™18) . IEEE.
[36] Sourav Das, Zhuolun Xiang, and Ling Ren. 2021. Asynchronous Data Dissemi-
nation and its Applications. In Proceedings of the 2021 ACM SIGSAC Conference
on Computer and Communications Security . 2705â€“2721.
[37] Carole Delporte-Gallet, Hugues Fauconnier, Michel Raynal, and Mouna Safir.
2022. Optimal Algorithms for Synchronous Byzantine k-Set Agreement. In
Stabilization, Safety, and Security of Distributed Systems - 24th International Sym-
posium, SSS 2022, Clermont-Ferrand, France, November 15-17, 2022, Proceedings
(Lecture Notes in Computer Science, Vol. 13751) , StÃ©phane Devismes, Franck Petit,
Karine Altisen, Giuseppe Antonio Di Luna, and Antonio FernÃ¡ndez Anta (Eds.).
Springer, 178â€“192. https://doi.org/10.1007/978-3-031-21017-4_12
[38] Carole Delporte-Gallet, Hugues Fauconnier, and Mouna Safir. 2020. Byzantine
k-Set Agreement. In Networked Systems - 8th International Conference, NETYS
2020, Marrakech, Morocco, June 3-5, 2020, Proceedings (Lecture Notes in Computer
Science, Vol. 12129) , Chryssis Georgiou and Rupak Majumdar (Eds.). Springer,
183â€“191. https://doi.org/10.1007/978-3-030-67087-0_12
[39] Danny Dolev and RÃ¼diger Reischuk. 1985. Bounds on Information Exchange for
Byzantine Agreement. Journal of the ACM (JACM) 32, 1 (1985), 191â€“204.
[40] Assia Doudou and AndrÃ© Schiper. 1998. Muteness Detectors for Consensus with
Byzantine Processes. In Proceedings of the Seventeenth Annual ACM Symposium
on Principles of Distributed Computing, PODC â€™98, Puerto Vallarta, Mexico, June
28 - July 2, 1998 , Brian A. Coan and Yehuda Afek (Eds.). ACM, 315. https:
//doi.org/10.1145/277697.277772
[41] Sisi Duan, Xin Wang, and Haibin Zhang. 2023. Practical Signature-Free Asyn-
chronous Common Subset in Constant Time. Cryptology ePrint Archive (2023).
[42] C. Dwork, N. Lynch, and L. Stockmeyer. 1988. Consensus in the Presence of
Partial Synchrony. Journal of the Association for Computing Machinery, Vol. 35,
No. 2, pp.288-323 (1988).
[43] Paul Ezhilchelvan, Achour Mostefaoui, and Michel Raynal. 2001. Random-
ized Multivalued Consensus. In Fourth IEEE International Symposium on Object-
Oriented Real-Time Distributed Computing. ISORC 2001 . IEEE, 195â€“200.
[44] Michael J Fischer and Nancy A Lynch. 1981. A Lower Bound for the Time to Assure
Interactive Consistency . Technical Report. GEORGIA INST OF TECH ATLANTA
SCHOOL OF INFORMATION AND COMPUTER SCIENCE.
[45] Michael J Fischer, Nancy A Lynch, and Michael S Paterson. 1985. Impossibility
of Distributed Consensus with One Faulty Process. Journal of the ACM (JACM)
32, 2 (1985), 374â€“382.
[46] Matthias Fitzi and Juan A Garay. 2003. Efficient Player-Optimal Protocols for
Strong and Differential Consensus. In Proceedings of the twenty-second annual
symposium on Principles of distributed computing . 211â€“220.
[47] Zvi Galil, Stuart Haber, and Moti Yung. 1987. Cryptographic Computation:
Secure Fault-Tolerant Protocols and the Public-Key Model. In Conference on the
Theory and Application of Cryptographic Techniques . Springer, 135â€“155.
[48] Diana Ghinea, Chen-Da Liu-Zhang, and Roger Wattenhofer. 2022. Optimal
Synchronous Approximate Agreement with Asynchronous Fallback. In PODC
â€™22: ACM Symposium on Principles of Distributed Computing, Salerno, Italy, July
25 - 29, 2022 , Alessia Milani and Philipp Woelfel (Eds.). ACM, 70â€“80. https:
//doi.org/10.1145/3519270.3538442
[49] Diana Ghinea, Chen-Da Liu-Zhang, and Roger Wattenhofer. 2023. Multidimen-
sional Approximate Agreement with Asynchronous Fallback. Cryptology ePrint
Archive (2023).
[50] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles (Shanghai,
China) (SOSP â€™17) . Association for Computing Machinery, New York, NY, USA,
51â€“68. https://doi.org/10.1145/3132747.3132757
[51] Seth Gilbert, Nancy A Lynch, and Alexander A Shvartsman. 2010. Rambo: A Ro-
bust, Reconfigurable Atomic Memory Service for Dynamic Networks. Distributed
Computing 23, 4 (2010), 225â€“272.
[52] Rachid Guerraoui and AndrÃ© Schiper. 2001. The Generic Consensus Service.
IEEE Trans. Software Eng. 27, 1 (2001), 29â€“41. https://doi.org/10.1109/32.895986
[53] Attiya Hagit and Avidor Zvi. 2002. Wait-Free n-Set Consensus When Inputs
Are Restricted. In International Symposium on Distributed Computing . Springer,
326â€“338.
[54] Maurice Herlihy, Dmitry N. Kozlov, and Sergio Rajsbaum. 2013. Distributed
Computing Through Combinatorial Topology . Morgan Kaufmann. https://store.
elsevier.com/product.jsp?isbn=9780124045781
[55] Maurice Herlihy and Nir Shavit. 1993. The Asynchronous Computability The-
orem forğ‘¡-Resilient Tasks. In Proceedings of the Twenty-Fifth Annual ACM
Symposium on Theory of Computing, May 16-18, 1993, San Diego, CA, USA ,
S. Rao Kosaraju, David S. Johnson, and Alok Aggarwal (Eds.). ACM, 111â€“120.
https://doi.org/10.1145/167088.167125
[56] Maurice Herlihy and Nir Shavit. 1999. The Topological Structure of Asynchro-
nous Computability. J. ACM 46, 6 (1999), 858â€“923. https://doi.org/10.1145/331524.331529
[57] Kim P. Kihlstrom, Louise E. Moser, and Peter M. Melliar-Smith. 2003. Byzantine
Fault Detectors for Solving Consensus. British Computer Society (2003).
[58] Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen Clement, and Edmund
Wong. 2007. Zyzzyva: Speculative Byzantine Fault Tolerance. In Proceedings of
twenty-first ACM SIGOPS symposium on Operating systems principles . 45â€“58.
[59] Ramakrishna Kotla and Michael Dahlin. 2004. High Throughput Byzantine Fault
Tolerance. In International Conference on Dependable Systems and Networks, 2004 .
IEEE, 575â€“584.
[60] Dariusz R Kowalski and Achour MostÃ©faoui. 2013. Synchronous Byzantine
Agreement with Nearly a Cubic Number of Communication Bits. In Proceedings
of the 2013 ACM symposium on Principles of distributed computing . 84â€“91.
[61] Leslie Lamport. 2001. Paxos Made Simple. ACM SIGACT News (Distributed
Computing Column) 32, 4 (Whole Number 121, December 2001) (2001), 51â€“58.
[62] Leslie Lamport, Robert Shostak, and Marshall Pease. 1982. The Byzantine Gen-
erals Problem. ACM Transactions on Programming Languages and Systems 4, 3
(1982), 382â€“401.
[63] Leslie Lamport, Robert Shostak, and Marshall Pease. 2019. The Byzantine Gener-
als Problem. In Concurrency: the works of leslie lamport . 203â€“226.
[64] Andrew Lewis-Pye. 2022. Quadratic worst-case message complexity for State Ma-
chine Replication in the partial synchrony model. arXiv preprint arXiv:2201.01107
(2022).
[65] BenoÃ®t Libert, Marc Joye, and Moti Yung. 2014. Born and Raised Distributively:
Fully Distributed Non-Interactive Adaptively-Secure Threshold Signatures with
Short Shares. In Proceedings of the 2014 ACM symposium on Principles of dis-
tributed computing . 303â€“312.
[66] Yuan Lu, Zhenliang Lu, Qiang Tang, and Guiling Wang. 2020. Dumbo-MVBA:
Optimal Multi-Valued Validated Asynchronous Byzantine Agreement, Revisited.
InPODC â€™20: ACM Symposium on Principles of Distributed Computing, Virtual
Event, Italy, August 3-7, 2020 , Yuval Emek and Christian Cachin (Eds.). ACM,
129â€“138. https://doi.org/10.1145/3382734.3405707
[67] Loi Luu, Viswesh Narayanan, Kunal Baweja, Chaodong Zheng, Seth Gilbert, and
Prateek Saxena. 2015. SCP: A Computationally-Scalable Byzantine Consensus
Protocol For Blockchains. Cryptology ePrint Archive (2015).
[68] Nancy A Lynch. 1996. Distributed Algorithms . Elsevier.
[69] Dahlia Malkhi, Kartik Nayak, and Ling Ren. 2019. Flexible Byzantine Fault
Tolerance. In Proceedings of the 2019 ACM SIGSAC conference on computer and
communications security . 1041â€“1053.
[70] Stathis Maneas, Nikos Chondros, Panos Diamantopoulos, Christos Patsonakis,
and Mema Roussopoulos. 2021. On achieving interactive consistency in real-
world distributed systems. J. Parallel and Distrib. Comput. 147 (2021), 220â€“235.
[71] Darya Melnyk and Roger Wattenhofer. 2018. Byzantine Agreement with Interval
Validity. In 2018 IEEE 37th Symposium on Reliable Distributed Systems (SRDS) .
IEEE, 251â€“260.
[72] Hammurabi Mendes and Maurice Herlihy. 2013. Multidimensional Approximate
Agreement in Byzantine Asynchronous Systems. In Symposium on Theory of
Computing Conference, STOCâ€™13, Palo Alto, CA, USA, June 1-4, 2013 , Dan Boneh,
Tim Roughgarden, and Joan Feigenbaum (Eds.). ACM, 391â€“400. https://doi.org/
10.1145/2488608.2488657
[73] Hammurabi Mendes, Christine Tasson, and Maurice Herlihy. 2014. Distributed
Computability in Byzantine Asynchronous Systems. In Symposium on Theory
of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014 , David B.
Shmoys (Ed.). ACM, 704â€“713. https://doi.org/10.1145/2591796.2591853
[74] Atsuki Momose and Ling Ren. 2021. Multi-Threshold Byzantine Fault Tolerance.
InProceedings of the 2021 ACM SIGSAC Conference on Computer and Communi-
cations Security . 1686â€“1699.
[75] Atsuki Momose and Ling Ren. 2021. Optimal Communication Complexity of Au-
thenticated Byzantine Agreement. In 35th International Symposium on Distributed
Computing, DISC 2021, October 4-8, 2021, Freiburg, Germany (Virtual Conference)
(LIPIcs, Vol. 209) , Seth Gilbert (Ed.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r
Informatik, 32:1â€“32:16. https://doi.org/10.4230/LIPIcs.DISC.2021.32
[76] Shlomo Moran and Yaron Wolfstahl. 1987. Extended Impossibility Results for
Asynchronous Complete Networks. Inform. Process. Lett. 26, 3 (1987), 145â€“151.
[77] Achour Mostefaoui, Sergio Rajsbaum, and Michel Raynal. 2003. Conditions on
Input Vectors for Consensus Solvability in Asynchronous Distributed Systems.
Journal of the ACM (JACM) 50, 6 (2003), 922â€“954.
[78] Achour Mostefaoui, Sergio Rajsbaum, and Michel Raynal. 2003. Using Conditions
to Expedite Consensus in Synchronous Distributed Systems. In International
Symposium on Distributed Computing . Springer, 249â€“263.
[79] Achour Mostefaoui, Sergio Rajsbaum, Michel Raynal, and Matthieu Roy. 2001. A
Hierarchy of Conditions for Consensus Solvability. In Proceedings of the twentieth
annual ACM symposium on Principles of distributed computing . 151â€“160.
[80] Achour MostÃ©faoui, Sergio Rajsbaum, Michel Raynal, and Matthieu Roy. 2002.
Condition-Based Protocols for Set Agreement Problems. In International Sympo-
sium on Distributed Computing . Springer, 48â€“62.
[81] Achour Mostefaoui, Michel Raynal, and FrÃ©dÃ©ric Tronel. 2000. From Binary
Consensus to Multivalued Consensus in asynchronous message-passing systems.
Inform. Process. Lett. 73, 5-6 (2000), 207â€“212.
12On the Validity of Consensus (Extended Version)
[82] Nuno Ferreira Neves, Miguel Correia, and Paulo Verissimo. 2005. Solving Vector
Consensus with a Wormhole. IEEE Transactions on Parallel and Distributed
Systems 16, 12 (2005), 1120â€“1131.
[83] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. 1980. Reaching
Agreement in the Presence of Faults. J. ACM 27, 2 (1980), 228â€“234. https:
//doi.org/10.1145/322186.322188
[84] Michel Raynal. 2002. Consensus in Synchronous Systems: A Concise Guided
Tour. In 2002 Pacific Rim International Symposium on Dependable Computing,
2002. Proceedings. IEEE, 221â€“228.
[85] Vikram Saraph, Maurice Herlihy, and Eli Gafni. 2018. An Algorithmic Approach
to the Asynchronous Computability Theorem. J. Appl. Comput. Topol. 1, 3-4
(2018), 451â€“474. https://doi.org/10.1007/s41468-018-0014-4
[86] Ulrich Schmid and Bettina Weiss. 2004. Synchronous Byzantine Agreement
under Hybrid Process and Link Failures. (2004).
[87] Victor Shoup. 2000. Practical Threshold Signatures. In Advances in Cryptology
- EUROCRYPT 2000, International Conference on the Theory and Application of
Cryptographic Techniques, Bruges, Belgium, May 14-18, 2000, Proceeding (Lecture
Notes in Computer Science, Vol. 1807) , Bart Preneel (Ed.). Springer, 207â€“220. https:
//doi.org/10.1007/3-540-45539-6_15
[88] Hin-Sing Siu, Yeh-Hao Chin, and Wei-Pang Yang. 1998. Reaching strong consen-
sus in the presence of mixed failure types. Information Sciences 108, 1-4 (1998),
157â€“180.
[89] David Stolz and Roger Wattenhofer. 2016. Byzantine Agreement with Median
Validity. In 19th International Conference on Principles of Distributed Systems
(OPODIS 2015) , Vol. 46. Schloss Dagstuhlâ€“Leibniz-Zentrum fÃ¼r Informatik GmbH,
22.
[90] Gadi Taubenfeld, Shmuel Katz, and Shlomo Moran. 1989. Initial Failures in
Distributed Computations. International Journal of Parallel Programming 18, 4
(1989), 255â€“276.
[91] Nitin H Vaidya and Vijay K Garg. 2013. Byzantine Vector Consensus in Complete
Graphs. In Proceedings of the 2013 ACM symposium on Principles of distributed
computing . 65â€“73.
[92] Giuliana Santos Veronese, Miguel Correia, Alysson Neves Bessani, Lau Cheuk
Lung, and Paulo Verissimo. 2011. Efficient Byzantine Fault-Tolerance. IEEE Trans.
Comput. 62, 1 (2011), 16â€“30.
[93] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT Consensus with Linearity and Responsiveness. In
Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing .
347â€“356.
[94] Yoav Zibin. 2003. Condition-Based Consensus in Synchronous Systems. In
International Symposium on Distributed Computing . Springer, 239â€“248.
A REMARK ON NON-DETERMINISM
The reader might be aware of several randomized protocols that
achieve expected sub-quadratic communication with a negligible
probability of failure [ 4,16,19,26,32]. This might seem at odds
with our lower bound (Theorem 4). However, this is not the case.
When proving Lemma 5, we show that the adversary has a (de-
terministic) strategy given any deterministic protocol. In particular,
the deterministic strategy of the adversary described in the construc-
tion ofEbase(including GST=0) resolves the pure non-determinism
(e.g., network scheduling) and thus deterministically implies Ebase
and the associated set ğ‘†ğ‘„(similarly forEâ€²
base). However, we did
not demonstrate that an adversary always has a pair of strategies
for every randomized protocol such that the lemma would hold
with a non-negligible probability. Hence, there is no contradiction
whatsoever with the aforementioned randomized protocols.
Extending Theorem 4 to the randomized case with an adaptive
adversary (in the same vein as [4]) is left for future work.
BVECTOR CONSENSUS: PROOFS & OMITTED
ALGORITHMS
In Appendix B.1, we prove the correctness and complexity of our
authenticated implementation of vector consensus (Algorithm 1).
We dedicate Appendix B.2 to a non-authenticated implementationof vector consensus. Finally, in Appendix B.3, we give an imple-
mentation of vector consensus with ğ‘‚(ğ‘›2logğ‘›)communication
complexity. Throughout the entire section, ğ‘›>3ğ‘¡.
B.1 Authenticated Implementation
(Algorithm 1): Proofs
We start this subsection with some clarifications about Quad [28],
a Byzantine consensus algorithm utilized in Algorithm 1. Then, we
prove the correctness and complexity of Algorithm 1.
A note on Quad .In Â§5.2.1, we claim that Quad satisfies the follow-
ing validity property: if a correct process decides a value-proof pair
(ğ‘£,Î£), then verify(ğ‘£,Î£)=true. Technically speaking, the authors of
Quad only consider Weak Validity , i.e., they do not claim that the
their protocol satisfies the aforementioned validity property. How-
ever, modifying their protocol to accommodate for the aforemen-
tioned property is trivial: each correct process simply discards each
message which contains a pair (ğ‘£,Î£)for which verify(ğ‘£,Î£)=false.
Another subtle remark is that the authors of Quad prove its
message and latency complexity assuming that all correct processes
start executing Quad by GST. In Algorithm 1, this might not be
the case: correct processes might receive ğ‘›âˆ’ğ‘¡proposal messages
atGST+ğ›¿(line 14), and thus start executing Quad atGST+ğ›¿
(line 17). Nevertheless, it is easy to show that Quad ensures the
stated complexity even if all correct processes start executing the
algorithm by time GST+ğ›¿. Not only that, even if correct processes
do not start executing Quad withinğ›¿time after GST, but they all
start executing the algorithm within ğ›¿time from each other (after
GST), the message complexity remains quadratic and the latency
remains linear (measured from the time the first correct process
starts executing Quad ).
Correctness & complexity. First, we prove the correctness.
Theorem 6. Algorithm 1 is correct.
Proof. Agreement follows directly from the fact that Quad sat-
isfies Agreement .Termination follows from (1) Termination ofQuad ,
and (2) the fact that, eventually, all correct processes receive ğ‘›âˆ’ğ‘¡
proposal messages (as there are at least ğ‘›âˆ’ğ‘¡correct processes).
We now prove that Algorithm 1 satisfies Vector Validity . Let a
correct process ğ‘ƒdecide vectorâ€²âˆˆIğ‘›âˆ’ğ‘¡from vector consensus
(line 19). Hence, ğ‘ƒhas decided(vectorâ€²,Î£â€²)from Quad , where (1)
Î£â€²is some proof, and (2) verify(vectorâ€²,Î£â€²)=true (due to the spec-
ification of Quad ). Furthermore, if there exists a process-proposal
pair(ğ‘ƒ,ğ‘£âˆˆVğ¼)invectorâ€², whereğ‘ƒis a correct process, a properly
signed proposal message belongs to Î£â€². As correct processes send
proposal messages only for their proposals (line 9), ğ‘£was indeed
proposed by ğ‘ƒ. Thus, the theorem. â–¡
Finally, we prove the complexity.
Theorem 7. The message complexity of Algorithm 1 is ğ‘‚(ğ‘›2).
Proof. The message complexity of the specific instance of Quad
utilized in Algorithm 1 is ğ‘‚(ğ‘›2). Additionally, correct processes
exchangeğ‘‚(ğ‘›2)proposal messages. Thus, the message complexity
isğ‘‚(ğ‘›2)+ğ‘‚(ğ‘›2)=ğ‘‚(ğ‘›2). â–¡
13Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
B.2 Non-Authenticated Implementation:
Pseudocode & Proofs
We now present a non-authenticated implementation (Algorithm 3)
of vector consensus. The design of Algorithm 3 follows the reduc-
tion from binary consensus to multivalued consensus (e.g., [ 35]).
Namely, we use the following two building blocks in Algorithm 3:
(1)Byzantine Reliable Broadcast [ 20,23]: This primitive allows
processes to disseminate information in a reliable manner.
Formally, Byzantine reliable broadcast exposes the follow-
ing interface: (1) request broadcast(ğ‘š), and (2) indication
deliver(ğ‘šâ€²). The primitive satisfies the following proper-
ties:
â€¢Validity: If a correct process ğ‘ƒbroadcasts a message
ğ‘š,ğ‘ƒeventually delivers ğ‘š.
â€¢Consistency: No two correct processes deliver different
messages.
â€¢Integrity: Every correct process delivers at most one
message. Moreover, if a correct process delivers a mes-
sageğ‘šfrom a process ğ‘ƒandğ‘ƒis correct, then ğ‘ƒbroad-
castğ‘š.
â€¢Totality: If a correct process delivers a message, every
correct process delivers a message.
In Algorithm 3, we use a non-authenticated implementa-
tion [20] of the Byzantine reliable broadcast primitive.
(2)Binary DBFT [ 35], a non-authenticated algorithm which
solves the Byzantine consensus problem with Strong Validity .
Let us briefly explain how Algorithm 3 works; we focus on a
correct process ğ‘ƒğ‘–. First,ğ‘ƒğ‘–reliably broadcasts its proposal (line 10).
Onceğ‘ƒğ‘–delivers a proposal of some process ğ‘ƒğ‘—(line 11),ğ‘ƒğ‘–proposes
1to the corresponding DBFT instance (line 15). Eventually, ğ‘›âˆ’ğ‘¡
DBFT instances decide 1(line 16). Once that happens, ğ‘ƒğ‘–proposes
0to all DBFT instances to which ğ‘ƒğ‘–has not proposed (line 20).
When all DBFT instances have decided (line 21), ğ‘ƒğ‘–decides an input
configuration associated with the first ğ‘›âˆ’ğ‘¡processes whose DBFT
instances decided 1(constructed at line 22).
Theorem 8. Algorithm 3 is correct.
Proof. We start by proving Termination of Algorithm 3. Even-
tually, at least ğ‘›âˆ’ğ‘¡DBFT instances decide 1due to the fact that (1)
no correct process proposes 0to any DBFT instance unless ğ‘›âˆ’ğ‘¡
DBFT instances have decided 1(line 16), and (2) all correct processes
eventually propose 1to the DBFT instances which correspond to
the correct processes (unless ğ‘›âˆ’ğ‘¡DBFT instances have already
decided 1). Whenğ‘›âˆ’ğ‘¡DBFT instances decide 1(line 16), each
correct process proposes to all instances to which it has not yet
proposed (line 20). Hence, eventually all DBFT instances decide,
and (at least) ğ‘›âˆ’ğ‘¡DBFT instances decide 1. Therefore, the rule at
line 21 eventually activates at every correct process, which implies
that every correct process eventually decides (line 23).
Next, we prove Vector Validity . If a correct process ğ‘ƒdecides
an input configuration with a process-proposal pair (ğ‘„,ğ‘£),ğ‘ƒhas
delivered a proposal message from ğ‘„(line 11). Ifğ‘„is correct, due
to integrity of the reliable broadcast primitive, ğ‘„â€™s proposal was
indeedğ‘£.Finally, Agreement follows from (1) Agreement of DBFT, and (2)
consistency of the reliable broadcast primitive. Therefore, Algo-
rithm 3 is correct. â–¡
The main downside of Algorithm 3 is that its message complex-
ity isğ‘‚(ğ‘›4). Therefore, non-authenticated version of Universal
hasğ‘‚(ğ‘›4)message complexity, which is not optimal according to
our lower bound (Â§5.1). Interestingly, as Algorithm 3 shows that
vector consensus can be solved using consensus with Strong Va-
lidity ,Strong Validity is â€œanotherâ€ strongest validity property: a
solution to consensus with Strong Validity yields a solution to any
non-trivial consensus variant (although with additional cost).
B.3 Implementation with ğ‘‚(ğ‘›2logğ‘›)
Communication: Pseudocode & Proofs
In this subsection, we give an implementation of vector consensus
withğ‘‚(ğ‘›2logğ‘›)communication complexity, which comes within
a logarithmic factor of the lower bound (Â§5.1). This implementation
represents a near-linear communication improvement over Algo-
rithm 1 (Â§5.2), which achieves ğ‘‚(ğ‘›3)communication complexity.
We note that the following solution is highly impractical due to its
exponential latency. However, our solution does represent a step
towards closing the existing gap in the communication complexity
of consensus with non-trivial (and solvable) validity properties.
Threshold signatures. For this implementation, we assume a (ğ‘˜,ğ‘›)-
threshold signature scheme [ 65], whereğ‘˜=ğ‘›âˆ’ğ‘¡. In a threshold
signature scheme, each process holds a distinct private key, and
there exists a single public key. Each process ğ‘ƒğ‘–can use its private
key to produce a (partial) signature of a message ğ‘š. Moreover, a
signature can be verified by other processes. Finally, a set of signa-
tures for a message ğ‘šfromğ‘˜(the threshold) distinct processes can
be combined into a single threshold signature for ğ‘š, which proves
thatğ‘˜processes have signed ğ‘š.
Hash functions. We denote by hash(Â·)a collision-resistant hash
function.
B.3.1 Vector Dissemination. First, we formally define the vector
dissemination problem, which plays the crucial role in our vector
consensus algorithm with improved communication complexity. In
this problem, each correct process disseminates a vector of exactly
ğ‘›âˆ’ğ‘¡values, and all correct processes eventually acquire (1) a
hash of some disseminated vector, and (2) a threshold signature for
that hash. Formally, the vector dissemination problem exposes the
following interface:
â€¢request disseminate(Vector vec): a process disseminates a
vector vec.
â€¢indication acquire(Hash _Valueğ»,T_Signature tsig): a pro-
cess acquires a hash value ğ»â€²and a threshold signature tsig.
The following properties are required:
â€¢Termination: Every correct process eventually acquires a
hash-signature pair.
â€¢Integrity: If a correct process acquires a hash-signature pair
(ğ»,tsig), then verify _sig(ğ»,tsig)=true.
â€¢Redundancy: Let a correct process cache (i.e., store in its
local memory) a threshold signature tsigfor some hash
14On the Validity of Consensus (Extended Version)
Algorithm 3 Non-Authenticated Vector Consensus: Pseudocode (for process ğ‘ƒğ‘–)
1:Uses:
2: Non-Authenticated Byzantine Reliable Broadcast [20], instance brb
3: Binary DBFT [35], instances dbft[1], ...,dbft[ğ‘›] âŠ²one instance of the binary DBFT algorithm per process
4:upon init:
5: Map(Processâ†’Vğ¼)proposalsğ‘–â†empty âŠ²received proposals
6: Boolean dbft_proposingğ‘–=true âŠ²isğ‘ƒğ‘–still proposing 1s to the DBFT instances
7: Map(Processâ†’Boolean)dbft_proposedğ‘–â†{false,for every Process}
8: Integer dbft_decisionsğ‘–â†0 âŠ²the number of the DBFT instances which have decided
9:upon propose(ğ‘£âˆˆVğ¼):
10: invoke brb.broadcast âŸ¨proposal,ğ‘£âŸ©âŠ²broadcast a proposal
11:upon reception of Messageğ‘š=âŸ¨proposal,ğ‘£ğ‘—âˆˆVğ¼âŸ©from process ğ‘ƒğ‘—: âŠ²delivered from brb
12: proposalsğ‘–[ğ‘ƒğ‘—]â†ğ‘£ğ‘—
13: ifdbft_proposingğ‘–=true:
14: dbft_proposedğ‘–[ğ‘ƒğ‘—]â† true
15: invoke dbft[ğ‘—].propose(1)
16:uponğ‘›âˆ’ğ‘¡DBFT instances have decided 1 (for the first time):
17: dbft_proposingğ‘–â†false
18: forevery Processğ‘ƒğ‘—such that dbft_proposedğ‘–[ğ‘ƒğ‘—]=false :
19: dbft_proposedğ‘–[ğ‘ƒğ‘—]â† true
20: invoke dbft[ğ‘—].propose(0)
21:upon all DBFT instances decided, and, for the first ğ‘›âˆ’ğ‘¡processesğ‘ƒğ‘—such that dbft[ğ‘—]decided 1,proposalsğ‘–[ğ‘ƒğ‘—]â‰ âŠ¥:
22: Input _Configuration vectorâ†input configuration with ğ‘›âˆ’ğ‘¡process-proposal pairs corresponding to the first ğ‘›âˆ’ğ‘¡DBFT instances which decided 1
23: trigger decide(vector)
valueğ». Then, (at least) ğ‘¡+1correct processes have cached
a vector vecsuch that hash(vec)=ğ».
Slow broadcast. In order to solve the vector dissemination prob-
lem, we present a simple algorithm (Algorithm 4) which implements
slow broadcast . In slow broadcast, each process disseminates its vec-
tor in â€œone-by-oneâ€ fashion, with a â€œwaiting stepâ€ between any two
sending events. Specifically, process ğ‘ƒ1broadcasts its vector by (1)
sending the vector to ğ‘ƒ1(line 3), and then waiting ğ›¿time (line 4),
(2) sending the vector to ğ‘ƒ2(line 3), and then waiting ğ›¿time (line 4),
etc. Process ğ‘ƒ2broadcasts its vector in the same manner, but it
waitsğ›¿Â·ğ‘›time (line 4). Crucially, if the system is synchronous,
the waiting time of ğ‘ƒ2is (roughly) sufficient for ğ‘ƒ1tocompletely
disseminate its vector. This holds for any two processes ğ‘ƒğ‘–andğ‘ƒğ‘—
withğ‘–<ğ‘—.
Algorithm 4 Slow Broadcast: Pseudocode (for process ğ‘ƒğ‘–)
1:upon broadcast(Vector vec):
2: for each Processğ‘ƒğ‘—:
3: sendâŸ¨slow_broadcast ,vecâŸ©toğ‘ƒğ‘—
4: wait forğ›¿Â·ğ‘›(ğ‘–âˆ’1)time
5:upon reception ofâŸ¨slow_broadcast ,Vector vecâ€²âŸ©from process ğ‘ƒğ‘—:
6: trigger deliver(vecâ€²,ğ‘ƒğ‘—)
Algorithm description. Our solution is given in Algorithm 5. We
explain it from the perspective of a correct process ğ‘ƒğ‘–.
Whenğ‘ƒğ‘–starts disseminating its vector vec(line 8),ğ‘ƒğ‘–stores
its hash (line 9) and slow-broadcasts the vector (line 10). Once ğ‘ƒğ‘–
receives stored messages from ğ‘›âˆ’ğ‘¡distinct processes (line 17),
ğ‘ƒğ‘–combines the received partial signatures into a threshold signa-
ture (line 18). Then, ğ‘ƒğ‘–broadcasts (using the best-effort broadcast
primitive) the signature (line 19).
Wheneverğ‘ƒğ‘–receives a threshold signature (line 21), ğ‘ƒğ‘–checks
whether the signature is valid (line 22). If it is, ğ‘ƒğ‘–rebroadcasts the
signature (line 23), acquires a hash value and the signature (line 24),
and stops participating (i.e., sending and processing messages) invector dissemination (line 25). Observe that, once ğ‘ƒğ‘–stops partic-
ipating in vector dissemination (line 25), it stops participating in
slow broadcast, as well.
Correctness & complexity. We start by proving redundancy.
Lemma 9. Algorithm 5 satisfies redundancy.
Proof. Let a correct process cache a threshold signature tsigâ€²
for some hash value ğ»â€². Hence,ğ‘›âˆ’ğ‘¡processes have (partially)
signedğ»â€². Among these ğ‘›âˆ’ğ‘¡processes, at least ğ‘¡+1are correct
(asğ‘›>3ğ‘¡). Before signing ğ»â€²(line 15), all these correct processes
cache a vector vecâ€²(line 14), where hash(vecâ€²)=ğ»â€². â–¡
The following lemma proves that, if a correct process ğ‘ƒğ‘–starts the
dissemination of its vector at time ğ‘¡ğ‘–, then every correct process ac-
quires a hash value and a threshold signature by time max(GST,ğ‘¡ğ‘–)+
ğ›¿Â·ğ‘›ğ‘–+3ğ›¿. We emphasize that the max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+3ğ›¿time is
not tight; we choose it for simplicity of presentation.
Lemma 10. If a correct process ğ‘ƒğ‘–starts the dissemination of its
vector at time ğ‘¡ğ‘–, every correct process acquires a hash value and a
threshold signature by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+3ğ›¿.
Proof. We separate the proof into two cases:
â€¢There exists a correct process which acquires a hash-signature
pair by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+2ğ›¿. In this case, the state-
ment of the lemma holds as every correct process acquires
a pair by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+3ğ›¿due to the â€œrebroad-
casting stepâ€ (line 23).
â€¢There does not exist a correct process which acquires a hash-
signature pair by time ğ‘‡=max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+2ğ›¿. Hence,
no process stops participating in vector dissemination by
timeğ‘‡, i.e., no process executes line 25 by time ğ‘‡. Every
correct process receives a slow_broadcast message from
processğ‘ƒğ‘–by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+ğ›¿.
Thus, by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+2ğ›¿,ğ‘ƒğ‘–receivesğ‘›âˆ’ğ‘¡partial
signatures (line 17). Finally, by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+3ğ›¿,
15Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Algorithm 5 Vector Dissemination: Pseudocode (for process ğ‘ƒğ‘–)
1:Uses:
2: Best-Effort Broadcast [23], instance beb âŠ²broadcast with no guarantees if the sender is faulty
3: Slow Broadcast, instance slow âŠ²see Algorithm 4
4:upon init:
5: Hash _Valueğ»ğ‘–â†âŠ¥ âŠ²hash of the message ğ‘ƒğ‘–slow-broadcasts
6: Map(Hash _Valueâ†’Vector)vectorsğ‘–â†empty âŠ²received vectors
7: Set(Process)disseminated ğ‘–â†empty âŠ²processes who have disseminated a vector
8:upon disseminate(Vector vec):
9:ğ»ğ‘–â†hash(vec)
10: invoke slow.broadcast(vec)
11:upon slow.deliver(Vector vecâ€²,Processğ‘ƒğ‘—):
12: ifğ‘ƒğ‘—âˆ‰disseminated ğ‘–:
13: disseminated ğ‘–â†disseminated ğ‘–âˆª{ğ‘ƒğ‘—}
14: vectorsğ‘–[hash(vecâ€²)]â† vecâ€²âŠ²cache vecâ€²
15: sendâŸ¨stored,hash(vecâ€²),partially _signğ‘– hash(vecâ€²)âŸ©toğ‘ƒğ‘— âŠ²acknowledge the reception by sending a partial signature to ğ‘ƒğ‘—
16:âŠ²acknowledgements are received
17:upon reception of Messageğ‘šğ‘—=âŸ¨stored,Hash _Valueğ»â€²,P_Signature psigâŸ©such thatğ»â€²=ğ»ğ‘–fromğ‘›âˆ’ğ‘¡distinct processes:
18: T_Signature tsigâ†combine {psig|psig is a signature received in the stored messages}
19: invoke beb.broadcast âŸ¨confirm,ğ»ğ‘–,tsigâŸ©âŠ²disseminate the threshold signature
20:âŠ²a threshold signature is received
21:upon reception of Messageğ‘š=âŸ¨confirm,Hash _Valueğ»â€²,T_Signature tsigâ€²âŸ©:
22: iftsigâ€²is a valid(ğ‘›âˆ’ğ‘¡)-threshold signature for ğ»â€²: âŠ²check that the threshold signature is valid
23: invoke beb.broadcast âŸ¨confirm,ğ»â€²,tsigâ€²âŸ©âŠ²rebroadcast the threshold signature
24: trigger acquire(ğ»â€²,tsigâ€²)
25: stop participating in vector dissemination (and slow broadcast)
every correct process receives a confirm message from ğ‘ƒğ‘–
(line 21), and acquires a hash-signature pair (line 24). In
this case, the statement of the lemma holds.
The lemma holds as its statement is satisfies in both cases. â–¡
The next lemma proves that Algorithm 5 satisfies termination.
Lemma 11. Algorithm 5 satisfies termination.
Proof. Follows directly from Lemma 10. â–¡
Next, we prove integrity.
Lemma 12. Algorithm 5 satisfies integrity.
Proof. Follows from the check at line 22. â–¡
Therefore, Algorithm 5 solves the vector dissemination problem.
Theorem 9. Algorithm 5 is correct.
Lastly, we prove that the communication complexity of Algo-
rithm 5 isğ‘‚(ğ‘›2). Recall that the communication complexity denotes
the number of words sent by correct processes at and after GST,
where a word consists of a constant number of values, hashes and
signatures.
Theorem 10. Let no correct process start the dissemination of its
vector after time GST+ğ›¿. Then, the communication complexity of
Algorithm 5 is ğ‘‚(ğ‘›2).
Proof. Letğ‘–be the minimum index such that (1) process ğ‘ƒğ‘–is
correct, and (2) ğ‘ƒğ‘–sends a slow_broadcast message at some time
â‰¥GST. Ifğ‘–does not exist, the lemma trivially holds.
Letğ‘¡ğ‘–denote the time at which ğ‘ƒğ‘–starts the dissemination of its
vector (line 8). By assumption, ğ‘¡ğ‘–â‰¤GST+ğ›¿. Every correct process
acquires a hash-signature pair by time max(GST,ğ‘¡ğ‘–)+ğ›¿Â·ğ‘›ğ‘–+3ğ›¿(by
Lemma 10). Thus, as ğ‘¡ğ‘–â‰¤GST+ğ›¿, every correct process acquires a
hash-signature pair by time GST+ğ›¿Â·ğ‘›ğ‘–+4ğ›¿. Moreover, by timeGST+ğ›¿Â·ğ‘›ğ‘–+4ğ›¿, all correct processes stop sending slow_broadcast
messages (due to line 25).
Letğ‘ƒğ‘—be a correct process such that ğ‘—>ğ‘–. Due to the slow
broadcast primitive (Algorithm 4), ğ‘ƒğ‘—has a â€œwaiting stepâ€ of (at
least)ğ›¿Â·ğ‘›ğ‘–time (after GST). Therefore, during the [GST,GST+ğ›¿Â·
ğ‘›ğ‘–+4ğ›¿]period,ğ‘ƒğ‘—can send only ğ‘‚(1)slow_broadcast messages.
Thus, at most one correct process (i.e., ğ‘ƒğ‘–) sends more than ğ‘‚(1)
slow_broadcast messages during the [GST,GST+ğ›¿Â·ğ‘›ğ‘–+4ğ›¿]
period; that process sends at most ğ‘›slow_broadcast messages.
As each message is of size ğ‘‚(ğ‘›)(since it carries a vector of ğ‘›âˆ’ğ‘¡
values), the communication complexity of Algorithm 5 is ğ‘‚(ğ‘›)Â·
ğ‘‚(1)Â·ğ‘‚(ğ‘›)+1Â·ğ‘‚(ğ‘›)Â·ğ‘‚(ğ‘›)=ğ‘‚(ğ‘›2). â–¡
B.3.2 Vector Consensus with ğ‘‚(ğ‘›2logğ‘›)Communication Complex-
ity.Finally, we are ready to present our vector consensus algorithm
(Algorithm 6) with subcubic communication complexity. Our al-
gorithm consists of three building blocks: (1) vector dissemination
(Appendix B.3.1), (2) Quad (Â§5.2.1), and (3) add [36], an algorithm
for asynchronous data dissemination. In Algorithm 6, we rely on
a specific instance of Quad in which (1) each proposal value is
a hash value, and (2) given a hash value ğ»and a Quad â€™s proof
Î£,verify(ğ»,Î£)=trueif and only if Î£is a valid(ğ‘›âˆ’ğ‘¡)-threshold
signature for ğ». Below, we briefly explain add.
add.This algorithm solves the data dissemination [36] problem
defined in the following way. Let ğ‘€be a data blob which is an input
of (at least) ğ‘¡+1correct processes; other correct processes have
âŠ¥as their input. The data dissemination problem requires every
correct process to eventually output ğ‘€, and no other message. The
key feature of add is that it solves the problem with ğ‘‚(ğ‘›2logğ‘›)
communication complexity. (For the full details on add, see [36].)
Algorithm description. We give the description of Algorithm 6
from the perspective of a correct process ğ‘ƒğ‘–. Whenğ‘ƒğ‘–proposes
its value (line 10), it disseminates the value (using the best-effort
16On the Validity of Consensus (Extended Version)
broadcast primitive) to all processes (line 11). Once ğ‘ƒğ‘–receives
proposals of ğ‘›âˆ’ğ‘¡distinct processes (line 16), it constructs an input
configuration (line 17), and starts disseminating it (line 18).6
Whenğ‘ƒğ‘–acquires a hash value ğ»and a threshold signature
tsig(line 19),ğ‘ƒğ‘–proposes(ğ»,tsig)toQuad (line 21). Observe that
verify(ğ»,tsig)=true(due to the integrity property of vector dis-
semination). Once ğ‘ƒğ‘–decides from Quad (line 22), it starts add
(line 24). Specifically, ğ‘ƒğ‘–checks whether it has cached an input
configuration whose hash value is ğ»â€²(line 23). If so, ğ‘ƒğ‘–inputs the
input configuration to add; otherwise, ğ‘ƒğ‘–inputsâŠ¥. Onceğ‘ƒğ‘–outputs
an input configuration from add (line 25), it decides it (line 26).
Correctness & complexity. We start by proving that (1) all correct
processes eventually output a non- âŠ¥value from add, and (2) no
two correct processes output different values from add.
Lemma 13. The following holds:
â€¢Every correct process eventually outputs a non- âŠ¥value
from add(line 25); moreover, the output value was an input
(toadd) of a correct process.
â€¢No two correct processes output different input configura-
tions from add (line 25).
Proof. First, every correct process broadcasts its proposal (line
11). Thus, every correct process eventually receives ğ‘›âˆ’ğ‘¡proposals
(line 16), and starts the dissemination of an input configuration
(line 18). Due to the termination property of vector dissemination
(Lemma 11), every correct process acquires a hash-signature pair
(line 19). Hence, every correct process eventually proposes to Quad
(line 21). Due to Termination ofQuad , every correct process eventu-
ally decides from Quad (line 22), and starts executing add (line 24).
As the pair decided from Quad (recall that Quad satisfies Agree-
ment ) includes a threshold signature, at least ğ‘¡+1correct processes
have cached an input configuration whose hash value is decided
from Quad (by redundancy of vector dissemination). Therefore,
all of these correct processes input the same non- âŠ¥value to add
(line 24); let that value be vec. Moreover, no correct process inputs
a different non-âŠ¥value to add. Therefore, the conditions required
byadd are met, which implies that all correct processes eventually
output vecâ‰ âŠ¥from add (line 25). â–¡
The following theorem proves that Algorithm 6 is correct.
Theorem 11. Algorithm 6 is correct.
Proof. Agreement andTermination follow from Lemma 13.
It is left to prove Vector Validity . Letvecâ€²be an input configuration
ofğ‘›âˆ’ğ‘¡proposals decided by a correct process (line 26). Hence,
vecâ€²is an input (to add) of a correct process (by Lemma 13), which
implies that some correct process has previously cached vecâ€². Before
a correct process caches a vector (Algorithm 5), it verifies that
it is associated with corresponding proposal messages; we omit
this check for brevity. As correct processes only send proposal
messages for their proposals (line 11), Vector Validity is satisfied. â–¡
Lastly, we show the communication complexity of Algorithm 6.
Theorem 12. The communication complexity of Algorithm 6 is
ğ‘‚(ğ‘›2logğ‘›).
6Recall that this input configuration is actually a vector of ğ‘›âˆ’ğ‘¡values.Proof. The communication complexity of a single best-effort
broadcast instance is ğ‘‚(ğ‘›). Every correct process starts the dissemi-
nation of its vector by time GST+ğ›¿(as every correct process receives
ğ‘›âˆ’ğ‘¡proposals by this time). Thus, the communication complexity of
vector dissemination is ğ‘‚(ğ‘›2)(by Theorem 10). The communication
complexity of Quad isğ‘‚(ğ‘›2). Moreover, the communication com-
plexity of addisğ‘‚(ğ‘›2logğ‘›)(see [ 36]). As Algorithm 6 is a composi-
tion of the aforementioned building blocks, its communication com-
plexity isğ‘›Â·ğ‘‚(ğ‘›)+ğ‘‚(ğ‘›2)+ğ‘‚(ğ‘›2)+ğ‘‚(ğ‘›2logğ‘›)=ğ‘‚(ğ‘›2logğ‘›).â–¡
C EXTENDED FORMALISM
In this section, we give intuition behind an extension of our formal-
ism which is suitable for the analysis of blockchain-specific validity
properties, such as External Validity [22,24,93].External Validity
stipulates that any decided value must satisfy a predetermined log-
ical predicate. However, the â€œdifficultyâ€ of this property is that the
logical predicate (usually) verifies a cryptographic proof, which
processes might not know a priori (see Appendix C.1).
In a nutshell, we make our original formalism more expressive
by (1) making the input ( Vğ¼) and output (Vğ‘‚) spaces â€œunknownâ€
to the processes, and (2) taking into account â€œproposalsâ€ of faulty
processes. In the rest of the paper:
â€¢We refer to the formalism introduced in the main body of
the paper as the â€œoriginal formalismâ€.
â€¢We refer to the formalism we introduce below as the â€œex-
tended formalismâ€.
We start by giving an intuition behind our extended formalism
(Appendix C.1). Then, we introduce some preliminaries (Appen-
dix C.2). Finally, we (incompletely) define our extended formalism
(Appendix C.3).
C.1 Intuition
In the original formalism, processes know the entire input space
Vğ¼and the entire output space Vğ‘‚. That is, processes are able to
â€œproduceâ€ any value which belongs to Vğ¼orVğ‘‚. However, this
assumption limits the expressiveness of our formalism as it is im-
possible to describe a Byzantine consensus problem in which input
or output spaces are not a priori known. Let us give an example.
Imagine a committee-based blockchain which establishes two
roles:
â€¢Clients are the users of the blockchain. They issue signed
transactions to the blockchain.
â€¢Servers are the operating nodes of the blockchain. Servers
receive signed transactions issued by the clients, and solve
the Byzantine consensus problem to agree on the exact
order the transactions are processed.
As the servers propose transactions signed by the clients and they do
not have access to the private keys of the clients, the servers do not
know the input space Vğ¼nor the output space Vğ‘‚of the Byzantine
consensus problem. Hence, our original formalism cannot describe
the Byzantine consensus problem in the core of the aforementioned
blockchain.
Extended vs. original formalism. As highlighted above, the main
difference between the two formalisms is that the extended one
allows us to specify the â€œknowledge levelâ€ of the input and out-
put spaces. In the extended formalism, a process is able to â€œlearnâ€
17Pierre Civit, Seth Gilbert, Rachid Guerraoui, Jovan Komatovic, and Manuel Vidigueira
Algorithm 6 ğ‘‚(ğ‘›2logğ‘›)Vector Consensus: Pseudocode (for process ğ‘ƒğ‘–)
1:Uses:
2: Best-Effort Broadcast [23], instance beb âŠ²broadcast with no guarantees if the sender is faulty
3: Vector Dissemination, instance disseminator âŠ²see Algorithm 5
4: Quad [28], instance quad
5: add [36], instance add
6:upon init:
7: Integer received _proposalsğ‘–â†0 âŠ²the number of received proposals
8: Map(Processâ†’Vğ¼)proposalsğ‘–â†empty âŠ²received proposals
9: Map(Processâ†’Message)messagesğ‘–â†empty âŠ²received proposal messages
10:upon propose(ğ‘£âˆˆVğ¼):
11: invoke beb.broadcast âŸ¨proposal,ğ‘£âŸ©ğœğ‘–âŠ²broadcast a signed proposal
12:upon reception of Messageğ‘š=âŸ¨proposal,ğ‘£ğ‘—âˆˆVğ¼âŸ©ğœğ‘—from process ğ‘ƒğ‘—andreceived _proposalsğ‘–<ğ‘›âˆ’ğ‘¡:
13: received _proposalsğ‘–â†received _proposalsğ‘–+1
14: proposalsğ‘–[ğ‘ƒğ‘—]â†ğ‘£ğ‘—
15: messagesğ‘–[ğ‘ƒğ‘—]â†ğ‘š
16: ifreceived _proposalsğ‘–=ğ‘›âˆ’ğ‘¡: âŠ²receivedğ‘›âˆ’ğ‘¡proposals; can start disseminating
17: Input _Configuration vectorâ†input configuration constructed from proposalsğ‘–
18: invoke disseminator .disseminate(vector)
19:upon disseminator .acquire (Hash _Value H,T_Signature tsig):
20: ifhave not yet proposed to Quad :
21: invoke quad.propose (H,tsig)
22:upon quad.decide (Hash _Value Hâ€²,T_Signature tsigâ€²):
23: Input _Configuration vectorâ€²â†a cached vector whose hash value is ğ»â€²âŠ²can beâŠ¥
24: invoke add.input(vectorâ€²)
25:upon add.output Input _Configuration vectorâ€²â€²:
26: trigger decide(vectorâ€²â€²)
output values by observing input values. That is, we define a dis-
covery function that defines which output values are learned given
observed input values. In the committee-based blockchain example,
once a server observes signed (by the issuing clients) transactions
tx1andtx2, it learns the following output values: (1) tx1, (2)tx2, (3)
tx1||tx2, and (4) tx2||tx1.7
The second difference between the original and the extended
formalism is that the extended formalism takes into account â€œpro-
posalsâ€ of the faulty processes. Indeed, the original formalism does
not enable us to define which values are admissible given the adver-
saryâ€™s knowledge of the input space. Think of the aforementioned
example with a blockchain system. If no process (correct or faulty)
obtains a transaction tx,txcannot be decided. However, even if
only a faulty process obtains a transaction tx,txcould still be an
admissible decision. This scenario can be described by the extended
formalism, and not by the original one.
C.2 Preliminaries
We denote byVğ¼the input space of Byzantine consensus. Similarly,
Vğ‘‚denotes the output space.
Membership functions. We define two membership functions :
â€¢valid _input :{0,1}âˆ—â†’{true,false}: specifies whether a
bit-sequence belongs to the input space Vğ¼.
â€¢valid _output :{0,1}âˆ—â†’{true,false}: specifies whether a
bit-sequence belongs to the output space Vğ‘‚.
We assume that each process has access to these two functions.
That is, each process can verify whether an arbitrary sequence of
bits belongs to the input ( Vğ¼) or output (Vğ‘‚) space. In the case
of a committee-based blockchain (Appendix C.1), the membership
functions are signature-verification functions.
7We denote by â€œ||â€ the concatenation operation.Discovery function. We define a function discover :2Vğ¼â†’2Vğ‘‚.
Given a set of proposals ğ‘‰ğ¼âŠ†Vğ¼,discover(ğ‘‰ğ¼)âŠ†Vğ‘‚specifies the
set of decisions which are â€œdiscoverableâ€ by ğ‘‰ğ¼. We assume that
each process has access to the discover(Â·)function. Moreover, for
any two sets ğ‘‰1
ğ¼,ğ‘‰2
ğ¼withğ‘‰1
ğ¼âŠ†ğ‘‰2
ğ¼,discover(ğ‘‰1
ğ¼)âŠ†discover(ğ‘‰2
ğ¼); in
other words, â€œknowledgeâ€ of the output space can only be improved
upon learning more input values.
Let us take a look at the committee-based blockchain example
again (Appendix C.1). If a server obtains a proposal tx, it learns tx
as a potential decision. We model this â€œdeductionâ€ concept using
thediscover(Â·)function: discover {tx}={tx}.
Adversary pool. Given an execution E,P(E)âŠ†V ğ¼defines the
adversary pool inE. Informally, the adversary pool represents the
input values the adversary â€œknowsâ€. In the example of a committee-
based blockchain (Appendix C.1), the adversary pool is a set of
signed transactions which the adversary â€œlearnsâ€ from the clients.
We underline that the adversary pool is an abstract concept.
Specifically, the adversary pool represents the â€œstarting knowledgeâ€
the adversary has. However, the notion of the â€œstarting knowledgeâ€
must be precisely defined once all particularities of the exact con-
sidered system are taken into account. Due to sophisticated details
(such as the aforementioned one), we believe that a formalism suit-
able for blockchain-specific validity properties deserves its own
standalone paper.
C.3 Validity
We start by restating the definition of process-proposal pairs. A
process-proposal pair is a pair(ğ‘ƒ,ğ‘£), where (1)ğ‘ƒâˆˆÎ is a process, and
(2)ğ‘£âˆˆVğ¼is a proposal. Given a process-proposal pair pp=(ğ‘ƒ,ğ‘£),
proposal(pp)=ğ‘£denotes the proposal associated with pp.
18On the Validity of Consensus (Extended Version)
Aninput configuration is a tuple
pp1,pp2,...,ppğ‘¥,ğœŒ
ofğ‘¥process-
proposal pairs and a set ğœŒâŠ†Vğ¼, where (1)ğ‘›âˆ’ğ‘¡â‰¤ğ‘¥â‰¤ğ‘›, (2) every
process-proposal pair is associated with a distinct process, and (3)
ifğ‘¥=ğ‘›,ğœŒ=âˆ…. Intuitively, an input configuration represents an
assignment of proposals to correct processes, as well as a â€œpartâ€
of the input space known to the adversary. For example, an input
configuration
(ğ‘ƒ1,ğ‘£),(ğ‘ƒ2,ğ‘£),(ğ‘ƒ3,ğ‘£),{ğ‘£,ğ‘£â€²,ğ‘£â€²â€²}describes an exe-
cution in which (1) only processes ğ‘ƒ1,ğ‘ƒ2, andğ‘ƒ3are correct, (2)
processesğ‘ƒ1,ğ‘ƒ2, andğ‘ƒ3propose the same value ğ‘£, and (3) faulty
processes know only ğ‘£,ğ‘£â€², andğ‘£â€²â€².
We denote byIthe set of all input configurations. For every
input configuration ğ‘âˆˆI, we denote by ğ‘[ğ‘–]the process-proposal
pair associated with process ğ‘ƒğ‘–; if such a process-proposal pair
does not exist, ğ‘[ğ‘–]=âŠ¥. Moreover, we define by pool(ğ‘)the set
of input values associated with ğ‘(the â€œğœŒâ€ field ofğ‘). Next,ğœ‹(ğ‘)=
{ğ‘ƒğ‘–âˆˆÎ |ğ‘[ğ‘–]â‰ âŠ¥}denotes the set of all processes included in
ğ‘. Finally, correct _proposals(ğ‘)={ğ‘£âˆˆVğ¼|âˆƒğ‘–âˆˆ [1,ğ‘›]:ğ‘[ğ‘–]â‰ 
âŠ¥âˆ§proposal(ğ‘[ğ‘–])=ğ‘£}denotes the set of all proposals of correct
processes (as specified by ğ‘).
Given (1) an execution Eâˆˆexecs(A), whereAis an algorithm
with the propose(Â·)/decide(Â·)interface, and (2) an input configura-
tionğ‘âˆˆI, we say thatEcorresponds toğ‘(input _conf(E)=ğ‘) if and
only if (1)ğœ‹(ğ‘)=CorrA(E), (2) for every process ğ‘ƒğ‘–âˆˆCorrA(E),
ğ‘ƒğ‘–â€™s proposal inEisproposal(ğ‘[ğ‘–]), and (3)P(E) =pool(ğ‘).
A validity property valis a function val:Iâ†’ 2Vğ‘‚such that, for
every input configuration ğ‘âˆˆI,val(c)â‰ âˆ…. AlgorithmA, where
Aexposes the propose(Â·)/decide(Â·)interface, satisfies a validity
property valif and only if, in any execution E âˆˆ execs(A), no
correct process decides a value ğ‘£â€²âˆ‰val input _conf(E). That is,
an algorithm satisfies a validity property if and only if correct
processes decide only admissible values.
Assumptions on executions. Lastly, we introduce two assumptions
that conclude our proposal for the extended formalism.
Assumption 1. For every execution Eof any algorithmAwhich
solves the Byzantine consensus problem with some validity prop-
erty, if a correct process ğ‘ƒdecides a value ğ‘£â€²âˆˆVğ‘‚inE, thenğ‘£â€²âˆˆ
discover correct _proposals(ğ‘)âˆªpool(ğ‘), where input _conf(E)=
ğ‘.
Assumption 1 states that correct processes can only decide values
which are â€œdiscoverableâ€ using all the proposals of correct processes
and the knowledge of the adversary. For example, if every correct
process proposes the same value ğ‘£âˆˆVğ¼and the adversary pool
contains only ğ‘£â€²âˆˆVğ¼, then a correct process can only decide a
value from discover({ğ‘£,ğ‘£â€²}).
Next, we introduce an assumption concerned only with the
canonical executions (executions in which faulty processes do not
take any computational step).
Assumption 2. For every canonical execution Eof any algorithm
Awhich solves the Byzantine consensus problem with some valid-
ity property, if a correct process ğ‘ƒdecides a value ğ‘£â€²âˆˆVğ‘‚inE, then
ğ‘£â€²âˆˆdiscover correct _proposals(ğ‘), where input _conf(E)=ğ‘.
Intuitively, Assumption 2 states that, if faulty processes are silent,
correct processes can only decide values which can be discoveredusing their own proposals. In other words, correct processes can-
not use â€œhiddenâ€ proposals (possessed by the silent adversary) to
discover a decision.
Finally, we underline that these two assumptions do not com-
pletely prevent â€œunreasonableâ€ executions. For example, given these
two assumptions, a (correct or faulty) process is still able to send a
message with a value which cannot be discovered using the pro-
posals of correct processes and the adversary pool. Hence, an as-
sumption that prevents such an execution should be introduced.
Thus, due to the complexity of the extended formalism, we leave
it out of this paper. In the future, we will focus on this interesting
and important problem.
19
arXiv:2303.10391v1  [cs.DC]  18 Mar 2023Deterministic Rendezvous Algorithms
Andrzej Pelc∗
Abstract
The task of rendezvous (also called gathering ) calls for a meeting of two or more mobile
entities, starting from diﬀerent positions in some environment. Tho se entities are called mobile
agents or robots, and the environment can be a network modeled a s a graph or a terrain in
the plane, possibly with obstacles. The rendezvous problem has bee n studied in many diﬀerent
scenarios. Two among many adopted assumptions particularly inﬂue nce the methodology to be
used to accomplish rendezvous. One of the assumptions speciﬁes w hether the agents in their
navigationcanseesomethingapartfrompartsoftheenvironment itself, forexampleotheragents
or marks left by them. The other assumption concerns the way in wh ich the entities move: it
can be either deterministic or randomized. In this paper we survey r esults on deterministic
rendezvous of agents that cannot see the other agents prior to meeting them, and cannot leave
any marks.
keywords: mobile agent, rendezvous, deterministic, network, graph, terra in, plane
∗D´ epartement d’informatique, Universit´ e du Qu´ ebec en Ou taouais, Gatineau, Qu´ ebec J8X 3X7, Canada. E-mail:
pelc@uqo.ca
Partially supported by NSERC discovery grant 8136 – 2013 and by the Research Chair in Distributed Computing at
the Universit´ e du Qu´ ebec en Outaouais.1 Introduction
How to meet in an unknown environment? This question has to be answered in many applications.
Themostobviousandcommonlyencounteredarethosewhereth eentities thathavetomeetarepart
of the natural world: they are humans or animals. One of the ex amples cited in [2] is the Astronaut
Problem, in which two astronauts land in distant places on a p lanet, without any orientation, and
have to minimize the expected time of getting together. More common examples of situations when
humans have to meet is the task of ﬁnding a lost hiker in the mou ntains by rescuers, or meeting
guests at the airport by their host. Schelling [38] studied i ssues related to rendezvous problems:
two players want to meet in an unknown town and have only one at tempt to make. Schelling
emphasized the need of ﬁnding “focal points” (such as the mai n station, or the central square of
the town) that are likely to be chosen by both players (withou t previous agreement), due to their
common cultural background. However, in algorithmic rende zvous problems, focal points often
do not exist, when agents have to meet in the empty plane or in a highly symmetric network.
Rendezvous tasks are also frequent in the animal world, such as gathering of migratory birds or
undersea animals, or penguin parents ﬁnding their oﬀspring w hen they come back with food.
In computer science applications, the most interesting cas es concern human-made agents. The ﬁrst
example of such mobile agents are autonomous mobile robots t hat start in diﬀerent locations of a
planar terrain or a labyrinth, and have to meet. The reason of meeting can be to exchange samples
of the ground previously collected by the robots, or exchang e information obtained when exploring
diﬀerent parts of the terrain. The second example is that of so ftware agents, i.e., mobile pieces of
software that navigate in a computer network in order to perf orm maintenance of its components or
to collect data distributed in nodes of the network. Periodi c meeting of software agents is necessary
to exchange collected data and plan further actions, possib ly depending on those data.
Since rendezvous algorithms do not depend on the physical na ture of the mobile entities executing
them, but only on their perception capabilities, memory siz e, mobility characteristics and on the
structure of the environment, we will not distinguish betwe en natural and artiﬁcial agents, and
among the latter between mobile robots and software agents, and we will use the generic name of
agentsregardless of whether the algorithm is to be applied to peopl e, animals, mobile robots, or
software agents. In the case of more than two agents, the rend ezvous problem is sometimes called
gathering . For the sake of uniformity, we will call it rendezvous also in this case, using the term
gathering as a synonym.
Since rendezvous problems usually have to be solved without the help of any central monitor
coordinating the actions of agents, these problems belong n aturally to the domain of distributed
computing. There are, however, many scenarios and models un der which rendezvous has been
studied. Two among many adopted assumptions particularly i nﬂuence the methodology to be used
to accomplish rendezvous.
One of the assumptions speciﬁes whether the agents in their n avigation can see something apart
from the underlying environment itself, for example other a gents or marks left by them. Needless
to say, such a capability signiﬁcantly facilitates the task of rendezvous: for example, two agents
seeing each other in the plane may meet approaching each othe r along the line joining them. The
other assumption concerns the way in which the entities move : it can be either deterministic
or randomized. In a deterministic scenario, the initial pos itions of the agents are chosen by an
2adversary which models the worst-case situation, and each m ove of the agent is determined only
by its current history that may include the identity of the ag ent (if any), and the part of the
environment that theagent hasseen todate. By contrast, ina randomizedscenario, initial positions
of the agents are often chosen at random and their moves may al so involve coin tosses. Randomized
rendezvous algorithms in networks often use random walks in the underlying graph. The cost of
rendezvous is also diﬀerent in both scenarios: while in deter ministic rendezvous the worst-case cost
is usually considered (cost being deﬁned as the time or the le ngth of the agents’ trajectories until
rendezvous), in the randomized scenario it is the expected v alue of this quantity. In both cases
the problem is often to minimize the worst case (resp. expect ed) cost. Deterministic rendezvous
problems usually require combinatorial tools, while rando mized rendezvous often calls for analytic
methods.
In this chapter we consider the task of rendezvous under the w eaker variant of each of the above
two assumptions. First we assume that the navigating agents do not see other agents prior to
their meeting and cannot leave any marks, and second, we cons ider only deterministic rendezvous
algorithms. The decision of carving out this particular sub domain of the domain of rendezvous
algorithms has two reasons. The ﬁrst and the most obvious of t hem is the space limitation: the
realm of rendezvous algorithms is very large and covering al l of it would require a large book rather
than a chapter. The second reason is to avoid duplication of i nformation contained in previous
surveys and in other chapters of this book.
There are six main previous surveys concerning rendezvous. Chronologically the ﬁrst of them is
[1], almost entirely contained in the second part of the exce llent book [2]. Both [1] and [2] concern
randomized rendezvous, viewed from the operations researc h point of view. The third survey is
[31]. While its scope is large, the authors concentrate main ly on presenting rendezvous models
and compare their underlying assumptions. The book [30] dea ls mostly with rendezvous problems
on the ring, only brieﬂy mentioning other network topologie s in this context. The survey [35] is
the closest to the present chapter but it covers only determi nistic rendezvous in networks. Finally,
Chapter XXX of this book covers the rich domain of gathering a gents in the plane, under a scenario
where agents have contrasting capabilities: they have no me mory but enjoy very strong perception
capabilities – they can periodically make snapshots in whic h they see other agents.
The existence of the book [2] is the main reason of our restric tion to deterministic rendezvous
algorithms, and chapter XXX of this book is the main reason of our restriction to rendezvous
under the scenario where navigating agents cannot see much.
The present chapter diﬀers from [1] and [2] by concentrating o n deterministic rather than on
randomized scenarios; it diﬀers from [31] by the level of deta ils in treating the rendezvous problem:
besides presenting various models under which determinist ic rendezvous is studied, we want to
report precisely the results obtained under each of them, di scussing how varying assumptions
inﬂuence feasibility and complexity of rendezvous under va rious settings. This chapter diﬀers from
[30] by discussing many diﬀerent topologies, mostly arbitra ry, even unknown graphs, rather than
concentrating on a particular type of networks. As mentione d above, this chapter is the closest to
[35]: the identity of the author may be a reason. What are the d iﬀerences with respect to [35]?
The survey [35] was published in 2012, reporting results unt il 2011. During these 7 years many
new results concerning deterministic rendezvous appeared in the literature. Since many of them
concerned the scenario where agents cannot leave any marks, and the scenario allowing marking of
3the nodes was considered in [35], we decided to exclude this s cenario from the present chapter, and
add instead issues concerning rendezvous in the plane, as th ey often use rendezvous in a speciﬁc
graph, the inﬁnite grid, as a methodological tool. There is s ome overlap of this chapter with [35]
but we tried to discuss the older results covered there only i n a cursory manner, concentrating on
the new developments.
A remark is in order concerning the chronology of the reporte d results. In each case when a journal
paper is available, we refer to it, as to the most deﬁnitive ve rsion. However, the journal version is
sometimes published much later than the conference version in which a given result ﬁrst appeared.
This may scramble the precedence relations of results. In su ch cases we tried to mention the correct
order of discoveries.
The rest of the chapter is organized as follows. In Section 2 w e discuss various scenarios resulting
from alternative assumptions adopted for the rendezvous pr oblem, and mention methodological
diﬀerences of the solutions in diﬀerent models. The main divid ing line in the entire body of
research surveyed in this chapter is between the two types of environment in which rendezvous
has to take place: one type are networks modeled as undirecte d graphs, the other is the plane or
parts of it, with possible obstacles obstructing moves of th e agents. Consequently, Section 3 covers
rendezvous in networks and Section 4 is devoted to rendezvou s in the plane. Finally, Section 5
contains conclusions and open problems.
2 Discussion of assumptions, models and methodology
As announced in the introduction, we will consider the rende zvous problem in two diﬀerent envi-
ronments: in networks modeled as undirected graphs and in th e plane or its parts. Among many
alternative pairs of assumptions adopted for the study of re ndezvous, this one is arguably the most
basic, as it inﬂuences even the precise deﬁnition of rendezv ous. In both cases, agents are modeled
as points. In the ﬁrst case they navigate in the graph, traver sing its edges and visiting its nodes,
and in the second case they move freely in the plane, possibly avoiding obstacles. In the case of
rendezvous in networks, meeting of the agents is deﬁned as be ing at the same node in the same
time or as being in the same point of an edge at the same time. (W e will further discuss submodels
in which one or the other of these deﬁnitions is applied). In t he case when agents move in the
plane, they are also modeled as points. However, in particul ar where rendezvous has to take place
in the empty plane, we cannot require the agents to get to the s ame point of the plane at the same
time. To see this, consider an easier problem, when one of the agents is inert and the other one
has to ﬁnd it. (Rendezvous can always be reduced to this case, if the adversary decides to delay
the start of one of the agents suﬃciently long). Since the wal king agent cannot see the inert agent
prior to meeting, a correct algorithm would require to const ruct a trajectory, which is a curve in
the plane passing through each given point after walking a ﬁn ite distance. Such a curve does not
exist. Hence, in the case of meeting in the plane, rendezvous is deﬁned more loosely as approach :
agents have to get at distance 1 of each other. An alternative , equivalent way of modeling this
situation is to assumethat in the planeagents are not points but discs of diameter 1 and rendezvous
is accomplished when these discs touch. Hence in the case of t he plane we will concentrate on the
task of approach.
4There is one exception to this change of deﬁnition. When agen ts are in a bounded part of the
plane, possibly with “holes”, i.e., impenetrable obstacle s, then rendezvous deﬁned as getting to the
same point at the same time can be required, because in this ca se agents can meet in a boundary
point of the terrain or of one of the obstacles. We will see suc h a situation in [13].
We will now review the common assumptions used in the literat ure to consider rendezvous in each
of the above scenarios. We ﬁrst consider the network scenari o. The ﬁrst common assumption is
modeling the network as a simple undirected connected graph , whose nodes represent processors,
computers or stations of a communication network, or crossi ngs of corridors of a labyrinth, depend-
ing on the application, and links represent communication c hannels in a communication network,
or corridors in a labyrinth. Modeling the network as an undir ected graph captures the ability of
the agents to move in both directions along each link. The ass umption that the graph is simple (no
self-loops or multiple edges) is motivated by most of the rea listic applications, and connectivity of
the graph is a necessary condition on feasibility of rendezv ous when starting from any initial posi-
tions: agents starting in diﬀerent connected components cou ld not meet. Throughout the chapter,
we use the term graphto mean a simple undirected connected graph.
Thesecondcommon assumptionistheanonymity oftheunderly ingnetwork: theabsenceof distinct
names of nodes that can be perceived by the navigating agents . There are two reasons for seeking
rendezvous algorithms that do not assume knowledge of node i dentities. The ﬁrst one is practical:
while nodes may indeed have diﬀerent labels, they may refrain from informing the agents about
them, e.g., forprivacyorsecurity reasons, orlimitedsens orycapabilities ofagents maypreventthem
from perceiving these names. The latter restriction is most ly applicable to mobile robots whose
sensing device may be too weak to read such labels. The other r eason for assuming anonymity of
the network is methodological. If distinct names of nodes ca n be perceived by the agents, they can
follow an algorithm which guides each of them to the node with the smallest label and stop. Thus
the rendezvous problem becomes reducible to graph explorat ion, which has been well studied.
The last common assumption concerns port numbers at each nod e. It is assumed that a node of
degreedhas ports 0 ,1,...,d−1 corresponding to the incident edges. Ports at each node can be
perceived by an agent visiting this node, but there is no cohe rence assumed between port labelings
at diﬀerent nodes. (In the case when such a coherence is assume d, for example in the case of an
oriented grid, it will be explicitly mentioned). When an age nt enters a node, it learns its degree
and the port of entry. The reason for assuming the existence o f port labelings accessible to agents
is the following. If an agent is unable to locally distinguis h ports at a node, it may even be unable
to visit all neighbors of a node of degree at least 3. Indeed, a fter visiting the second neighbor,
the agent cannot distinguish the port leading to the ﬁrst vis ited neighbor from the port leading
to the unvisited one. Thus an adversary may always force an ag ent to avoid all but two edges
incident to such a node. Consequently, agents initially loc ated at two nodes of degree at least
3 might never be able to meet. From the practical point of view , assuming the existence of port
numbers legible by the agents is a much less problematic assu mption than assuming labels of nodes.
First, the privacy and security reasons for not divulging no de labels do not apply to port numbers.
Second, the sensory capabilities of agents required to read port numbers are much smaller than
those for reading node labels. For example, one port at a node can be marked by a “red dot”
and then consecutive ports can have a pointer nextfrom the preceding port. Reading this type of
information requires minimal sensory capabilities.
5We will now review the common assumptions concerning rendez vous (i.e., approach) in the plane.
Theseassumptionspermitanagent tonavigateintheplanein theabsenceofanyvisualinformation.
It is assumed that the agent has a compass indicating North an d that it has a measure of distance.
These two features permit to establish a system of orthogona l coordinates and permit to trace
arbitrary angles. Consequently, the agent can execute inst ructions such as “go at distance xin
direction dir”, where diris expressed as an angle from direction North. Notice that th e compasses
and the measures of length of diﬀerent agents are not necessar ily the same. If they are, this will be
explicitly mentioned.
We proceed to the overview of various alternative assumptio ns yielding diﬀerent scenarios under
which the rendezvous problem is usually considered, both in the network environment and in
the plane. There are two such main pairs of assumptions. The ﬁ rst concerns the possibility to
distinguish the agents: they can be either anonymous (i.e., identical), or each agent may have a
distinctinteger label that it knows andcan useas aparamete r intheexecuted rendezvous algorithm
which is common to all agents. The second pair of alternative assumptions concerns time: agents
may move either in a synchronous or in an asynchronous way. We will give the precise deﬁnitions
later but, roughly speaking, synchronous movement in graph s means that clocks of the agents tick
at the same rate, one tick per round, and in each round an agent can either stay in the current
node, or move to a neighbor. In the plane, synchronous moveme nt means that the speed of agents
is the same. In the asynchronous scenario, the speed of the ag ents may vary adversarially. (We will
see that there is also a semi-synchronous scenario, where sp eeds of agents are constant but possibly
diﬀerent).
The above possible scenarios imply diﬀerent methodological approach to rendezvous in each case.
The main problem that has to be solved in order to make determi nistic rendezvous possible, both
in networks and in the plane, is breaking symmetry. To see why this is necessary, consider a highly
symmetric network, such as an oriented ring (i.e., a ring in w hich ports at all nodes are labeled
as follows: 0 the clockwise port and 1 the counterclockwise p ort) or consider the inﬁnite plane
without obstacles. Consider two identical agents starting at distinct nodes of the ring or at any
two points in the plane, and running the same deterministic a lgorithm. It is easy to see that if
they start simultaneously and move synchronously, they wil l never meet. In the ring, at all times
they will use the port (at their respective current nodes) ha ving the same label (as their history is
the same and the algorithm is deterministic), and hence the d istance between them will be always
the same. Likewise, in the plane, if the agents start simulta neously, have the same compass, the
same measure of length and the same speed, they will traverse parallel trajectories and remain at
the same distance at all times.
Inthedeterministic scenariotherearetwoways ofbreaking symmetry. Theﬁrstisbydistinguishing
the agents: each of them has a label and the labels are diﬀerent . Each agent knows its label, but we
do not need to assume that it knows the label of the other agent . (If it does, then the solution is the
well-known algorithm Wait For Mommy: the agent with the smal ler label stays idle, while the other
one explores the graph or the plane in order to ﬁnd it.) Both ag ents use the same parametrized
algorithm with the agent’s label as the parameter. To see how this can help, consider two agents
that have to meet in an oriented ringof known size n. As mentioned above, if agents are anonymous
(and marking nodes is disallowed), rendezvous is impossibl e. Now assume that agents have distinct
labelsL1andL2. A simple (although ineﬃcient) rendezvous algorithm is: Ma keLtours of the
ring, where Lis your label, and stop. Then the agent with larger label will make at least one full
6tour of the ring while the other one is already inert, thus gua ranteeing rendezvous.
The second way of breaking symmetry, available even when age nts are anonymous, is by exploiting
either non-symmetries of the network itself, or the diﬀerenc es of the initial positions of the agents,
even in a symmetric network. This method is impossible to use in the plane without obstacles, and
in thenetwork environment it is usableonly forsome classes of networks, as either thenetwork must
have distinguishable nodes that play the role of “focal poin ts” or the initial positions of agents have
to be “non-symmetric” (the precise meaning of this conditio n will be deﬁned later). As a simple
example of the application of this method, consider a n-node line with two identical agents. If nis
odd, then the line contains a central node that both agents ca n identify and meet at this node. If
nis even, (and even when the port labelings are symmetric with respect to the axis of symmetry of
the line) but the initial positions of the agents have diﬀeren t distances from their closest extremity,
then the following algorithm works: Compute your distance dfrom the closest extremity of the line,
then traverse the line dtimes and stop. For the same reasons as before, this algorith m guarantees
rendezvous, whenever the initial positions of the agents ar e not symmetrically situated. On the
other hand, if they are symmetric (and port labelings are sym metric as well), then it is easy to see
that rendezvous is impossible if agents have to meet at a node and do not realize crossings on an
edge.
Wenowdiscussmethodological implicationsofthedistinct ion betweenthesecondpairofalternative
assumptions, yielding the synchronous and asynchronous sc enarios. The discussion is for agents
with distinct labels. In the ﬁrstcase, the ability of the age nts to exploit time, and more precisely, to
vary between carefully measured periodsof activity, whent heagent explores parts of thenetwork or
of the plane, and of passivity, when it stays idle, is a powerf ul tool in the solution of the rendezvous
problem. Indeed, agents may exploit diﬀerences in their labe ls to schedule these activity and
passivity periods in such a way that at some point the active a gent must visit the position of the
agent that is currently passive, and thus accomplish rendez vous. No such possibility is available in
the asynchronous scenario. In this case, the main methodolo gical tool is constructing trajectories
of the agents, again exploiting the diﬀerences of their label s, in such a way that parts of these
trajectories coincide, and the agents are forced, regardle ss of their speed, to traverse a common
segment of the trajectory at approximately the same time, im plying rendezvous. It should be
mentioned that, in the asynchronous scenario applied to net works, it may be impossible to meet at
a node, and thus the requirement is relaxed to that of meeting at a node or inside an edge.
In order to make the statement of a rendezvous problem precis e, we have to point out what exactly
is being sought, apart from meeting. The most general questi on is that of feasibility: for what
classes of networks and what initial positions is rendezvou s possible under a particular scenario,
and when is it possible in the plane? Here a complete solution would be to prove that for some
classes ofnetworksandsomeinitial conﬁgurationsofagent s rendezvousisimpossible, andtoprovide
a rendezvous algorithm for all other situations. In the case of the plane, the question is whether
approach starting from arbitrary unknown positions is alwa ys possible under a given scenario.
More speciﬁc questions concern the amount of resources need ed for rendezvous. These are usually
of two types. The ﬁrst is rendezvous cost: the maximum number of steps made by an agent until
rendezvous, or the maximum time used by the agents to meet. Al gorithms minimizing the cost (or
its order of magnitude) are sought in this context. The other important resource is memory: what
is the minimum memory with which agents have to be equipped in order to solve the rendezvous
problem in a given class of networks. When only cost optimiza tion is sought, memory of the
7agents is often assumed to be unbounded and they are modeled a s Turing machines. In problems
seeking memory minimization (or tradeoﬀs between memory and time), the model of input/output
automata (ﬁnitestatemachines)isusuallyused. Asusualin optimization tasks, acompletesolution
calls for an algorithm with given cost or memory and for an acc ompanying lower bound showing
that this cost or amount of memory is optimal.
As mentioned before, in Section 3 we present results concern ing rendezvous in networks, while in
Section 4 we study the problem of approach in the plane. The st udy is further subdivided by
considering the synchronous and asynchronous scenarios. F urther assumptions are added when
presenting a particular model. In each case, we ﬁrst give a pr ecise description of the model, state
the problem to be solved, then present the results and often g ive a high-level description of methods
and algorithms used to obtain them.
3 Rendezvous in networks
In this section we survey results on deterministic rendezvo us in networks, dividing our considera-
tions into two major scenarios : synchronous and asynchrono us.
3.1 Synchronous rendezvous
Agents move in synchronous rounds. In every round, an agent m ay either remain at the same
node or move to an adjacent node. Rendezvous means that all ag ents are at the same node in the
same round. Agents that cross each other when moving along th e same edge, do not notice this
fact. Two subscenarios are considered: simultaneous startup , when both agents start executing
the algorithm in the same round, and arbitrary delay , when starting rounds are arbitrarily decided
by an adversary. In the former case, agents know that startin g rounds are the same, while in the
latter case, they are not aware of the diﬀerence between start ing rounds, and each of them starts
executing the rendezvous algorithm and counting steps in th e round of its own startup.
We will discuss separately the sub scenario of labeled agent s, where agents have distinct inte-
ger labels that they can use as a parameter in the common deter ministic algorithm, and that of
anonymous agents, where agents do not have any labels and thu s are identical.
3.1.1 Labeled agents
In [17] (whose journal version was published in 2006, but whi ch is based on two earlier conference
papers published in 2003 and 2004), rendezvous of two agents is considered and it is indicated that
all results can be generalized to an arbitrary number of agen ts. It is assumed that agents have
diﬀerent positive integer labels, and each agent knows its ow n label (which is a parameter of the
common deterministic algorithm that they use), but is unawa re of the label of the other agent. In
general, agents do not know the topology of the graph in which they have to meet. It is assumed
that the agents have unlimited memory (they are modeled as Tu ring machines) and the authors
aim at optimizing the cost of rendezvous. This cost is deﬁned as the worst-case number of rounds
since the startup of the later agent until rendezvous is achi eved, where the worst case is taken over
8all graphs in the considered class, all initial positions of the agents and all possible startup times
(decided by an adversary), in the case of the arbitrary delay scenario.
The following notation is used. The labels of the agents are L1andL2. The smaller of the two
labels is denoted by l. The delay (the diﬀerence between startup times of the agents ) is denoted
byτ,ndenotes the number of nodes in the graph, and D– the distance between initial positions
of agents.
Theauthorsintroducetheproblemintherelatively simplec ase oftrees. Theyshowthat rendezvous
can be completed at cost O(n+ logl) on any n-node tree, even with arbitrary delay. They also
show that for some trees this complexity cannot be improved, even with simultaneous startup.
Rendezvous intrees is relatively easy for two reasons. Firs t, a tree can beexplored with termination
and a map of it can be constructed by a single agent, using the basic walk which consists in leaving
every node by the next port with respect to the entry port at th is node (modulo the degree).
The second reason is the existence of the central node or the c entral edge in any tree. Once each
agent locates this object independently, the central node p lays the role of the “focal point” and
rendezvous can be accomplished at linear cost. If there exis ts a central edge, rendezvous is slightly
more complicated and, after identifying this edge, it reduc es to rendezvous in the two-node graph.
It is this case that is responsible for the O(logl) additive term in the cost complexity.
As soon as the graph contains cycles, another technique has t o be applied. The authors continue
the study by concentrating on the simplest class of such grap hs, i.e., rings. They prove that, with
simultaneous startup, the optimal cost of rendezvous on any ring is Θ( Dlogl). They construct an
algorithm achieving rendezvous with this complexity and sh ow that, for any distance D, it cannot
be improved.
The lower bound Ω( Dlogl) relies on the following idea. The (oriented) ring is partit ioned into
pieces of equal size Θ( D) and time is partitioned into segments of the same length. It is observed
that at the end of a segment the agent can be either in the same p iece as in the beginning of it,
or in one of the neighboring pieces. This permits to code the b ehavior of an agent by a ternary
sequence corresponding to its position at the end of each tim e segment. It is argued that if two
agents have the same behavior code, then they cannot meet. Mo reover, if the time of rendezvous
wereo(Dlogl), then behavior codes would have to be short, and thus for som e two diﬀerent labels
of agents they would have to be the same, as the behavior of an a gent before the meeting depends
only on its label. Assigning these labels to the agents would preclude rendezvous.
With an arbitrary delay, Ω( n+Dlogl) is a lower bound on the cost required for rendezvous in
an-node ring. Under this scenario, two rendezvous algorithms for the ring are presented in [17]:
an algorithm with cost O(nlogl), for known n, and an algorithm with cost O(lτ+ln2), ifnis
unknown. In the latter case, the cost was later improved to O(nlogl) in [29]. In view of the above
lower bound, this cannot be improved in general.
For arbitrary connected graphs, the main contribution of [1 7] is the ﬁrst deterministic rendezvous
algorithm with cost polynomial in n,τand logl. More precisely, the authors present an algorithm
that solves therendezvousproblemforany n-nodegraph G, foranylabels L1> L2=lofagents and
for any delay τbetween startup times, in cost O(n5√τlogllogn+n10log2nlogl). The algorithm
contains a non-constructive ingredient: agents use combin atorial objects whose existence is proved
by the probabilistic method. Nevertheless the algorithm is indeed deterministic. Both agents can
9ﬁnd separately the same combinatorial object with the desir ed properties (which is then used in the
rendezvous algorithm). This can be done using brute force ex haustive search which may be quite
complex but in the adopted model only moves of the agents are c ounted and local computation
time of the agents does not contribute to cost. Finally, the a uthors prove a lower bound Ω( n2) on
the cost of rendezvous in some family of graphs.
The paper is concluded by an open problem concerning the depe ndence of rendezvous cost on the
delayτ. The dependence on the other parameters follows from the res ults cited above. Indeed, a
lower bound Ω( n2) on rendezvous cost has been shown in some graphs. The author s also showed
that cost Ω(log l) is required even for the two-node graph. On the other hand, f or agents starting
at distance Ω( n) in a ring, cost Ω( nlogl) is required, even for τ= 0. However, since the complexity
of their algorithm contains a factor√τ, the authors state the following problem:
Does there exist a deterministic rendezvous algorithm for a rbitrary connected graphs with cost
polynomial in nandl(or even in nand logl) but independent of τ?
A positive answer to this problem was given in [29] (whose con ference version was published in
2006). The authors present a rendezvous algorithm for two ag ents, working in arbitrary connected
graphs for an arbitrary delay τ, whose complexity is O(log3l+n15log12n), i.e., is independent of
τand polynomial in nand logl. As before, the algorithm contains a non-constructive ingr edient,
but is deterministic.
Therendezvousalgorithms from[17,29], workingforarbitr aryconnected graphs, yield anintriguing
question, stated in [17]. While both of them have polynomial cost (the one from [17] depending
onτ, and the one from [29] independent of τ), they both use a non-constructive ingredient, i.e,
a combinatorial object whose existence is proved using the p robabilistic method. As mentioned
above, each of the agents can deterministically ﬁnd such an o bject by exhaustive search, and
then use it in the execution of its algorithm, which keeps the algorithm deterministic, but may
signiﬁcantly increase the time of local computations. In th e described model the time of these local
computations does not contribute to cost which is measured b y the number of steps, regardless of
the time taken to compute each step. Nevertheless, it is inte resting if there exists a rendezvous
algorithm for which both the cost and the time of local comput ations are polynomial in nand logl.
Such an algorithm would have to eliminate any non-construct ive ingredients.
This problem was solved in [40] (whose conference version ap peared in 2007), using the important
notionofa Universal Exploration Sequence (UXS)[28]. Let( a1,a2,...,a k)beasequenceofintegers.
Anapplication of this sequence to a graph Gat node uis the sequence of nodes ( u0,...,u k+1)
obtained as follows: u0=u,u1is the node joined to uby the edge corresponding to port 0 at
u; for any 1 ≤i≤k,ui+1is the node joined to uiby the edge corresponding (at ui) to port
(p+ai) modd(ui), where pis the port number at uicorresponding to the edge {ui,ui−1}and
d(ui) denotes the degree of node ui. (Informally, an application of ( a1,a2,...,a k) corresponds to
a walk in the graph in which the current exit port is computed b y adding aito the current entry
port.) A sequence ( a1,a2,...,ak) whose application to a graph Gat any node ucontains all nodes
of this graph is called a UXS for this graph. A UXS for a class Gof graphs is a UXS for all graphs
in this class. The solution from [40] uses a result following from [37] that a UXS for the class of all
connected graphs with at most nnodes can be computed in time polynomial in n. Moreover, the
authors propose a rendezvous algorithm working in O(n5logl) rounds (up to factors logarithmic
innand logl). This complexity beats those from [17, 29] and makes the alg orithm from [40] the
10currently most eﬃcient rendezvous algorithm working in arb itrary connected graphs.
The paper [21] started the investigation of gathering of a te am of labeled agents, some of which can
be Byzantine. The size of the team is unknown to the agents. Ag ents can exchange all currently
held information when they meet at a node of the graph. Up to fof the agents are Byzantine.
The authors deﬁne two levels of Byzantine behavior. A strong ly Byzantine agent can choose an
arbitrary port when it moves and it can transmit arbitrary in formation to other agents, while a
weakly Byzantine agent can do the same, except changing its l abel. The main problem investigated
in the paper is what is the minimum numberof good agents that g uarantees deterministic gathering
of all of them, with termination. (Of course, Byzantine agen ts cannot be forced to gather.) The
authors solve exactly this Byzantine gathering problem in a rbitrary networks for weakly Byzantine
agents, and give approximate solutions for strongly Byzant ine agents, both when the size of the
network is known and when it is unknown. They show that both th e strength versus weakness of
Byzantine behavior and the knowledge of network size have an important inﬂuence on the results.
For weaklyByzantine agents itisshownthat anynumberofgoo dagents permittosolve theproblem
for networks of known size. If the size is unknown, then this m inimum number is f+ 2. More
precisely, the authors design a deterministic polynomial a lgorithm that gathers all good agents in
an arbitrary network, provided that there are at least f+2 of them. They also prove a matching
lower bound showing that if the number of good agents is at mos tf+1, then they are not able to
gather deterministically with termination in some network s.
For strongly Byzantine agents the authors give a lower bound off+ 1, even when the graph is
known: theyshowthat fgoodagents cannot gatherdeterministically inthepresenc eoffByzantine
agents even in a ring of known size. In order to establish uppe r bounds, they propose deterministic
gathering algorithms for at least 2 f+1 good agents when the size of the network is known, and for
at least 4 f+2 good agents when it is unknown. These upper bounds were sub sequently improved
in [5] to f+1 when the size of the network is known and to f+2 when it is unknown. Together
with the lower bounds from [21], both these upper bounds are t ight.
Astheauthorsof[5]pointout, theaboveresultsshowaninte restingdiﬀerencebetweenthescenarios
of known vs. unknown size of the network. While for known size , the gap between the number of
goodagents permittinggatheringwithweakly andwithstron glyByzantine agents isvery signiﬁcant
(1 vs.f+1) this gap completely disappears for the scenario of unkno wn size: the minimum number
of good agents is then f+2, regardless of whether the bad agents are weakly or strong ly Byzantine.
Gathering of agents in the presence of a more benign type of fa ults is considered in [36]. In this
paper it is assumed that some agents are subject to crash faults which can occur at any time. Two
fault scenarios are considered. A motion fault immobilizes the agent at a node or inside an edge but
leaves intact its memory at the time when the fault occurred. A more severe total fault immobilizes
the agent as well, but also erases its entire memory. As befor e, we cannot require faulty agents to
gather. Thus the gathering problem for fault prone agents ca lls for all fault-free agents to gather
at a single node, and terminate.
It is observed that when agents move completely asynchronou sly, gathering with crash faults of
any type is impossible. Hence the author considers a restric ted version of asynchrony, where each
agent is assigned by the adversary a ﬁxed speed, possibly diﬀe rent for each agent. Agents have
clocks ticking at the same rate. Each agent can wait for a time of its choice at any node, or decide
11to traverse an edge but then it moves at constant speed assign ed to it. It is appropriate to discuss
this model in the section devoted to synchronous algorithms , as methodologically the two scenarios
are similar: it is still possible to wait at a node for a prescr ibed amount of time, and this capability
signiﬁcantly inﬂuences algorithm design. When two or more a gents are at the same node or in the
same point of an edge in the same time, they can see the memory c ontent of other agents at this
node or at this point of an edge, except for memory of faulty ag ents in the case of total faults.
The main results of the paper are a gathering algorithm worki ng for any team of at least two agents
in the scenario of motion faults, and a gathering algorithm w orking in the presence of total faults,
provided that at least two agents are fault free all the time. If only one agent is fault free, the task
of gathering with total faults is sometimes impossible. Thi s shows that in the case of crash faults
more faulty agents can be tolerated for gathering than when f aults are Byzantine. Both algorithms
from [36] work in time polynomial in the size of the graph, in t he logarithm of the largest label, in
the inverse of the smallest speed, and in the ratio between th e largest and the smallest speed.
Rendezvous of two agents subject to transient faults is cons idered in [8]. Agents do not know the
topology of the network or any bound on its size. In each round an agent decides if it remains
idle or if it wants to move to one of the adjacent nodes. Agents are subject to delay faults : if an
agent incurs a fault in a given round, it remains in the curren t node, regardless of its decision. If
it planned to move and the fault happened, the agent is aware o f it. The authors consider three
scenarios of fault distribution: random (delay faults occu r independently in each roundand for each
agent with constant probability 0 < p <1), unbounded adversarial (the adversary can delay an
agent for an arbitrary ﬁnite number of consecutive rounds) a nd bounded adversarial (the adversary
can delay an agent for at most cconsecutive rounds, where cis unknown to the agents). The
quality measure of a rendezvous algorithm is its cost, which is the total number of edge traversals.
For random faults, the authors design an algorithm with cost polynomial in the size nof the
network and polylogarithmic in the larger label L, which achieves rendezvous with probability at
least 1−1/nin arbitrary networks. By contrast, for unbounded adversar ial faults they prove that
rendezvous is not feasible, even in the class of rings. Under this scenario, the authors design a
rendezvous algorithm with cost O(nℓ), where ℓis the smaller label, working in arbitrary trees, and
they show that Ω( ℓ) is the lower boundon rendezvous cost, even for thetwo-node tree. For bounded
adversarial faults, the authors construct a rendezvous alg orithm working for arbitrary networks,
with cost polynomial in n, and logarithmic in the bound cand in the larger label L.
In [34], the authors use a diﬀerent approach to counter transi ent faults. They propose a self-
stabilizing rendezvousalgorithm fortwoagents navigating inanarbitr arynetwork. Aself-stabilizing
algorithmhasthepropertythatiftheagentsstartfromanyt wonodeswitharbitrarymemorystates,
then eventually they will get to the same node in the same roun d. Thus, even if the agents incur
a transient fault of any kind that corrupts their memory, the y can meet in ﬁnite time after the
fault disappears. The authors design a self-stabilizing re ndezvous algorithm for arbitrary graphs,
without any time guarantees, and construct polynomial-tim e self-stabilizing rendezvous algorithms
for trees and rings. More precisely, the algorithm for trees is polynomial in the size of the tree and
in the logarithm of the smaller label, and the algorithm for r ings is polynomial in the size of the
ring and in both labels.
In [32], the authors consider two main eﬃciency measures of r endezvous: its time, i.e., the number
of rounds until the meeting, and its cost, i.e., the total num ber of edge traversals. They investigate
12tradeoﬀs between these two measures. A natural benchmark for both time and cost of rendezvous
in a network is the number of edge traversals needed for visit ing all nodes of the network, called
the exploration time. The authors express the time and cost o f rendezvous as functions of an
upper bound Eon the time of exploration (where Eand a corresponding exploration procedure
are known to both agents) and of the size Lof the label space. They design two rendezvous
algorithms: algorithm Cheaphas cost O(E) and time O(EL), and algorithm Fasthas both time
and cost O(ElogL). The main contribution of the paper are lower bounds showin g that these two
algorithms capture the tradeoﬀs between time and cost of rend ezvous almost tightly. They show
that any deterministic rendezvous algorithm of cost asympt oticallyE(i.e., of cost E+o(E)) must
have time Ω( EL). On the other hand, they prove that any deterministic rende zvous algorithm with
time complexity O(ElogL) must have cost Ω( ElogL).
In[33], theproblemofrendezvousisstudiedintheframewor kofadvice, whichisapopularparadigm
permitting to measure the amount of information that agents need in order to perform some task in
networks. If Disthedistancebetweentheinitial positionsoftheagents, thenΩ(D)isalower bound
on the time of rendezvous. However, in the absence of any know ledge about the network, agents
usually cannot meet in time O(D). Thus the authors study the minimum amount of information
that has to be available a priorito the agents in order to achieve rendezvous in optimal time Θ (D).
Following the advice paradigm, this information is provide d to the agents at the start by an oracle
knowing the entire instance of the problem, i.e., the networ k, the starting positions of the agents,
their wake-up rounds, and both of their labels. The oracle pr ovides the agents with the same binary
string called advice, which can be used by the agents duringtheir rendezvous algo rithm. The length
of this string is called the size of advice . The goal of the paper is to ﬁnd the smallest size of advice
which enables the agents to meet in time Θ( D). The authors solve this problem completely by
showing that this optimal size of advice is Θ( Dlog(n/D) + loglog L), where nis the size of the
graph,Dis the initial distance between the agents, and Lis the size of the label space. The upper
bound is proved by constructing an advice string of this size , and providing a rendezvous algorithm
using this advice that works in time Θ( D) for all networks. The matching lower bound, which is
the most diﬃcult and interesting part of the paper, is proved by constructing classes of networks
for which it is impossible to achieve rendezvous in time Θ( D) with smaller advice.
The authors of [15] investigate the rendezvous problem in gr aphs under the scenario where during
navigation each agent gets some restricted feedback about t he position of the other agent. More
precisely, they consider distance-aware agents that, in ev ery round, are informed of the distance
between them. The authors show that such agents can meet in ti meO(∆(D+logl)), where Dis
the initial distance between the two agents, lis the smaller label and ∆ is the maximum degree of
the graph. Thus, even in a very large graph, distance-aware a gents can meet in time polynomial in
local parameters of the instance of the rendezvous problem. Moreover, the authors show an almost
matching lower bound Ω(∆( D+logl/log∆)) on the time of rendezvous in their scenario.
In most formulations of the synchronous rendezvous problem , meeting is accomplished when the
agents get to the same node in the same round. In [23], the auth ors consider a more demanding
task, called rendezvous with detection : agents must become aware that the meeting is accomplished,
simultaneouslydeclarethisandstop. Itisclearthatinord ertosignaltotheotheragentthepresence
at a given node, agents must communicate, and the awareness o f the meeting depends on ways of
communication between the agents. The authors study two var iations of a very weak model of
communication, called the beeping model , introduced in [10]. In each round an agent can either
13listen or beep. In the local beeping model , an agent hears a beep in a round if it listens in this round
and if the other agent is at the same node and beeps. In the global beeping model , an agent hears a
loudbeep in a round if it listens in this round and if the other agen t is at the same node and beeps,
and it hears a softbeep in a round if it listens in this round and if the other agen t is at some other
node and beeps.
The authors propose a deterministic algorithm of rendezvou s with detection working, even for the
weaker local beeping model, in an arbitrary unknown network in time polynomial in the size of the
network and in the logarithm of the smaller label. However, t his algorithm is highly energy con-
suming: the number of moves that an agent must make, is propor tional to the time of rendezvous.
Hence the authors ask if bounded-energy agents , i.e., agents that can make at most cmoves, for
some integer c, can always achieve rendezvous with detection as well. They observe that this is
impossible for some networks of unbounded size. Hence they r ephrase the question as follows. Can
bounded-energy agents always achieve rendezvous with dete ction in bounded-size networks? The
authors prove that the answer to this question is positive, e ven in the local beeping model but
this ability comes at a steep price of time: the meeting time o f bounded-energy agents is exponen-
tially larger than that of unrestricted agents. By contrast , the authors propose an algorithm for
rendezvous with detection in the global beeping model that w orks for bounded-energy agents (in
bounded-size networks) as fast as for unrestricted agents.
We conclude this section by discussing rendezvous of agents that have ﬁxed but possibly diﬀerent
speeds. The meeting must be at a node, which precludes the ful ly asynchronous scenario. Hence,
the authors of [7] consider a scenario of agents with restric ted asynchrony: agents have the same
measure of time but the adversary can arbitrarily impose the speed of traversing each edge by each
of the agents. They construct a rendezvous algorithm for suc h agents, working in time polynomial
in the size of the graph, in the length of the smaller label, an d in the largest edge traversal time.
3.1.2 Anonymous agents
One of the ﬁrst papers on synchronous rendezvous of two anony mous agents was [25] where the
authors compare the time of deterministic and of randomized rendezvous in trees. For deterministic
rendezvous they propose an algorithm working in time linear in the size of the tree, for every initial
conﬁguration for which rendezvous is possible, and they sho w that this time cannot be improved
in general, even when agents start at distance 1 in bounded de gree trees.
In the case of anonymous agents, rendezvous may be impossibl e for some initial conﬁgurations, in
some networks, as witnessed by the example of two agents in th e oriented ring, mentioned before.
This yields an important feasibility problem, which is to ch aracterize those initial conﬁgurations
of an arbitrary number of anonymous agents for which rendezv ous (gathering) is feasible, and to
provide a gathering algorithm working for all such conﬁgura tions. This problem was attacked and
completely solved in [18].
At least two agents start from diﬀerent nodes of the graph. The adversary wakes up some of the
agents at possibly diﬀerent times. A dormant agent, not woken up by the adversary, is woken up by
the ﬁrst agent that visits its starting node, if such an agent exists. Agents do not know the topology
of the graph or the size of the team. The authors considered tw o scenarios: one when agents know
a polynomial upper bound on the size of the graph and another w hen no bound is known. When
14several agents are at the same node in the same round, they can exchange all information they
currently have. The authors assume that the memory of the age nts is unlimited.
An initial conﬁguration of agents, i.e., their placement at some distinct nodes of the graph, is
calledgatherable if there exists a deterministic algorithm (even only dedica ted to this particular
conﬁguration) that achieves meeting of all agents in one nod e, regardless of the times at which
some of the agents are woken up by the adversary. The authors s tudy the problem of which
initial conﬁgurations are gatherable and how to gather all o f them deterministically by the same
algorithm. The problem calls for deciding which initial con ﬁgurations are possible to gather, even
by an algorithm speciﬁcally designed for this particular co nﬁguration, and for ﬁnding a universal
gathering algorithm that gathers all such conﬁgurations. T he authors restrict attention only to
terminating algorithms, in which every agent eventually stops forever.
The main result of the paper is a complete solution of the abov e gathering problem in arbitrary
graphs. The authors characterize all gatherable conﬁgurat ions and give two universal deterministic
gathering algorithms, i.e., algorithms that gather all gat herable conﬁgurations. The ﬁrst algorithm
works under the assumption that an upper bound non the size of the network is known. In this
case their algorithm guarantees gathering with detection , i.e., the existence of a round in which,
for any gatherable conﬁguration, all agents are at the same n ode and all declare that gathering is
accomplished. If no upper bound on the size of the network is k nown, the authors show that a
universal algorithm for gathering with detection does not e xist. Hence, for this harder scenario,
they construct a second universal gathering algorithm, whi ch guarantees that, for any gatherable
conﬁguration, all agents eventually get to one node and stop , although they cannot tell if gathering
is over. The time of the ﬁrst algorithm is polynomial in the up per bound non the size of the
network, and the time of the second algorithm is polynomial i n the (unknown) size of the network
itself.
As pointed out by the authors of [18], the problem of gatherin g an unknown team of anonymous
agents in an arbitrary network presents the following major diﬃculty. The asymmetry of the initial
conﬁgurationbecauseofwhichgatheringisfeasible, maybe causednotonlybynon-similarlocations
of the agents with respect to the structure of the graph, but b y their diﬀerent situation with respect
to other agents. Hence the authors had to come up with a new alg orithmic idea: in order to gather,
agents that were initially identical, must make decisions b ased on the memories of other agents met
to date, in order to make their future behavior diﬀerent and br eak symmetry in this way. In the
beginning the memory of each agent is empty and in the executi on of the algorithm it records what
the agent has seen in previous steps of the navigation and wha t it heard from other agents that
it met. Even small diﬀerences occurring in a remote part of the graph must eventually inﬂuence
the behavior of initially distant agents. Agents in diﬀerent initial situations may be unaware of
this diﬀerence in early meetings, as the diﬀerence may depend o n their location with respect to
remote agents and thus be revealed only later on. Hence an age nt may mistakenly consider that
two diﬀerent agents that it met in diﬀerent stages of the algori thm execution, are the same agent.
Confusions due to this possibility are a signiﬁcant challen ge in the algorithm design, that occurs
neither in gathering two (even anonymous) agents nor in gath ering many labeled agents.
Rendezvous of two anonymous agents was considered in [11, 26 ]. As mentioned before, in this case
rendezvous is not possible for arbitrary networks and arbit rary initial positions of the agents. In
order to describe initial positions of the agents for which r endezvous is possible, we need the notion
15of aviewfrom a node of a graph, introduced in [41]. Let Gbe a graph and va node of G. Theview
fromvis the inﬁnite tree V(v) rooted at vwith labeled ports, whose branches are inﬁnite paths in
Gstarting at v, coded as sequences of ports. A pair ( u,v) of distinct nodes is called symmetric , if
V(u) =V(v). Initial positions forming a symmetric pair of nodes are cr ucial when considering the
feasibility of rendezvous in arbitrary graphs. Indeed, it i s proved in [11] that rendezvous is feasible,
if and only if the initial positions of the agents are not a sym metric pair. For the particular case of
the class of trees, this is equivalent to the non-existence o f a port-preserving automorphism of the
tree that carries one initial position to the other.
The aim of [11, 26] was optimizing the memory size of the agent s that seek rendezvous. In order to
model agents with bounded memory, the formalism of input/ou tput automata is used. An agent
is an abstract state machine A= (S,π,λ,s 0), where Sis a set of states among which there is a
speciﬁed state s0called the initialstate,π:S×Z2→S, andλ:S→Z. Initially the agent
is at some node u0, called its initial position , in the initial state s0∈S. The agent performs an
action in each step. Each action can be either a move to an adja cent node or a null move resulting
in remaining in the currently occupied node. State s0determines an integer number λ(s0). If
λ(s0) =−1, then the agent makes a null move (i.e., remains at u0). Ifλ(s0)≥0 then the agent
leavesu0by portλ(s0) modd(u0), where d(u0) is the degree of u0. When incoming to a node v
in states∈S, the behavior of the agent is as follows. It reads the number iof the port through
which it entered vand the degree dofv. The pair ( i,d)∈Z2is an input symbol that causes the
transition from state sto state s′=π(s,(i,d)). If the previous move of the agent was null, (i.e.,
the agent stayed at node vin states), then the pair ( −1,d)∈Z2is the input symbol read by the
agent, that causes the transition from state sto states′=π(s,(−1,d)). In both cases s′determines
an integer λ(s′), which is either −1, in which case the agent makes a null move, or a non negative
integer indicating the port number by which the agent leaves v. This port number is λ(s′) mod
d(v), where d(v) is the degree of v. The agent continues moving in this way, possibly inﬁnitely .
In order to grasp the assumption that agents are identical, i t is assumed that agents are copies A
andA′of the same abstract state machine A, starting at two distinct nodes vAandvA′. We will
refer to such identical machines as a pair of agents . A pair of agents is said to solve the rendezvous
problem with delay τin a class Cof graphs, if, for any graph in the class Cand for any initial
positions that are not symmetric, both agents are eventuall y in the same node of the graph in the
same round, provided that they start with delay τ. The memory of an agent is measured by the
number of states of the corresponding automaton, or equival ently by the number of bits on which
these states are encoded. An automaton with Kstates requires Θ(log K) bits of memory.
In [26] (based on conference papers published by the same aut hors in DISC 2008 and SPAA 2010)
theauthorsfocusattention onoptimizingmemorysizeofide nticalagents thatpermitsthemmeeting
in trees. They assume that the port labeling is decided by an a dversary aiming at preventing two
agents frommeeting, oratallowing theagents tomeet onlyaf ter havingconsumedalot ofresources,
e.g., memory space. This yields the following deﬁnition. A p air of agents initially placed at nodes
uandvof a tree Tsolves the rendezvous problem if, for any port labeling of T, both agents are
eventually in the same node of the tree in the same round.
Nodesuandvof a tree T= (V,E) areperfectly symmetrizable if there exists a port labeling µofT
and an automorphism of the tree preserving µthat carries one node on the other. According to the
above deﬁnition, the condition on feasibility of rendezvou s can be reformulated as follows: a pair
16of agents can solve the rendezvous problem in a tree, if and on ly if their initial positions are not
perfectly symmetrizable. Consequently, throughout [26], the authors consider only non perfectly
symmetrizable initial positions of the agents.
It is ﬁrst shown that the minimum size of memory of the agents t hat can solve the rendezvous
problem in the class of trees with at most nnodes is Θ(log n). A rendezvous algorithm for arbitrary
delayτ, that uses only a logarithmic number of memory bits follows, e.g., from [11]. It is observed
in [26] that Ω(log n) is also a lower bound on the number of bits of memory that perm it the
agents to meet in all trees of size linear in n. Due to this lower bound, a universal pair of ﬁnite
agents achieving rendezvous in the class of all trees cannot exist. However, the lower bound uses a
counterexample of a tree with maximum degree linear in the si ze of the tree. Hence, it is natural
to ask if there exists a pair of ﬁnite agents solving the rende zvous problem in all trees of bounded
degree. The authors give a negative answer to this question. In fact they show that, for any pair of
identical ﬁnite agents, there is a line for which these agent s cannot solve the rendezvous problem,
even withsimultaneous start. Asafunctionofthesizeofthe trees, thisimpossibilityresultindicates
a lower bound Ω(loglog n) bits on the memory size for rendezvous in bounded degree tre es of at
mostnnodes.
The main topic of [26] is the impact of the delay between start up times of agents on the minimum
size of memory permitting rendezvous. The authors show that if this delay is arbitrary, then the
lower bound on memory required for rendezvous is Ω(log n) bits, even for the line of length n. This
lower bound matches the upper bound from [11], which shows th at the minimum size of memory of
the agents that can solve the rendezvous problem in the class ofbounded degree trees with at most
nnodes is Θ(log n). By contrast, for simultaneous start, they show that the am ount of memory
needed for rendezvous depends on two parameters of the tree: the number nof nodes and the
numberℓof leaves. Indeed, they construct two identical agents with O(logℓ+ loglog n) bits of
memory that solve the rendezvous problem in all trees with nnodes and ℓleaves. For the class of
trees with O(logn) leaves, this proves an exponential gap in minimum memory si ze of the agents
permitting them to meet, between the scenario with arbitrar y delay and with delay zero.
Moreover, it is shown in[26] that thesize Θ(log ℓ+loglog n) of memory usedtosolve therendezvous
problem with simultaneous start in trees with at most nnodes and at most ℓleaves is optimal,
even in the class of trees with degrees bounded by 3. More prec isely, for inﬁnitely many integers
ℓ, the authors show a class of arbitrarily large trees with max imum degree 3 and with ℓleaves,
for which rendezvous with simultaneous start requires Ω(lo gℓ) bits of memory. This lower bound,
together with the previously mentioned lower bound Ω(loglo gn) on the number of bits of memory
required to meet with simultaneous start in the line of lengt hn, implies that the upper bound
O(logℓ+loglog n) cannot be improved even for trees with maximum degree at mos t 3.
Trade-oﬀs between the size of memory and the time of rendezvou s in trees by identical agents are
investigated in [12]. The authors consider trees with a give n port labeling and assume that there
is no port-preserving automorphism of the tree that carries the initial position of one agent to that
of the other (otherwise rendezvous with simultaneous start is impossible). The main result of the
paper is a tight trade-oﬀ between optimal time of rendezvous and the size of memory of the agents.
For agents with kmemory bits, it is shown that optimal rendezvous time is Θ( n+n2/k) inn-node
trees. More precisely, if k≥clogn, for some constant c, the authors construct agents accomplishing
rendezvous in arbitrary trees of unknown size nin timeO(n+n2/k), starting with arbitrary delay.
17They also show that no pair of agents can accomplish rendezvo us in time o(n+n2/k), even in the
class of lines and even with simultaneous start.
Trade-oﬀs between the size of memory of the agents and the time of rendezvous in trees are inves-
tigated in [3] in a slightly diﬀerent scenario: the diﬀerence i s in the deﬁnition of rendezvous. The
authors consider the rendezvous problem of any number of ano nymous agents. To handle the case
of symmetric trees they weaken the rendezvous requirements : agents have to meet at one node if
the tree is not symmetric, and at two neighboring nodes other wise. In this latter case, some of the
agents may ﬁnish the algorithm in one of the two nodes and othe r agents in the other node. The
authors observe that Ω( n) is a lower bound on the time of rendezvous in the class of n-node trees
and show that any algorithm achieving rendezvous in optimal (i.e.,O(n)) time must use Ω( n) bits
of memory for each agent. Then they show a rendezvous algorit hm that uses O(n) time and O(n)
bits of memory per agent. Finally they design a polynomial ti me algorithm using O(logn) bits
of memory per agent. An additional feature of the algorithms from [3] is that they can also work
in an asynchronous setting: each agent independently ident iﬁes the node or one of the two nodes
where meeting should occur, it reaches this node and stops.
While [26] solves the problem of minimum memory size needed f or rendezvous in trees, the same
problem for the class of arbitrary graphs is solved in [11]. T he authors establish the minimum size
of the memory of agents that guarantees deterministic rende zvous when it is feasible. They show
that this minimum size is Θ(log n), where nis the size of the graph, regardless of the delay between
the startup rounds of the agents. More precisely, the author s construct identical agents equipped
with Θ(log n) memory bits that solve the rendezvous problem in all graphs with at most nnodes,
when starting with any delay, and they prove a matching lower bound Ω(log n) on the number of
memory bits needed to achieve rendezvous, even for simultan eous start. In fact, this lower bound
is valid already on the class of rings.
The positive result from [11] is based on a result from [37] wh ich implies that a (usually non-
simple) path traversing all nodes can be computed (node by no de) in memory O(logn), for any
graph with at most nnodes. Moreover, logarithmic memory suﬃces to walk back and forth on
this path. More precisely the result from [37] states that, f or any positive integer n, there exists
a UXSY(n) = (a1,a2,...,aM) for the class Gnof all graphs with at most nnodes, such that M
is polynomial in n, and for any i≤M, the integer aican be constructed using O(logn) bits of
memory.
At ahighlevel, theideaofthealgorithm from[11]isthefoll owing. Theauthorsintroducethenotion
of thesignature S(u) of node ucorrespondingto a given UXS. This is the sequence of entry an d exit
ports which are traversed by an application of the UXS at u. They show that if Yis a UXS for the
classGn2+nof all graphs with at most n2+nnodes, and S(u) denotes the signature of uin an-node
graphG, corresponding to the UXS Y, then for any nodes v,wofG,V(v)/ne}ationslash=V(w) is equivalent
toS(v)/ne}ationslash=S(w). Thus, the sequence S(u) can be treated as a compact representation of the view
V(u). Then the authors show that, using logarithmic memory, it i s possible to further compress
S(u) to a positive integer value of at most nin such a way that diﬀerent signatures correspond to
diﬀerent values. This numerical value is then used as the labe l of the agent. Hence agents starting
from non-symmetric initial positions get diﬀerent labels. O nce the agents’ anonymity is broken,
the rest of the meeting procedure is performed in the usual wa y, by dividing time into segments
corresponding to activity/passivity phases. Time segment s are long enough to perform a complete
18exploration of G(using a UXS that can be computed in logarithmic memory). An a gent explores G
in a single phase allowed for its label and waits in the remain ing phases. Hence an agent performing
its exploration phase must meet any agent of diﬀerent label wh ich is inert during this phase.
3.2 Asynchronous rendezvous
Inthe asynchronous scenario agents nolonger performtheir moves in synchronized steps. While the
agent chooses theadjacent nodetowhichit wants to go, theti meat whichthis move isexecuted and
the possibly varying speed are chosen by an adversary, which considerably complicates rendezvous.
It is easy to see that, even in the two-node graph, meeting at a node cannot be guaranteed under
this scenario, hence the rendezvous requirement is relaxed by demanding only that meeting occur
either at a node or inside an edge. Since meetings inside an ed ge are allowed, unwanted crossings
of edges have to be avoided. Thus, for the asynchronous scena rio, an embedding of the underlying
graph in the three-dimensional Euclidean space is consider ed, with nodes of the graph being points
of the space and edges being pairwise disjoint line segments joining them. For any graph such an
embedding exists. Agents are modeled as points moving insid e this embedding.
At any currently visited node, an agent executing a rendezvo us algorithm chooses a port number
at this node, corresponding to the edge that the agent wants t o traverse. However, the way of
traversing this edge is decided by the adversary, capturing the asynchronous characteristics of the
rendezvousprocess. Whentheagent, situated at anode vattimet0hastotraverse anedgemodeled
as a segment [ v,w], the adversary performs the following choice. It selects a time point t1> t0and
any continuous function f: [t0,t1]−→[v,w], withf(t0) =vandf(t1) =w. This function models
the actual movement of the agent inside the line segment [ v,w] in the time period [ t0,t1]. Hence
this movement can be at arbitrary speed, the agent may be even forced by the adversary to go back
and forth, as long as it does not leave the segment and the move ment is continuous. We say that
at timet∈[t0,t1] the agent is in point f(t)∈[v,w]. Moreover, the adversary chooses the starting
time of the agent. Hence an agent’s trajectory is represente d by the concatenation of the functions
chosen by the adversary for consecutive edges that the agent traverses. Recall that the choice of
the edge incident to a current node is determined by the choic e of the port number, belonging to
the agent.
For a given algorithm, given starting nodes of agents and a gi ven sequence of adversarial decisions
in an embedding of a graph G, a rendezvous occurs, if both agents are at the same point of t he
embedding at the same time. Rendezvous is feasiblein a given graph, if there exists an algorithm
for agents such that for any embedding of the graph, any (adve rsarial) choice of two distinct labels
of agents, any starting nodes and any sequences of adversari al decisions, the rendezvous does occur.
Thecostof rendezvous is deﬁned as the worst-case number of edge trav ersals by both agents (the
last partial traversal counted as a complete one for both age nts), where the worst case is taken over
all decisions of the adversary.
3.2.1 Labeled agents
The above asynchronous model was introduced in [16] where th e authors consider labeled agents.
They study asynchronous rendezvous in the inﬁnite line, in t he ring and in arbitrary connected
19graphs, both in the case when the initial instance Dbetween the agents is known, and when it is
unknown. In the ﬁrst two cases they propose several algorith ms and analyze their cost. In one
situation, for rendezvous in a ring of known size n(but unknown D) they propose an algorithm of
costO(nl), where lis the logarithm of the smaller label. This cost is optimal. T he cost of their
rendezvous algorithms in the inﬁnite line has been subseque ntly improved in [39]. The rendezvous
algorithms from [16] for the inﬁnite line and for the ring are based on the following idea: ﬁrst
transform the label Lof the agent in an appropriate way, and then executethe transformed label by
making some prescribed moves, if the current bit of it is 0 and making symmetric moves otherwise.
However, from the hindsight, the most inﬂuential part of [16 ] was that concerning rendezvous in
arbitrary graphs. Here the authors tackle the question of fe asibility. They prove that rendezvous is
feasible, if an upperboundon thesize of thegraph is known. A s an open problem, theauthors state
the question if asynchronous deterministic rendezvous is f easible in arbitrary graphs of unknown
size. The solution from [16] heavily uses the knowledge of th e upper bound on the size.
The general problem of feasibility of asynchronous rendezv ous for arbitrary graphs is solved in [14].
The authors propose an algorithm that accomplishes asynchr onous rendezvous in any connected
countable (ﬁnite or inﬁnite) graph, for arbitrary starting nodes. A consequence of this result is
a strong positive answer to the above mentioned open problem from [16]: not only is rendezvous
always possible, without the knowledge of any upper bound on the size of a ﬁnite (connected)
graph, but it is also possible for all inﬁnite (countable and connected) graphs.
The rendezvous algorithm from [14] is based on the notion of a tunnel. Consider any graph Gand
two routes R1andR2starting at nodes vandw, respectively. (These are sequences of edges, such
that consecutive edges in the sequence are incident.) We say that these routes form a tunnel, if
there exists a preﬁx [ e1,e2,...,en] of route R1and a preﬁx [ en,en−1,...,e1] of route R2, for some
edgeseiin the graph, such that ei={vi,vi+1}, wherev1=vandvn+1=w. Intuitively, the route
R1has a preﬁx Pending at wand the route R2has a preﬁx which is the reverse of P, ending
atv. It is proved in [14] that if routes R1andR2form a tunnel, then rendezvous is guaranteed,
regardless of the decisions of the adversary.
A high-level idea of the algorithm from [14] is to force the ro utes of any two agents with diﬀerent
labels to form a tunnel, for every possible combination of st arting nodes and (distinct) labels of
the two agents. This is done by enumerating all quadruples ( i,j,s′,s′′) , where iandjare diﬀerent
positive integers and s′,s′′are ﬁnite sequences of natural numbers, and arranging them i n one
countably inﬁnite sequence. This enumeration is part of the algorithm and is the same for all
agents. Then each agent processes quadruples ( i,j,s′,s′′) in the order of their enumeration. Any
starting conﬁguration of agent with label iplaced at node vand of agent with label jplaced at
nodewby the adversary corresponds to a quadruple ( i,j,s′,s′′), where s′is a sequence of port
numbers coding a path from vtowands′′is a sequence of port numbers coding the reverse path
fromwtov. During the processing of a quadruple ( i,j,s′,s′′), a suﬃx is added to the already
constructed initial segment of the route of agents with labe liorj, in such a way that if labels
and initial positions of agents correspond to this quadrupl e, then the routes of the agents form a
tunnel. Since for some quadruple this condition must hold, a rbitrary agents placed at arbitrary
initial positions in the graph must eventually meet.
The cost of the algorithm depends on the enumeration of the qu adruples, and more precisely on
the position (in this enumeration) of the quadruple corresp onding to the initial conﬁguration of the
20agents. Duringeach phaseof thealgorithm, thelength of the routes of thetwo agents corresponding
to the currently processed quadruple, is at least doubled. H ence, the complexity of the algorithm
is at least exponential in terms of the number of quadruples w ith the same labels as those of the
two agents, that are before the quadruple corresponding to t he initial conﬁguration of the agents
in the enumeration. Thus the authors conclude their paper wi th the following natural question:
Does there exist a deterministic asynchronous rendezvous a lgorithm, working for all unknown con-
nected ﬁnite graphs, with complexity polynomial in the labe ls of the agents and in the size of the
graph?
This question is answered in [22] where the authors propose a deterministic asynchronous ren-
dezvous algorithm, working for all unknown connected ﬁnite graphs, with cost polynomial in the
size of the graph and in the logarithm of the smaller label.
The high-level idea of the algorithm from [22] is based on the following observation. If one agent
follows a trajectory traversing all edges of the graph durin g some time segment, then it must either
meet the other agent or this other agent must perform at least one complete edge traversal during
this time segment, i.e., it must make progress. A naive use of this observation leads to the following
simple algorithm (which is similar to that from [16]). Let R(n,v) be a trajectory starting at vand
traversing all edges of the graph of size at most n, and let R(n,v) be the reverse trajectory. R(n,v)
can be , e.g., based on Reingold’s [37] exploration. An agent with label Lstarting at node vof
a graph of size nfollows the trajectory ( R(n,v)R(n,v))(2P(n)+1)L, whereP(n) is an upper bound
on the length of R(n,v), and stops. Indeed, in this case the number of trajectories R(n,v)R(n,v)
(that traverse all edges of the graph) performed by the large r agent (i.e., the agent with the larger
label) is larger than the number of edge traversals by the sma ller agent and consequently, if they
have not met before, the larger agent must meet the smaller on e after the smaller agent stops,
because the larger agent will still perform at least one enti re trajectory afterwards. However, this
simple algorithm has two major drawbacks. First, it require s knowledge of n(or of an upper
bound on it) and second, it is exponential in L, while the goal is an algorithm polylogarithmic in
L. Hence the above observation has to be used in a much more subt le way. As the authors of [22]
say, their algorithm “constructs a trajectory for each agen t, polynomial in the size of the graph
and polylogarithmic in the shorter label, i.e., polynomial in its length, which has the following
synchronization property that holds in a graph of arbitrary unknown size. Whe n one of the agents
has already followed some part of its trajectory, it has eith er met the other agent, or this other
agent must have completed some other related part of its traj ectory. (In a way, if the meeting
has not yet occurred, the other agent has been “pushed” to exe cute some part of its route.) The
trajectories are designed in such a way that, unless a meetin g has already occurred, the agents are
forced to follow in the same time interval such parts of their trajectories that meeting is inevitable.
A design satisfying this synchronization property is diﬃcu lt due to the arbitrary behavior of the
adversary and is the main technical challenge of the paper.”
The aim of [20] is to investigate the diﬀerence of cost between the synchronous and asynchronous
versions of a task executed by mobile agents. The authors sho w that for some natural task executed
by mobile agents in a network, the optimal cost of its determi nistic solution in the asynchronous
setting has higher order of magnitude than that in the synchr onous scenario. The task for which
this diﬀerence is proved is rendezvous of two agents in an inﬁn ite oriented grid. They consider two
agents starting at a known distance Din the inﬁnite oriented grid. Agents do not have any global
21system of coordinates. They have to meet in a node or inside an edge of the grid, and the cost of
a rendezvous algorithm is the number of edge traversals by bo th agents until the meeting. It is
proved that in the synchronous scenario rendezvous can be pe rformed at cost O(Dℓ), where ℓis
the length of the binary representation of the smaller label , while cost Ω( D2+Dℓ) is needed for
asynchronous completion of rendezvous. Hence, for instanc es withℓ=o(D), the optimal cost of
asynchronous rendezvous is asymptotically larger than tha t of synchronous rendezvous.
3.2.2 Anonymous agents
The papers [4, 9] were among the ﬁrst to consider asynchronou s rendezvous of anonymous agents
in graphs. The authors concentrate on particular graphs and use strong additional assumptions.
They consider rendezvous in an inﬁnite two-dimensional gri d, where ports are consistently labeled
N,E,S,W , and agents know their initial coordinates in the grid, with respect to a common system
of coordinates. Hence, it is even problematic if such agents can be called anonymous (identical),
as they are right away diﬀerentiated by their diﬀerent initial coordinates. It is proved in [9] that
under these assumptions asynchronous rendezvous can be acc omplished at cost O(d2+ǫ), where d
is the initial distance between the agents in the grid, and ǫis an arbitrary positive real. This
result has been generalized and strengthened in [4], under t he same assumptions. The authors
show an asynchronous rendezvous algorithm working for δ-dimensional inﬁnite grids with cost
O(dδpolylog(d)). This complexity is close to optimal, as Ω( dδ) is a lower bound on the cost of any
asynchronous rendezvous algorithm in this setting.
The problem of feasibility of asynchronous rendezvous of an onymous agents in arbitrary graphs is
solved in [27]. The authors show that rendezvous is possible if and only if the views from the initial
positions of the agents are diﬀerent, or these positions are c onnected by a path whose corresponding
sequence of port numbers is a palindrome. The authors provid e an algorithm guaranteeing deter-
ministic asynchronous rendezvous from all such initial pos itions in an arbitrary connected graph
that is either ﬁnite of arbitrary unknown size, or (countabl y) inﬁnite.
The algorithm is based on the idea of creating a tunnel, simil arly as in [14]. However, the main
diﬃculty in designing the algorithm in the present setting i s that, as opposed to [14], agents do
not have distinct labels allowing them to break symmetry. He nce symmetry can be broken only by
inspecting the views of the agents, if these views are diﬀeren t. Even when they are diﬀerent, the
agents cannot know how deeply their views have to be explored to ﬁnd the ﬁrst diﬀerence. Thus
the algorithm proceeds in epochs: in each consecutive epoch each agent explores its view more
deeply, and creates a code of this truncated view, subsequen tly treating it as its temporary label
and applying the procedure from [14] to a restricted list of q uadruples. If views are diﬀerent, a
tunnel will be eventually created after an epoch with suﬃcie ntly high index because in this epoch
the truncated views serving as temporary labels of the agent s will be diﬀerent, and the argument
from [14] will work. The algorithm in [27] has an additional f eature permitting the creation of
a tunnel when views of the agents are the same but their initia l positions are joined by a path
which is a palindrome. The simplest example of such a situati on is the two-node graph with agents
starting at extremities of the single edge. Views of the agen ts are the same and the code of the
unique simple path joining the initial positions of the agen ts is the palindrome (00).
224 Approach in the plane
In this section we study the problem of approach in the plane o r in terrains that are subsets of the
plane: agents modeled as points moving in the terrain and sta rting at distinct points of it have to
get at distance at most 1 of each other. Throughout the sectio n we assume that agents have labels
that are diﬀerent positive integers. Each agent is equipped w ith a compass and a unit of length.
The problem of approach in the plane of agents that have coher ent compasses and the same unit of
length can be reduced to the problem of rendezvous in an inﬁni te oriented grid, where rendezvous
is deﬁned as getting at the same time to the same node or the sam e point of some edge of the
grid. This means that if rendezvous in the inﬁnite oriented g rid can be solved under some set of
assumptions about the agents, then the problem of approach i n the empty plane can be solved
under analogous assumptions.
The problem of feasibility of asynchronous rendezvous in th e plane or terrains is solved in [14].
Consider any terrain (bounded or unbounded) that is a (topol ogically) closed subset of the plane
with path-connected interior. (The latter means that for an y two interior points of the terrain
there exists a path, all of whose points are interior points o f the terrain, connecting them). Agents
start at arbitrary interior points of the terrain and their t rajectories can be any polygonal lines.
The authors propose an algorithm that accomplishes approac h of any such agents in the terrain in
ﬁnite time. Compasses and units of length of the agents may ev en be diﬀerent.
While the algorithm from [14] works in a very general setting , its drawback is the complexity:
similarly asfortherendezvousalgorithm forgraphspropos edinthispaper, thecost of thealgorithm
for terrains cannot be controlled. In order to ﬁnd a more eﬃci ent algorithm, the authors of [19]
consider ascenario of restricted asynchrony. Agents have c oherent compasses and thesamemeasure
of length and of time, but they are assigned arbitrary, possi bly diﬀerent velocities by an adversary.
Anagentcanstayinertforachosenamountoftime, oritcanmo veinachosendirectionanddistance
at its assigned speed. Under these restrictions the authors propose an algorithm accomplishing
approach in the plane in time polynomial in the unknown initi al distance between the agents, in
the logarithm of the smaller label and in the inverse of the la rger speed. The distance travelled by
each agent until approach is polynomial in the ﬁrst two param eters and does not depend on the
third.
The problem of tractable approach in the plane under full asy nchrony has been ﬁnally solved in
[6]. The authors propose an algorithm accomplishing approa ch in the plane for agents whose speed
may vary adversarially. The cost of the algorithm is polynom ial in the initial distance between the
agents and in the logarithm of the smaller label.
It should be mentioned that the result from [4] concerning as ynchronous rendezvous in the inﬁnite
oriented two dimensional grid, accomplished at cost O(d2polylog(d)), where dis the initial distance
between the agents in the grid, carries over to the task of app roach in the plane undersimilar strong
assumptions as in [4]: agents have coherent compasses and th e same unit of length and they know
their initial coordinates in the plane, with respect to a com mon system of coordinates. Similarly
as for the grid, this complexity is close to optimal, due to th e lower bound Ω( d2).
In [24], the authors consider the problem of approach in the p lane under the synchronous model.
Agents are equipped with coherent compasses and the same uni t of length, and have synchronized
23clocks. They make a series of moves. Each move speciﬁes the di rection and the duration of moving.
In a null move an agent stays inert for some time, or forever. I n a non-null move agents travel at
the same constant speed, normalized to 1.
The twist of the model in this paper is restricted feedback th at the agents get after each move,
that is similar in spirit to the model of distance-aware agen ts from [15], but weaker. It is assumed
that agents have sensors enabling them to estimate the dista nce from the other agent, but not the
direction towards it. The authors consider two models of est imation. In both models an agent
reads its sensor at the moment of its appearance in the plane a nd then at the end of each move.
This reading (together with the previous ones) determines t he decision concerning the next move.
In both models the reading of the sensor tells the agent if the other agent is already present.
Moreover, in the monotone model , each agent can determine, for any two readings in moments t1
andt2, whether the distance from the other agent at time t1was smaller, equal or larger than at
timet2. It does not, however, get the value of this distance. In the w eakerbinary model , each agent
can ﬁnd out, at any reading, whether it is at distance less tha nρor at distance at least ρfrom the
other agent, for some real ρ >1 unknown to them. To motivate their model, the authors menti on
that such distance estimation can be implemented, e.g., usi ng chemical sensors. Each agent emits
some chemical substance (scent), and the sensor of the other agent detects it, i.e., the other agent
sniﬀs. The intensity of the scent decreases with the distance. In t he monotone model it is assumed
that the sensors of the agents are very precise and can measur e any change of intensity. In the
binary model it is only assumed that the sensors can detect th e scent below some distance (without
being able to measure intensity or its changes) above which t he density of the chemical is too weak
to be detected.
The authors investigate how the two ways of sensing inﬂuence the cost of meeting, deﬁned as the
total distance travelled by both agents until the meeting. F or the monotone model they present an
algorithm achieving meeting in time O(D), where Dis the initial distance between the agents. This
complexity is of course optimal. For the binary model they sh ow that, if agents start at a distance
smaller than ρ(i.e., when they can sense each other initially) then meetin g can be guaranteed at
costO(ρlogλ), where λis the larger label, and that this cost cannot be improved in g eneral. It is
also observed that, if agents start at distance αρ, for some constant α >1 in the binary model, then
sniﬃng does not help, i.e., the worst-case optimal meeting c ost is of the same order of magnitude
as without any sniﬃng ability.
In [13], the authors consider both the task of approach and th at of (exact) rendezvous of two agents
in a terrain. Exact rendezvous (getting to the samepoint of t he terrain at the same time) is possible
because the terrain is a polygon with polygonal holes, and he nce exact meeting can take place at
the boundaryof the terrain or of ahole. Movements of the agen ts are asynchronous and agents have
bounded memory: they are modeled as ﬁnite automata. The auth ors compare the feasibility of the
task of rendezvous to that of approach for anonymous and for l abeled agents. This gives rise to four
scenarios, and the authors show classes of polygonal terrai ns which distinguish all pairs of them
from the point of view of feasibility of rendezvous. The char acteristics of the terrain that inﬂuence
the feasibility of rendezvous and of approach include symme tries of the terrain, boundedness of its
diameter, and the total number of vertices of polygons in the terrain.
245 Conclusion
In this chapter we surveyed algorithmic results concerning deterministic rendezvous in networks
and deterministic approach in terrains of the plane. The app earance of many new results in the
last few years is an indication of how vibrant is this domain o f distributed computing. On the other
hand, hopefully we managed to show that our understanding of rendezvous problems is still very
incomplete, and a lot remains to be done. We would like to conc lude the chapter by pointing out
several avenues of research that this author ﬁnds promising . This choice of the open problems is
very subjective and reﬂects the personal taste of the author , rather than their importance on some
hypothetical objective scale.
It seems reasonable to classify possible open problems into two categories. The ﬁrst category is
strengthening of the existing results without changing the model under which they were originally
obtained. Here the most interesting problems seem those aim ing at improving the eﬃciency of
existing algorithms and ultimately ﬁnding an algorithm of o ptimal complexity. In this category we
would put forward the problem of ﬁnding:
•an optimal-time synchronous rendezvous algorithm in arbit rary graphs
•an optimal-cost asynchronous rendezvous algorithm in arbi trary graphs
•an optimal-cost asynchronous approach algorithm in the pla ne
All these problems are formulated for labeled agents. The th ird problem is for agents with coherent
compasses and the same unit of length. As we know, for all thes e problems polynomial algorithms
are known, but, especially in the case of problems 2 and 3, the exponents of the polynomials are
very large. Finding algorithms of optimal complexity for an y of these scenarios seems to be very
challenging. We think that even a signiﬁcant improvement of the existing algorithms would be a
big step forward.
The second category concerns investigating rendezvous und er new models. It seems that the in-
terplay between eﬃciency of rendezvous or approach and the c ommunication capabilities of agents
is still poorly understood. This problem has been “touched” in papers [15, 23, 24] but a more
complete analysis of tradeoﬀs between communication of agen ts and eﬃciency of rendezvous under
various scenarios is badly needed. A realistic type of commu nication, especially for agents in the
terrains, seems to be wireless. This can be challenging, esp ecially for large teams of agents, as usual
problems of wireless communication concerning collisions would have to be tackled.
Anotherinteresting issuearetrade-oﬀs betweenmemory ofth eagents andtheirsensorycapabilities.
In this chapter we assumed that agents cannot see other agent s prior to meeting but usually they
have signiﬁcant or even unbounded memory. By contrast, in ch apter XXX, it is usually assumed
that agents cannot remember any information from the previo us Look-Compute-Move cycles, but
they can take a snapshot of the entire network (or a large part of it) during the Look action. Most
applications are probably in between those two extremes: ag ents have some memory of past events
(for example of constant size), but their sensory capabilit ies are more limited, e.g, they can only
perceive the part of the conﬁguration at a given radius from t heir current position, they cannot see
“through” other agents, etc. Studying feasibility of rende zvous under such more balanced scenarios
25could involve characterizing initial conﬁgurations for wh ich rendezvous (or approach in the plane)
is possible, and trying to optimize the cost of meeting, whic h, under very small memory of the
agents, is often still unknown.
References
[1] S. Alpern, Rendezvous search: A personal perspective, O perations Research 50 (2002), 772-
795.
[2] S. Alpern and S. Gal, The theory of search games and rendez vous. International Series in
Operations Research and Management Science, Kluwer Academ ic Publishers, 2003.
[3] D. Baba, T. Izumi, F. Ooshita, H. Kakugawa, T. Masuzawa, L inear time and space gathering
of anonymous mobile agents in asynchronous trees. Theoreti cal Computer Science 478 (2013),
118-126.
[4] E. Bampas, J. Czyzowicz, L. Gasieniec, D. Ilcinkas, A. La bourel, Almost optimal asynchronous
rendezvous in inﬁnite multidimensional grids. Proc. 24th I nternational Symposium on Dis-
tributed Computing (DISC 2010), 297-311.
[5] S. Bouchard, Y. Dieudonn´ e, B. Ducourthial, Byzantine g athering in networks, Distributed
Computing 29 (2016), 435-457.
[6] S. Bouchard, M. Bournat, Y. Dieudonn´ e, S. Dubois, F. Pet it, Asynchronous approach in the
plane: A deterministic polynomial algorithm. CoRR abs/161 2.02168 (2016).
[7] S. Bouchard, Y. Dieudonn´ e, A. Pelc, F. Petit, Determini stic rendezvous at a node of agents
with arbitrary velocities, arXiv:1710.08291 [cs.DS] (201 7).
[8] J. Chalopin, Y. Dieudonn´ e, A. Labourel, A. Pelc, Rendez vous in networks in spite of delay
faults, Distributed Computing 29 (2016), 187-205.
[9] A. Collins, J. Czyzowicz, L. Gasieniec, A. Labourel, Tel l me where I am so I can meet you
sooner. Proc. 37th International Colloquium on Automata, L anguages, and Programming
(ICALP 2010), 502-514.
[10] A. Cornejo, F. Kuhn, Deploying wireless networks with b eeps, Proc. 24th International Sym-
posium on Distributed Computing (DISC 2010), 148-162.
[11] J. Czyzowicz, A. Kosowski, A. Pelc, How to meet when you f orget: Log-space rendezvous in
arbitrary graphs Distributed Computing 25 (2012), 165-178 .
[12] J. Czyzowicz, A. Kosowski, A. Pelc, Time vs. space trade -oﬀs for rendezvous in trees, Dis-
tributed Computing 27 (2014), 95-109.
[13] J. Czyzowicz, A. Kosowski, A. Pelc, Deterministic rend ezvous of asynchronous bounded-
memory agents in polygonal terrains, Theory of Computing Sy stems 52 (2013), 179-199.
26[14] J. Czyzowicz, A. Labourel, A. Pelc, How to meet asynchro nously (almost) everywhere, ACM
Transactions on Algorithms 8 (2012), 37:1-37:14.
[15] S.Das, D. Dereniowski, A. Kosowski, P. Uznanski, Rende zvousofdistance-aware mobileagents
in unknown graphs, Proc. 21st Int. Colloquium on Structural Information and Comm. Com-
plexity (SIROCCO 2014), 295-310.
[16] G. De Marco, L. Gargano, E. Kranakis, D. Krizanc, A. Pelc , U. Vaccaro, Asynchronous deter-
ministic rendezvous in graphs, Theoretical Computer Scien ce 355 (2006), 315-326.
[17] A. Dessmark, P. Fraigniaud, D. Kowalski, and A. Pelc, De terministic rendezvous in graphs,
Algorithmica 46 (2006), 69-96.
[18] Y. Dieudonn´ e, A. Pelc, Anonymous meeting in networks, Algorithmica 74 (2016), 908-946 .
[19] Y. Dieudonn´ e, A. Pelc, Deterministic polynomial appr oach in the plane, Distributed Comput-
ing 28 (2015), 111-129.
[20] Y. Dieudonn´ e, A. Pelc, Price of asynchrony in mobile ag ents computing, Theoretical Computer
Science 524 (2014), 59-67.
[21] Y. Dieudonn´ e, A. Pelc, D. Peleg, Gatheringdespitemis chief, ACMTransactions onAlgorithms
11 (2014), 1:1-1:28.
[22] Y. Dieudonn´ e, A. Pelc, V. Villain, How to meet asynchro nously at polynomial cost, SIAM
Journal on Computing 44 (2015), 844-867.
[23] S. Elouasbi, A. Pelc, Deterministic rendezvous with de tection using beeps, International Jour-
nal of Foundations of Computer Science 28 (2017), 77-97.
[24] S. Elouasbi, A. Pelc, Deterministic meeting of sniﬃng a gents in the plane, Proc. 23rd Inter-
national Colloquium on Structural Information and Communi cation Complexity (SIROCCO
2016), 212-227.
[25] S. Elouasbi, A. Pelc, Time of anonymous rendezvous in tr ees: Determinism vs. randomization,
Proc. 19th International Colloquium on Structural Informa tion and Communication Complex-
ity (SIROCCO 2012), 291-302.
[26] P. Fraigniaud, A. Pelc, Delays induce an exponential me mory gap for rendezvous in trees,
ACM Transactions on Algorithms 9 (2013), 17:1-17:24.
[27] S. Guilbault, A. Pelc, Asynchronous rendezvous of anon ymous agents in arbitrary graphs,
Proc. 15th International Conference on Principles of Distr ibuted Systems (OPODIS 2011),
162-173.
[28] M. Kouck` y, Universal traversal sequences with backtr acking, J. Comput. Syst. Sci. 65 (2002),
717-726.
[29] D. Kowalski, A. Malinowski, How to meet in anonymous net work, Theoretical Computer
Science 399 (2008), 141-156.
27[30] E.Kranakis, D. Krizanc, E.Markou, Themobileagent ren dezvousprobleminthering, Morgan
and Claypool Publishers, 2010.
[31] E. Kranakis, D. Krizanc, S. Rajsbaum, Mobile agent rend ezvous: A survey. Proc. 13th Collo-
quium on Structural Information and Communication Complex ity (SIROCCO 2006), 1-9.
[32] A. Miller, A. Pelc, Time versus cost tradeoﬀs for determi nistic rendezvous in networks, Dis-
tributed Computing 29 (2016), 51-64.
[33] A. Miller, A. Pelc, Fast rendezvous with advice, Theore tical Computer Science 608 (2015),
190-198.
[34] F. Ooshita, A. K. Datta, T. Masuzawa, Self-stabilizing rendezvous of synchronous mobile
agents in graphs, Proc. 19th International Symposium on Sta bilization, Safety, and Security
of Distributed Systems (SSS 2017), 18-32.
[35] A. Pelc, Deterministic rendezvous in networks: A compr ehensive survey, Networks 59 (2012),
331-347.
[36] A. Pelc, Deterministic gathering with crash faults, Co RR abs/1704.08880 (2017).
[37] O. Reingold. Undirected connectivity in log-space. Jo urnal of the ACM 55 (2008), 1-24.
[38] T. Schelling, The strategy of conﬂict, Oxford Universi ty Press, Oxford, 1960.
[39] G. Stachowiak, Asynchronous Deterministic Rendezvou s on the Line, Proc. 35th International
Conference on Current Trends in Theory and Practice of Compu ter Science (SOFSEM 2009),
497-508.
[40] A. Ta-Shma, U. Zwick, Deterministic rendezvous, treas ure hunts and strongly universal explo-
ration sequences, ACM Trans. Algorithms 10 (2014): 12:1-12 :15
[41] M. Yamashita and T. Kameda, Computing on Anonymous Netw orks: Part I-Characterizing
the Solvable Cases, IEEE Trans. Parallel Distrib. Syst. 7 (1 996), 69-89.
28